#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonCrawler

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "DungeonCrawler_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CommonUI_classes.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Slate_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "AkAudio_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "ReplicationGraph_classes.hpp"
#include "InputCore_structs.hpp"
#include "GeometryCollectionEngine_classes.hpp"
#include "CommonInput_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "EngineSettings_classes.hpp"


namespace SDK
{

// Class DungeonCrawler.DCDataAssetBase
// 0x0018 (0x0048 - 0x0030)
class UDCDataAssetBase : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2346[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetType                      AssetType;                                         // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDataAssetBase">();
	}
	static class UDCDataAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDataAssetBase>();
	}
};
static_assert(alignof(UDCDataAssetBase) == 0x000008, "Wrong alignment on UDCDataAssetBase");
static_assert(sizeof(UDCDataAssetBase) == 0x000048, "Wrong size on UDCDataAssetBase");
static_assert(offsetof(UDCDataAssetBase, AssetType) == 0x000040, "Member 'UDCDataAssetBase::AssetType' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetItemConsume
// 0x0020 (0x0068 - 0x0048)
class UDesignDataAssetItemConsume final : public UDCDataAssetBase
{
public:
	struct FDesignDataItemConsume                 Item;                                              // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItemConsume">();
	}
	static class UDesignDataAssetItemConsume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItemConsume>();
	}
};
static_assert(alignof(UDesignDataAssetItemConsume) == 0x000008, "Wrong alignment on UDesignDataAssetItemConsume");
static_assert(sizeof(UDesignDataAssetItemConsume) == 0x000068, "Wrong size on UDesignDataAssetItemConsume");
static_assert(offsetof(UDesignDataAssetItemConsume, Item) == 0x000048, "Member 'UDesignDataAssetItemConsume::Item' has a wrong offset!");

// Class DungeonCrawler.AccountLink
// 0x02C0 (0x02E8 - 0x0028)
class UAccountLink final : public UObject
{
public:
	uint8                                         Pad_2347[0x2C0];                                   // 0x0028(0x02C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccountLink">();
	}
	static class UAccountLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccountLink>();
	}
};
static_assert(alignof(UAccountLink) == 0x000008, "Wrong alignment on UAccountLink");
static_assert(sizeof(UAccountLink) == 0x0002E8, "Wrong size on UAccountLink");

// Class DungeonCrawler.ArtDataBase
// 0x0000 (0x0048 - 0x0048)
class UArtDataBase : public UDCDataAssetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataBase">();
	}
	static class UArtDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataBase>();
	}
};
static_assert(alignof(UArtDataBase) == 0x000008, "Wrong alignment on UArtDataBase");
static_assert(sizeof(UArtDataBase) == 0x000048, "Wrong size on UArtDataBase");

// Class DungeonCrawler.DCCharacterPartsArtData
// 0x0140 (0x0188 - 0x0048)
class UDCCharacterPartsArtData : public UArtDataBase
{
public:
	TMap<EDCCharacterPart, class USkeletalMesh*>  BodyParts;                                         // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EDCCharacterPart, class USkeletalMesh*>  DefaultParts;                                      // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FDCHitboxData>       HitBoxOverridesWithTypes;                          // 0x00E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EDCMorphTarget, float>                   MorphTargets;                                      // 0x0138(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterPartsArtData">();
	}
	static class UDCCharacterPartsArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterPartsArtData>();
	}
};
static_assert(alignof(UDCCharacterPartsArtData) == 0x000008, "Wrong alignment on UDCCharacterPartsArtData");
static_assert(sizeof(UDCCharacterPartsArtData) == 0x000188, "Wrong size on UDCCharacterPartsArtData");
static_assert(offsetof(UDCCharacterPartsArtData, BodyParts) == 0x000048, "Member 'UDCCharacterPartsArtData::BodyParts' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsArtData, DefaultParts) == 0x000098, "Member 'UDCCharacterPartsArtData::DefaultParts' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsArtData, HitBoxOverridesWithTypes) == 0x0000E8, "Member 'UDCCharacterPartsArtData::HitBoxOverridesWithTypes' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsArtData, MorphTargets) == 0x000138, "Member 'UDCCharacterPartsArtData::MorphTargets' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSkinArtData
// 0x0060 (0x01E8 - 0x0188)
class UDCCharacterSkinArtData final : public UDCCharacterPartsArtData
{
public:
	class UTexture2D*                             CharacterSkinIconTexture;                          // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCCharacterModifyBoneData             CharacterModifyBoneData;                           // 0x0190(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinArtData">();
	}
	static class UDCCharacterSkinArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinArtData>();
	}
};
static_assert(alignof(UDCCharacterSkinArtData) == 0x000008, "Wrong alignment on UDCCharacterSkinArtData");
static_assert(sizeof(UDCCharacterSkinArtData) == 0x0001E8, "Wrong size on UDCCharacterSkinArtData");
static_assert(offsetof(UDCCharacterSkinArtData, CharacterSkinIconTexture) == 0x000188, "Member 'UDCCharacterSkinArtData::CharacterSkinIconTexture' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinArtData, CharacterModifyBoneData) == 0x000190, "Member 'UDCCharacterSkinArtData::CharacterModifyBoneData' has a wrong offset!");

// Class DungeonCrawler.AccountLinkAll
// 0x00B0 (0x00D8 - 0x0028)
class UAccountLinkAll final : public UObject
{
public:
	uint8                                         Pad_2348[0xB0];                                    // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccountLinkAll">();
	}
	static class UAccountLinkAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccountLinkAll>();
	}
};
static_assert(alignof(UAccountLinkAll) == 0x000008, "Wrong alignment on UAccountLinkAll");
static_assert(sizeof(UAccountLinkAll) == 0x0000D8, "Wrong size on UAccountLinkAll");

// Class DungeonCrawler.AccountSession
// 0x0178 (0x01A0 - 0x0028)
class UAccountSession final : public UObject
{
public:
	uint8                                         Pad_2349[0x58];                                    // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234A[0x118];                                   // 0x0088(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccountSession">();
	}
	static class UAccountSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccountSession>();
	}
};
static_assert(alignof(UAccountSession) == 0x000008, "Wrong alignment on UAccountSession");
static_assert(sizeof(UAccountSession) == 0x0001A0, "Wrong size on UAccountSession");
static_assert(offsetof(UAccountSession, BaseObject) == 0x000080, "Member 'UAccountSession::BaseObject' has a wrong offset!");

// Class DungeonCrawler.DCWidgetBase
// 0x0070 (0x0358 - 0x02E8)
class UDCWidgetBase : public UCommonUserWidget
{
public:
	uint8                                         Pad_234B[0x60];                                    // 0x02E8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundData*                             SoundData;                                         // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate);
	void BroadcastMsgBlueprint(const int32& InMsg);
	TScriptInterface<class IBaseInterface> GetOwningBaseInterfaceBlueprint();
	bool IsSpectating();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void UnbindMsgAllOwner();
	void UnbindMsgOwner(class UScriptStruct* InMsgType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWidgetBase">();
	}
	static class UDCWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCWidgetBase>();
	}
};
static_assert(alignof(UDCWidgetBase) == 0x000008, "Wrong alignment on UDCWidgetBase");
static_assert(sizeof(UDCWidgetBase) == 0x000358, "Wrong size on UDCWidgetBase");
static_assert(offsetof(UDCWidgetBase, BaseObject) == 0x000348, "Member 'UDCWidgetBase::BaseObject' has a wrong offset!");
static_assert(offsetof(UDCWidgetBase, SoundData) == 0x000350, "Member 'UDCWidgetBase::SoundData' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterBasedWidget
// 0x0028 (0x0380 - 0x0358)
class UDCPlayerCharacterBasedWidget : public UDCWidgetBase
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0358(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacter*                             PlayerCharacter;                                   // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCEquipmentComponent*                  EquipmentComponent;                                // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterBasedWidget">();
	}
	static class UDCPlayerCharacterBasedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerCharacterBasedWidget>();
	}
};
static_assert(alignof(UDCPlayerCharacterBasedWidget) == 0x000008, "Wrong alignment on UDCPlayerCharacterBasedWidget");
static_assert(sizeof(UDCPlayerCharacterBasedWidget) == 0x000380, "Wrong size on UDCPlayerCharacterBasedWidget");
static_assert(offsetof(UDCPlayerCharacterBasedWidget, AccountId) == 0x000358, "Member 'UDCPlayerCharacterBasedWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterBasedWidget, PlayerCharacter) == 0x000368, "Member 'UDCPlayerCharacterBasedWidget::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterBasedWidget, InventoryComponent) == 0x000370, "Member 'UDCPlayerCharacterBasedWidget::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterBasedWidget, EquipmentComponent) == 0x000378, "Member 'UDCPlayerCharacterBasedWidget::EquipmentComponent' has a wrong offset!");

// Class DungeonCrawler.DCInventoryWidgetBase
// 0x0060 (0x03E0 - 0x0380)
class UDCInventoryWidgetBase : public UDCPlayerCharacterBasedWidget
{
public:
	uint8                                         Pad_234C[0x48];                                    // 0x0380(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReadOnly;                                         // 0x03C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234D[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCInventoryWidgetBase*>         ChildInventoryWidgets;                             // 0x03D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryWidgetBase">();
	}
	static class UDCInventoryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryWidgetBase>();
	}
};
static_assert(alignof(UDCInventoryWidgetBase) == 0x000008, "Wrong alignment on UDCInventoryWidgetBase");
static_assert(sizeof(UDCInventoryWidgetBase) == 0x0003E0, "Wrong size on UDCInventoryWidgetBase");
static_assert(offsetof(UDCInventoryWidgetBase, bReadOnly) == 0x0003C8, "Member 'UDCInventoryWidgetBase::bReadOnly' has a wrong offset!");
static_assert(offsetof(UDCInventoryWidgetBase, ChildInventoryWidgets) == 0x0003D0, "Member 'UDCInventoryWidgetBase::ChildInventoryWidgets' has a wrong offset!");

// Class DungeonCrawler.DCTradeInventoryWidget
// 0x0008 (0x03E8 - 0x03E0)
class UDCTradeInventoryWidget final : public UDCInventoryWidgetBase
{
public:
	class UDCInventorySetWidget*                  InventorySetWidget;                                // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTradeEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradeInventoryWidget">();
	}
	static class UDCTradeInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradeInventoryWidget>();
	}
};
static_assert(alignof(UDCTradeInventoryWidget) == 0x000008, "Wrong alignment on UDCTradeInventoryWidget");
static_assert(sizeof(UDCTradeInventoryWidget) == 0x0003E8, "Wrong size on UDCTradeInventoryWidget");
static_assert(offsetof(UDCTradeInventoryWidget, InventorySetWidget) == 0x0003E0, "Member 'UDCTradeInventoryWidget::InventorySetWidget' has a wrong offset!");

// Class DungeonCrawler.DCInventoryBase
// 0x0288 (0x02B0 - 0x0028)
class UDCInventoryBase : public UObject
{
public:
	uint8                                         Pad_234E[0x30];                                    // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EDCInventoryId                                InventoryId;                                       // 0x0058(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234F[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Indexes;                                           // 0x0060(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FDCItemId>                 KeyByIndex;                                        // 0x0070(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FDCItemId, struct FDCItemInfo>    Values;                                            // 0x00C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 OwnerCharacter;                                    // 0x0110(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCInventoryData                       InventoryData;                                     // 0x0118(0x0120)(Net, Protected, NativeAccessSpecifierProtected)
	TMap<EDCInventoryValidatorType, class UDCInventoryValidatorBase*> Validators;                                        // 0x0238(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FDCInventoryVersion                    Version;                                           // 0x0288(0x0028)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_Indexes(const TArray<int32>& OldIndexes);
	void OnRep_Version(const struct FDCInventoryVersion& OldVersion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryBase">();
	}
	static class UDCInventoryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryBase>();
	}
};
static_assert(alignof(UDCInventoryBase) == 0x000008, "Wrong alignment on UDCInventoryBase");
static_assert(sizeof(UDCInventoryBase) == 0x0002B0, "Wrong size on UDCInventoryBase");
static_assert(offsetof(UDCInventoryBase, InventoryId) == 0x000058, "Member 'UDCInventoryBase::InventoryId' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, Indexes) == 0x000060, "Member 'UDCInventoryBase::Indexes' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, KeyByIndex) == 0x000070, "Member 'UDCInventoryBase::KeyByIndex' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, Values) == 0x0000C0, "Member 'UDCInventoryBase::Values' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, OwnerCharacter) == 0x000110, "Member 'UDCInventoryBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, InventoryData) == 0x000118, "Member 'UDCInventoryBase::InventoryData' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, Validators) == 0x000238, "Member 'UDCInventoryBase::Validators' has a wrong offset!");
static_assert(offsetof(UDCInventoryBase, Version) == 0x000288, "Member 'UDCInventoryBase::Version' has a wrong offset!");

// Class DungeonCrawler.DCBoxInventory
// 0x0008 (0x02B8 - 0x02B0)
class UDCBoxInventory final : public UDCInventoryBase
{
public:
	struct FIntPoint                              BoxSize;                                           // 0x02B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_BoxSize(const struct FIntPoint& OldBoxSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCBoxInventory">();
	}
	static class UDCBoxInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCBoxInventory>();
	}
};
static_assert(alignof(UDCBoxInventory) == 0x000008, "Wrong alignment on UDCBoxInventory");
static_assert(sizeof(UDCBoxInventory) == 0x0002B8, "Wrong size on UDCBoxInventory");
static_assert(offsetof(UDCBoxInventory, BoxSize) == 0x0002B0, "Member 'UDCBoxInventory::BoxSize' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsVideosSlotWidget
// 0x0010 (0x0368 - 0x0358)
class UGameMenuOptionsVideosSlotWidget final : public UDCWidgetBase
{
public:
	class UTextBlock*                             Title;                                             // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2350[0x8];                                     // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetQualityLevel();
	void OnEpicButtonClicked();
	void OnExtraButtonClicked();
	void OnHighButtonClicked();
	void OnLowButtonClicked();
	void OnMediumButtonClicked();
	void OnQualityLevel(const int32& NewValue, const int32& OldValue);
	void SetQualityLevel(int32 InQualityLevel);
	void SetTitle(const class FText& InTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsVideosSlotWidget">();
	}
	static class UGameMenuOptionsVideosSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsVideosSlotWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsVideosSlotWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsVideosSlotWidget");
static_assert(sizeof(UGameMenuOptionsVideosSlotWidget) == 0x000368, "Wrong size on UGameMenuOptionsVideosSlotWidget");
static_assert(offsetof(UGameMenuOptionsVideosSlotWidget, Title) == 0x000358, "Member 'UGameMenuOptionsVideosSlotWidget::Title' has a wrong offset!");

// Class DungeonCrawler.ActorStatusUIData
// 0x0008 (0x0050 - 0x0048)
class UActorStatusUIData final : public UDCDataAssetBase
{
public:
	class UTexture2D*                             IconTexture;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorStatusUIData">();
	}
	static class UActorStatusUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorStatusUIData>();
	}
};
static_assert(alignof(UActorStatusUIData) == 0x000008, "Wrong alignment on UActorStatusUIData");
static_assert(sizeof(UActorStatusUIData) == 0x000050, "Wrong size on UActorStatusUIData");
static_assert(offsetof(UActorStatusUIData, IconTexture) == 0x000048, "Member 'UActorStatusUIData::IconTexture' has a wrong offset!");

// Class DungeonCrawler.DCTagCollisionDetectorComponent
// 0x0060 (0x0610 - 0x05B0)
class UDCTagCollisionDetectorComponent final : public UBoxComponent
{
public:
	FMulticastInlineDelegateProperty_             OnGameplayTagCollisionDetected;                    // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      GameplayTagQuery;                                  // 0x05C0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2351[0x8];                                     // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTagCollisionDetectorComponent">();
	}
	static class UDCTagCollisionDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTagCollisionDetectorComponent>();
	}
};
static_assert(alignof(UDCTagCollisionDetectorComponent) == 0x000010, "Wrong alignment on UDCTagCollisionDetectorComponent");
static_assert(sizeof(UDCTagCollisionDetectorComponent) == 0x000610, "Wrong size on UDCTagCollisionDetectorComponent");
static_assert(offsetof(UDCTagCollisionDetectorComponent, OnGameplayTagCollisionDetected) == 0x0005B0, "Member 'UDCTagCollisionDetectorComponent::OnGameplayTagCollisionDetected' has a wrong offset!");
static_assert(offsetof(UDCTagCollisionDetectorComponent, GameplayTagQuery) == 0x0005C0, "Member 'UDCTagCollisionDetectorComponent::GameplayTagQuery' has a wrong offset!");

// Class DungeonCrawler.DCUserInfoManagerBase
// 0x0008 (0x0030 - 0x0028)
class UDCUserInfoManagerBase : public UObject
{
public:
	uint8                                         Pad_2352[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCUserInfoManagerBase">();
	}
	static class UDCUserInfoManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCUserInfoManagerBase>();
	}
};
static_assert(alignof(UDCUserInfoManagerBase) == 0x000008, "Wrong alignment on UDCUserInfoManagerBase");
static_assert(sizeof(UDCUserInfoManagerBase) == 0x000030, "Wrong size on UDCUserInfoManagerBase");

// Class DungeonCrawler.DCDeathCamManager
// 0x00D0 (0x0100 - 0x0030)
class UDCDeathCamManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_2353[0xD0];                                    // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDeathCamManager">();
	}
	static class UDCDeathCamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDeathCamManager>();
	}
};
static_assert(alignof(UDCDeathCamManager) == 0x000008, "Wrong alignment on UDCDeathCamManager");
static_assert(sizeof(UDCDeathCamManager) == 0x000100, "Wrong size on UDCDeathCamManager");

// Class DungeonCrawler.DesignDataAssetItemPropertyType
// 0x0060 (0x00A8 - 0x0048)
class UDesignDataAssetItemPropertyType final : public UDCDataAssetBase
{
public:
	struct FDesignDataItemPropertyType            Item;                                              // 0x0048(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItemPropertyType">();
	}
	static class UDesignDataAssetItemPropertyType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItemPropertyType>();
	}
};
static_assert(alignof(UDesignDataAssetItemPropertyType) == 0x000008, "Wrong alignment on UDesignDataAssetItemPropertyType");
static_assert(sizeof(UDesignDataAssetItemPropertyType) == 0x0000A8, "Wrong size on UDesignDataAssetItemPropertyType");
static_assert(offsetof(UDesignDataAssetItemPropertyType, Item) == 0x000048, "Member 'UDesignDataAssetItemPropertyType::Item' has a wrong offset!");

// Class DungeonCrawler.ArenaSelectSlotWidget
// 0x0030 (0x0388 - 0x0358)
class UArenaSelectSlotWidget final : public UDCWidgetBase
{
public:
	EGameType                                     ArenaGameType;                                     // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2354[0x3];                                     // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ArenaDungeonIdTag;                                 // 0x035C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2355[0x4];                                     // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonSelectSlotButtonWidget*         ArenaButton;                                       // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             ArenaSelectSlotDelegate;                           // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGameType                                     CurGameType;                                       // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2356[0x7];                                     // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArenaButtonClicked();
	void OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce);
	void UpdateArenaSelectSlot();

	bool CanJoin() const;
	struct FDateTime GetBeginTime() const;
	struct FDateTime GetEndTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArenaSelectSlotWidget">();
	}
	static class UArenaSelectSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArenaSelectSlotWidget>();
	}
};
static_assert(alignof(UArenaSelectSlotWidget) == 0x000008, "Wrong alignment on UArenaSelectSlotWidget");
static_assert(sizeof(UArenaSelectSlotWidget) == 0x000388, "Wrong size on UArenaSelectSlotWidget");
static_assert(offsetof(UArenaSelectSlotWidget, ArenaGameType) == 0x000358, "Member 'UArenaSelectSlotWidget::ArenaGameType' has a wrong offset!");
static_assert(offsetof(UArenaSelectSlotWidget, ArenaDungeonIdTag) == 0x00035C, "Member 'UArenaSelectSlotWidget::ArenaDungeonIdTag' has a wrong offset!");
static_assert(offsetof(UArenaSelectSlotWidget, ArenaButton) == 0x000368, "Member 'UArenaSelectSlotWidget::ArenaButton' has a wrong offset!");
static_assert(offsetof(UArenaSelectSlotWidget, ArenaSelectSlotDelegate) == 0x000370, "Member 'UArenaSelectSlotWidget::ArenaSelectSlotDelegate' has a wrong offset!");
static_assert(offsetof(UArenaSelectSlotWidget, CurGameType) == 0x000380, "Member 'UArenaSelectSlotWidget::CurGameType' has a wrong offset!");

// Class DungeonCrawler.DCGameModeAIControllerBase
// 0x0070 (0x0430 - 0x03C0)
class ADCGameModeAIControllerBase : public AAIController
{
public:
	uint8                                         Pad_2358[0x70];                                    // 0x03C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ReceivePreInitializeComponents();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerBase">();
	}
	static class ADCGameModeAIControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerBase");
static_assert(sizeof(ADCGameModeAIControllerBase) == 0x000430, "Wrong size on ADCGameModeAIControllerBase");

// Class DungeonCrawler.DCGameModeAIControllerGameBase
// 0x0008 (0x0438 - 0x0430)
class ADCGameModeAIControllerGameBase : public ADCGameModeAIControllerBase
{
public:
	class UAccountLinkAll*                        AccountLinkAll;                                    // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerGameBase">();
	}
	static class ADCGameModeAIControllerGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerGameBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerGameBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerGameBase");
static_assert(sizeof(ADCGameModeAIControllerGameBase) == 0x000438, "Wrong size on ADCGameModeAIControllerGameBase");
static_assert(offsetof(ADCGameModeAIControllerGameBase, AccountLinkAll) == 0x000430, "Member 'ADCGameModeAIControllerGameBase::AccountLinkAll' has a wrong offset!");

// Class DungeonCrawler.DCGameModeAIControllerTestBase
// 0x0000 (0x0438 - 0x0438)
class ADCGameModeAIControllerTestBase final : public ADCGameModeAIControllerGameBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerTestBase">();
	}
	static class ADCGameModeAIControllerTestBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerTestBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerTestBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerTestBase");
static_assert(sizeof(ADCGameModeAIControllerTestBase) == 0x000438, "Wrong size on ADCGameModeAIControllerTestBase");

// Class DungeonCrawler.DCGameplayAbilityBase
// 0x01E8 (0x05A0 - 0x03B8)
class UDCGameplayAbilityBase : public UGameplayAbility
{
public:
	uint8                                         Pad_2359[0xE0];                                    // 0x03B8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCGameplayEffectContainer>     EffectContainerArray;                              // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          OverrideGameplayEffectDataArray;                   // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ActiveEffectHandles;                               // 0x04B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           IdleAnimSequenceGameplayTag;                       // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDesignDataMovementModifier>    MovementModifierArray;                             // 0x04D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDesignDataMovementModifier>    DefaultMovementModifierArray;                      // 0x04E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPrimaryAssetId>                AdditionalMovementModifierIds;                     // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        AbilityId;                                         // 0x0500(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDesignDataGameplayAbility             DesignDataGameplayAbility;                         // 0x0510(0x0068)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AppliedMovementModifierTags;                       // 0x0578(0x0020)(NativeAccessSpecifierPrivate)
	bool                                          bIsDefaultMovementModifierApplied;                 // 0x0598(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_235A[0x7];                                     // 0x0599(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext);
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext);
	void AddGameplayCueLocalWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0);
	void AddGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0);
	TArray<struct FActiveGameplayEffectHandle> ApplyEffectContainer(const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel, int32 InCountToApply, bool bIsApplyTargetSelf);
	TArray<struct FActiveGameplayEffectHandle> ApplyEffectContainerSpec(const struct FDCGameplayEffectContainerSpec& ContainerSpec, int32 InCountToApply, bool bIsApplyTargetSelf);
	TArray<struct FActiveGameplayEffectHandle> ApplyEffectContainerSpecArray(TArray<struct FDCGameplayEffectContainerSpec>& OutContainerSpecArray, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData);
	void ApplyMovementModifier(const struct FGameplayTag& EventTag);
	TArray<struct FActiveGameplayEffectHandle> ApplyPremadeSpecArray(const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData);
	void CopyPremadeSpecArray(class AActor* InActor);
	void ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext);
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext);
	void ExecuteGameplayCueLocalWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0);
	void ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0);
	struct FGameplayTagContainer GetEffectAssetTagsInEffectContainerArray(const struct FGameplayTag& InContainerTag);
	struct FGameplayTag GetGameplayTriggerTag(int32 Param_Index);
	int32 GetSetByCallerValueInEffectContainerArray(const struct FGameplayTag& ContainerTag, const struct FGameplayTag& SetByCallerDataTag);
	void MakeEffectContainerPremadeSpec(class AActor* InActor, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel);
	void MakeEffectContainerSpec(TArray<struct FDCGameplayEffectContainerSpec>* OutContainerSpecArray, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel);
	void MakeEffectContainerSpecFromContainer(TArray<struct FDCGameplayEffectContainerSpec>& OutContainerSpecArray, const struct FDCGameplayEffectContainer& Container, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel);
	void RemoveAllAppliedMovementModifiers();
	void RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag);
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag);
	void RemoveMovementModifier(const struct FGameplayTag& EventTag);

	const bool HasMovementModifier(const struct FGameplayTag& EventTag) const;
	const bool IsMovementModifierApplied(const struct FGameplayTag& EventTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayAbilityBase">();
	}
	static class UDCGameplayAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayAbilityBase>();
	}
};
static_assert(alignof(UDCGameplayAbilityBase) == 0x000008, "Wrong alignment on UDCGameplayAbilityBase");
static_assert(sizeof(UDCGameplayAbilityBase) == 0x0005A0, "Wrong size on UDCGameplayAbilityBase");
static_assert(offsetof(UDCGameplayAbilityBase, EffectContainerArray) == 0x000498, "Member 'UDCGameplayAbilityBase::EffectContainerArray' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, OverrideGameplayEffectDataArray) == 0x0004A8, "Member 'UDCGameplayAbilityBase::OverrideGameplayEffectDataArray' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, ActiveEffectHandles) == 0x0004B8, "Member 'UDCGameplayAbilityBase::ActiveEffectHandles' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, IdleAnimSequenceGameplayTag) == 0x0004C8, "Member 'UDCGameplayAbilityBase::IdleAnimSequenceGameplayTag' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, MovementModifierArray) == 0x0004D0, "Member 'UDCGameplayAbilityBase::MovementModifierArray' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, DefaultMovementModifierArray) == 0x0004E0, "Member 'UDCGameplayAbilityBase::DefaultMovementModifierArray' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, AdditionalMovementModifierIds) == 0x0004F0, "Member 'UDCGameplayAbilityBase::AdditionalMovementModifierIds' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, AbilityId) == 0x000500, "Member 'UDCGameplayAbilityBase::AbilityId' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, DesignDataGameplayAbility) == 0x000510, "Member 'UDCGameplayAbilityBase::DesignDataGameplayAbility' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, AppliedMovementModifierTags) == 0x000578, "Member 'UDCGameplayAbilityBase::AppliedMovementModifierTags' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityBase, bIsDefaultMovementModifierApplied) == 0x000598, "Member 'UDCGameplayAbilityBase::bIsDefaultMovementModifierApplied' has a wrong offset!");

// Class DungeonCrawler.GA_Interact
// 0x0170 (0x0710 - 0x05A0)
class UGA_Interact : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlayBothHandEquipped;                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlayPrimaryEquipped;                      // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlaySecondaryEquipped;                    // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlayPrimaryEquippedInstant;               // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlaySecondaryEquippedInstant;             // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TwoHandRightHandedItems;                           // 0x05C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDCAT_WaitDelayPausable*                WaitDelayPausableTask;                             // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRandomStream                          Stream;                                            // 0x05F0(0x0008)(ZeroConstructor, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FInteractionData                       CurrentData;                                       // 0x05F8(0x00B8)(Protected, NativeAccessSpecifierProtected)
	struct FDesignDataPropsSkillCheck             CurrentSkillCheckData;                             // 0x06B0(0x0030)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentInteractTag;                                // 0x06E0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentStateTag;                                   // 0x06E8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 InteractTargetActor;                               // 0x06F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2362[0x18];                                    // 0x06F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	bool IsValidData(const struct FGameplayEventData& EventData);
	void OnAimDirectionChange();
	void OnCancelled();
	void OnDetectUnableInteraction();
	void OnEndSync();
	void OnFinish();
	void OnInteractBlockTagAdded();
	void OnPause();
	void OnResume();
	void OnSkillCheck();
	void OnSkillCheckFailed();
	void OnSkillCheckFinished(ESkillCheckResult Result);
	void OnSkillCheckPerfectSucceed();
	void OnSkillCheckSucceed();
	void OnStartDelayFinished();
	void OnStartSync();
	void OnVelocityChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_Interact">();
	}
	static class UGA_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_Interact>();
	}
};
static_assert(alignof(UGA_Interact) == 0x000008, "Wrong alignment on UGA_Interact");
static_assert(sizeof(UGA_Interact) == 0x000710, "Wrong size on UGA_Interact");
static_assert(offsetof(UGA_Interact, MontageToPlayBothHandEquipped) == 0x0005A0, "Member 'UGA_Interact::MontageToPlayBothHandEquipped' has a wrong offset!");
static_assert(offsetof(UGA_Interact, MontageToPlayPrimaryEquipped) == 0x0005A8, "Member 'UGA_Interact::MontageToPlayPrimaryEquipped' has a wrong offset!");
static_assert(offsetof(UGA_Interact, MontageToPlaySecondaryEquipped) == 0x0005B0, "Member 'UGA_Interact::MontageToPlaySecondaryEquipped' has a wrong offset!");
static_assert(offsetof(UGA_Interact, MontageToPlayPrimaryEquippedInstant) == 0x0005B8, "Member 'UGA_Interact::MontageToPlayPrimaryEquippedInstant' has a wrong offset!");
static_assert(offsetof(UGA_Interact, MontageToPlaySecondaryEquippedInstant) == 0x0005C0, "Member 'UGA_Interact::MontageToPlaySecondaryEquippedInstant' has a wrong offset!");
static_assert(offsetof(UGA_Interact, TwoHandRightHandedItems) == 0x0005C8, "Member 'UGA_Interact::TwoHandRightHandedItems' has a wrong offset!");
static_assert(offsetof(UGA_Interact, WaitDelayPausableTask) == 0x0005E8, "Member 'UGA_Interact::WaitDelayPausableTask' has a wrong offset!");
static_assert(offsetof(UGA_Interact, Stream) == 0x0005F0, "Member 'UGA_Interact::Stream' has a wrong offset!");
static_assert(offsetof(UGA_Interact, CurrentData) == 0x0005F8, "Member 'UGA_Interact::CurrentData' has a wrong offset!");
static_assert(offsetof(UGA_Interact, CurrentSkillCheckData) == 0x0006B0, "Member 'UGA_Interact::CurrentSkillCheckData' has a wrong offset!");
static_assert(offsetof(UGA_Interact, CurrentInteractTag) == 0x0006E0, "Member 'UGA_Interact::CurrentInteractTag' has a wrong offset!");
static_assert(offsetof(UGA_Interact, CurrentStateTag) == 0x0006E8, "Member 'UGA_Interact::CurrentStateTag' has a wrong offset!");
static_assert(offsetof(UGA_Interact, InteractTargetActor) == 0x0006F0, "Member 'UGA_Interact::InteractTargetActor' has a wrong offset!");

// Class DungeonCrawler.GA_HuntingTrapDisarmInteract
// 0x0000 (0x0710 - 0x0710)
class UGA_HuntingTrapDisarmInteract : public UGA_Interact
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_HuntingTrapDisarmInteract">();
	}
	static class UGA_HuntingTrapDisarmInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_HuntingTrapDisarmInteract>();
	}
};
static_assert(alignof(UGA_HuntingTrapDisarmInteract) == 0x000008, "Wrong alignment on UGA_HuntingTrapDisarmInteract");
static_assert(sizeof(UGA_HuntingTrapDisarmInteract) == 0x000710, "Wrong size on UGA_HuntingTrapDisarmInteract");

// Class DungeonCrawler.DesignDataAssetShapeShift
// 0x00C8 (0x0110 - 0x0048)
class UDesignDataAssetShapeShift final : public UDCDataAssetBase
{
public:
	struct FDesignDataShapeShift                  Item;                                              // 0x0048(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetShapeShift">();
	}
	static class UDesignDataAssetShapeShift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetShapeShift>();
	}
};
static_assert(alignof(UDesignDataAssetShapeShift) == 0x000008, "Wrong alignment on UDesignDataAssetShapeShift");
static_assert(sizeof(UDesignDataAssetShapeShift) == 0x000110, "Wrong size on UDesignDataAssetShapeShift");
static_assert(offsetof(UDesignDataAssetShapeShift, Item) == 0x000048, "Member 'UDesignDataAssetShapeShift::Item' has a wrong offset!");

// Class DungeonCrawler.ArtDataPlayerCharacter
// 0x0030 (0x0078 - 0x0048)
class UArtDataPlayerCharacter final : public UArtDataBase
{
public:
	class UTexture2D*                             PlayerCharacterIconTexture;                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PlayerCharacterIconTextureL;                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PlayerCharacterIconTextureXL;                      // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MasterIconTexture;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PlayerCharacterImageTexture;                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PlayerCharacterIllustImageTexture;                 // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataPlayerCharacter">();
	}
	static class UArtDataPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataPlayerCharacter>();
	}
};
static_assert(alignof(UArtDataPlayerCharacter) == 0x000008, "Wrong alignment on UArtDataPlayerCharacter");
static_assert(sizeof(UArtDataPlayerCharacter) == 0x000078, "Wrong size on UArtDataPlayerCharacter");
static_assert(offsetof(UArtDataPlayerCharacter, PlayerCharacterIconTexture) == 0x000048, "Member 'UArtDataPlayerCharacter::PlayerCharacterIconTexture' has a wrong offset!");
static_assert(offsetof(UArtDataPlayerCharacter, PlayerCharacterIconTextureL) == 0x000050, "Member 'UArtDataPlayerCharacter::PlayerCharacterIconTextureL' has a wrong offset!");
static_assert(offsetof(UArtDataPlayerCharacter, PlayerCharacterIconTextureXL) == 0x000058, "Member 'UArtDataPlayerCharacter::PlayerCharacterIconTextureXL' has a wrong offset!");
static_assert(offsetof(UArtDataPlayerCharacter, MasterIconTexture) == 0x000060, "Member 'UArtDataPlayerCharacter::MasterIconTexture' has a wrong offset!");
static_assert(offsetof(UArtDataPlayerCharacter, PlayerCharacterImageTexture) == 0x000068, "Member 'UArtDataPlayerCharacter::PlayerCharacterImageTexture' has a wrong offset!");
static_assert(offsetof(UArtDataPlayerCharacter, PlayerCharacterIllustImageTexture) == 0x000070, "Member 'UArtDataPlayerCharacter::PlayerCharacterIllustImageTexture' has a wrong offset!");

// Class DungeonCrawler.DCActorComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDCActorComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActorComponent">();
	}
	static class UDCActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActorComponent>();
	}
};
static_assert(alignof(UDCActorComponent) == 0x000008, "Wrong alignment on UDCActorComponent");
static_assert(sizeof(UDCActorComponent) == 0x0000A0, "Wrong size on UDCActorComponent");

// Class DungeonCrawler.DCExpressmanComponent
// 0x0048 (0x00E8 - 0x00A0)
class UDCExpressmanComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2364[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultDeliveryCharge;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinimumDeliveryCharge;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeliveryMagnification;                             // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2365[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCItemDataAsset*                       AssetItemGoldCoin;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCTargetExpressmanData                TargetExpressmanData;                              // 0x00C0(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2366[0x18];                                    // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TargetExpressmanData();
	void ShowSystemMessage_Client(const class FText& InMsg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCExpressmanComponent">();
	}
	static class UDCExpressmanComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCExpressmanComponent>();
	}
};
static_assert(alignof(UDCExpressmanComponent) == 0x000008, "Wrong alignment on UDCExpressmanComponent");
static_assert(sizeof(UDCExpressmanComponent) == 0x0000E8, "Wrong size on UDCExpressmanComponent");
static_assert(offsetof(UDCExpressmanComponent, DefaultDeliveryCharge) == 0x0000A8, "Member 'UDCExpressmanComponent::DefaultDeliveryCharge' has a wrong offset!");
static_assert(offsetof(UDCExpressmanComponent, MinimumDeliveryCharge) == 0x0000AC, "Member 'UDCExpressmanComponent::MinimumDeliveryCharge' has a wrong offset!");
static_assert(offsetof(UDCExpressmanComponent, DeliveryMagnification) == 0x0000B0, "Member 'UDCExpressmanComponent::DeliveryMagnification' has a wrong offset!");
static_assert(offsetof(UDCExpressmanComponent, AssetItemGoldCoin) == 0x0000B8, "Member 'UDCExpressmanComponent::AssetItemGoldCoin' has a wrong offset!");
static_assert(offsetof(UDCExpressmanComponent, TargetExpressmanData) == 0x0000C0, "Member 'UDCExpressmanComponent::TargetExpressmanData' has a wrong offset!");

// Class DungeonCrawler.ArtDataMonster
// 0x0008 (0x0050 - 0x0048)
class UArtDataMonster final : public UArtDataBase
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataMonster">();
	}
	static class UArtDataMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataMonster>();
	}
};
static_assert(alignof(UArtDataMonster) == 0x000008, "Wrong alignment on UArtDataMonster");
static_assert(sizeof(UArtDataMonster) == 0x000050, "Wrong size on UArtDataMonster");
static_assert(offsetof(UArtDataMonster, BehaviorTree) == 0x000048, "Member 'UArtDataMonster::BehaviorTree' has a wrong offset!");

// Class DungeonCrawler.ArtDataAoe
// 0x0008 (0x0050 - 0x0048)
class UArtDataAoe final : public UArtDataBase
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataAoe">();
	}
	static class UArtDataAoe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataAoe>();
	}
};
static_assert(alignof(UArtDataAoe) == 0x000008, "Wrong alignment on UArtDataAoe");
static_assert(sizeof(UArtDataAoe) == 0x000050, "Wrong size on UArtDataAoe");
static_assert(offsetof(UArtDataAoe, BehaviorTree) == 0x000048, "Member 'UArtDataAoe::BehaviorTree' has a wrong offset!");

// Class DungeonCrawler.DCActorBase
// 0x0060 (0x02F8 - 0x0298)
class ADCActorBase : public AActor
{
public:
	uint8                                         Pad_2367[0x58];                                    // 0x0298(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	bool HasActorBegunPlayBlueprint();
	void ReceivePreInitializeComponents();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActorBase">();
	}
	static class ADCActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCActorBase>();
	}
};
static_assert(alignof(ADCActorBase) == 0x000008, "Wrong alignment on ADCActorBase");
static_assert(sizeof(ADCActorBase) == 0x0002F8, "Wrong size on ADCActorBase");
static_assert(offsetof(ADCActorBase, BaseObject) == 0x0002F0, "Member 'ADCActorBase::BaseObject' has a wrong offset!");

// Class DungeonCrawler.DCInteractableActorBase
// 0x0010 (0x0308 - 0x02F8)
class ADCInteractableActorBase : public ADCActorBase
{
public:
	uint8                                         Pad_2368[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableTargetComponent*           InteractableTargetComponent;                       // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InteractFailed(class AActor* Interacter, const struct FGameplayTag& EventTag);
	void InteractFound(class AActor* Interacter, class UPrimitiveComponent* InteractPart);
	void InteractLost(class AActor* Interacter);
	void InteractStarted(class AActor* Interacter, const struct FGameplayTag& EventTag);
	void InteractSucceed(class AActor* Interacter, const struct FGameplayTag& StateTag, const struct FGameplayTag& TriggerTag, const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInteractableActorBase">();
	}
	static class ADCInteractableActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCInteractableActorBase>();
	}
};
static_assert(alignof(ADCInteractableActorBase) == 0x000008, "Wrong alignment on ADCInteractableActorBase");
static_assert(sizeof(ADCInteractableActorBase) == 0x000308, "Wrong size on ADCInteractableActorBase");
static_assert(offsetof(ADCInteractableActorBase, InteractableTargetComponent) == 0x000300, "Member 'ADCInteractableActorBase::InteractableTargetComponent' has a wrong offset!");

// Class DungeonCrawler.DCAbilityInteractableActorBase
// 0x0010 (0x0318 - 0x0308)
class ADCAbilityInteractableActorBase : public ADCInteractableActorBase
{
public:
	uint8                                         Pad_2369[0x8];                                     // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAbilityInteractableActorBase">();
	}
	static class ADCAbilityInteractableActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCAbilityInteractableActorBase>();
	}
};
static_assert(alignof(ADCAbilityInteractableActorBase) == 0x000008, "Wrong alignment on ADCAbilityInteractableActorBase");
static_assert(sizeof(ADCAbilityInteractableActorBase) == 0x000318, "Wrong size on ADCAbilityInteractableActorBase");
static_assert(offsetof(ADCAbilityInteractableActorBase, AbilitySystemComponent) == 0x000310, "Member 'ADCAbilityInteractableActorBase::AbilitySystemComponent' has a wrong offset!");

// Class DungeonCrawler.PropsActorBase
// 0x00C8 (0x03E0 - 0x0318)
class APropsActorBase : public ADCAbilityInteractableActorBase
{
public:
	uint8                                         Pad_236A[0x70];                                    // 0x0318(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCReferenceCounterComponent*           ReferenceCounterComponent;                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImpactableComponent*                   ImpactableComponent;                               // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCUpdateRateOptimizeManagerComponent*  OptimizeComponent;                                 // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDesignDataAssetProps*                  DesignDataAssetProps;                              // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    ActiveGameplayEffectHandleArray;                   // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDCPropDataComponent*                   DataComponent;                                     // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236B[0x1];                                     // 0x03C8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPreview;                                          // 0x03C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236C[0x6];                                     // 0x03CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADCPlayerController*>            Looters;                                           // 0x03D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CheckQuestUseItem(class AActor* Interacter, const struct FItemData& ItemData);
	void FinishLooting();
	void GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount);
	const class UDesignDataAssetProps* GetDesignDataAssetProps();
	const struct FDesignDataProps GetDesignDataProps();
	const struct FPrimaryAssetId GetPropsId();
	uint8 IsNetLoadOnClient();
	void OnImpactEnduranceExhausted(float ExhaustedTime, TSubclassOf<class UGameplayEffect> GameplayEffectClass, const struct FDCGameplayEffectContext& EffectContext);
	void SetPropsId(const struct FPrimaryAssetId& InPropsId);
	void SetSoundData(const struct FPrimaryAssetId& InSoundDataId);
	void StartLooting(class ADCPlayerCharacterBase* Looter, const struct FHitResult& HitResult);
	void UndoUsed();
	void UpdateInteractDepthValue(int32 DepthValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropsActorBase">();
	}
	static class APropsActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropsActorBase>();
	}
};
static_assert(alignof(APropsActorBase) == 0x000008, "Wrong alignment on APropsActorBase");
static_assert(sizeof(APropsActorBase) == 0x0003E0, "Wrong size on APropsActorBase");
static_assert(offsetof(APropsActorBase, ReferenceCounterComponent) == 0x000388, "Member 'APropsActorBase::ReferenceCounterComponent' has a wrong offset!");
static_assert(offsetof(APropsActorBase, ImpactableComponent) == 0x000390, "Member 'APropsActorBase::ImpactableComponent' has a wrong offset!");
static_assert(offsetof(APropsActorBase, OptimizeComponent) == 0x000398, "Member 'APropsActorBase::OptimizeComponent' has a wrong offset!");
static_assert(offsetof(APropsActorBase, DesignDataAssetProps) == 0x0003A0, "Member 'APropsActorBase::DesignDataAssetProps' has a wrong offset!");
static_assert(offsetof(APropsActorBase, ActiveGameplayEffectHandleArray) == 0x0003A8, "Member 'APropsActorBase::ActiveGameplayEffectHandleArray' has a wrong offset!");
static_assert(offsetof(APropsActorBase, DataComponent) == 0x0003B8, "Member 'APropsActorBase::DataComponent' has a wrong offset!");
static_assert(offsetof(APropsActorBase, InventoryComponent) == 0x0003C0, "Member 'APropsActorBase::InventoryComponent' has a wrong offset!");
static_assert(offsetof(APropsActorBase, bPreview) == 0x0003C9, "Member 'APropsActorBase::bPreview' has a wrong offset!");
static_assert(offsetof(APropsActorBase, Looters) == 0x0003D0, "Member 'APropsActorBase::Looters' has a wrong offset!");

// Class DungeonCrawler.FloorPortalScrollBase
// 0x0010 (0x03F0 - 0x03E0)
class AFloorPortalScrollBase : public APropsActorBase
{
public:
	EDCPortalScrollType                           PortalScrollType;                                  // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236E[0xF];                                     // 0x03E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClosePortalScroll(class ADCPlayerCharacterBase* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPortalScrollBase">();
	}
	static class AFloorPortalScrollBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFloorPortalScrollBase>();
	}
};
static_assert(alignof(AFloorPortalScrollBase) == 0x000008, "Wrong alignment on AFloorPortalScrollBase");
static_assert(sizeof(AFloorPortalScrollBase) == 0x0003F0, "Wrong size on AFloorPortalScrollBase");
static_assert(offsetof(AFloorPortalScrollBase, PortalScrollType) == 0x0003E0, "Member 'AFloorPortalScrollBase::PortalScrollType' has a wrong offset!");

// Class DungeonCrawler.LobbyUserSlotBase
// 0x0098 (0x03F0 - 0x0358)
class ULobbyUserSlotBase : public UDCWidgetBase
{
public:
	class UClassRankIconBase*                     ClassRankIcon;                                     // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AccountNickname;                                   // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNickname                              Nickname;                                          // 0x0370(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   LevelText;                                         // 0x03B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ClassNameText;                                     // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ClassIconImage;                                    // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ClassPortraitImage;                                // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetNicknameBlueprint(const struct FNickname& InNickName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyUserSlotBase">();
	}
	static class ULobbyUserSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyUserSlotBase>();
	}
};
static_assert(alignof(ULobbyUserSlotBase) == 0x000008, "Wrong alignment on ULobbyUserSlotBase");
static_assert(sizeof(ULobbyUserSlotBase) == 0x0003F0, "Wrong size on ULobbyUserSlotBase");
static_assert(offsetof(ULobbyUserSlotBase, ClassRankIcon) == 0x000358, "Member 'ULobbyUserSlotBase::ClassRankIcon' has a wrong offset!");
static_assert(offsetof(ULobbyUserSlotBase, AccountNickname) == 0x000360, "Member 'ULobbyUserSlotBase::AccountNickname' has a wrong offset!");
static_assert(offsetof(ULobbyUserSlotBase, Nickname) == 0x000370, "Member 'ULobbyUserSlotBase::Nickname' has a wrong offset!");
static_assert(offsetof(ULobbyUserSlotBase, LevelText) == 0x0003B0, "Member 'ULobbyUserSlotBase::LevelText' has a wrong offset!");
static_assert(offsetof(ULobbyUserSlotBase, ClassNameText) == 0x0003C8, "Member 'ULobbyUserSlotBase::ClassNameText' has a wrong offset!");
static_assert(offsetof(ULobbyUserSlotBase, ClassIconImage) == 0x0003E0, "Member 'ULobbyUserSlotBase::ClassIconImage' has a wrong offset!");
static_assert(offsetof(ULobbyUserSlotBase, ClassPortraitImage) == 0x0003E8, "Member 'ULobbyUserSlotBase::ClassPortraitImage' has a wrong offset!");

// Class DungeonCrawler.DCChannelPlayerListEntryWidget
// 0x00A0 (0x0490 - 0x03F0)
class UDCChannelPlayerListEntryWidget final : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_236F[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCChannelPlayerWidgetInfo             Info;                                              // 0x0400(0x0090)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCChannelPlayerListEntryWidget">();
	}
	static class UDCChannelPlayerListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCChannelPlayerListEntryWidget>();
	}
};
static_assert(alignof(UDCChannelPlayerListEntryWidget) == 0x000008, "Wrong alignment on UDCChannelPlayerListEntryWidget");
static_assert(sizeof(UDCChannelPlayerListEntryWidget) == 0x000490, "Wrong size on UDCChannelPlayerListEntryWidget");
static_assert(offsetof(UDCChannelPlayerListEntryWidget, Info) == 0x000400, "Member 'UDCChannelPlayerListEntryWidget::Info' has a wrong offset!");

// Class DungeonCrawler.DCCommonActivatableWidgetBase
// 0x0078 (0x0488 - 0x0410)
class UDCCommonActivatableWidgetBase : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_2370[0x58];                                    // 0x0410(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    VirtualCursorModeInputActionData;                  // 0x0470(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2371[0x8];                                     // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate);
	void BroadcastMsgBlueprint(const int32& InMsg);
	void DisableVirtualCursor();
	void EnableVirtualCursor();
	TScriptInterface<class IBaseInterface> GetOwningBaseInterfaceBlueprint();
	bool IsSpectating();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void UnbindMsgAllOwner();
	void UnbindMsgOwner(class UScriptStruct* InMsgType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommonActivatableWidgetBase">();
	}
	static class UDCCommonActivatableWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommonActivatableWidgetBase>();
	}
};
static_assert(alignof(UDCCommonActivatableWidgetBase) == 0x000008, "Wrong alignment on UDCCommonActivatableWidgetBase");
static_assert(sizeof(UDCCommonActivatableWidgetBase) == 0x000488, "Wrong size on UDCCommonActivatableWidgetBase");
static_assert(offsetof(UDCCommonActivatableWidgetBase, BaseObject) == 0x000468, "Member 'UDCCommonActivatableWidgetBase::BaseObject' has a wrong offset!");
static_assert(offsetof(UDCCommonActivatableWidgetBase, VirtualCursorModeInputActionData) == 0x000470, "Member 'UDCCommonActivatableWidgetBase::VirtualCursorModeInputActionData' has a wrong offset!");

// Class DungeonCrawler.GameGroupWidgetBase
// 0x0020 (0x04A8 - 0x0488)
class UGameGroupWidgetBase : public UDCCommonActivatableWidgetBase
{
public:
	bool                                          bShowCursor;                                       // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetGameGroupType                          WidgetGameGroupType;                               // 0x0489(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2372[0x6];                                     // 0x048A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWidgetGameGroupType>                  NonCoexistWidgetGameGroupTypeArray;                // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2373[0x8];                                     // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGroupWidgetVisibilityChanged(ESlateVisibility NewVisibility);
	void OnHidden();
	void OnVisible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameGroupWidgetBase">();
	}
	static class UGameGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameGroupWidgetBase>();
	}
};
static_assert(alignof(UGameGroupWidgetBase) == 0x000008, "Wrong alignment on UGameGroupWidgetBase");
static_assert(sizeof(UGameGroupWidgetBase) == 0x0004A8, "Wrong size on UGameGroupWidgetBase");
static_assert(offsetof(UGameGroupWidgetBase, bShowCursor) == 0x000488, "Member 'UGameGroupWidgetBase::bShowCursor' has a wrong offset!");
static_assert(offsetof(UGameGroupWidgetBase, WidgetGameGroupType) == 0x000489, "Member 'UGameGroupWidgetBase::WidgetGameGroupType' has a wrong offset!");
static_assert(offsetof(UGameGroupWidgetBase, NonCoexistWidgetGameGroupTypeArray) == 0x000490, "Member 'UGameGroupWidgetBase::NonCoexistWidgetGameGroupTypeArray' has a wrong offset!");

// Class DungeonCrawler.MusicListWidgetBase
// 0x0040 (0x04E8 - 0x04A8)
class UMusicListWidgetBase : public UGameGroupWidgetBase
{
public:
	class UMusicSlotWidgetBase*                   MusicSlot_1;                                       // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicSlotWidgetBase*                   MusicSlot_2;                                       // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicSlotWidgetBase*                   MusicSlot_3;                                       // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicSlotWidgetBase*                   MusicSlot_4;                                       // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicSlotWidgetBase*                   MusicSlot_5;                                       // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMusicSlotWidgetBase*>           MusicSlots;                                        // 0x04D0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EWidgetMusicSlotsType                         WidgetSlotType;                                    // 0x04E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2374[0x7];                                     // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicListWidgetBase">();
	}
	static class UMusicListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicListWidgetBase>();
	}
};
static_assert(alignof(UMusicListWidgetBase) == 0x000008, "Wrong alignment on UMusicListWidgetBase");
static_assert(sizeof(UMusicListWidgetBase) == 0x0004E8, "Wrong size on UMusicListWidgetBase");
static_assert(offsetof(UMusicListWidgetBase, MusicSlot_1) == 0x0004A8, "Member 'UMusicListWidgetBase::MusicSlot_1' has a wrong offset!");
static_assert(offsetof(UMusicListWidgetBase, MusicSlot_2) == 0x0004B0, "Member 'UMusicListWidgetBase::MusicSlot_2' has a wrong offset!");
static_assert(offsetof(UMusicListWidgetBase, MusicSlot_3) == 0x0004B8, "Member 'UMusicListWidgetBase::MusicSlot_3' has a wrong offset!");
static_assert(offsetof(UMusicListWidgetBase, MusicSlot_4) == 0x0004C0, "Member 'UMusicListWidgetBase::MusicSlot_4' has a wrong offset!");
static_assert(offsetof(UMusicListWidgetBase, MusicSlot_5) == 0x0004C8, "Member 'UMusicListWidgetBase::MusicSlot_5' has a wrong offset!");
static_assert(offsetof(UMusicListWidgetBase, MusicSlots) == 0x0004D0, "Member 'UMusicListWidgetBase::MusicSlots' has a wrong offset!");
static_assert(offsetof(UMusicListWidgetBase, WidgetSlotType) == 0x0004E0, "Member 'UMusicListWidgetBase::WidgetSlotType' has a wrong offset!");

// Class DungeonCrawler.GameMusicSelectGroupWidget
// 0x0058 (0x0540 - 0x04E8)
class UGameMusicSelectGroupWidget final : public UMusicListWidgetBase
{
public:
	int32                                         SelectedMusicIndex;                                // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2375[0x4];                                     // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CapacityOverloadedTextBlock;                       // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RequiredText;                                      // 0x04F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   CapacityOverloadedText;                            // 0x0510(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2376[0x10];                                    // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCurrentMusicSlotChanged(class UGameMusicSlotWidget* InSelectedSlot);
	void OnMusicSelectClose();
	void OnMusicSelectPopup();
	void OnSelectedMusicIndexChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMusicSelectGroupWidget">();
	}
	static class UGameMusicSelectGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMusicSelectGroupWidget>();
	}
};
static_assert(alignof(UGameMusicSelectGroupWidget) == 0x000008, "Wrong alignment on UGameMusicSelectGroupWidget");
static_assert(sizeof(UGameMusicSelectGroupWidget) == 0x000540, "Wrong size on UGameMusicSelectGroupWidget");
static_assert(offsetof(UGameMusicSelectGroupWidget, SelectedMusicIndex) == 0x0004E8, "Member 'UGameMusicSelectGroupWidget::SelectedMusicIndex' has a wrong offset!");
static_assert(offsetof(UGameMusicSelectGroupWidget, CapacityOverloadedTextBlock) == 0x0004F0, "Member 'UGameMusicSelectGroupWidget::CapacityOverloadedTextBlock' has a wrong offset!");
static_assert(offsetof(UGameMusicSelectGroupWidget, RequiredText) == 0x0004F8, "Member 'UGameMusicSelectGroupWidget::RequiredText' has a wrong offset!");
static_assert(offsetof(UGameMusicSelectGroupWidget, CapacityOverloadedText) == 0x000510, "Member 'UGameMusicSelectGroupWidget::CapacityOverloadedText' has a wrong offset!");
static_assert(offsetof(UGameMusicSelectGroupWidget, PlayerCharacter) == 0x000538, "Member 'UGameMusicSelectGroupWidget::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.ArtDataProps
// 0x0000 (0x0048 - 0x0048)
class UArtDataProps final : public UArtDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataProps">();
	}
	static class UArtDataProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataProps>();
	}
};
static_assert(alignof(UArtDataProps) == 0x000008, "Wrong alignment on UArtDataProps");
static_assert(sizeof(UArtDataProps) == 0x000048, "Wrong size on UArtDataProps");

// Class DungeonCrawler.ArtDataItem
// 0x0090 (0x00D8 - 0x0048)
class UArtDataItem : public UArtDataBase
{
public:
	class UTexture2D*                             ItemIconTexture;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ItemSkeletalMesh;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemMaterialInfo>              ItemSkeletalMeshMaterialInfoArray;                 // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ItemStaticMesh;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemMaterialInfo>              ItemStaticMeshMaterialInfoArray;                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              ItemAnimInstanceClass;                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FItemBoneModifyData> ItemsBoneModifyData;                               // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataItem">();
	}
	static class UArtDataItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataItem>();
	}
};
static_assert(alignof(UArtDataItem) == 0x000008, "Wrong alignment on UArtDataItem");
static_assert(sizeof(UArtDataItem) == 0x0000D8, "Wrong size on UArtDataItem");
static_assert(offsetof(UArtDataItem, ItemIconTexture) == 0x000048, "Member 'UArtDataItem::ItemIconTexture' has a wrong offset!");
static_assert(offsetof(UArtDataItem, ItemSkeletalMesh) == 0x000050, "Member 'UArtDataItem::ItemSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UArtDataItem, ItemSkeletalMeshMaterialInfoArray) == 0x000058, "Member 'UArtDataItem::ItemSkeletalMeshMaterialInfoArray' has a wrong offset!");
static_assert(offsetof(UArtDataItem, ItemStaticMesh) == 0x000068, "Member 'UArtDataItem::ItemStaticMesh' has a wrong offset!");
static_assert(offsetof(UArtDataItem, ItemStaticMeshMaterialInfoArray) == 0x000070, "Member 'UArtDataItem::ItemStaticMeshMaterialInfoArray' has a wrong offset!");
static_assert(offsetof(UArtDataItem, ItemAnimInstanceClass) == 0x000080, "Member 'UArtDataItem::ItemAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UArtDataItem, ItemsBoneModifyData) == 0x000088, "Member 'UArtDataItem::ItemsBoneModifyData' has a wrong offset!");

// Class DungeonCrawler.EquipmentInventoryComponent
// 0x0458 (0x04F8 - 0x00A0)
class UEquipmentInventoryComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2377[0x70];                                    // 0x00A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	EInventoryType                                InventoryType;                                     // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2378[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCEquipmentInventoryData              InventoryData;                                     // 0x0118(0x0010)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AItemActor*>                     EquippedItemActors;                                // 0x0128(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AItemActor*>                     SheathItemActors;                                  // 0x0138(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	struct FDCQuickSlotData                       QuickSlotData;                                     // 0x0148(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDCEquipAnimData                       EquipAnimData;                                     // 0x0150(0x02D0)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TMap<EDCEquipmentSlotIndex, class UDCEquipmentSlot*> EquipSlotMap;                                      // 0x0420(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EEquipmentQuickSlotType, struct FEquipmentQuickSlotInfo> QuickSlotInfoMap;                                  // 0x0470(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          bHideSheathItemActorsFromOwner;                    // 0x04C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2379[0x37];                                    // 0x04C1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	struct FItemData GetCurrentHoldingItemData();
	void HideEquippedItemActorsInGame(bool bHidden);
	void OnQuickSlotApplied();
	void OnRep_EquipAnimData(const struct FDCEquipAnimData& OldEquipAnimData);
	void OnRep_EquippedItemActors(const TArray<class AItemActor*>& OldEquippedItemActors);
	void OnRep_InventoryData(const struct FDCEquipmentInventoryData& OldInventoryData);
	void OnRep_QuickSlotData(const struct FDCQuickSlotData& OldQuickSlotData);
	void OnRep_SheathItemActors(const TArray<class AItemActor*>& OldSheathItemActors);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	void ClientReqChangeQuickSlot(EEquipmentQuickSlotType QuickSlotType, bool bSkipCondition) const;
	EEquipmentQuickSlotType GetCurrentActiveSlotType() const;
	TArray<class UItem*> GetItemsBySlotType(const struct FGameplayTag& ItemSlotType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentInventoryComponent">();
	}
	static class UEquipmentInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentInventoryComponent>();
	}
};
static_assert(alignof(UEquipmentInventoryComponent) == 0x000008, "Wrong alignment on UEquipmentInventoryComponent");
static_assert(sizeof(UEquipmentInventoryComponent) == 0x0004F8, "Wrong size on UEquipmentInventoryComponent");
static_assert(offsetof(UEquipmentInventoryComponent, InventoryType) == 0x000110, "Member 'UEquipmentInventoryComponent::InventoryType' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, InventoryData) == 0x000118, "Member 'UEquipmentInventoryComponent::InventoryData' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, EquippedItemActors) == 0x000128, "Member 'UEquipmentInventoryComponent::EquippedItemActors' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, SheathItemActors) == 0x000138, "Member 'UEquipmentInventoryComponent::SheathItemActors' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, QuickSlotData) == 0x000148, "Member 'UEquipmentInventoryComponent::QuickSlotData' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, EquipAnimData) == 0x000150, "Member 'UEquipmentInventoryComponent::EquipAnimData' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, EquipSlotMap) == 0x000420, "Member 'UEquipmentInventoryComponent::EquipSlotMap' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, QuickSlotInfoMap) == 0x000470, "Member 'UEquipmentInventoryComponent::QuickSlotInfoMap' has a wrong offset!");
static_assert(offsetof(UEquipmentInventoryComponent, bHideSheathItemActorsFromOwner) == 0x0004C0, "Member 'UEquipmentInventoryComponent::bHideSheathItemActorsFromOwner' has a wrong offset!");

// Class DungeonCrawler.ArtDataAnimatedItem
// 0x0098 (0x0170 - 0x00D8)
class UArtDataAnimatedItem : public UArtDataItem
{
public:
	struct FAnimationSet                          AnimationSet;                                      // 0x00D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FAnimationSet> ConditionalAnimationSet;                           // 0x0110(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   EquipmentSocket;                                   // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SheathSocket;                                      // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataAnimatedItem">();
	}
	static class UArtDataAnimatedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataAnimatedItem>();
	}
};
static_assert(alignof(UArtDataAnimatedItem) == 0x000008, "Wrong alignment on UArtDataAnimatedItem");
static_assert(sizeof(UArtDataAnimatedItem) == 0x000170, "Wrong size on UArtDataAnimatedItem");
static_assert(offsetof(UArtDataAnimatedItem, AnimationSet) == 0x0000D8, "Member 'UArtDataAnimatedItem::AnimationSet' has a wrong offset!");
static_assert(offsetof(UArtDataAnimatedItem, ConditionalAnimationSet) == 0x000110, "Member 'UArtDataAnimatedItem::ConditionalAnimationSet' has a wrong offset!");
static_assert(offsetof(UArtDataAnimatedItem, EquipmentSocket) == 0x000160, "Member 'UArtDataAnimatedItem::EquipmentSocket' has a wrong offset!");
static_assert(offsetof(UArtDataAnimatedItem, SheathSocket) == 0x000168, "Member 'UArtDataAnimatedItem::SheathSocket' has a wrong offset!");

// Class DungeonCrawler.DCDungeonResultGroupWidget
// 0x0028 (0x04D0 - 0x04A8)
class UDCDungeonResultGroupWidget final : public UGameGroupWidgetBase
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCDungeonResultWidget*                 DungeonResult;                                     // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCDungeonResultWidget*                 DungeonResult_AP;                                  // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCDungeonResultWidget*                 DeathCamResult;                                    // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCDungeonResultWidget*                 ArenaResult;                                       // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDungeonResultGroupVisibilityChanged(ESlateVisibility NewVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonResultGroupWidget">();
	}
	static class UDCDungeonResultGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDungeonResultGroupWidget>();
	}
};
static_assert(alignof(UDCDungeonResultGroupWidget) == 0x000008, "Wrong alignment on UDCDungeonResultGroupWidget");
static_assert(sizeof(UDCDungeonResultGroupWidget) == 0x0004D0, "Wrong size on UDCDungeonResultGroupWidget");
static_assert(offsetof(UDCDungeonResultGroupWidget, WidgetSwitcher) == 0x0004A8, "Member 'UDCDungeonResultGroupWidget::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultGroupWidget, DungeonResult) == 0x0004B0, "Member 'UDCDungeonResultGroupWidget::DungeonResult' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultGroupWidget, DungeonResult_AP) == 0x0004B8, "Member 'UDCDungeonResultGroupWidget::DungeonResult_AP' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultGroupWidget, DeathCamResult) == 0x0004C0, "Member 'UDCDungeonResultGroupWidget::DeathCamResult' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultGroupWidget, ArenaResult) == 0x0004C8, "Member 'UDCDungeonResultGroupWidget::ArenaResult' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_UnHideEquippedWeapons
// 0x0000 (0x0038 - 0x0038)
class UDCAnimNotify_UnHideEquippedWeapons final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_UnHideEquippedWeapons">();
	}
	static class UDCAnimNotify_UnHideEquippedWeapons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_UnHideEquippedWeapons>();
	}
};
static_assert(alignof(UDCAnimNotify_UnHideEquippedWeapons) == 0x000008, "Wrong alignment on UDCAnimNotify_UnHideEquippedWeapons");
static_assert(sizeof(UDCAnimNotify_UnHideEquippedWeapons) == 0x000038, "Wrong size on UDCAnimNotify_UnHideEquippedWeapons");

// Class DungeonCrawler.GA_ItemInstallBase
// 0x0160 (0x0700 - 0x05A0)
class UGA_ItemInstallBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APropsActorBase>            ActorClassToInstall;                               // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ConsumeText;                                       // 0x05B0(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_237A[0x8];                                     // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemData                              ItemData;                                          // 0x05D0(0x0100)(NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocation;                                    // 0x06D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APropsActorBase>            SkinActorClassToInstall;                           // 0x06E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        SkinSoundDataId;                                   // 0x06F0(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnAimDirectionChange();
	void OnDistanceChanged();
	void OnFinishConsume();
	void OnNetSync();
	void OnVelocityChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ItemInstallBase">();
	}
	static class UGA_ItemInstallBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ItemInstallBase>();
	}
};
static_assert(alignof(UGA_ItemInstallBase) == 0x000008, "Wrong alignment on UGA_ItemInstallBase");
static_assert(sizeof(UGA_ItemInstallBase) == 0x000700, "Wrong size on UGA_ItemInstallBase");
static_assert(offsetof(UGA_ItemInstallBase, MontageToPlay) == 0x0005A0, "Member 'UGA_ItemInstallBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_ItemInstallBase, ActorClassToInstall) == 0x0005A8, "Member 'UGA_ItemInstallBase::ActorClassToInstall' has a wrong offset!");
static_assert(offsetof(UGA_ItemInstallBase, ConsumeText) == 0x0005B0, "Member 'UGA_ItemInstallBase::ConsumeText' has a wrong offset!");
static_assert(offsetof(UGA_ItemInstallBase, ItemData) == 0x0005D0, "Member 'UGA_ItemInstallBase::ItemData' has a wrong offset!");
static_assert(offsetof(UGA_ItemInstallBase, TargetLocation) == 0x0006D0, "Member 'UGA_ItemInstallBase::TargetLocation' has a wrong offset!");
static_assert(offsetof(UGA_ItemInstallBase, SkinActorClassToInstall) == 0x0006E8, "Member 'UGA_ItemInstallBase::SkinActorClassToInstall' has a wrong offset!");
static_assert(offsetof(UGA_ItemInstallBase, SkinSoundDataId) == 0x0006F0, "Member 'UGA_ItemInstallBase::SkinSoundDataId' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetSkill
// 0x00E0 (0x0128 - 0x0048)
class UDesignDataAssetSkill final : public UDCDataAssetBase
{
public:
	struct FDesignDataSkill                       Item;                                              // 0x0048(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetSkill">();
	}
	static class UDesignDataAssetSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetSkill>();
	}
};
static_assert(alignof(UDesignDataAssetSkill) == 0x000008, "Wrong alignment on UDesignDataAssetSkill");
static_assert(sizeof(UDesignDataAssetSkill) == 0x000128, "Wrong size on UDesignDataAssetSkill");
static_assert(offsetof(UDesignDataAssetSkill, Item) == 0x000048, "Member 'UDesignDataAssetSkill::Item' has a wrong offset!");

// Class DungeonCrawler.ArtDataWeapon
// 0x0000 (0x0170 - 0x0170)
class UArtDataWeapon final : public UArtDataAnimatedItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataWeapon">();
	}
	static class UArtDataWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataWeapon>();
	}
};
static_assert(alignof(UArtDataWeapon) == 0x000008, "Wrong alignment on UArtDataWeapon");
static_assert(sizeof(UArtDataWeapon) == 0x000170, "Wrong size on UArtDataWeapon");

// Class DungeonCrawler.DCDamageIndicatorComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDCDamageIndicatorComponent : public UDCActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDamageIndicatorComponent">();
	}
	static class UDCDamageIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDamageIndicatorComponent>();
	}
};
static_assert(alignof(UDCDamageIndicatorComponent) == 0x000008, "Wrong alignment on UDCDamageIndicatorComponent");
static_assert(sizeof(UDCDamageIndicatorComponent) == 0x0000A0, "Wrong size on UDCDamageIndicatorComponent");

// Class DungeonCrawler.GA_LobbyEmoteBase
// 0x0028 (0x05C8 - 0x05A0)
class UGA_LobbyEmoteBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           CenterMontage;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LeftMontage;                                       // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RightMontage;                                      // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TransitionSectionName;                             // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_LobbyEmoteBase">();
	}
	static class UGA_LobbyEmoteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_LobbyEmoteBase>();
	}
};
static_assert(alignof(UGA_LobbyEmoteBase) == 0x000008, "Wrong alignment on UGA_LobbyEmoteBase");
static_assert(sizeof(UGA_LobbyEmoteBase) == 0x0005C8, "Wrong size on UGA_LobbyEmoteBase");
static_assert(offsetof(UGA_LobbyEmoteBase, CenterMontage) == 0x0005A0, "Member 'UGA_LobbyEmoteBase::CenterMontage' has a wrong offset!");
static_assert(offsetof(UGA_LobbyEmoteBase, LeftMontage) == 0x0005A8, "Member 'UGA_LobbyEmoteBase::LeftMontage' has a wrong offset!");
static_assert(offsetof(UGA_LobbyEmoteBase, RightMontage) == 0x0005B0, "Member 'UGA_LobbyEmoteBase::RightMontage' has a wrong offset!");
static_assert(offsetof(UGA_LobbyEmoteBase, TransitionSectionName) == 0x0005B8, "Member 'UGA_LobbyEmoteBase::TransitionSectionName' has a wrong offset!");
static_assert(offsetof(UGA_LobbyEmoteBase, GameplayCueTag) == 0x0005C0, "Member 'UGA_LobbyEmoteBase::GameplayCueTag' has a wrong offset!");

// Class DungeonCrawler.ArtDataArmor
// 0x0050 (0x0128 - 0x00D8)
class UArtDataArmor final : public UArtDataItem
{
public:
	TMap<EDCMorphTarget, float>                   MorphTargetsV2;                                    // 0x00D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataArmor">();
	}
	static class UArtDataArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataArmor>();
	}
};
static_assert(alignof(UArtDataArmor) == 0x000008, "Wrong alignment on UArtDataArmor");
static_assert(sizeof(UArtDataArmor) == 0x000128, "Wrong size on UArtDataArmor");
static_assert(offsetof(UArtDataArmor, MorphTargetsV2) == 0x0000D8, "Member 'UArtDataArmor::MorphTargetsV2' has a wrong offset!");

// Class DungeonCrawler.DCCommonButtonBase
// 0x00E0 (0x1660 - 0x1580)
#pragma pack(push, 0x1)
class alignas(0x10) UDCCommonButtonBase : public UCommonButtonBase
{
public:
	uint8                                         Pad_237B[0x60];                                    // 0x1580(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCommonButtonClick;                               // 0x15E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USoundData*                             SoundData;                                         // 0x15F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ButtonText;                                        // 0x15F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsClickBlocked;                                   // 0x1610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237C[0x7];                                     // 0x1611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonTooltipText;                                 // 0x1618(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCSimpleTooltipWidget>     ButtonTooltipWidgetClass;                          // 0x1630(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseObject*                            BaseObject;                                        // 0x1638(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                HoverWidget;                                       // 0x1640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                PressWidget;                                       // 0x1648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCSimpleTooltipWidget*                 ButtonTooltipWidget;                               // 0x1650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate);
	void BroadcastMsgBlueprint(const int32& InMsg);
	TScriptInterface<class IBaseInterface> GetOwningBaseInterfaceBlueprint();
	class UUserWidget* GetTooltipWidget();
	void OnCommonButtonClicked();
	void PlayClickSound();
	void SetBlockClick(bool bInIsBlocked);
	void SetButtonText(const class FText& InButtonText);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void UnbindMsgAllOwner();
	void UnbindMsgOwner(class UScriptStruct* InMsgType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommonButtonBase">();
	}
	static class UDCCommonButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommonButtonBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDCCommonButtonBase) == 0x000010, "Wrong alignment on UDCCommonButtonBase");
static_assert(sizeof(UDCCommonButtonBase) == 0x001660, "Wrong size on UDCCommonButtonBase");
static_assert(offsetof(UDCCommonButtonBase, OnCommonButtonClick) == 0x0015E0, "Member 'UDCCommonButtonBase::OnCommonButtonClick' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, SoundData) == 0x0015F0, "Member 'UDCCommonButtonBase::SoundData' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, ButtonText) == 0x0015F8, "Member 'UDCCommonButtonBase::ButtonText' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, bIsClickBlocked) == 0x001610, "Member 'UDCCommonButtonBase::bIsClickBlocked' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, ButtonTooltipText) == 0x001618, "Member 'UDCCommonButtonBase::ButtonTooltipText' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, ButtonTooltipWidgetClass) == 0x001630, "Member 'UDCCommonButtonBase::ButtonTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, BaseObject) == 0x001638, "Member 'UDCCommonButtonBase::BaseObject' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, HoverWidget) == 0x001640, "Member 'UDCCommonButtonBase::HoverWidget' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, PressWidget) == 0x001648, "Member 'UDCCommonButtonBase::PressWidget' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonBase, ButtonTooltipWidget) == 0x001650, "Member 'UDCCommonButtonBase::ButtonTooltipWidget' has a wrong offset!");

// Class DungeonCrawler.DungeonSelectSlotButtonWidget
// 0x0010 (0x1670 - 0x1660)
class UDungeonSelectSlotButtonWidget final : public UDCCommonButtonBase
{
public:
	class UImage*                                 On;                                                // 0x1658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Off;                                               // 0x1660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237D[0x8];                                     // 0x1668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSelectSlotButtonWidget">();
	}
	static class UDungeonSelectSlotButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSelectSlotButtonWidget>();
	}
};
static_assert(alignof(UDungeonSelectSlotButtonWidget) == 0x000010, "Wrong alignment on UDungeonSelectSlotButtonWidget");
static_assert(sizeof(UDungeonSelectSlotButtonWidget) == 0x001670, "Wrong size on UDungeonSelectSlotButtonWidget");
static_assert(offsetof(UDungeonSelectSlotButtonWidget, On) == 0x001658, "Member 'UDungeonSelectSlotButtonWidget::On' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotButtonWidget, Off) == 0x001660, "Member 'UDungeonSelectSlotButtonWidget::Off' has a wrong offset!");

// Class DungeonCrawler.ArtDataUtility
// 0x0000 (0x0170 - 0x0170)
class UArtDataUtility final : public UArtDataAnimatedItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataUtility">();
	}
	static class UArtDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataUtility>();
	}
};
static_assert(alignof(UArtDataUtility) == 0x000008, "Wrong alignment on UArtDataUtility");
static_assert(sizeof(UArtDataUtility) == 0x000170, "Wrong size on UArtDataUtility");

// Class DungeonCrawler.DCDataAsset
// 0x0018 (0x0048 - 0x0030)
class UDCDataAsset : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_237E[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetType                      AssetType;                                         // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDataAsset">();
	}
	static class UDCDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDataAsset>();
	}
};
static_assert(alignof(UDCDataAsset) == 0x000008, "Wrong alignment on UDCDataAsset");
static_assert(sizeof(UDCDataAsset) == 0x000048, "Wrong size on UDCDataAsset");
static_assert(offsetof(UDCDataAsset, AssetType) == 0x000040, "Member 'UDCDataAsset::AssetType' has a wrong offset!");

// Class DungeonCrawler.DCTableDataAsset
// 0x0000 (0x0048 - 0x0048)
class UDCTableDataAsset : public UDCDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTableDataAsset">();
	}
	static class UDCTableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTableDataAsset>();
	}
};
static_assert(alignof(UDCTableDataAsset) == 0x000008, "Wrong alignment on UDCTableDataAsset");
static_assert(sizeof(UDCTableDataAsset) == 0x000048, "Wrong size on UDCTableDataAsset");

// Class DungeonCrawler.DCFloorRuleDataAsset
// 0x0000 (0x0048 - 0x0048)
class UDCFloorRuleDataAsset : public UDCTableDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFloorRuleDataAsset">();
	}
	static class UDCFloorRuleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFloorRuleDataAsset>();
	}
};
static_assert(alignof(UDCFloorRuleDataAsset) == 0x000008, "Wrong alignment on UDCFloorRuleDataAsset");
static_assert(sizeof(UDCFloorRuleDataAsset) == 0x000048, "Wrong size on UDCFloorRuleDataAsset");

// Class DungeonCrawler.DCFloorRuleBlizzardDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCFloorRuleBlizzardDataAsset final : public UDCFloorRuleDataAsset
{
public:
	TArray<struct FDCFloorRuleBlizzardItemData>   FloorRuleItemArray;                                // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFloorRuleBlizzardDataAsset">();
	}
	static class UDCFloorRuleBlizzardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFloorRuleBlizzardDataAsset>();
	}
};
static_assert(alignof(UDCFloorRuleBlizzardDataAsset) == 0x000008, "Wrong alignment on UDCFloorRuleBlizzardDataAsset");
static_assert(sizeof(UDCFloorRuleBlizzardDataAsset) == 0x000058, "Wrong size on UDCFloorRuleBlizzardDataAsset");
static_assert(offsetof(UDCFloorRuleBlizzardDataAsset, FloorRuleItemArray) == 0x000048, "Member 'UDCFloorRuleBlizzardDataAsset::FloorRuleItemArray' has a wrong offset!");

// Class DungeonCrawler.ArtDataAccessory
// 0x0000 (0x00D8 - 0x00D8)
class UArtDataAccessory final : public UArtDataItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataAccessory">();
	}
	static class UArtDataAccessory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataAccessory>();
	}
};
static_assert(alignof(UArtDataAccessory) == 0x000008, "Wrong alignment on UArtDataAccessory");
static_assert(sizeof(UArtDataAccessory) == 0x0000D8, "Wrong size on UArtDataAccessory");

// Class DungeonCrawler.ArtDataMisc
// 0x0000 (0x00D8 - 0x00D8)
class UArtDataMisc final : public UArtDataItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataMisc">();
	}
	static class UArtDataMisc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataMisc>();
	}
};
static_assert(alignof(UArtDataMisc) == 0x000008, "Wrong alignment on UArtDataMisc");
static_assert(sizeof(UArtDataMisc) == 0x0000D8, "Wrong size on UArtDataMisc");

// Class DungeonCrawler.GameAmmoWidget
// 0x0010 (0x0390 - 0x0380)
class UGameAmmoWidget final : public UDCPlayerCharacterBasedWidget
{
public:
	int32                                         LoadedAmmoCount;                                   // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalAmmoCount;                                    // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AItemActor*                             WeaponItemActor;                                   // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEquipItemActorsEvent(const TArray<class AItemActor*>& ItemActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAmmoWidget">();
	}
	static class UGameAmmoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAmmoWidget>();
	}
};
static_assert(alignof(UGameAmmoWidget) == 0x000008, "Wrong alignment on UGameAmmoWidget");
static_assert(sizeof(UGameAmmoWidget) == 0x000390, "Wrong size on UGameAmmoWidget");
static_assert(offsetof(UGameAmmoWidget, LoadedAmmoCount) == 0x000380, "Member 'UGameAmmoWidget::LoadedAmmoCount' has a wrong offset!");
static_assert(offsetof(UGameAmmoWidget, TotalAmmoCount) == 0x000384, "Member 'UGameAmmoWidget::TotalAmmoCount' has a wrong offset!");
static_assert(offsetof(UGameAmmoWidget, WeaponItemActor) == 0x000388, "Member 'UGameAmmoWidget::WeaponItemActor' has a wrong offset!");

// Class DungeonCrawler.DCCharacterInventoryWidget
// 0x0068 (0x0448 - 0x03E0)
class UDCCharacterInventoryWidget final : public UDCInventoryWidgetBase
{
public:
	bool                                          bBagValid;                                         // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237F[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCEquipmentWidget*                     EquipWidget;                                       // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           BagWidget;                                         // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryCurrencyWidget*             CurrencyWidget;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryGearScoreWidget*            GearScoreWidget;                                   // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNickname                              Nickname;                                          // 0x0408(0x0040)(Transient, NativeAccessSpecifierPrivate)

public:
	class FText GetTitle() const;
	struct FLinearColor GetTitleColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterInventoryWidget">();
	}
	static class UDCCharacterInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterInventoryWidget>();
	}
};
static_assert(alignof(UDCCharacterInventoryWidget) == 0x000008, "Wrong alignment on UDCCharacterInventoryWidget");
static_assert(sizeof(UDCCharacterInventoryWidget) == 0x000448, "Wrong size on UDCCharacterInventoryWidget");
static_assert(offsetof(UDCCharacterInventoryWidget, bBagValid) == 0x0003E0, "Member 'UDCCharacterInventoryWidget::bBagValid' has a wrong offset!");
static_assert(offsetof(UDCCharacterInventoryWidget, EquipWidget) == 0x0003E8, "Member 'UDCCharacterInventoryWidget::EquipWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInventoryWidget, BagWidget) == 0x0003F0, "Member 'UDCCharacterInventoryWidget::BagWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInventoryWidget, CurrencyWidget) == 0x0003F8, "Member 'UDCCharacterInventoryWidget::CurrencyWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInventoryWidget, GearScoreWidget) == 0x000400, "Member 'UDCCharacterInventoryWidget::GearScoreWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInventoryWidget, Nickname) == 0x000408, "Member 'UDCCharacterInventoryWidget::Nickname' has a wrong offset!");

// Class DungeonCrawler.GA_PickUp
// 0x0168 (0x0708 - 0x05A0)
class UGA_PickUp : public UDCGameplayAbilityBase
{
public:
	struct FDCItemInfo                            PickupItemInfo;                                    // 0x05A0(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPickedUp(class AActor* ItemHolderToPickUp, bool bShouldDestroy);
	void OnStartSync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PickUp">();
	}
	static class UGA_PickUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PickUp>();
	}
};
static_assert(alignof(UGA_PickUp) == 0x000008, "Wrong alignment on UGA_PickUp");
static_assert(sizeof(UGA_PickUp) == 0x000708, "Wrong size on UGA_PickUp");
static_assert(offsetof(UGA_PickUp, PickupItemInfo) == 0x0005A0, "Member 'UGA_PickUp::PickupItemInfo' has a wrong offset!");

// Class DungeonCrawler.ArtDataProjectile
// 0x0038 (0x0080 - 0x0048)
class UArtDataProjectile final : public UArtDataBase
{
public:
	float                                         DestroyTime;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2381[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         HitStaticObject;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         HitCharacter;                                      // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         HitShield;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DefaultEffect;                                     // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoctionOffsetAlongNormal;                          // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomizeHitNormal;                                // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2382[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataProjectile">();
	}
	static class UArtDataProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataProjectile>();
	}
};
static_assert(alignof(UArtDataProjectile) == 0x000008, "Wrong alignment on UArtDataProjectile");
static_assert(sizeof(UArtDataProjectile) == 0x000080, "Wrong size on UArtDataProjectile");
static_assert(offsetof(UArtDataProjectile, DestroyTime) == 0x000048, "Member 'UArtDataProjectile::DestroyTime' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, HitStaticObject) == 0x000050, "Member 'UArtDataProjectile::HitStaticObject' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, HitCharacter) == 0x000058, "Member 'UArtDataProjectile::HitCharacter' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, HitShield) == 0x000060, "Member 'UArtDataProjectile::HitShield' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, DefaultEffect) == 0x000068, "Member 'UArtDataProjectile::DefaultEffect' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, LoctionOffsetAlongNormal) == 0x000070, "Member 'UArtDataProjectile::LoctionOffsetAlongNormal' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, RandomizeHitNormal) == 0x000074, "Member 'UArtDataProjectile::RandomizeHitNormal' has a wrong offset!");
static_assert(offsetof(UArtDataProjectile, Scale) == 0x000078, "Member 'UArtDataProjectile::Scale' has a wrong offset!");

// Class DungeonCrawler.ArtDataSkill
// 0x0028 (0x0070 - 0x0048)
class UArtDataSkill final : public UArtDataBase
{
public:
	class UTexture2D*                             SkillIconTexture;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CastStart;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CastReady;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CastFire;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChannelingStart;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataSkill">();
	}
	static class UArtDataSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataSkill>();
	}
};
static_assert(alignof(UArtDataSkill) == 0x000008, "Wrong alignment on UArtDataSkill");
static_assert(sizeof(UArtDataSkill) == 0x000070, "Wrong size on UArtDataSkill");
static_assert(offsetof(UArtDataSkill, SkillIconTexture) == 0x000048, "Member 'UArtDataSkill::SkillIconTexture' has a wrong offset!");
static_assert(offsetof(UArtDataSkill, CastStart) == 0x000050, "Member 'UArtDataSkill::CastStart' has a wrong offset!");
static_assert(offsetof(UArtDataSkill, CastReady) == 0x000058, "Member 'UArtDataSkill::CastReady' has a wrong offset!");
static_assert(offsetof(UArtDataSkill, CastFire) == 0x000060, "Member 'UArtDataSkill::CastFire' has a wrong offset!");
static_assert(offsetof(UArtDataSkill, ChannelingStart) == 0x000068, "Member 'UArtDataSkill::ChannelingStart' has a wrong offset!");

// Class DungeonCrawler.FriendSlotWidgetData
// 0x01D8 (0x0200 - 0x0028)
class UFriendSlotWidgetData final : public UObject
{
public:
	struct FDCFriendInfo                          Info;                                              // 0x0028(0x0098)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterClassId;                                  // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPlayerCharacter             DesignDataPlayerCharacter;                         // 0x00D0(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UInvitePartyWidget*                     InvitePartyWidget;                                 // 0x01F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSlotWidgetData">();
	}
	static class UFriendSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSlotWidgetData>();
	}
};
static_assert(alignof(UFriendSlotWidgetData) == 0x000008, "Wrong alignment on UFriendSlotWidgetData");
static_assert(sizeof(UFriendSlotWidgetData) == 0x000200, "Wrong size on UFriendSlotWidgetData");
static_assert(offsetof(UFriendSlotWidgetData, Info) == 0x000028, "Member 'UFriendSlotWidgetData::Info' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidgetData, CharacterClassId) == 0x0000C0, "Member 'UFriendSlotWidgetData::CharacterClassId' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidgetData, DesignDataPlayerCharacter) == 0x0000D0, "Member 'UFriendSlotWidgetData::DesignDataPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidgetData, InvitePartyWidget) == 0x0001F8, "Member 'UFriendSlotWidgetData::InvitePartyWidget' has a wrong offset!");

// Class DungeonCrawler.ArtDataSpell
// 0x0030 (0x0078 - 0x0048)
class UArtDataSpell final : public UArtDataBase
{
public:
	class UTexture2D*                             SpellIconTexture;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CastStart;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CastReady;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CastFire;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChannelingStart;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChannelingStartOnCharacter;                        // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataSpell">();
	}
	static class UArtDataSpell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataSpell>();
	}
};
static_assert(alignof(UArtDataSpell) == 0x000008, "Wrong alignment on UArtDataSpell");
static_assert(sizeof(UArtDataSpell) == 0x000078, "Wrong size on UArtDataSpell");
static_assert(offsetof(UArtDataSpell, SpellIconTexture) == 0x000048, "Member 'UArtDataSpell::SpellIconTexture' has a wrong offset!");
static_assert(offsetof(UArtDataSpell, CastStart) == 0x000050, "Member 'UArtDataSpell::CastStart' has a wrong offset!");
static_assert(offsetof(UArtDataSpell, CastReady) == 0x000058, "Member 'UArtDataSpell::CastReady' has a wrong offset!");
static_assert(offsetof(UArtDataSpell, CastFire) == 0x000060, "Member 'UArtDataSpell::CastFire' has a wrong offset!");
static_assert(offsetof(UArtDataSpell, ChannelingStart) == 0x000068, "Member 'UArtDataSpell::ChannelingStart' has a wrong offset!");
static_assert(offsetof(UArtDataSpell, ChannelingStartOnCharacter) == 0x000070, "Member 'UArtDataSpell::ChannelingStartOnCharacter' has a wrong offset!");

// Class DungeonCrawler.DCEngineConfigValidatorSubsystem
// 0x0028 (0x0058 - 0x0030)
class UDCEngineConfigValidatorSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2383[0x28];                                    // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEngineConfigValidatorSubsystem">();
	}
	static class UDCEngineConfigValidatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEngineConfigValidatorSubsystem>();
	}
};
static_assert(alignof(UDCEngineConfigValidatorSubsystem) == 0x000008, "Wrong alignment on UDCEngineConfigValidatorSubsystem");
static_assert(sizeof(UDCEngineConfigValidatorSubsystem) == 0x000058, "Wrong size on UDCEngineConfigValidatorSubsystem");

// Class DungeonCrawler.ItemHolderActorBase
// 0x0268 (0x0570 - 0x0308)
class AItemHolderActorBase : public ADCInteractableActorBase
{
public:
	uint8                                         Pad_2384[0x10];                                    // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         ItemMeshComponent;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        ItemId;                                            // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemDataAsset*                       ItemDataAsset;                                     // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCItemInfo                            ItemInfo;                                          // 0x0338(0x0168)(Net, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemDataMeta                          ItemMetaData;                                      // 0x04A0(0x0068)(Edit, BlueprintVisible, Net, Protected, NativeAccessSpecifierProtected)
	class UArtDataItem*                           ArtDataItem;                                       // 0x0508(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             SoundData;                                         // 0x0510(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        PropInteractId;                                    // 0x0518(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0528(0x0020)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2385[0x20];                                    // 0x0548(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPreview;                                          // 0x0568(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2386[0x7];                                     // 0x0569(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitItemHolderActor(const struct FItemData& InItemData);
	void OnRep_ArtDataItem(class UArtDataItem* OldArtDataItem);
	void OnRep_ItemInfo(const struct FDCItemInfo& OldItemInfo);
	void OverrideItemArtData(class UArtDataItem* NewItemArtData);
	void SetItemId(const struct FPrimaryAssetId& InItemId);

	struct FPrimaryAssetId GetItemId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemHolderActorBase">();
	}
	static class AItemHolderActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemHolderActorBase>();
	}
};
static_assert(alignof(AItemHolderActorBase) == 0x000008, "Wrong alignment on AItemHolderActorBase");
static_assert(sizeof(AItemHolderActorBase) == 0x000570, "Wrong size on AItemHolderActorBase");
static_assert(offsetof(AItemHolderActorBase, ItemMeshComponent) == 0x000318, "Member 'AItemHolderActorBase::ItemMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, ItemId) == 0x000320, "Member 'AItemHolderActorBase::ItemId' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, ItemDataAsset) == 0x000330, "Member 'AItemHolderActorBase::ItemDataAsset' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, ItemInfo) == 0x000338, "Member 'AItemHolderActorBase::ItemInfo' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, ItemMetaData) == 0x0004A0, "Member 'AItemHolderActorBase::ItemMetaData' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, ArtDataItem) == 0x000508, "Member 'AItemHolderActorBase::ArtDataItem' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, SoundData) == 0x000510, "Member 'AItemHolderActorBase::SoundData' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, PropInteractId) == 0x000518, "Member 'AItemHolderActorBase::PropInteractId' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, GameplayTagContainer) == 0x000528, "Member 'AItemHolderActorBase::GameplayTagContainer' has a wrong offset!");
static_assert(offsetof(AItemHolderActorBase, bPreview) == 0x000568, "Member 'AItemHolderActorBase::bPreview' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitGenericGameplayTagEvent
// 0x0038 (0x00B8 - 0x0080)
class UDCAT_WaitGenericGameplayTagEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             Added;                                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Removed;                                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2387[0x10];                                    // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitGenericGameplayTagEvent* WaitGenericGameplayTagEvent(class UGameplayAbility* OwningAbility, class AActor* InOptionalExternalTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitGenericGameplayTagEvent">();
	}
	static class UDCAT_WaitGenericGameplayTagEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitGenericGameplayTagEvent>();
	}
};
static_assert(alignof(UDCAT_WaitGenericGameplayTagEvent) == 0x000008, "Wrong alignment on UDCAT_WaitGenericGameplayTagEvent");
static_assert(sizeof(UDCAT_WaitGenericGameplayTagEvent) == 0x0000B8, "Wrong size on UDCAT_WaitGenericGameplayTagEvent");
static_assert(offsetof(UDCAT_WaitGenericGameplayTagEvent, Added) == 0x000080, "Member 'UDCAT_WaitGenericGameplayTagEvent::Added' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitGenericGameplayTagEvent, Removed) == 0x000090, "Member 'UDCAT_WaitGenericGameplayTagEvent::Removed' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitGenericGameplayTagEvent, OptionalExternalTarget) == 0x0000A0, "Member 'UDCAT_WaitGenericGameplayTagEvent::OptionalExternalTarget' has a wrong offset!");

// Class DungeonCrawler.ArtDataMusic
// 0x0068 (0x00B0 - 0x0048)
class UArtDataMusic final : public UArtDataBase
{
public:
	class UTexture2D*                             MusicIconTexture;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PlayStart;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PlayStartOnCharacter;                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PlayReady;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PlayReadyOnCharacter;                              // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PlayFire;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PlayFireOnCharacter;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChannelingStart;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChannelingStartOnCharacter;                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         MusicParticleSystemOnTarget;                       // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MusicParticleSystemOnTargetAttachBoneName;         // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         MusicNoteSystemOnTarget;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MusicNoteSystemMaterial;                           // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataMusic">();
	}
	static class UArtDataMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataMusic>();
	}
};
static_assert(alignof(UArtDataMusic) == 0x000008, "Wrong alignment on UArtDataMusic");
static_assert(sizeof(UArtDataMusic) == 0x0000B0, "Wrong size on UArtDataMusic");
static_assert(offsetof(UArtDataMusic, MusicIconTexture) == 0x000048, "Member 'UArtDataMusic::MusicIconTexture' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, PlayStart) == 0x000050, "Member 'UArtDataMusic::PlayStart' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, PlayStartOnCharacter) == 0x000058, "Member 'UArtDataMusic::PlayStartOnCharacter' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, PlayReady) == 0x000060, "Member 'UArtDataMusic::PlayReady' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, PlayReadyOnCharacter) == 0x000068, "Member 'UArtDataMusic::PlayReadyOnCharacter' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, PlayFire) == 0x000070, "Member 'UArtDataMusic::PlayFire' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, PlayFireOnCharacter) == 0x000078, "Member 'UArtDataMusic::PlayFireOnCharacter' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, ChannelingStart) == 0x000080, "Member 'UArtDataMusic::ChannelingStart' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, ChannelingStartOnCharacter) == 0x000088, "Member 'UArtDataMusic::ChannelingStartOnCharacter' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, MusicParticleSystemOnTarget) == 0x000090, "Member 'UArtDataMusic::MusicParticleSystemOnTarget' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, MusicParticleSystemOnTargetAttachBoneName) == 0x000098, "Member 'UArtDataMusic::MusicParticleSystemOnTargetAttachBoneName' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, MusicNoteSystemOnTarget) == 0x0000A0, "Member 'UArtDataMusic::MusicNoteSystemOnTarget' has a wrong offset!");
static_assert(offsetof(UArtDataMusic, MusicNoteSystemMaterial) == 0x0000A8, "Member 'UArtDataMusic::MusicNoteSystemMaterial' has a wrong offset!");

// Class DungeonCrawler.ArtDataPerk
// 0x0008 (0x0050 - 0x0048)
class UArtDataPerk final : public UArtDataBase
{
public:
	class UTexture2D*                             PerkIconTexture;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataPerk">();
	}
	static class UArtDataPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataPerk>();
	}
};
static_assert(alignof(UArtDataPerk) == 0x000008, "Wrong alignment on UArtDataPerk");
static_assert(sizeof(UArtDataPerk) == 0x000050, "Wrong size on UArtDataPerk");
static_assert(offsetof(UArtDataPerk, PerkIconTexture) == 0x000048, "Member 'UArtDataPerk::PerkIconTexture' has a wrong offset!");

// Class DungeonCrawler.PopupDataBase
// 0x0008 (0x0030 - 0x0028)
class UPopupDataBase : public UObject
{
public:
	uint8                                         Pad_2388[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupDataBase">();
	}
	static class UPopupDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupDataBase>();
	}
};
static_assert(alignof(UPopupDataBase) == 0x000008, "Wrong alignment on UPopupDataBase");
static_assert(sizeof(UPopupDataBase) == 0x000030, "Wrong size on UPopupDataBase");

// Class DungeonCrawler.DCQuestCompleteResultPopupData
// 0x0040 (0x0070 - 0x0030)
class UDCQuestCompleteResultPopupData final : public UPopupDataBase
{
public:
	struct FDCMerchantId                          MerchantId;                                        // 0x0030(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0040(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   ResultText;                                        // 0x0058(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestCompleteResultPopupData">();
	}
	static class UDCQuestCompleteResultPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestCompleteResultPopupData>();
	}
};
static_assert(alignof(UDCQuestCompleteResultPopupData) == 0x000008, "Wrong alignment on UDCQuestCompleteResultPopupData");
static_assert(sizeof(UDCQuestCompleteResultPopupData) == 0x000070, "Wrong size on UDCQuestCompleteResultPopupData");
static_assert(offsetof(UDCQuestCompleteResultPopupData, MerchantId) == 0x000030, "Member 'UDCQuestCompleteResultPopupData::MerchantId' has a wrong offset!");
static_assert(offsetof(UDCQuestCompleteResultPopupData, TitleText) == 0x000040, "Member 'UDCQuestCompleteResultPopupData::TitleText' has a wrong offset!");
static_assert(offsetof(UDCQuestCompleteResultPopupData, ResultText) == 0x000058, "Member 'UDCQuestCompleteResultPopupData::ResultText' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinArtData
// 0x0008 (0x0050 - 0x0048)
class UDCActionSkinArtData final : public UArtDataBase
{
public:
	class UTexture2D*                             IconTexture;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinArtData">();
	}
	static class UDCActionSkinArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinArtData>();
	}
};
static_assert(alignof(UDCActionSkinArtData) == 0x000008, "Wrong alignment on UDCActionSkinArtData");
static_assert(sizeof(UDCActionSkinArtData) == 0x000050, "Wrong size on UDCActionSkinArtData");
static_assert(offsetof(UDCActionSkinArtData, IconTexture) == 0x000048, "Member 'UDCActionSkinArtData::IconTexture' has a wrong offset!");

// Class DungeonCrawler.ArtDataMerchant
// 0x0008 (0x0050 - 0x0048)
class UArtDataMerchant final : public UArtDataBase
{
public:
	class UTexture2D*                             MerchantIconTexture;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataMerchant">();
	}
	static class UArtDataMerchant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataMerchant>();
	}
};
static_assert(alignof(UArtDataMerchant) == 0x000008, "Wrong alignment on UArtDataMerchant");
static_assert(sizeof(UArtDataMerchant) == 0x000050, "Wrong size on UArtDataMerchant");
static_assert(offsetof(UArtDataMerchant, MerchantIconTexture) == 0x000048, "Member 'UArtDataMerchant::MerchantIconTexture' has a wrong offset!");

// Class DungeonCrawler.DCQuestLogDealTableWidget
// 0x0120 (0x03E0 - 0x02C0)
class UDCQuestLogDealTableWidget final : public UUserWidget
{
public:
	class UDCCommonButtonBase*                    ButtonAccept;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonComplete;                                    // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCQuestCompleteResultPopup> QuestCompleteResultPopupClass;                     // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RequiredLevelText;                                 // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequiredQuestText;                                 // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequiredAffinityText;                              // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRewardItemWidget>        RewardItemWidgetClass;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UListView*                              RequirementListView;                               // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         RewardItemHorizontalBox;                           // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCQuestRequirementFetchWidget*         FetchRequiredWidget;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCQuestInfo                           QuestInfo;                                         // 0x0348(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class FString                                 MerchantId;                                        // 0x0398(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ChapterId;                                         // 0x03A8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCQuestCompleteInfo                   QuestCompleteInfo;                                 // 0x03B8(0x0028)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnButtonAccept();
	void OnButtonComplete();
	void OnButtonItemDeliver();
	void OnMatchStateChange(bool bIsMatching);
	void OnQuestInfoUpdated();

	EDCQuestState GetQuestState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogDealTableWidget">();
	}
	static class UDCQuestLogDealTableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogDealTableWidget>();
	}
};
static_assert(alignof(UDCQuestLogDealTableWidget) == 0x000008, "Wrong alignment on UDCQuestLogDealTableWidget");
static_assert(sizeof(UDCQuestLogDealTableWidget) == 0x0003E0, "Wrong size on UDCQuestLogDealTableWidget");
static_assert(offsetof(UDCQuestLogDealTableWidget, ButtonAccept) == 0x0002C0, "Member 'UDCQuestLogDealTableWidget::ButtonAccept' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, ButtonComplete) == 0x0002C8, "Member 'UDCQuestLogDealTableWidget::ButtonComplete' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, QuestCompleteResultPopupClass) == 0x0002D0, "Member 'UDCQuestLogDealTableWidget::QuestCompleteResultPopupClass' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, RequiredLevelText) == 0x0002D8, "Member 'UDCQuestLogDealTableWidget::RequiredLevelText' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, RequiredQuestText) == 0x0002F0, "Member 'UDCQuestLogDealTableWidget::RequiredQuestText' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, RequiredAffinityText) == 0x000308, "Member 'UDCQuestLogDealTableWidget::RequiredAffinityText' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, RewardItemWidgetClass) == 0x000320, "Member 'UDCQuestLogDealTableWidget::RewardItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, MerchantInfoWidget) == 0x000328, "Member 'UDCQuestLogDealTableWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, RequirementListView) == 0x000330, "Member 'UDCQuestLogDealTableWidget::RequirementListView' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, RewardItemHorizontalBox) == 0x000338, "Member 'UDCQuestLogDealTableWidget::RewardItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, FetchRequiredWidget) == 0x000340, "Member 'UDCQuestLogDealTableWidget::FetchRequiredWidget' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, QuestInfo) == 0x000348, "Member 'UDCQuestLogDealTableWidget::QuestInfo' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, MerchantId) == 0x000398, "Member 'UDCQuestLogDealTableWidget::MerchantId' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, ChapterId) == 0x0003A8, "Member 'UDCQuestLogDealTableWidget::ChapterId' has a wrong offset!");
static_assert(offsetof(UDCQuestLogDealTableWidget, QuestCompleteInfo) == 0x0003B8, "Member 'UDCQuestLogDealTableWidget::QuestCompleteInfo' has a wrong offset!");

// Class DungeonCrawler.ArtDataEmote
// 0x0008 (0x0050 - 0x0048)
class UArtDataEmote final : public UArtDataBase
{
public:
	class UTexture2D*                             EmoteIconTexture;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataEmote">();
	}
	static class UArtDataEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataEmote>();
	}
};
static_assert(alignof(UArtDataEmote) == 0x000008, "Wrong alignment on UArtDataEmote");
static_assert(sizeof(UArtDataEmote) == 0x000050, "Wrong size on UArtDataEmote");
static_assert(offsetof(UArtDataEmote, EmoteIconTexture) == 0x000048, "Member 'UArtDataEmote::EmoteIconTexture' has a wrong offset!");

// Class DungeonCrawler.KarmaReportWidgetBase
// 0x0010 (0x0368 - 0x0358)
class UKarmaReportWidgetBase final : public UDCWidgetBase
{
public:
	int32                                         MyFame;                                            // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2389[0x4];                                     // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextFame;                                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFMsgWidgetKarmaReportActionResponseBlueprint(const struct FMsgWidgetKarmaReportActionResponse& InMsg);
	void OnFMsgWidgetKarmaReportInfoNotifyBlueprint(const struct FMsgWidgetKarmaReportInfoNotify& InMsg);
	void OnUpdateFame();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KarmaReportWidgetBase">();
	}
	static class UKarmaReportWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKarmaReportWidgetBase>();
	}
};
static_assert(alignof(UKarmaReportWidgetBase) == 0x000008, "Wrong alignment on UKarmaReportWidgetBase");
static_assert(sizeof(UKarmaReportWidgetBase) == 0x000368, "Wrong size on UKarmaReportWidgetBase");
static_assert(offsetof(UKarmaReportWidgetBase, MyFame) == 0x000358, "Member 'UKarmaReportWidgetBase::MyFame' has a wrong offset!");
static_assert(offsetof(UKarmaReportWidgetBase, TextFame) == 0x000360, "Member 'UKarmaReportWidgetBase::TextFame' has a wrong offset!");

// Class DungeonCrawler.DCArmorSkinDataAsset
// 0x0068 (0x00B0 - 0x0048)
class UDCArmorSkinDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCArmorSkinDataAsset;                         // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataArmor>           Art;                                               // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetItem;                                        // 0x00A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemPreviewDataAsset*                ItemPreview;                                       // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCArmorSkinDataAsset">();
	}
	static class UDCArmorSkinDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCArmorSkinDataAsset>();
	}
};
static_assert(alignof(UDCArmorSkinDataAsset) == 0x000008, "Wrong alignment on UDCArmorSkinDataAsset");
static_assert(sizeof(UDCArmorSkinDataAsset) == 0x0000B0, "Wrong size on UDCArmorSkinDataAsset");
static_assert(offsetof(UDCArmorSkinDataAsset, Name_DCArmorSkinDataAsset) == 0x000048, "Member 'UDCArmorSkinDataAsset::Name_DCArmorSkinDataAsset' has a wrong offset!");
static_assert(offsetof(UDCArmorSkinDataAsset, FlavorText) == 0x000060, "Member 'UDCArmorSkinDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCArmorSkinDataAsset, Art) == 0x000078, "Member 'UDCArmorSkinDataAsset::Art' has a wrong offset!");
static_assert(offsetof(UDCArmorSkinDataAsset, TargetItem) == 0x0000A0, "Member 'UDCArmorSkinDataAsset::TargetItem' has a wrong offset!");
static_assert(offsetof(UDCArmorSkinDataAsset, ItemPreview) == 0x0000A8, "Member 'UDCArmorSkinDataAsset::ItemPreview' has a wrong offset!");

// Class DungeonCrawler.ArtDataRewardItem
// 0x0050 (0x0098 - 0x0048)
class UArtDataRewardItem final : public UArtDataBase
{
public:
	class UTexture2D*                             RewardTexture;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RewardItemName;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RewardItemDescription;                             // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RewardItemFlavorText;                              // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtDataRewardItem">();
	}
	static class UArtDataRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtDataRewardItem>();
	}
};
static_assert(alignof(UArtDataRewardItem) == 0x000008, "Wrong alignment on UArtDataRewardItem");
static_assert(sizeof(UArtDataRewardItem) == 0x000098, "Wrong size on UArtDataRewardItem");
static_assert(offsetof(UArtDataRewardItem, RewardTexture) == 0x000048, "Member 'UArtDataRewardItem::RewardTexture' has a wrong offset!");
static_assert(offsetof(UArtDataRewardItem, RewardItemName) == 0x000050, "Member 'UArtDataRewardItem::RewardItemName' has a wrong offset!");
static_assert(offsetof(UArtDataRewardItem, RewardItemDescription) == 0x000068, "Member 'UArtDataRewardItem::RewardItemDescription' has a wrong offset!");
static_assert(offsetof(UArtDataRewardItem, RewardItemFlavorText) == 0x000080, "Member 'UArtDataRewardItem::RewardItemFlavorText' has a wrong offset!");

// Class DungeonCrawler.LeaderboardClassDataItemWidgetData
// 0x0008 (0x0030 - 0x0028)
class ULeaderboardClassDataItemWidgetData final : public UObject
{
public:
	class UDCPlayerCharacterDataAsset*            PlayerCharacterData;                               // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardClassDataItemWidgetData">();
	}
	static class ULeaderboardClassDataItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardClassDataItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardClassDataItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardClassDataItemWidgetData");
static_assert(sizeof(ULeaderboardClassDataItemWidgetData) == 0x000030, "Wrong size on ULeaderboardClassDataItemWidgetData");
static_assert(offsetof(ULeaderboardClassDataItemWidgetData, PlayerCharacterData) == 0x000028, "Member 'ULeaderboardClassDataItemWidgetData::PlayerCharacterData' has a wrong offset!");

// Class DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem
// 0x0000 (0x01E8 - 0x01E8)
class UDCEnhancedInputLocalPlayerSubsystem final : public UEnhancedInputLocalPlayerSubsystem
{
public:
	void AddPlayerMappableConfigByTag(const struct FGameplayTag& InputConfigTag, const struct FModifyContextOptions& Options);
	void RemovePlayerMappableConfigByTag(const struct FGameplayTag& InputConfigTag, const struct FModifyContextOptions& Options);

	const class UDCInputConfig* GetInputConfig(const struct FGameplayTag& ConfigTag) const;
	const class UPlayerMappableInputConfig* GetPlayerMappableInputConfig(const struct FGameplayTag& ConfigTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEnhancedInputLocalPlayerSubsystem">();
	}
	static class UDCEnhancedInputLocalPlayerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEnhancedInputLocalPlayerSubsystem>();
	}
};
static_assert(alignof(UDCEnhancedInputLocalPlayerSubsystem) == 0x000008, "Wrong alignment on UDCEnhancedInputLocalPlayerSubsystem");
static_assert(sizeof(UDCEnhancedInputLocalPlayerSubsystem) == 0x0001E8, "Wrong size on UDCEnhancedInputLocalPlayerSubsystem");

// Class DungeonCrawler.DCQuestListEntryWidgetData
// 0x0058 (0x0080 - 0x0028)
class UDCQuestListEntryWidgetData final : public UObject
{
public:
	struct FDCQuestInfo                           QuestInfo;                                         // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bIsFirst;                                          // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLast;                                           // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x007A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238C[0x5];                                     // 0x007B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestListEntryWidgetData">();
	}
	static class UDCQuestListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestListEntryWidgetData>();
	}
};
static_assert(alignof(UDCQuestListEntryWidgetData) == 0x000008, "Wrong alignment on UDCQuestListEntryWidgetData");
static_assert(sizeof(UDCQuestListEntryWidgetData) == 0x000080, "Wrong size on UDCQuestListEntryWidgetData");
static_assert(offsetof(UDCQuestListEntryWidgetData, QuestInfo) == 0x000028, "Member 'UDCQuestListEntryWidgetData::QuestInfo' has a wrong offset!");
static_assert(offsetof(UDCQuestListEntryWidgetData, bIsFirst) == 0x000078, "Member 'UDCQuestListEntryWidgetData::bIsFirst' has a wrong offset!");
static_assert(offsetof(UDCQuestListEntryWidgetData, bIsLast) == 0x000079, "Member 'UDCQuestListEntryWidgetData::bIsLast' has a wrong offset!");
static_assert(offsetof(UDCQuestListEntryWidgetData, bIsSelected) == 0x00007A, "Member 'UDCQuestListEntryWidgetData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.AsyncTaskAttributeChanged
// 0x0060 (0x0090 - 0x0030)
class UAsyncTaskAttributeChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnAttributeChanged;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238D[0x48];                                    // 0x0048(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskAttributeChanged* ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute);
	static class UAsyncTaskAttributeChanged* ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FGameplayAttribute>& Attributes);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskAttributeChanged">();
	}
	static class UAsyncTaskAttributeChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskAttributeChanged>();
	}
};
static_assert(alignof(UAsyncTaskAttributeChanged) == 0x000008, "Wrong alignment on UAsyncTaskAttributeChanged");
static_assert(sizeof(UAsyncTaskAttributeChanged) == 0x000090, "Wrong size on UAsyncTaskAttributeChanged");
static_assert(offsetof(UAsyncTaskAttributeChanged, OnAttributeChanged) == 0x000030, "Member 'UAsyncTaskAttributeChanged::OnAttributeChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskAttributeChanged, ASC) == 0x000040, "Member 'UAsyncTaskAttributeChanged::ASC' has a wrong offset!");

// Class DungeonCrawler.AsyncTaskCooldownChanged
// 0x0050 (0x0080 - 0x0030)
class UAsyncTaskCooldownChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnCooldownBegin;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCooldownEnd;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238E[0x28];                                    // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskCooldownChanged* ListenForCooldownChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTagContainer& CooldownTags, bool UseServerCooldown);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskCooldownChanged">();
	}
	static class UAsyncTaskCooldownChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskCooldownChanged>();
	}
};
static_assert(alignof(UAsyncTaskCooldownChanged) == 0x000008, "Wrong alignment on UAsyncTaskCooldownChanged");
static_assert(sizeof(UAsyncTaskCooldownChanged) == 0x000080, "Wrong size on UAsyncTaskCooldownChanged");
static_assert(offsetof(UAsyncTaskCooldownChanged, OnCooldownBegin) == 0x000030, "Member 'UAsyncTaskCooldownChanged::OnCooldownBegin' has a wrong offset!");
static_assert(offsetof(UAsyncTaskCooldownChanged, OnCooldownEnd) == 0x000040, "Member 'UAsyncTaskCooldownChanged::OnCooldownEnd' has a wrong offset!");
static_assert(offsetof(UAsyncTaskCooldownChanged, ASC) == 0x000050, "Member 'UAsyncTaskCooldownChanged::ASC' has a wrong offset!");

// Class DungeonCrawler.DCAoeDataAsset
// 0x0088 (0x00D0 - 0x0048)
class UDCAoeDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCAoeDataAsset;                               // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataAoe>             ArtData;                                           // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0088(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAoeDataAsset">();
	}
	static class UDCAoeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAoeDataAsset>();
	}
};
static_assert(alignof(UDCAoeDataAsset) == 0x000008, "Wrong alignment on UDCAoeDataAsset");
static_assert(sizeof(UDCAoeDataAsset) == 0x0000D0, "Wrong size on UDCAoeDataAsset");
static_assert(offsetof(UDCAoeDataAsset, Name_DCAoeDataAsset) == 0x000048, "Member 'UDCAoeDataAsset::Name_DCAoeDataAsset' has a wrong offset!");
static_assert(offsetof(UDCAoeDataAsset, ArtData) == 0x000060, "Member 'UDCAoeDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCAoeDataAsset, SoundData) == 0x000088, "Member 'UDCAoeDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCAoeDataAsset, Abilities) == 0x0000B0, "Member 'UDCAoeDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCAoeDataAsset, Effects) == 0x0000C0, "Member 'UDCAoeDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.AsyncTaskEffectInhibitionChanged
// 0x0020 (0x0050 - 0x0030)
class UAsyncTaskEffectInhibitionChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnGameplayEffectInhibitionChange;                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2390[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskEffectInhibitionChanged* ListenForGameplayInhibitionChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectInhibitionChanged">();
	}
	static class UAsyncTaskEffectInhibitionChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectInhibitionChanged>();
	}
};
static_assert(alignof(UAsyncTaskEffectInhibitionChanged) == 0x000008, "Wrong alignment on UAsyncTaskEffectInhibitionChanged");
static_assert(sizeof(UAsyncTaskEffectInhibitionChanged) == 0x000050, "Wrong size on UAsyncTaskEffectInhibitionChanged");
static_assert(offsetof(UAsyncTaskEffectInhibitionChanged, OnGameplayEffectInhibitionChange) == 0x000030, "Member 'UAsyncTaskEffectInhibitionChanged::OnGameplayEffectInhibitionChange' has a wrong offset!");
static_assert(offsetof(UAsyncTaskEffectInhibitionChanged, ASC) == 0x000040, "Member 'UAsyncTaskEffectInhibitionChanged::ASC' has a wrong offset!");

// Class DungeonCrawler.DCQuestChapterListEntryWidget
// 0x0028 (0x0380 - 0x0358)
class UDCQuestChapterListEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2391[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ChapterName;                                       // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCQuestListWidget*                     QuestListWidget;                                   // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestChapterListEntryWidget">();
	}
	static class UDCQuestChapterListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestChapterListEntryWidget>();
	}
};
static_assert(alignof(UDCQuestChapterListEntryWidget) == 0x000008, "Wrong alignment on UDCQuestChapterListEntryWidget");
static_assert(sizeof(UDCQuestChapterListEntryWidget) == 0x000380, "Wrong size on UDCQuestChapterListEntryWidget");
static_assert(offsetof(UDCQuestChapterListEntryWidget, ChapterName) == 0x000360, "Member 'UDCQuestChapterListEntryWidget::ChapterName' has a wrong offset!");
static_assert(offsetof(UDCQuestChapterListEntryWidget, QuestListWidget) == 0x000378, "Member 'UDCQuestChapterListEntryWidget::QuestListWidget' has a wrong offset!");

// Class DungeonCrawler.PlayerCharacterCaptureActor
// 0x01C0 (0x04B8 - 0x02F8)
class APlayerCharacterCaptureActor final : public ADCActorBase
{
public:
	uint8                                         Pad_2392[0x10];                                    // 0x02F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCAccountId                           TargetAccount;                                     // 0x0308(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 TargetPlayerCharacter;                             // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RootSceneComponent;                                // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartHead;                                          // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartTongue;                                        // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartHelmet;                                        // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartGloves;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartChest;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartPants;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBoots;                                         // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBack;                                          // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartTail;                                          // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        DefaultIdleAnimation;                              // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartRotateLocation;                               // 0x0380(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2393[0x4];                                     // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSceneCaptureComponent2D*             SceneCapture2D;                                    // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        ItemStandIdleAnimation;                            // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCAkComponent*                         DCAKEmitter;                                       // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCAkComponent*                         DCAKListener;                                      // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAccountLink*                           AccountLink;                                       // 0x03B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LinkedAccountId;                                   // 0x03C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CheckTargetAccountId;                              // 0x03D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UEquipmentInventoryComponent> CapturedEquipmentComponent;                        // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterDataComponent*              DataComponent;                                     // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterPartsComponent*             PartsComponent;                                    // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterSkinComponent*              CharacterSkinComponent;                            // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCItemSkinComponent*                   ItemSkinComponent;                                 // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCArmorSkinComponent*                  ArmorSkinComponent;                                // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, struct FDCItemInfo>    ItemInfos;                                         // 0x0410(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, class AItemActor*>     ItemActors;                                        // 0x0460(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2394[0x8];                                     // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimInstance* GetCharacterMeshAnimInstance();
	void OnItemEquipped(const class UAnimationAsset* ItemStandIdle, const struct FGameplayTag& ItemHandType, const struct FGameplayTag& ItemSlotType);
	void ResetMeshRotation();
	void SetMeshRotation(float InYaw);
	void SetMeshRotationSpeedMultiplier(float Value);
	void SetStartRotateLocation(float InStartPosition);

	class UTextureRenderTarget2D* GetRenderTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacterCaptureActor">();
	}
	static class APlayerCharacterCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCharacterCaptureActor>();
	}
};
static_assert(alignof(APlayerCharacterCaptureActor) == 0x000008, "Wrong alignment on APlayerCharacterCaptureActor");
static_assert(sizeof(APlayerCharacterCaptureActor) == 0x0004B8, "Wrong size on APlayerCharacterCaptureActor");
static_assert(offsetof(APlayerCharacterCaptureActor, TargetAccount) == 0x000308, "Member 'APlayerCharacterCaptureActor::TargetAccount' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, TargetPlayerCharacter) == 0x000318, "Member 'APlayerCharacterCaptureActor::TargetPlayerCharacter' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, RootSceneComponent) == 0x000320, "Member 'APlayerCharacterCaptureActor::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, Mesh) == 0x000328, "Member 'APlayerCharacterCaptureActor::Mesh' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartHead) == 0x000330, "Member 'APlayerCharacterCaptureActor::PartHead' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartTongue) == 0x000338, "Member 'APlayerCharacterCaptureActor::PartTongue' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartHelmet) == 0x000340, "Member 'APlayerCharacterCaptureActor::PartHelmet' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartGloves) == 0x000348, "Member 'APlayerCharacterCaptureActor::PartGloves' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartChest) == 0x000350, "Member 'APlayerCharacterCaptureActor::PartChest' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartPants) == 0x000358, "Member 'APlayerCharacterCaptureActor::PartPants' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartBoots) == 0x000360, "Member 'APlayerCharacterCaptureActor::PartBoots' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartBack) == 0x000368, "Member 'APlayerCharacterCaptureActor::PartBack' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartTail) == 0x000370, "Member 'APlayerCharacterCaptureActor::PartTail' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, DefaultIdleAnimation) == 0x000378, "Member 'APlayerCharacterCaptureActor::DefaultIdleAnimation' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, StartRotateLocation) == 0x000380, "Member 'APlayerCharacterCaptureActor::StartRotateLocation' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, AbilitySystemComponent) == 0x000388, "Member 'APlayerCharacterCaptureActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, SceneCapture2D) == 0x000390, "Member 'APlayerCharacterCaptureActor::SceneCapture2D' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, RenderTarget) == 0x000398, "Member 'APlayerCharacterCaptureActor::RenderTarget' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, ItemStandIdleAnimation) == 0x0003A0, "Member 'APlayerCharacterCaptureActor::ItemStandIdleAnimation' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, DCAKEmitter) == 0x0003A8, "Member 'APlayerCharacterCaptureActor::DCAKEmitter' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, DCAKListener) == 0x0003B0, "Member 'APlayerCharacterCaptureActor::DCAKListener' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, AccountLink) == 0x0003B8, "Member 'APlayerCharacterCaptureActor::AccountLink' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, LinkedAccountId) == 0x0003C0, "Member 'APlayerCharacterCaptureActor::LinkedAccountId' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, CheckTargetAccountId) == 0x0003D0, "Member 'APlayerCharacterCaptureActor::CheckTargetAccountId' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, CapturedEquipmentComponent) == 0x0003E0, "Member 'APlayerCharacterCaptureActor::CapturedEquipmentComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, DataComponent) == 0x0003E8, "Member 'APlayerCharacterCaptureActor::DataComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, PartsComponent) == 0x0003F0, "Member 'APlayerCharacterCaptureActor::PartsComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, CharacterSkinComponent) == 0x0003F8, "Member 'APlayerCharacterCaptureActor::CharacterSkinComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, ItemSkinComponent) == 0x000400, "Member 'APlayerCharacterCaptureActor::ItemSkinComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, ArmorSkinComponent) == 0x000408, "Member 'APlayerCharacterCaptureActor::ArmorSkinComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, ItemInfos) == 0x000410, "Member 'APlayerCharacterCaptureActor::ItemInfos' has a wrong offset!");
static_assert(offsetof(APlayerCharacterCaptureActor, ItemActors) == 0x000460, "Member 'APlayerCharacterCaptureActor::ItemActors' has a wrong offset!");

// Class DungeonCrawler.DCAT_WindforceToActor
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WindforceToActor final : public UAbilityTask
{
public:
	uint8                                         Pad_2395[0x20];                                    // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WindforceToActor* WindforceToActor(class UGameplayAbility* OwningAbility, class ADCPlayerCharacterBase* TargetCharcter, const struct FVector& WindVector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WindforceToActor">();
	}
	static class UDCAT_WindforceToActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WindforceToActor>();
	}
};
static_assert(alignof(UDCAT_WindforceToActor) == 0x000008, "Wrong alignment on UDCAT_WindforceToActor");
static_assert(sizeof(UDCAT_WindforceToActor) == 0x0000A0, "Wrong size on UDCAT_WindforceToActor");

// Class DungeonCrawler.AsyncTaskEffectStackChanged
// 0x0030 (0x0060 - 0x0030)
class UAsyncTaskEffectStackChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnGameplayEffectStackChange;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameplayEffectDurationChange;                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2396[0x8];                                     // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskEffectStackChanged* ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectStackChanged">();
	}
	static class UAsyncTaskEffectStackChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectStackChanged>();
	}
};
static_assert(alignof(UAsyncTaskEffectStackChanged) == 0x000008, "Wrong alignment on UAsyncTaskEffectStackChanged");
static_assert(sizeof(UAsyncTaskEffectStackChanged) == 0x000060, "Wrong size on UAsyncTaskEffectStackChanged");
static_assert(offsetof(UAsyncTaskEffectStackChanged, OnGameplayEffectStackChange) == 0x000030, "Member 'UAsyncTaskEffectStackChanged::OnGameplayEffectStackChange' has a wrong offset!");
static_assert(offsetof(UAsyncTaskEffectStackChanged, OnGameplayEffectDurationChange) == 0x000040, "Member 'UAsyncTaskEffectStackChanged::OnGameplayEffectDurationChange' has a wrong offset!");
static_assert(offsetof(UAsyncTaskEffectStackChanged, ASC) == 0x000050, "Member 'UAsyncTaskEffectStackChanged::ASC' has a wrong offset!");

// Class DungeonCrawler.AsyncTaskWaitGAActivated
// 0x0108 (0x0140 - 0x0038)
class UAsyncTaskWaitGAActivated final : public UAbilityAsync
{
public:
	uint8                                         Pad_2397[0xE8];                                    // 0x0038(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActivate;                                        // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2398[0x10];                                    // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskWaitGAActivated* WaitForAbilityActivate(class AActor* TargetActor, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool IncludeTriggeredAbilities, bool TriggerOnce);
	static class UAsyncTaskWaitGAActivated* WaitForAbilityActivate_Query(class AActor* TargetActor, const struct FGameplayTagQuery& Query, bool IncludeTriggeredAbilities, bool TriggerOnce);
	static class UAsyncTaskWaitGAActivated* WaitForAbilityActivateWithTagRequirements(class AActor* TargetActor, const struct FGameplayTagRequirements& TagRequirements, bool IncludeTriggeredAbilities, bool TriggerOnce);

	void OnAbilityActivate(class UGameplayAbility* ActivatedAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskWaitGAActivated">();
	}
	static class UAsyncTaskWaitGAActivated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskWaitGAActivated>();
	}
};
static_assert(alignof(UAsyncTaskWaitGAActivated) == 0x000008, "Wrong alignment on UAsyncTaskWaitGAActivated");
static_assert(sizeof(UAsyncTaskWaitGAActivated) == 0x000140, "Wrong size on UAsyncTaskWaitGAActivated");
static_assert(offsetof(UAsyncTaskWaitGAActivated, OnActivate) == 0x000120, "Member 'UAsyncTaskWaitGAActivated::OnActivate' has a wrong offset!");

// Class DungeonCrawler.DCQuestContentDataAsset
// 0x0018 (0x0060 - 0x0048)
class UDCQuestContentDataAsset : public UDCTableDataAsset
{
public:
	TArray<struct FGameplayTag>                   DungeonIdTags;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EDCQuestContentType                           ContentType;                                       // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239C[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContentCount;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentDataAsset">();
	}
	static class UDCQuestContentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentDataAsset");
static_assert(sizeof(UDCQuestContentDataAsset) == 0x000060, "Wrong size on UDCQuestContentDataAsset");
static_assert(offsetof(UDCQuestContentDataAsset, DungeonIdTags) == 0x000048, "Member 'UDCQuestContentDataAsset::DungeonIdTags' has a wrong offset!");
static_assert(offsetof(UDCQuestContentDataAsset, ContentType) == 0x000058, "Member 'UDCQuestContentDataAsset::ContentType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentDataAsset, ContentCount) == 0x00005C, "Member 'UDCQuestContentDataAsset::ContentCount' has a wrong offset!");

// Class DungeonCrawler.DCQuestContentUseItemDataAsset
// 0x0038 (0x0098 - 0x0060)
class UDCQuestContentUseItemDataAsset final : public UDCQuestContentDataAsset
{
public:
	EItemType                                     ItemType;                                          // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239D[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ItemIdTag;                                         // 0x0064(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TypeTag;                                           // 0x006C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x0074(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SingleSession;                                     // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x007D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x007E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239E[0x1];                                     // 0x007F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239F[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTagQueryData>>   TagQueryData;                                      // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentUseItemDataAsset">();
	}
	static class UDCQuestContentUseItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentUseItemDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentUseItemDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentUseItemDataAsset");
static_assert(sizeof(UDCQuestContentUseItemDataAsset) == 0x000098, "Wrong size on UDCQuestContentUseItemDataAsset");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, ItemType) == 0x000060, "Member 'UDCQuestContentUseItemDataAsset::ItemType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, ItemIdTag) == 0x000064, "Member 'UDCQuestContentUseItemDataAsset::ItemIdTag' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, TypeTag) == 0x00006C, "Member 'UDCQuestContentUseItemDataAsset::TypeTag' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, RarityType) == 0x000074, "Member 'UDCQuestContentUseItemDataAsset::RarityType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, SingleSession) == 0x00007C, "Member 'UDCQuestContentUseItemDataAsset::SingleSession' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, MustEscape) == 0x00007D, "Member 'UDCQuestContentUseItemDataAsset::MustEscape' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, HealthRequirementType) == 0x00007E, "Member 'UDCQuestContentUseItemDataAsset::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, HealthRequirementRatio) == 0x000080, "Member 'UDCQuestContentUseItemDataAsset::HealthRequirementRatio' has a wrong offset!");
static_assert(offsetof(UDCQuestContentUseItemDataAsset, TagQueryData) == 0x000088, "Member 'UDCQuestContentUseItemDataAsset::TagQueryData' has a wrong offset!");

// Class DungeonCrawler.DCAIPerceptionComponent
// 0x0000 (0x0190 - 0x0190)
class UDCAIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAIPerceptionComponent">();
	}
	static class UDCAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAIPerceptionComponent>();
	}
};
static_assert(alignof(UDCAIPerceptionComponent) == 0x000008, "Wrong alignment on UDCAIPerceptionComponent");
static_assert(sizeof(UDCAIPerceptionComponent) == 0x000190, "Wrong size on UDCAIPerceptionComponent");

// Class DungeonCrawler.AsyncTaskWaitGAEnded
// 0x0108 (0x0140 - 0x0038)
class UAsyncTaskWaitGAEnded final : public UAbilityAsync
{
public:
	uint8                                         Pad_23A0[0xE8];                                    // 0x0038(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAbilityEndedDelegate;                            // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A1[0x10];                                    // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskWaitGAEnded* WaitForAbilityEnd(class AActor* TargetActor, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool TriggerOnce);
	static class UAsyncTaskWaitGAEnded* WaitForAbilityEnd_Query(class AActor* TargetActor, const struct FGameplayTagQuery& Query, bool TriggerOnce);
	static class UAsyncTaskWaitGAEnded* WaitForAbilityEndWithTagRequirements(class AActor* TargetActor, const struct FGameplayTagRequirements& TagRequirements, bool TriggerOnce);

	void OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskWaitGAEnded">();
	}
	static class UAsyncTaskWaitGAEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskWaitGAEnded>();
	}
};
static_assert(alignof(UAsyncTaskWaitGAEnded) == 0x000008, "Wrong alignment on UAsyncTaskWaitGAEnded");
static_assert(sizeof(UAsyncTaskWaitGAEnded) == 0x000140, "Wrong size on UAsyncTaskWaitGAEnded");
static_assert(offsetof(UAsyncTaskWaitGAEnded, OnAbilityEndedDelegate) == 0x000120, "Member 'UAsyncTaskWaitGAEnded::OnAbilityEndedDelegate' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequireDungeonDetailEntryData
// 0x0020 (0x0048 - 0x0028)
class UDCQuestRequireDungeonDetailEntryData final : public UObject
{
public:
	uint8                                         Pad_23A5[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequireDungeonDetailEntryData">();
	}
	static class UDCQuestRequireDungeonDetailEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequireDungeonDetailEntryData>();
	}
};
static_assert(alignof(UDCQuestRequireDungeonDetailEntryData) == 0x000008, "Wrong alignment on UDCQuestRequireDungeonDetailEntryData");
static_assert(sizeof(UDCQuestRequireDungeonDetailEntryData) == 0x000048, "Wrong size on UDCQuestRequireDungeonDetailEntryData");

// Class DungeonCrawler.AsyncTaskWaitGameplayEvent
// 0x0028 (0x0060 - 0x0038)
class UAsyncTaskWaitGameplayEvent final : public UAbilityAsync
{
public:
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A6[0x18];                                    // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskWaitGameplayEvent* WaitGameplayEventToActor(class AActor* TargetActor, const struct FGameplayTag& EventTag, bool OnlyTriggerOnce, bool OnlyMatchExact);

	void EventReceivedDelegate__DelegateSignature(const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskWaitGameplayEvent">();
	}
	static class UAsyncTaskWaitGameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskWaitGameplayEvent>();
	}
};
static_assert(alignof(UAsyncTaskWaitGameplayEvent) == 0x000008, "Wrong alignment on UAsyncTaskWaitGameplayEvent");
static_assert(sizeof(UAsyncTaskWaitGameplayEvent) == 0x000060, "Wrong size on UAsyncTaskWaitGameplayEvent");
static_assert(offsetof(UAsyncTaskWaitGameplayEvent, EventReceived) == 0x000038, "Member 'UAsyncTaskWaitGameplayEvent::EventReceived' has a wrong offset!");

// Class DungeonCrawler.LeaderboardDetailPopupData
// 0x0058 (0x0088 - 0x0030)
class ULeaderboardDetailPopupData final : public UPopupDataBase
{
public:
	struct FLeaderboardInfo                       LeaderboardInfo;                                   // 0x0030(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLeaderboardSheetInfo                  LeaderboardSheetInfo;                              // 0x0070(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDetailPopupData">();
	}
	static class ULeaderboardDetailPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDetailPopupData>();
	}
};
static_assert(alignof(ULeaderboardDetailPopupData) == 0x000008, "Wrong alignment on ULeaderboardDetailPopupData");
static_assert(sizeof(ULeaderboardDetailPopupData) == 0x000088, "Wrong size on ULeaderboardDetailPopupData");
static_assert(offsetof(ULeaderboardDetailPopupData, LeaderboardInfo) == 0x000030, "Member 'ULeaderboardDetailPopupData::LeaderboardInfo' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailPopupData, LeaderboardSheetInfo) == 0x000070, "Member 'ULeaderboardDetailPopupData::LeaderboardSheetInfo' has a wrong offset!");

// Class DungeonCrawler.ItemWidget
// 0x0140 (0x0498 - 0x0358)
class UItemWidget : public UDCWidgetBase
{
public:
	class UImage*                                 ItemIconImage;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               ItemIconSizeBox;                                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ItemOwnedActor;                                    // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidgetOriginalSize;                                // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A8[0x14];                                    // 0x0374(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemWidgetData                        WidgetData;                                        // 0x0388(0x0100)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A9[0x10];                                    // 0x0488(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCanEquipByRequirementsChanged(bool bCanEquip, const TArray<EItemRequirementType>& RequirementsNotMatched);
	void OnItemData(const struct FItemData& NewItemData, const struct FItemData& OldItemData);
	void SetItemData(const struct FItemData& NewItemData);
	void SetItemIcon(class UTexture2D* ItemIconTexture, const struct FItemInventorySize& ItemInventorySize);
	void SetItemOwnerActor(class AActor* InItemOwnedActor);

	struct FItemData GetItemData() const;
	class UImage* GetItemIconImage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWidget">();
	}
	static class UItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWidget>();
	}
};
static_assert(alignof(UItemWidget) == 0x000008, "Wrong alignment on UItemWidget");
static_assert(sizeof(UItemWidget) == 0x000498, "Wrong size on UItemWidget");
static_assert(offsetof(UItemWidget, ItemIconImage) == 0x000358, "Member 'UItemWidget::ItemIconImage' has a wrong offset!");
static_assert(offsetof(UItemWidget, ItemIconSizeBox) == 0x000360, "Member 'UItemWidget::ItemIconSizeBox' has a wrong offset!");
static_assert(offsetof(UItemWidget, ItemOwnedActor) == 0x000368, "Member 'UItemWidget::ItemOwnedActor' has a wrong offset!");
static_assert(offsetof(UItemWidget, WidgetOriginalSize) == 0x000370, "Member 'UItemWidget::WidgetOriginalSize' has a wrong offset!");
static_assert(offsetof(UItemWidget, WidgetData) == 0x000388, "Member 'UItemWidget::WidgetData' has a wrong offset!");

// Class DungeonCrawler.ControllableItemWidget
// 0x0000 (0x0498 - 0x0498)
class UControllableItemWidget final : public UItemWidget
{
public:
	void DropAllItem();
	void DropOneItem();
	struct FEventReply OnLeftMouseButtonDoubleClick();
	struct FEventReply OnLeftMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, bool bInventoryItemLinkButtonPressed);
	struct FEventReply OnRightMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, bool bInventoryDropButtonPressed, bool bInventorySplitButtonPressed);
	void QuickMoveItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllableItemWidget">();
	}
	static class UControllableItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllableItemWidget>();
	}
};
static_assert(alignof(UControllableItemWidget) == 0x000008, "Wrong alignment on UControllableItemWidget");
static_assert(sizeof(UControllableItemWidget) == 0x000498, "Wrong size on UControllableItemWidget");

// Class DungeonCrawler.DCQuestLogListEntryWidget
// 0x0028 (0x0380 - 0x0358)
class UDCQuestLogListEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_23AD[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MerchantName;                                      // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCQuestLogContentsListWidget*          QuestLogListWidgetClass;                           // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogListEntryWidget">();
	}
	static class UDCQuestLogListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogListEntryWidget>();
	}
};
static_assert(alignof(UDCQuestLogListEntryWidget) == 0x000008, "Wrong alignment on UDCQuestLogListEntryWidget");
static_assert(sizeof(UDCQuestLogListEntryWidget) == 0x000380, "Wrong size on UDCQuestLogListEntryWidget");
static_assert(offsetof(UDCQuestLogListEntryWidget, MerchantName) == 0x000360, "Member 'UDCQuestLogListEntryWidget::MerchantName' has a wrong offset!");
static_assert(offsetof(UDCQuestLogListEntryWidget, QuestLogListWidgetClass) == 0x000378, "Member 'UDCQuestLogListEntryWidget::QuestLogListWidgetClass' has a wrong offset!");

// Class DungeonCrawler.AttackInputManagerComponent
// 0x0068 (0x0108 - 0x00A0)
class UAttackInputManagerComponent final : public UDCActorComponent
{
public:
	class UAsyncTaskWaitGameplayEvent*            AsyncGameplayEventWaitTask;                        // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAsyncTaskWaitGAActivated*              AsyncGAActivateTask;                               // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAsyncTaskWaitGAEnded*                  AsyncGAEndTask;                                    // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayTag> CurrentTriggerMap;                                 // 0x00B8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void EventReceived(const struct FGameplayEventData& EventData);
	struct FGameplayTag GetCurrentTriggerTag(const struct FGameplayTag& TriggerTag);
	void HandleAttackInput(const struct FGameplayTag& InputTag);
	void OnAbilityActivate(class UGameplayAbility* ActivatedAbility);
	void OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData);
	void SetAttackEnabled(bool bIsAttackEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackInputManagerComponent">();
	}
	static class UAttackInputManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackInputManagerComponent>();
	}
};
static_assert(alignof(UAttackInputManagerComponent) == 0x000008, "Wrong alignment on UAttackInputManagerComponent");
static_assert(sizeof(UAttackInputManagerComponent) == 0x000108, "Wrong size on UAttackInputManagerComponent");
static_assert(offsetof(UAttackInputManagerComponent, AsyncGameplayEventWaitTask) == 0x0000A0, "Member 'UAttackInputManagerComponent::AsyncGameplayEventWaitTask' has a wrong offset!");
static_assert(offsetof(UAttackInputManagerComponent, AsyncGAActivateTask) == 0x0000A8, "Member 'UAttackInputManagerComponent::AsyncGAActivateTask' has a wrong offset!");
static_assert(offsetof(UAttackInputManagerComponent, AsyncGAEndTask) == 0x0000B0, "Member 'UAttackInputManagerComponent::AsyncGAEndTask' has a wrong offset!");
static_assert(offsetof(UAttackInputManagerComponent, CurrentTriggerMap) == 0x0000B8, "Member 'UAttackInputManagerComponent::CurrentTriggerMap' has a wrong offset!");

// Class DungeonCrawler.DCArenaWidget
// 0x0020 (0x0378 - 0x0358)
class UDCArenaWidget final : public UDCWidgetBase
{
public:
	int32                                         CurrentRound;                                      // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RedTeamPoint;                                      // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BlueTeamPoint;                                     // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23AE[0x4];                                     // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCArenaGameState*                      ArenaGameState;                                    // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23AF[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowRoundResult();
	void ShowRoundStart();

	EGameStateType GetCurrentPhase() const;
	int32 GetNumMaxPlayers() const;
	int32 GetNumPlayers() const;
	struct FTimespan GetRemainIntermissionTime() const;
	struct FTimespan GetRemainRoundTime() const;
	struct FTimespan GetRemainWelcomeTime() const;
	struct FTimespan GetRoundTime() const;
	bool IsDrawLastRound() const;
	bool IsWinLastRound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCArenaWidget">();
	}
	static class UDCArenaWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCArenaWidget>();
	}
};
static_assert(alignof(UDCArenaWidget) == 0x000008, "Wrong alignment on UDCArenaWidget");
static_assert(sizeof(UDCArenaWidget) == 0x000378, "Wrong size on UDCArenaWidget");
static_assert(offsetof(UDCArenaWidget, CurrentRound) == 0x000358, "Member 'UDCArenaWidget::CurrentRound' has a wrong offset!");
static_assert(offsetof(UDCArenaWidget, RedTeamPoint) == 0x00035C, "Member 'UDCArenaWidget::RedTeamPoint' has a wrong offset!");
static_assert(offsetof(UDCArenaWidget, BlueTeamPoint) == 0x000360, "Member 'UDCArenaWidget::BlueTeamPoint' has a wrong offset!");
static_assert(offsetof(UDCArenaWidget, ArenaGameState) == 0x000368, "Member 'UDCArenaWidget::ArenaGameState' has a wrong offset!");

// Class DungeonCrawler.DCQuestContentExploreDataAsset
// 0x0030 (0x0090 - 0x0060)
class UDCQuestContentExploreDataAsset final : public UDCQuestContentDataAsset
{
public:
	TSoftObjectPtr<class UDCDungeonModuleDataAsset> ModuleId;                                          // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B0[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentExploreDataAsset">();
	}
	static class UDCQuestContentExploreDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentExploreDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentExploreDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentExploreDataAsset");
static_assert(sizeof(UDCQuestContentExploreDataAsset) == 0x000090, "Wrong size on UDCQuestContentExploreDataAsset");
static_assert(offsetof(UDCQuestContentExploreDataAsset, ModuleId) == 0x000060, "Member 'UDCQuestContentExploreDataAsset::ModuleId' has a wrong offset!");
static_assert(offsetof(UDCQuestContentExploreDataAsset, MustEscape) == 0x000088, "Member 'UDCQuestContentExploreDataAsset::MustEscape' has a wrong offset!");

// Class DungeonCrawler.ReceivedInvitationSlotWidget
// 0x0040 (0x0430 - 0x03F0)
class UReceivedInvitationSlotWidget final : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_23B1[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCFriendStatus                               Status;                                            // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x0421(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23B2[0xE];                                     // 0x0422(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReceivedInvitationSlotWidget">();
	}
	static class UReceivedInvitationSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReceivedInvitationSlotWidget>();
	}
};
static_assert(alignof(UReceivedInvitationSlotWidget) == 0x000008, "Wrong alignment on UReceivedInvitationSlotWidget");
static_assert(sizeof(UReceivedInvitationSlotWidget) == 0x000430, "Wrong size on UReceivedInvitationSlotWidget");
static_assert(offsetof(UReceivedInvitationSlotWidget, AccountId) == 0x000400, "Member 'UReceivedInvitationSlotWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UReceivedInvitationSlotWidget, CharacterId) == 0x000410, "Member 'UReceivedInvitationSlotWidget::CharacterId' has a wrong offset!");
static_assert(offsetof(UReceivedInvitationSlotWidget, Status) == 0x000420, "Member 'UReceivedInvitationSlotWidget::Status' has a wrong offset!");
static_assert(offsetof(UReceivedInvitationSlotWidget, bSelected) == 0x000421, "Member 'UReceivedInvitationSlotWidget::bSelected' has a wrong offset!");

// Class DungeonCrawler.DCGameModeBase
// 0x0070 (0x03A8 - 0x0338)
class ADCGameModeBase : public AGameModeBase
{
public:
	uint8                                         Pad_23B3[0x58];                                    // 0x0338(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADCGameModeAIControllerBase> GameModeAIControllerClass;                         // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADCGameModeAIControllerBase*            GameModeAIController;                              // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeBase">();
	}
	static class ADCGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeBase>();
	}
};
static_assert(alignof(ADCGameModeBase) == 0x000008, "Wrong alignment on ADCGameModeBase");
static_assert(sizeof(ADCGameModeBase) == 0x0003A8, "Wrong size on ADCGameModeBase");
static_assert(offsetof(ADCGameModeBase, BaseObject) == 0x000390, "Member 'ADCGameModeBase::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCGameModeBase, GameModeAIControllerClass) == 0x000398, "Member 'ADCGameModeBase::GameModeAIControllerClass' has a wrong offset!");
static_assert(offsetof(ADCGameModeBase, GameModeAIController) == 0x0003A0, "Member 'ADCGameModeBase::GameModeAIController' has a wrong offset!");

// Class DungeonCrawler.DCIngameGameMode
// 0x0150 (0x04F8 - 0x03A8)
class ADCIngameGameMode : public ADCGameModeBase
{
public:
	class ADCGameStateBase*                       IngameGameState;                                   // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B4[0x70];                                    // 0x03B0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADCPlayerStart*>                 StartPoints;                                       // 0x0420(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B5[0xC8];                                    // 0x0430(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIngameGameMode">();
	}
	static class ADCIngameGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCIngameGameMode>();
	}
};
static_assert(alignof(ADCIngameGameMode) == 0x000008, "Wrong alignment on ADCIngameGameMode");
static_assert(sizeof(ADCIngameGameMode) == 0x0004F8, "Wrong size on ADCIngameGameMode");
static_assert(offsetof(ADCIngameGameMode, IngameGameState) == 0x0003A8, "Member 'ADCIngameGameMode::IngameGameState' has a wrong offset!");
static_assert(offsetof(ADCIngameGameMode, StartPoints) == 0x000420, "Member 'ADCIngameGameMode::StartPoints' has a wrong offset!");

// Class DungeonCrawler.DCDungeonGameMode
// 0x0048 (0x0540 - 0x04F8)
class ADCDungeonGameMode : public ADCIngameGameMode
{
public:
	FMulticastInlineDelegateProperty_             DespawnDungeonExpressmanDelegate;                  // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         WarmupDuration;                                    // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23B6[0x4];                                     // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPoolManager*                         PoolManager;                                       // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADCDungeonGameState*                    DungeonGameState;                                  // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B7[0x20];                                    // 0x0520(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFloorRuleData(const struct FGameFloorRuleData& InFloorRuleData);
	void OnFloorRuleFinished();
	void RegisterPoolingObject(const struct FPrimaryAssetId& PrimaryAssetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonGameMode">();
	}
	static class ADCDungeonGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCDungeonGameMode>();
	}
};
static_assert(alignof(ADCDungeonGameMode) == 0x000008, "Wrong alignment on ADCDungeonGameMode");
static_assert(sizeof(ADCDungeonGameMode) == 0x000540, "Wrong size on ADCDungeonGameMode");
static_assert(offsetof(ADCDungeonGameMode, DespawnDungeonExpressmanDelegate) == 0x0004F8, "Member 'ADCDungeonGameMode::DespawnDungeonExpressmanDelegate' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameMode, WarmupDuration) == 0x000508, "Member 'ADCDungeonGameMode::WarmupDuration' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameMode, PoolManager) == 0x000510, "Member 'ADCDungeonGameMode::PoolManager' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameMode, DungeonGameState) == 0x000518, "Member 'ADCDungeonGameMode::DungeonGameState' has a wrong offset!");

// Class DungeonCrawler.DCTestGameMode
// 0x0000 (0x0540 - 0x0540)
class ADCTestGameMode : public ADCDungeonGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTestGameMode">();
	}
	static class ADCTestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCTestGameMode>();
	}
};
static_assert(alignof(ADCTestGameMode) == 0x000008, "Wrong alignment on ADCTestGameMode");
static_assert(sizeof(ADCTestGameMode) == 0x000540, "Wrong size on ADCTestGameMode");

// Class DungeonCrawler.DCResource
// 0x03B0 (0x03D8 - 0x0028)
class UDCResource : public UObject
{
public:
	TMap<EDCGender, class UDCCharacterPartsArtData*> CharacterPartsDataMap;                             // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FDCPlayerCharacterKey, struct FDCPlayerCharacterData> PlayerCharacterDataMap;                            // 0x0078(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EDCGender, class USoundData*>            CharacterSounds;                                   // 0x00C8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UDCInputConfigData*                     InputConfigData;                                   // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMappableConfigPair>            MappableConfigPairs;                               // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCContextMenuWidget>       ContextMenuWidgetClass;                            // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCMerchantAssetManager                MerchantAssetManager;                              // 0x0138(0x01E0)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UWorld>> WaitingMaps;                                       // 0x0318(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCurveTable*                            LuckGradeCurveTable;                               // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADCCharacterV2>             ResurrectionCharacterClass;                        // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDCRewardType, class UDCRewardArtData*>  RewardArtDataMap;                                  // 0x0378(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveTable*                            AdvPointCurveTable;                                // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCItemTypeArtData*                     ItemTypeArtData;                                   // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCResource">();
	}
	static class UDCResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCResource>();
	}
};
static_assert(alignof(UDCResource) == 0x000008, "Wrong alignment on UDCResource");
static_assert(sizeof(UDCResource) == 0x0003D8, "Wrong size on UDCResource");
static_assert(offsetof(UDCResource, CharacterPartsDataMap) == 0x000028, "Member 'UDCResource::CharacterPartsDataMap' has a wrong offset!");
static_assert(offsetof(UDCResource, PlayerCharacterDataMap) == 0x000078, "Member 'UDCResource::PlayerCharacterDataMap' has a wrong offset!");
static_assert(offsetof(UDCResource, CharacterSounds) == 0x0000C8, "Member 'UDCResource::CharacterSounds' has a wrong offset!");
static_assert(offsetof(UDCResource, InputConfigData) == 0x000118, "Member 'UDCResource::InputConfigData' has a wrong offset!");
static_assert(offsetof(UDCResource, MappableConfigPairs) == 0x000120, "Member 'UDCResource::MappableConfigPairs' has a wrong offset!");
static_assert(offsetof(UDCResource, ContextMenuWidgetClass) == 0x000130, "Member 'UDCResource::ContextMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCResource, MerchantAssetManager) == 0x000138, "Member 'UDCResource::MerchantAssetManager' has a wrong offset!");
static_assert(offsetof(UDCResource, WaitingMaps) == 0x000318, "Member 'UDCResource::WaitingMaps' has a wrong offset!");
static_assert(offsetof(UDCResource, LuckGradeCurveTable) == 0x000368, "Member 'UDCResource::LuckGradeCurveTable' has a wrong offset!");
static_assert(offsetof(UDCResource, ResurrectionCharacterClass) == 0x000370, "Member 'UDCResource::ResurrectionCharacterClass' has a wrong offset!");
static_assert(offsetof(UDCResource, RewardArtDataMap) == 0x000378, "Member 'UDCResource::RewardArtDataMap' has a wrong offset!");
static_assert(offsetof(UDCResource, AdvPointCurveTable) == 0x0003C8, "Member 'UDCResource::AdvPointCurveTable' has a wrong offset!");
static_assert(offsetof(UDCResource, ItemTypeArtData) == 0x0003D0, "Member 'UDCResource::ItemTypeArtData' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitDistChangeFromLocation
// 0x0030 (0x00B0 - 0x0080)
class UDCAT_WaitDistChangeFromLocation final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnDistanceChange;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B8[0x20];                                    // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitDistChangeFromLocation* WaitDistanceChange(class UGameplayAbility* OwningAbility, const struct FVector& TargetLocation, float MaximumDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitDistChangeFromLocation">();
	}
	static class UDCAT_WaitDistChangeFromLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitDistChangeFromLocation>();
	}
};
static_assert(alignof(UDCAT_WaitDistChangeFromLocation) == 0x000008, "Wrong alignment on UDCAT_WaitDistChangeFromLocation");
static_assert(sizeof(UDCAT_WaitDistChangeFromLocation) == 0x0000B0, "Wrong size on UDCAT_WaitDistChangeFromLocation");
static_assert(offsetof(UDCAT_WaitDistChangeFromLocation, OnDistanceChange) == 0x000080, "Member 'UDCAT_WaitDistChangeFromLocation::OnDistanceChange' has a wrong offset!");

// Class DungeonCrawler.BlizzardBase
// 0x0158 (0x0538 - 0x03E0)
class ABlizzardBase : public APropsActorBase
{
public:
	uint8                                         Pad_23BA[0x40];                                    // 0x03E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          AuraBox;                                           // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCFloorRuleBlizzardDataAsset*          FloorRuleBlizzardData;                             // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23BB[0x8];                                     // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCFloorRuleBlizzardInfo>       Rules;                                             // 0x0438(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGameFloorRuleData                     GameFloorRuleData;                                 // 0x0448(0x0040)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameBlizzardData                      GameBlizzardData;                                  // 0x0488(0x0040)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23BC[0x70];                                    // 0x04C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlizzardIndex(int32 InIndex);
	void OnNewPlayerCharacterRegistered(class ADCCharacterBase* InRegisteredCharacter);
	void OnRep_GameBlizzardData(const struct FGameBlizzardData& InOldGameBlizzardData);
	void OnRep_GameFloorRuleData(const struct FGameFloorRuleData& InOldGameFloorRuleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlizzardBase">();
	}
	static class ABlizzardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlizzardBase>();
	}
};
static_assert(alignof(ABlizzardBase) == 0x000008, "Wrong alignment on ABlizzardBase");
static_assert(sizeof(ABlizzardBase) == 0x000538, "Wrong size on ABlizzardBase");
static_assert(offsetof(ABlizzardBase, AuraBox) == 0x000420, "Member 'ABlizzardBase::AuraBox' has a wrong offset!");
static_assert(offsetof(ABlizzardBase, FloorRuleBlizzardData) == 0x000428, "Member 'ABlizzardBase::FloorRuleBlizzardData' has a wrong offset!");
static_assert(offsetof(ABlizzardBase, Rules) == 0x000438, "Member 'ABlizzardBase::Rules' has a wrong offset!");
static_assert(offsetof(ABlizzardBase, GameFloorRuleData) == 0x000448, "Member 'ABlizzardBase::GameFloorRuleData' has a wrong offset!");
static_assert(offsetof(ABlizzardBase, GameBlizzardData) == 0x000488, "Member 'ABlizzardBase::GameBlizzardData' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementDungeonWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCQuestRequirementDungeonWidgetData final : public UObject
{
public:
	uint8                                         Pad_23BD[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementDungeonWidgetData">();
	}
	static class UDCQuestRequirementDungeonWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementDungeonWidgetData>();
	}
};
static_assert(alignof(UDCQuestRequirementDungeonWidgetData) == 0x000008, "Wrong alignment on UDCQuestRequirementDungeonWidgetData");
static_assert(sizeof(UDCQuestRequirementDungeonWidgetData) == 0x000038, "Wrong size on UDCQuestRequirementDungeonWidgetData");

// Class DungeonCrawler.BlizzardInterface
// 0x0000 (0x0028 - 0x0028)
class IBlizzardInterface final : public IInterface
{
public:
	void BindBlizzardDataDelegate(TDelegate<void(struct FGameBlizzardData& InBlizzardData)> InBindDelegate);
	void UnbindBlizzardDataDelegate(class UObject* InBoundObject);

	struct FGameBlizzardData GetBlizzardData() const;
	void LogHandleBlizzardData(const class UObject* InHandler, const struct FGameBlizzardData& InBlizzardData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlizzardInterface">();
	}
	static class IBlizzardInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlizzardInterface>();
	}
};
static_assert(alignof(IBlizzardInterface) == 0x000008, "Wrong alignment on IBlizzardInterface");
static_assert(sizeof(IBlizzardInterface) == 0x000028, "Wrong size on IBlizzardInterface");

// Class DungeonCrawler.LeaderboardDataItemWidgetData
// 0x0040 (0x0068 - 0x0028)
class ULeaderboardDataItemWidgetData final : public UObject
{
public:
	struct FLeaderboardInfo                       LeaderboardInfo;                                   // 0x0028(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDataItemWidgetData">();
	}
	static class ULeaderboardDataItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDataItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardDataItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardDataItemWidgetData");
static_assert(sizeof(ULeaderboardDataItemWidgetData) == 0x000068, "Wrong size on ULeaderboardDataItemWidgetData");
static_assert(offsetof(ULeaderboardDataItemWidgetData, LeaderboardInfo) == 0x000028, "Member 'ULeaderboardDataItemWidgetData::LeaderboardInfo' has a wrong offset!");

// Class DungeonCrawler.DCAbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCAbilitySystemBlueprintLibrary final : public UAbilitySystemBlueprintLibrary
{
public:
	static void AddGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static void AddGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static bool AddGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static struct FActiveGameplayEffectHandle AddGameplayTagContainer(class AActor* InActor, const struct FGameplayTagContainer& InGameplayTagContainer);
	static void AddLooseGameplayTag(class AActor* InActor, const struct FGameplayTag& GameplayTag);
	static void AimFromHitResultToActorViewPoint(class AActor* InActor, const struct FHitResult& InHitResult, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel);
	static void AimLineWithActorPointToViewPointResult(class AActor* InActor, const struct FVector& TraceStart, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange);
	static void AimLineWithActorViewPoint(class AActor* InActor, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange);
	static void AimLineWithActorViewPointToPoint(class AActor* InActor, const struct FVector& TraceEnd, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel);
	static void AimSphereWithActorViewPoint(class AActor* InActor, float Radius, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange);
	static TArray<struct FActiveGameplayEffectHandle> ApplyEffectContainerSpec(const struct FDCGameplayEffectContainerSpec& ContainerSpec, int32 InStackCount, bool bIsApplyTargetSelf);
	static struct FActiveGameplayEffectHandle ApplyGameplayEffect(class AActor* InActor, const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, class AActor* InSourceActor);
	static TArray<struct FActiveGameplayEffectHandle> ApplyGameplayEffectByIds(class AActor* InActor, const TArray<struct FPrimaryAssetId>& InGameplayEffectIdArray, class AActor* InSourceActor);
	static TArray<struct FActiveGameplayEffectHandle> ApplyGameplayEffects(class AActor* InActor, const TArray<struct FDCGameplayEffectData>& InGameplayEffectDataArray, class AActor* InSourceActor);
	static TArray<struct FActiveGameplayEffectHandle> ApplyPremadeSpecArray(class AActor* InActor, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData);
	static void CancelAllAbilities(class AActor* InActor);
	static void ClearAllAbilities(class AActor* InActor);
	static void DCEffectContextAddHitResult(const struct FDCGameplayEffectContext& EffectContext, const struct FHitResult& HitResult, bool bReset);
	static class AActor* DCEffectContextGetEffectCauser(const struct FDCGameplayEffectContext& EffectContext);
	static struct FHitResult DCEffectContextGetHitResult(const struct FDCGameplayEffectContext& EffectContext);
	static class AActor* DCEffectContextGetInstigatorActor(const struct FDCGameplayEffectContext& EffectContext);
	static struct FVector DCEffectContextGetOrigin(const struct FDCGameplayEffectContext& EffectContext);
	static class AActor* DCEffectContextGetOriginalInstigatorActor(const struct FDCGameplayEffectContext& EffectContext);
	static struct FPrimaryAssetId DCEffectContextGetSoundDataPrimaryAssetId(const struct FDCGameplayEffectContext& EffectContext);
	static class UObject* DCEffectContextGetSourceObject(const struct FDCGameplayEffectContext& EffectContext);
	static bool DCEffectContextHasHitResult(const struct FDCGameplayEffectContext& EffectContext);
	static void DCEffectContextSetOrigin(const struct FDCGameplayEffectContext& EffectContext, const struct FVector& Origin);
	static void DCEffectContextSetSoundDataPrimaryAssetId(const struct FDCGameplayEffectContext& EffectContext, const struct FPrimaryAssetId& PrimaryAssetId);
	static struct FPrimaryAssetId EffectContextGetEffectId(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static TArray<struct FItemData> EffectContextGetItemDatas(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static class USoundData* EffectContextGetSoundData(const struct FGameplayEffectContextHandle& EffectContext);
	static struct FPrimaryAssetId EffectContextGetSoundDataPrimaryAssetId(const struct FGameplayEffectContextHandle& EffectContext);
	static void EffectContextSetSoundDataPrimaryAssetId(const struct FGameplayEffectContextHandle& EffectContext, const struct FPrimaryAssetId& PrimaryAssetId);
	static void ExecuteGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static void ExecuteGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static class USkeletalMeshComponent* FindSocketOwningMeshComponent(const class FName SocketName, const class UObject* Object, const class AActor* AvatarActor);
	static float GetActorAttributeValue(class AActor* InActor, const struct FGameplayAttribute& InAttribute);
	static void GetBoundingBoxPointsLocation(class AActor* InActor, class AActor* InTarget, struct FVector& OutTop, struct FVector& OutBottom, struct FVector& OutLeft, struct FVector& OutRight, struct FVector& OutCenter);
	static void GetBoundingBoxPointsLocationFromLocation(class AActor* InTarget, const struct FVector& InStartLocation, struct FVector& OutTop, struct FVector& OutBottom, struct FVector& OutLeft, struct FVector& OutRight, struct FVector& OutCenter);
	static const TArray<struct FGameplayAttribute> GetCharacterPrimitiveAttributes();
	static float GetCurrentMontagePlayRate(class AActor* InActor);
	static class FName GetCurrentMontageSectionName(class AActor* InActor);
	static struct FGameplayEffectQuery GetCurseDebuffEffectTagQuery();
	static class UDCAbilitySystemComponent* GetDCAbilitySystemComponent(class AActor* InActor);
	static void GetDefaultUnscaledCapsuleSize(class AActor* InActor, float* OutRadius, float* OutHalfHeight);
	static struct FGameplayTagContainer GetEffectAssetTagsInEffectContainerArray(const struct FGameplayTag& InEventTag, const TArray<struct FDCGameplayEffectContainer>& InEffectContainer);
	static void GetEffectSpec(const struct FGameplayEffectSpecHandle& SpecHandle, struct FGameplayEffectSpec* OutEffectSpec);
	static void GetGameplayAbilityData(const struct FDesignDataGameplayAbility& InDesignDataGameplayAbility, struct FDCGameplayAbilityData& OutGameplayAbilityData);
	static void GetGameplayDataFromDesignDataSkill(const struct FDesignDataSkill& InDesignDataSkill, TArray<struct FDCGameplayAbilityData>* OutGameplayAbilityDataArray, TArray<struct FDCGameplayEffectData>* OutGameplayEffectDataArray);
	static void GetGameplayDataFromDesignDataSpell(const struct FDesignDataSpell& InDesignDataSpell, TArray<struct FDCGameplayAbilityData>* OutGameplayAbilityDataArray, TArray<struct FDCGameplayEffectData>* OutGameplayEffectDataArray);
	static void GetGameplayEffectData(const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, struct FDCGameplayEffectData& OutGameplayEffectData);
	static float GetGameplayEffectSetByCallerValue(const struct FGameplayTag& InSetByCallerTag, int32 InSetByCallerValue);
	static struct FGameplayTagContainer GetGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle);
	static class AItemActor* GetItemActor(const struct FGameplayEffectContextHandle& Handle);
	static void GetItemDataFromDesignData(const struct FDesignDataItem& InDesignDataItem, struct FItemData& OutItemData);
	static struct FGameplayEffectQuery GetMagicBuffEffectTagQuery();
	static struct FGameplayEffectQuery GetMagicDebuffEffectTagQuery();
	static TArray<class UDCGameplayAbilityBase*> GetMatchingAbilityActivated(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static int32 GetMatchingAbilityActivatedCount(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static TArray<struct FGameplayTag> GetMatchingAbilityActivatedTriggers(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static float GetMeleeAttackAbilityDamageRatioFromDesignData(const struct FDesignDataGameplayAbility& DesignDataGameplayAbility);
	static float GetMeleeAttackAbilityDamageRatioFromEffectSpec(const struct FGameplayEffectSpec& InSpec);
	static struct FGameplayEffectQuery GetMoveSpeedBuffEffectTagQuery();
	static struct FGameplayEffectQuery GetMoveSpeedDebuffEffectTagQuery();
	static void GetOwnedGameplayTags(class AActor* InActor, struct FGameplayTagContainer* TagContainer);
	static float GetProjectileDamageCurveFloatValue(const struct FGameplayEffectSpec& InSpec);
	static struct FGameplayEffectQuery GetProtectionBuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableBuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableCurseDebuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableDebuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableDrunkDebuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableMagicBuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableMagicDebuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableMoveSpeedBuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableMoveSpeedDebuffEffectTagQuery();
	static struct FGameplayEffectQuery GetRemovableProtectionBuffEffectTagQuery();
	static float GetSetByCallerValueInAbilityAssets(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<class UDesignDataAssetGameplayAbility*>& InAbilities);
	static float GetSetByCallerValueInAbilityData(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const struct FDCGameplayAbilityData& InAbilityData, bool bShouldGetOnlyOneValueInData);
	static float GetSetByCallerValueInAbilityIds(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FPrimaryAssetId>& InAbilities);
	static float GetSetByCallerValueInContainer(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FDCGameplayEffectContainer>& InEffectContainer);
	static float GetSetByCallerValueInContainerSpecArray(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FDCGameplayEffectContainerSpec>& InEffectHandle);
	static float GetSetByCallerValueInEffectAssets(const struct FGameplayTag& InSetByCallerDataTag, const TArray<class UDesignDataAssetGameplayEffect*>& InEffects);
	static float GetSetByCallerValueInEffectData(const struct FGameplayTag& InSetByCallerDataTag, const struct FDCGameplayEffectData& InEffectData);
	static float GetSetByCallerValueInEffectIds(const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FPrimaryAssetId>& InEffects);
	static void GetSocketLocationBySocketName(const class FName SocketName, const class UObject* Object, const class AActor* AvatarActor, struct FVector& OutSocketLocation);
	static TArray<struct FGameplayAbilitySpecHandle> GiveAbilities(class UObject* SourceObject, class AActor* InActor, const TArray<struct FDCGameplayAbilityData>& InGameplayAbilityDataArray, bool bTriggerOnlyOnce);
	static struct FGameplayAbilitySpecHandle GiveAbility(class UObject* SourceObject, class AActor* InActor, const struct FDCGameplayAbilityData& InGameplayAbilityData, bool bTriggerOnlyOnce);
	static bool HasAnyMatchingGameplayTags(class AActor* InActor, const struct FGameplayTagContainer& Tags);
	static bool HasMatchingGameplayTag(class AActor* InActor, const struct FGameplayTag& TagToCheck);
	static bool IsInstigatorAppliedEffectToTarget(const class AActor* InInstigator, class AActor* InTarget, const struct FGameplayTag& InGameplayTag);
	static bool IsMagicalAttackHit(const struct FGameplayEventData& EventData);
	static bool IsMatchingAbilityActivated(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static bool IsMeaningfulCharacterTarget(const class AActor* InTarget);
	static bool IsMeleeAttackHit(const struct FGameplayEventData& EventData);
	static bool IsOnHitSkillActivatingPhysicalAttackHit(const struct FGameplayEventData& EventData);
	static bool IsProjectileAttackHit(const struct FGameplayEventData& EventData);
	static bool IsRangedMagicalAttackHit(const struct FGameplayEventData& EventData);
	static bool IsRangedPhysicalAttackHit(const struct FGameplayEventData& EventData);
	static bool IsSameTeam(class AActor* SourceActor, class AActor* TargetActor);
	static bool IsSameTeamWithPartyId(class AActor* SourceActor, const class FString& InPartyId);
	static bool IsSystemDamage(const struct FGameplayEventData& EventData);
	static bool IsSystemDamageFromEffectData(const struct FGameplayEventData& EventData);
	static bool IsTargetLocationSightBlocked(class AActor* InActor, const struct FVector& InLocation);
	static bool IsTargetSightBlocked(class AActor* InActor, class AActor* InTarget, bool bIsTargetExcluded);
	static bool IsTargetSightBlockedFromLocation(class AActor* InTarget, const struct FVector& InLocation, bool bIsTargetExcluded);
	static bool IsUtilityThrowableAttackHit(const struct FGameplayEventData& EventData);
	static bool MatchesQuery(class AActor* InActor, const struct FGameplayTagQuery& InTagQuery);
	static void MessageNotifyByReasonTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag, float MsgDuration);
	static void MessageNotifyByReasonTagContainer(class AActor* InActor, const struct FGameplayTagContainer& InGameplayTags, float MsgDuration);
	static struct FGameplayTag ParseOptionGameplayTag(const class FString& InOptionStr, const class FString& InOptionKey);
	static int32 RemoveActiveEffectsWithGrantedTags(class AActor* InActor, const struct FGameplayTagContainer& Tags);
	static bool RemoveActiveGameplayEffect(class AActor* InActor, const struct FActiveGameplayEffectHandle& InHandle);
	static int32 RemoveEffectWithTagQuery(class AActor* InActor, const struct FGameplayEffectQuery& InGameplayTagQuery);
	static void RemoveGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag);
	static void RemoveGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag);
	static bool RemoveGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static void RemoveLooseGameplayTagAll(class AActor* InActor, const struct FGameplayTag& GameplayTag);
	static void SendGameplayEventToActorOverride(class AActor* Actor, const struct FGameplayTag& EventTag, const TArray<struct FDCGameplayEffectData>& InOverrideGameplayEffectDataArray);
	static bool SetAnimationStateGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static bool SetModeGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag);
	static int32 TriggerAbilityFromGameplayEvent(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAbilitySystemBlueprintLibrary">();
	}
	static class UDCAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UDCAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UDCAbilitySystemBlueprintLibrary");
static_assert(sizeof(UDCAbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UDCAbilitySystemBlueprintLibrary");

// Class DungeonCrawler.BlockUserSlotWidgetData
// 0x0080 (0x00A8 - 0x0028)
class UBlockUserSlotWidgetData final : public UObject
{
public:
	struct FDCCommunityCharacterInfo              Info;                                              // 0x0028(0x0078)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UInvitePartyWidget*                     InvitePartyWidget;                                 // 0x00A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockUserSlotWidgetData">();
	}
	static class UBlockUserSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockUserSlotWidgetData>();
	}
};
static_assert(alignof(UBlockUserSlotWidgetData) == 0x000008, "Wrong alignment on UBlockUserSlotWidgetData");
static_assert(sizeof(UBlockUserSlotWidgetData) == 0x0000A8, "Wrong size on UBlockUserSlotWidgetData");
static_assert(offsetof(UBlockUserSlotWidgetData, Info) == 0x000028, "Member 'UBlockUserSlotWidgetData::Info' has a wrong offset!");
static_assert(offsetof(UBlockUserSlotWidgetData, InvitePartyWidget) == 0x0000A0, "Member 'UBlockUserSlotWidgetData::InvitePartyWidget' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequireDungeonTitleEntryData
// 0x0028 (0x0050 - 0x0028)
class UDCQuestRequireDungeonTitleEntryData final : public UObject
{
public:
	uint8                                         Pad_23F5[0x28];                                    // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequireDungeonTitleEntryData">();
	}
	static class UDCQuestRequireDungeonTitleEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequireDungeonTitleEntryData>();
	}
};
static_assert(alignof(UDCQuestRequireDungeonTitleEntryData) == 0x000008, "Wrong alignment on UDCQuestRequireDungeonTitleEntryData");
static_assert(sizeof(UDCQuestRequireDungeonTitleEntryData) == 0x000050, "Wrong size on UDCQuestRequireDungeonTitleEntryData");

// Class DungeonCrawler.BlockUserSlotWidget
// 0x0050 (0x03A8 - 0x0358)
class UBlockUserSlotWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_23F6[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0368(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AccountNickname;                                   // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0388(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x0398(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23F7[0xF];                                     // 0x0399(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockUserSlotWidget">();
	}
	static class UBlockUserSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockUserSlotWidget>();
	}
};
static_assert(alignof(UBlockUserSlotWidget) == 0x000008, "Wrong alignment on UBlockUserSlotWidget");
static_assert(sizeof(UBlockUserSlotWidget) == 0x0003A8, "Wrong size on UBlockUserSlotWidget");
static_assert(offsetof(UBlockUserSlotWidget, AccountId) == 0x000368, "Member 'UBlockUserSlotWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UBlockUserSlotWidget, AccountNickname) == 0x000378, "Member 'UBlockUserSlotWidget::AccountNickname' has a wrong offset!");
static_assert(offsetof(UBlockUserSlotWidget, CharacterId) == 0x000388, "Member 'UBlockUserSlotWidget::CharacterId' has a wrong offset!");
static_assert(offsetof(UBlockUserSlotWidget, bSelected) == 0x000398, "Member 'UBlockUserSlotWidget::bSelected' has a wrong offset!");

// Class DungeonCrawler.BTD_CheckGameplayTagsOnActorAbortObservers
// 0x0010 (0x00D8 - 0x00C8)
class UBTD_CheckGameplayTagsOnActorAbortObservers final : public UBTDecorator_CheckGameplayTagsOnActor
{
public:
	uint8                                         Pad_23F8[0x10];                                    // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_CheckGameplayTagsOnActorAbortObservers">();
	}
	static class UBTD_CheckGameplayTagsOnActorAbortObservers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_CheckGameplayTagsOnActorAbortObservers>();
	}
};
static_assert(alignof(UBTD_CheckGameplayTagsOnActorAbortObservers) == 0x000008, "Wrong alignment on UBTD_CheckGameplayTagsOnActorAbortObservers");
static_assert(sizeof(UBTD_CheckGameplayTagsOnActorAbortObservers) == 0x0000D8, "Wrong size on UBTD_CheckGameplayTagsOnActorAbortObservers");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationDexterity
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationDexterity final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_23F9[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationDexterity">();
	}
	static class UDCAttributeModMagnitudeCalculationDexterity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationDexterity>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationDexterity) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationDexterity");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationDexterity) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationDexterity");

// Class DungeonCrawler.BTD_DCCheckGameplayTagsOnActor
// 0x0000 (0x00C8 - 0x00C8)
class UBTD_DCCheckGameplayTagsOnActor final : public UBTDecorator_CheckGameplayTagsOnActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_DCCheckGameplayTagsOnActor">();
	}
	static class UBTD_DCCheckGameplayTagsOnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_DCCheckGameplayTagsOnActor>();
	}
};
static_assert(alignof(UBTD_DCCheckGameplayTagsOnActor) == 0x000008, "Wrong alignment on UBTD_DCCheckGameplayTagsOnActor");
static_assert(sizeof(UBTD_DCCheckGameplayTagsOnActor) == 0x0000C8, "Wrong size on UBTD_DCCheckGameplayTagsOnActor");

// Class DungeonCrawler.DCReportPlayerWidget
// 0x0100 (0x03C0 - 0x02C0)
class UDCReportPlayerWidget final : public UUserWidget
{
public:
	TSubclassOf<class UDCReportPlayerChecklistSlotWidget> ReportPlayerChecklistWidgetClass;                  // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Cancel;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Report;                                        // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMultiLineEditableTextBox*              ReportEditableMultiTextBox;                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ReportCategoryCheckList;                           // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   SelectReportCategoryText;                          // 0x02E8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   TargetUserNickname;                                // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReportHintText;                                    // 0x0318(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReportTextMaxCountText;                            // 0x0330(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReportTextCurrentCountText;                        // 0x0348(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDCAccountId                           ReportTargetAccountId;                             // 0x0360(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNickname                              ReportTargetNickname;                              // 0x0370(0x0040)(Transient, NativeAccessSpecifierPrivate)
	EDCReportPlayerCategory                       SelectedCategory;                                  // 0x03B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsReportButtonClicked;                            // 0x03B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23FA[0x2];                                     // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCharacterCount;                                 // 0x03B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    Btn_Block;                                         // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ESlateVisibility GetSelectCategoryTextVisibility();
	void HandleBlockButtonClicked();
	void HandleCancelButtonClicked();
	void HandleCheckStatedChanged(EDCReportPlayerCategory InCategory, bool InbNewChecked);
	void HandleReportButtonClicked();
	void HandleReportTextChanged(const class FText& InText);
	bool IsReportCategorySelected();
	void OnBlockConfirmed(const EPopupResult PopupResult);
	void OnSelectedCategoryChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerWidget">();
	}
	static class UDCReportPlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerWidget>();
	}
};
static_assert(alignof(UDCReportPlayerWidget) == 0x000008, "Wrong alignment on UDCReportPlayerWidget");
static_assert(sizeof(UDCReportPlayerWidget) == 0x0003C0, "Wrong size on UDCReportPlayerWidget");
static_assert(offsetof(UDCReportPlayerWidget, ReportPlayerChecklistWidgetClass) == 0x0002C0, "Member 'UDCReportPlayerWidget::ReportPlayerChecklistWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, Btn_Cancel) == 0x0002C8, "Member 'UDCReportPlayerWidget::Btn_Cancel' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, Btn_Report) == 0x0002D0, "Member 'UDCReportPlayerWidget::Btn_Report' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportEditableMultiTextBox) == 0x0002D8, "Member 'UDCReportPlayerWidget::ReportEditableMultiTextBox' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportCategoryCheckList) == 0x0002E0, "Member 'UDCReportPlayerWidget::ReportCategoryCheckList' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, SelectReportCategoryText) == 0x0002E8, "Member 'UDCReportPlayerWidget::SelectReportCategoryText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, TargetUserNickname) == 0x000300, "Member 'UDCReportPlayerWidget::TargetUserNickname' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportHintText) == 0x000318, "Member 'UDCReportPlayerWidget::ReportHintText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportTextMaxCountText) == 0x000330, "Member 'UDCReportPlayerWidget::ReportTextMaxCountText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportTextCurrentCountText) == 0x000348, "Member 'UDCReportPlayerWidget::ReportTextCurrentCountText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportTargetAccountId) == 0x000360, "Member 'UDCReportPlayerWidget::ReportTargetAccountId' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, ReportTargetNickname) == 0x000370, "Member 'UDCReportPlayerWidget::ReportTargetNickname' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, SelectedCategory) == 0x0003B0, "Member 'UDCReportPlayerWidget::SelectedCategory' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, bIsReportButtonClicked) == 0x0003B1, "Member 'UDCReportPlayerWidget::bIsReportButtonClicked' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, MaxCharacterCount) == 0x0003B4, "Member 'UDCReportPlayerWidget::MaxCharacterCount' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerWidget, Btn_Block) == 0x0003B8, "Member 'UDCReportPlayerWidget::Btn_Block' has a wrong offset!");

// Class DungeonCrawler.SentInvitationSlotWidget
// 0x0040 (0x0430 - 0x03F0)
class USentInvitationSlotWidget final : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_23FB[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCFriendStatus                               Status;                                            // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x0421(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23FC[0xE];                                     // 0x0422(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SentInvitationSlotWidget">();
	}
	static class USentInvitationSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USentInvitationSlotWidget>();
	}
};
static_assert(alignof(USentInvitationSlotWidget) == 0x000008, "Wrong alignment on USentInvitationSlotWidget");
static_assert(sizeof(USentInvitationSlotWidget) == 0x000430, "Wrong size on USentInvitationSlotWidget");
static_assert(offsetof(USentInvitationSlotWidget, AccountId) == 0x000400, "Member 'USentInvitationSlotWidget::AccountId' has a wrong offset!");
static_assert(offsetof(USentInvitationSlotWidget, CharacterId) == 0x000410, "Member 'USentInvitationSlotWidget::CharacterId' has a wrong offset!");
static_assert(offsetof(USentInvitationSlotWidget, Status) == 0x000420, "Member 'USentInvitationSlotWidget::Status' has a wrong offset!");
static_assert(offsetof(USentInvitationSlotWidget, bSelected) == 0x000421, "Member 'USentInvitationSlotWidget::bSelected' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationItemArmorRating
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationItemArmorRating final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_23FD[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationItemArmorRating">();
	}
	static class UDCAttributeModMagnitudeCalculationItemArmorRating* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationItemArmorRating>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationItemArmorRating) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationItemArmorRating");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationItemArmorRating) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationItemArmorRating");

// Class DungeonCrawler.BTD_RandomCooldown
// 0x0010 (0x0078 - 0x0068)
class UBTD_RandomCooldown final : public UBTDecorator
{
public:
	float                                         MinCoolDownTime;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCoolDownTime;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitCoolDownTime;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FE[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_RandomCooldown">();
	}
	static class UBTD_RandomCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_RandomCooldown>();
	}
};
static_assert(alignof(UBTD_RandomCooldown) == 0x000008, "Wrong alignment on UBTD_RandomCooldown");
static_assert(sizeof(UBTD_RandomCooldown) == 0x000078, "Wrong size on UBTD_RandomCooldown");
static_assert(offsetof(UBTD_RandomCooldown, MinCoolDownTime) == 0x000068, "Member 'UBTD_RandomCooldown::MinCoolDownTime' has a wrong offset!");
static_assert(offsetof(UBTD_RandomCooldown, MaxCoolDownTime) == 0x00006C, "Member 'UBTD_RandomCooldown::MaxCoolDownTime' has a wrong offset!");
static_assert(offsetof(UBTD_RandomCooldown, InitCoolDownTime) == 0x000070, "Member 'UBTD_RandomCooldown::InitCoolDownTime' has a wrong offset!");

// Class DungeonCrawler.BTT_BlueprintBase
// 0x0000 (0x00A8 - 0x00A8)
class UBTT_BlueprintBase : public UBTTask_BlueprintBase
{
public:
	void OnTaskFinished(class AAIController* OwnerController, class APawn* ControlledPawn, EBTNodeResult TaskResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_BlueprintBase">();
	}
	static class UBTT_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_BlueprintBase>();
	}
};
static_assert(alignof(UBTT_BlueprintBase) == 0x000008, "Wrong alignment on UBTT_BlueprintBase");
static_assert(sizeof(UBTT_BlueprintBase) == 0x0000A8, "Wrong size on UBTT_BlueprintBase");

// Class DungeonCrawler.DCRotatorComponent
// 0x0010 (0x02B0 - 0x02A0)
class UDCRotatorComponent final : public USceneComponent
{
public:
	float                                         ManualRotateSensitivity;                           // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoRotateSensitivity;                             // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecelerateAutoRotatePer;                           // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2400[0x4];                                     // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRotatorComponent">();
	}
	static class UDCRotatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRotatorComponent>();
	}
};
static_assert(alignof(UDCRotatorComponent) == 0x000010, "Wrong alignment on UDCRotatorComponent");
static_assert(sizeof(UDCRotatorComponent) == 0x0002B0, "Wrong size on UDCRotatorComponent");
static_assert(offsetof(UDCRotatorComponent, ManualRotateSensitivity) == 0x0002A0, "Member 'UDCRotatorComponent::ManualRotateSensitivity' has a wrong offset!");
static_assert(offsetof(UDCRotatorComponent, AutoRotateSensitivity) == 0x0002A4, "Member 'UDCRotatorComponent::AutoRotateSensitivity' has a wrong offset!");
static_assert(offsetof(UDCRotatorComponent, DecelerateAutoRotatePer) == 0x0002A8, "Member 'UDCRotatorComponent::DecelerateAutoRotatePer' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitGameplayTags
// 0x0088 (0x0108 - 0x0080)
class UDCAT_WaitGameplayTags : public UAbilityTask
{
public:
	uint8                                         Pad_2401[0x28];                                    // 0x0080(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2402[0x58];                                    // 0x00B0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameplayTagCallback(const struct FGameplayTag& Tag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitGameplayTags">();
	}
	static class UDCAT_WaitGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitGameplayTags>();
	}
};
static_assert(alignof(UDCAT_WaitGameplayTags) == 0x000008, "Wrong alignment on UDCAT_WaitGameplayTags");
static_assert(sizeof(UDCAT_WaitGameplayTags) == 0x000108, "Wrong size on UDCAT_WaitGameplayTags");
static_assert(offsetof(UDCAT_WaitGameplayTags, OptionalExternalTarget) == 0x0000A8, "Member 'UDCAT_WaitGameplayTags::OptionalExternalTarget' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitGameplayTagsAdded
// 0x0020 (0x0128 - 0x0108)
class UDCAT_WaitGameplayTagsAdded final : public UDCAT_WaitGameplayTags
{
public:
	FMulticastInlineDelegateProperty_             Added;                                             // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AddedOnTarget;                                     // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UDCAT_WaitGameplayTagsAdded* WaitGameplayTagsAdded(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& TagContainer, bool bIsWaitAnyTag, class AActor* InOptionalExternalTarget, bool bIsOnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitGameplayTagsAdded">();
	}
	static class UDCAT_WaitGameplayTagsAdded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitGameplayTagsAdded>();
	}
};
static_assert(alignof(UDCAT_WaitGameplayTagsAdded) == 0x000008, "Wrong alignment on UDCAT_WaitGameplayTagsAdded");
static_assert(sizeof(UDCAT_WaitGameplayTagsAdded) == 0x000128, "Wrong size on UDCAT_WaitGameplayTagsAdded");
static_assert(offsetof(UDCAT_WaitGameplayTagsAdded, Added) == 0x000108, "Member 'UDCAT_WaitGameplayTagsAdded::Added' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitGameplayTagsAdded, AddedOnTarget) == 0x000118, "Member 'UDCAT_WaitGameplayTagsAdded::AddedOnTarget' has a wrong offset!");

// Class DungeonCrawler.BTT_CustomRunBehavior
// 0x0000 (0x0078 - 0x0078)
class UBTT_CustomRunBehavior final : public UBTTask_RunBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_CustomRunBehavior">();
	}
	static class UBTT_CustomRunBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_CustomRunBehavior>();
	}
};
static_assert(alignof(UBTT_CustomRunBehavior) == 0x000008, "Wrong alignment on UBTT_CustomRunBehavior");
static_assert(sizeof(UBTT_CustomRunBehavior) == 0x000078, "Wrong size on UBTT_CustomRunBehavior");

// Class DungeonCrawler.DCPlayerState
// 0x00A8 (0x03F8 - 0x0350)
class ADCPlayerState final : public APlayerState
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0350(0x0010)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUserLoaded;                                     // 0x0360(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2405[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ForceExitWorldTimeSeconds;                         // 0x0368(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2406[0x8];                                     // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameResultInfo                        GameResult;                                        // 0x0378(0x0048)(Net, NativeAccessSpecifierPrivate)
	bool                                          bGameOver;                                         // 0x03C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2407[0x37];                                    // 0x03C1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ForceExitWorldTimeSeconds();
	void OnRep_GameOver();
	void OnRep_IsUserLoaded();

	float GetForceExitRemainSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerState">();
	}
	static class ADCPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerState>();
	}
};
static_assert(alignof(ADCPlayerState) == 0x000008, "Wrong alignment on ADCPlayerState");
static_assert(sizeof(ADCPlayerState) == 0x0003F8, "Wrong size on ADCPlayerState");
static_assert(offsetof(ADCPlayerState, AccountId) == 0x000350, "Member 'ADCPlayerState::AccountId' has a wrong offset!");
static_assert(offsetof(ADCPlayerState, bIsUserLoaded) == 0x000360, "Member 'ADCPlayerState::bIsUserLoaded' has a wrong offset!");
static_assert(offsetof(ADCPlayerState, ForceExitWorldTimeSeconds) == 0x000368, "Member 'ADCPlayerState::ForceExitWorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(ADCPlayerState, GameResult) == 0x000378, "Member 'ADCPlayerState::GameResult' has a wrong offset!");
static_assert(offsetof(ADCPlayerState, bGameOver) == 0x0003C0, "Member 'ADCPlayerState::bGameOver' has a wrong offset!");

// Class DungeonCrawler.CharacterCreateAttributeWidgetData
// 0x0010 (0x0038 - 0x0028)
class UCharacterCreateAttributeWidgetData final : public UObject
{
public:
	struct FGameplayEffectDescData                AttrributeEffectDescData;                          // 0x0028(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2408[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCreateAttributeWidgetData">();
	}
	static class UCharacterCreateAttributeWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCreateAttributeWidgetData>();
	}
};
static_assert(alignof(UCharacterCreateAttributeWidgetData) == 0x000008, "Wrong alignment on UCharacterCreateAttributeWidgetData");
static_assert(sizeof(UCharacterCreateAttributeWidgetData) == 0x000038, "Wrong size on UCharacterCreateAttributeWidgetData");
static_assert(offsetof(UCharacterCreateAttributeWidgetData, AttrributeEffectDescData) == 0x000028, "Member 'UCharacterCreateAttributeWidgetData::AttrributeEffectDescData' has a wrong offset!");

// Class DungeonCrawler.CommonPopupBase
// 0x0008 (0x0490 - 0x0488)
class UCommonPopupBase : public UDCCommonActivatableWidgetBase
{
public:
	class UPopupDataBase*                         RawPopupData;                                      // 0x0488(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonPopupBase">();
	}
	static class UCommonPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonPopupBase>();
	}
};
static_assert(alignof(UCommonPopupBase) == 0x000008, "Wrong alignment on UCommonPopupBase");
static_assert(sizeof(UCommonPopupBase) == 0x000490, "Wrong size on UCommonPopupBase");
static_assert(offsetof(UCommonPopupBase, RawPopupData) == 0x000488, "Member 'UCommonPopupBase::RawPopupData' has a wrong offset!");

// Class DungeonCrawler.GRACPopup
// 0x0008 (0x0498 - 0x0490)
class UGRACPopup : public UCommonPopupBase
{
public:
	class UGRACPopupData*                         GRACPopupData;                                     // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClosePopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRACPopup">();
	}
	static class UGRACPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRACPopup>();
	}
};
static_assert(alignof(UGRACPopup) == 0x000008, "Wrong alignment on UGRACPopup");
static_assert(sizeof(UGRACPopup) == 0x000498, "Wrong size on UGRACPopup");
static_assert(offsetof(UGRACPopup, GRACPopupData) == 0x000490, "Member 'UGRACPopup::GRACPopupData' has a wrong offset!");

// Class DungeonCrawler.DCAccountStatusUpgradeShopWidget
// 0x0038 (0x0390 - 0x0358)
class UDCAccountStatusUpgradeShopWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2409[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    UpgradeButton;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableUpgradeAccountStatus;                       // 0x0370(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240A[0x1F];                                    // 0x0371(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetContentsBlockHours(const EServicePolicyType InPolicyType, const int32 InBlockHours);
	void OnSetUpgradeShopInfo(const struct FDCAccountStatusUpgradeShopInfo& InUpgradeShopInfo);
	void OnUpgradeButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountStatusUpgradeShopWidget">();
	}
	static class UDCAccountStatusUpgradeShopWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountStatusUpgradeShopWidget>();
	}
};
static_assert(alignof(UDCAccountStatusUpgradeShopWidget) == 0x000008, "Wrong alignment on UDCAccountStatusUpgradeShopWidget");
static_assert(sizeof(UDCAccountStatusUpgradeShopWidget) == 0x000390, "Wrong size on UDCAccountStatusUpgradeShopWidget");
static_assert(offsetof(UDCAccountStatusUpgradeShopWidget, UpgradeButton) == 0x000368, "Member 'UDCAccountStatusUpgradeShopWidget::UpgradeButton' has a wrong offset!");
static_assert(offsetof(UDCAccountStatusUpgradeShopWidget, bEnableUpgradeAccountStatus) == 0x000370, "Member 'UDCAccountStatusUpgradeShopWidget::bEnableUpgradeAccountStatus' has a wrong offset!");

// Class DungeonCrawler.CharacterCreateAttributeWidget
// 0x0008 (0x0360 - 0x0358)
class UCharacterCreateAttributeWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_240C[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCreateAttributeWidget">();
	}
	static class UCharacterCreateAttributeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCreateAttributeWidget>();
	}
};
static_assert(alignof(UCharacterCreateAttributeWidget) == 0x000008, "Wrong alignment on UCharacterCreateAttributeWidget");
static_assert(sizeof(UCharacterCreateAttributeWidget) == 0x000360, "Wrong size on UCharacterCreateAttributeWidget");

// Class DungeonCrawler.DCQuestRequirementFetchWidget
// 0x0028 (0x0380 - 0x0358)
class UDCQuestRequirementFetchWidget final : public UDCWidgetBase
{
public:
	TSubclassOf<class UDCQuestRequiredEntryWidget> RequiredItemWidgetClass;                           // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RequiredItemHorizontalBox;                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonFill;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonDeliver;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCQuestState                                 QuestSate;                                         // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240D[0x7];                                     // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonFill();

	class FText GetFetchRequiredTitle() const;
	bool IsFilled() const;
	bool IsItemDeliveryAvailable() const;
	void OnAnyItemFilled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementFetchWidget">();
	}
	static class UDCQuestRequirementFetchWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementFetchWidget>();
	}
};
static_assert(alignof(UDCQuestRequirementFetchWidget) == 0x000008, "Wrong alignment on UDCQuestRequirementFetchWidget");
static_assert(sizeof(UDCQuestRequirementFetchWidget) == 0x000380, "Wrong size on UDCQuestRequirementFetchWidget");
static_assert(offsetof(UDCQuestRequirementFetchWidget, RequiredItemWidgetClass) == 0x000358, "Member 'UDCQuestRequirementFetchWidget::RequiredItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementFetchWidget, RequiredItemHorizontalBox) == 0x000360, "Member 'UDCQuestRequirementFetchWidget::RequiredItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementFetchWidget, ButtonFill) == 0x000368, "Member 'UDCQuestRequirementFetchWidget::ButtonFill' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementFetchWidget, ButtonDeliver) == 0x000370, "Member 'UDCQuestRequirementFetchWidget::ButtonDeliver' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementFetchWidget, QuestSate) == 0x000378, "Member 'UDCQuestRequirementFetchWidget::QuestSate' has a wrong offset!");

// Class DungeonCrawler.CharacterCreateClassItemWidgetData
// 0x0008 (0x0030 - 0x0028)
class UCharacterCreateClassItemWidgetData final : public UObject
{
public:
	EDCCharacterClass                             CharacterClass;                                    // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x002A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOwned;                                          // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240E[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCreateClassItemWidgetData">();
	}
	static class UCharacterCreateClassItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCreateClassItemWidgetData>();
	}
};
static_assert(alignof(UCharacterCreateClassItemWidgetData) == 0x000008, "Wrong alignment on UCharacterCreateClassItemWidgetData");
static_assert(sizeof(UCharacterCreateClassItemWidgetData) == 0x000030, "Wrong size on UCharacterCreateClassItemWidgetData");
static_assert(offsetof(UCharacterCreateClassItemWidgetData, CharacterClass) == 0x000028, "Member 'UCharacterCreateClassItemWidgetData::CharacterClass' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidgetData, Gender) == 0x000029, "Member 'UCharacterCreateClassItemWidgetData::Gender' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidgetData, bSelected) == 0x00002A, "Member 'UCharacterCreateClassItemWidgetData::bSelected' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidgetData, bIsOwned) == 0x00002B, "Member 'UCharacterCreateClassItemWidgetData::bIsOwned' has a wrong offset!");

// Class DungeonCrawler.CharacterCreateClassItemWidget
// 0x0038 (0x0390 - 0x0358)
class UCharacterCreateClassItemWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_240F[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             Icon;                                              // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Portrait;                                          // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanCreate;                                        // 0x0389(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExperimental;                                     // 0x038A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOwned;                                          // 0x038B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2410[0x4];                                     // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCreateClassItemWidget">();
	}
	static class UCharacterCreateClassItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCreateClassItemWidget>();
	}
};
static_assert(alignof(UCharacterCreateClassItemWidget) == 0x000008, "Wrong alignment on UCharacterCreateClassItemWidget");
static_assert(sizeof(UCharacterCreateClassItemWidget) == 0x000390, "Wrong size on UCharacterCreateClassItemWidget");
static_assert(offsetof(UCharacterCreateClassItemWidget, Title) == 0x000360, "Member 'UCharacterCreateClassItemWidget::Title' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidget, Icon) == 0x000378, "Member 'UCharacterCreateClassItemWidget::Icon' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidget, Portrait) == 0x000380, "Member 'UCharacterCreateClassItemWidget::Portrait' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidget, bSelected) == 0x000388, "Member 'UCharacterCreateClassItemWidget::bSelected' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidget, bCanCreate) == 0x000389, "Member 'UCharacterCreateClassItemWidget::bCanCreate' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidget, bExperimental) == 0x00038A, "Member 'UCharacterCreateClassItemWidget::bExperimental' has a wrong offset!");
static_assert(offsetof(UCharacterCreateClassItemWidget, bIsOwned) == 0x00038B, "Member 'UCharacterCreateClassItemWidget::bIsOwned' has a wrong offset!");

// Class DungeonCrawler.CharacterCreatePerkItemWidget
// 0x0000 (0x0358 - 0x0358)
class UCharacterCreatePerkItemWidget final : public UDCWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCreatePerkItemWidget">();
	}
	static class UCharacterCreatePerkItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCreatePerkItemWidget>();
	}
};
static_assert(alignof(UCharacterCreatePerkItemWidget) == 0x000008, "Wrong alignment on UCharacterCreatePerkItemWidget");
static_assert(sizeof(UCharacterCreatePerkItemWidget) == 0x000358, "Wrong size on UCharacterCreatePerkItemWidget");

// Class DungeonCrawler.DCRewardTokensWidgetBase
// 0x0038 (0x0320 - 0x02E8)
class UDCRewardTokensWidgetBase final : public UCommonUserWidget
{
public:
	int32                                         TokenCount;                                        // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2411[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NextTokenLevelText;                                // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCCountButtonWidget*                   RedeemButton;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRedeemRewardTokenCheckPopup> RedeemRewardTokenCheckPopupClass;                  // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRedeem;                                        // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2412[0x7];                                     // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickRedeemButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRewardTokensWidgetBase">();
	}
	static class UDCRewardTokensWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRewardTokensWidgetBase>();
	}
};
static_assert(alignof(UDCRewardTokensWidgetBase) == 0x000008, "Wrong alignment on UDCRewardTokensWidgetBase");
static_assert(sizeof(UDCRewardTokensWidgetBase) == 0x000320, "Wrong size on UDCRewardTokensWidgetBase");
static_assert(offsetof(UDCRewardTokensWidgetBase, TokenCount) == 0x0002E8, "Member 'UDCRewardTokensWidgetBase::TokenCount' has a wrong offset!");
static_assert(offsetof(UDCRewardTokensWidgetBase, NextTokenLevelText) == 0x0002F0, "Member 'UDCRewardTokensWidgetBase::NextTokenLevelText' has a wrong offset!");
static_assert(offsetof(UDCRewardTokensWidgetBase, RedeemButton) == 0x000308, "Member 'UDCRewardTokensWidgetBase::RedeemButton' has a wrong offset!");
static_assert(offsetof(UDCRewardTokensWidgetBase, RedeemRewardTokenCheckPopupClass) == 0x000310, "Member 'UDCRewardTokensWidgetBase::RedeemRewardTokenCheckPopupClass' has a wrong offset!");
static_assert(offsetof(UDCRewardTokensWidgetBase, bCanRedeem) == 0x000318, "Member 'UDCRewardTokensWidgetBase::bCanRedeem' has a wrong offset!");

// Class DungeonCrawler.LobbyGroupWidgetBase
// 0x0030 (0x04B8 - 0x0488)
class ULobbyGroupWidgetBase : public UDCCommonActivatableWidgetBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2413[0x7];                                     // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWidgetLobbyGroupType>                 NonCoexistWidgetLobbyGroupTypeArray;               // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         GroupWidgetPriority;                               // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldWaitResponseOnHide;                         // 0x04A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowConfirmPopupOnHide;                           // 0x04A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2414[0x2];                                     // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCommonPopupSWidget>        CommonPopupWidget;                                 // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2415[0x8];                                     // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGroupWidgetBase">();
	}
	static class ULobbyGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyGroupWidgetBase>();
	}
};
static_assert(alignof(ULobbyGroupWidgetBase) == 0x000008, "Wrong alignment on ULobbyGroupWidgetBase");
static_assert(sizeof(ULobbyGroupWidgetBase) == 0x0004B8, "Wrong size on ULobbyGroupWidgetBase");
static_assert(offsetof(ULobbyGroupWidgetBase, WidgetLobbyGroupType) == 0x000488, "Member 'ULobbyGroupWidgetBase::WidgetLobbyGroupType' has a wrong offset!");
static_assert(offsetof(ULobbyGroupWidgetBase, NonCoexistWidgetLobbyGroupTypeArray) == 0x000490, "Member 'ULobbyGroupWidgetBase::NonCoexistWidgetLobbyGroupTypeArray' has a wrong offset!");
static_assert(offsetof(ULobbyGroupWidgetBase, GroupWidgetPriority) == 0x0004A0, "Member 'ULobbyGroupWidgetBase::GroupWidgetPriority' has a wrong offset!");
static_assert(offsetof(ULobbyGroupWidgetBase, bShouldWaitResponseOnHide) == 0x0004A4, "Member 'ULobbyGroupWidgetBase::bShouldWaitResponseOnHide' has a wrong offset!");
static_assert(offsetof(ULobbyGroupWidgetBase, bShowConfirmPopupOnHide) == 0x0004A5, "Member 'ULobbyGroupWidgetBase::bShowConfirmPopupOnHide' has a wrong offset!");
static_assert(offsetof(ULobbyGroupWidgetBase, CommonPopupWidget) == 0x0004A8, "Member 'ULobbyGroupWidgetBase::CommonPopupWidget' has a wrong offset!");

// Class DungeonCrawler.LobbyGroupTradingWidget
// 0x0018 (0x04D0 - 0x04B8)
class ULobbyGroupTradingWidget final : public ULobbyGroupWidgetBase
{
public:
	class UTopTitleWidgetBase*                    TopTitle;                                          // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTradeInventoryWidget*                TradeUserInventory;                                // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTradeSubscriptionPopup>  TradersGuildRulesPopupClass;                       // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLeaveChannelButtonClicked();
	void OnReadRulesButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGroupTradingWidget">();
	}
	static class ULobbyGroupTradingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyGroupTradingWidget>();
	}
};
static_assert(alignof(ULobbyGroupTradingWidget) == 0x000008, "Wrong alignment on ULobbyGroupTradingWidget");
static_assert(sizeof(ULobbyGroupTradingWidget) == 0x0004D0, "Wrong size on ULobbyGroupTradingWidget");
static_assert(offsetof(ULobbyGroupTradingWidget, TopTitle) == 0x0004B8, "Member 'ULobbyGroupTradingWidget::TopTitle' has a wrong offset!");
static_assert(offsetof(ULobbyGroupTradingWidget, TradeUserInventory) == 0x0004C0, "Member 'ULobbyGroupTradingWidget::TradeUserInventory' has a wrong offset!");
static_assert(offsetof(ULobbyGroupTradingWidget, TradersGuildRulesPopupClass) == 0x0004C8, "Member 'ULobbyGroupTradingWidget::TradersGuildRulesPopupClass' has a wrong offset!");

// Class DungeonCrawler.DCAccountNameChangeShopConfirmPopup
// 0x0060 (0x04F0 - 0x0490)
class UDCAccountNameChangeShopConfirmPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    ConfirmButton;                                     // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelButton;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   OldAccountName;                                    // 0x04A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   NewAccountName;                                    // 0x04B8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDCAccountNameChangeShopInfo           ShopInfo;                                          // 0x04D0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCAccountNameChangeShopConfirmPopupData* AccountNameChangeShopConfirmPopupData;             // 0x04E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancel();
	void OnConfirm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountNameChangeShopConfirmPopup">();
	}
	static class UDCAccountNameChangeShopConfirmPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountNameChangeShopConfirmPopup>();
	}
};
static_assert(alignof(UDCAccountNameChangeShopConfirmPopup) == 0x000008, "Wrong alignment on UDCAccountNameChangeShopConfirmPopup");
static_assert(sizeof(UDCAccountNameChangeShopConfirmPopup) == 0x0004F0, "Wrong size on UDCAccountNameChangeShopConfirmPopup");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopup, ConfirmButton) == 0x000490, "Member 'UDCAccountNameChangeShopConfirmPopup::ConfirmButton' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopup, CancelButton) == 0x000498, "Member 'UDCAccountNameChangeShopConfirmPopup::CancelButton' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopup, OldAccountName) == 0x0004A0, "Member 'UDCAccountNameChangeShopConfirmPopup::OldAccountName' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopup, NewAccountName) == 0x0004B8, "Member 'UDCAccountNameChangeShopConfirmPopup::NewAccountName' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopup, ShopInfo) == 0x0004D0, "Member 'UDCAccountNameChangeShopConfirmPopup::ShopInfo' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopup, AccountNameChangeShopConfirmPopupData) == 0x0004E8, "Member 'UDCAccountNameChangeShopConfirmPopup::AccountNameChangeShopConfirmPopupData' has a wrong offset!");

// Class DungeonCrawler.CharacterCreateWidget
// 0x00C0 (0x0548 - 0x0488)
class UCharacterCreateWidget : public UDCCommonActivatableWidgetBase
{
public:
	EDCCharacterClass                             SelectedCharacterClass;                            // 0x0488(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCGender                                     SelectedGender;                                    // 0x0489(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanCreate;                                        // 0x048A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2416[0x5];                                     // 0x048B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SelectedCharacterClassName;                        // 0x0490(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   SelectedCharacterClassDialog;                      // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   SelectedCharacterClassInfo;                        // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         AccountBluestoneShardValue;                        // 0x04D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AccountRedstoneShardValue;                         // 0x04DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SelectedCharacterIllustration;                     // 0x04E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              ClassSelectTileView;                               // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              ClassAttributeTileView;                            // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEditableText*                        NickNameTextBox;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCaptureStudioWidget*                 CaptureStudioWidget;                               // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    WB_Btn_Purchase;                                   // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    WB_Btn_LaunchShopURL;                              // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCClassPackageShopItemInfo            SelectedShopInfo;                                  // 0x0518(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	bool CanLaunchRedstoneShardShop();
	ESlateVisibility GetCanCreateVisibility();
	ESlateVisibility GetCannotCreateVisibility();
	int32 GetCashPrice();
	int32 GetPrice();
	void HandleConfirmButtonClicked();
	void HandleExitButtonClicked();
	void OnClassSelectTileViewItemSelectionChanged(class UObject* InItem);
	void OnGenderClicked(const EDCGender Gender);
	void OnLaunchShopURLButtonClicked();
	void OnPurchaseButtonClicked();
	void OnTextChangedNickName(const class FText& InNickName);
	void SelectCharacterClass(const EDCCharacterClass CharacterClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCreateWidget">();
	}
	static class UCharacterCreateWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCreateWidget>();
	}
};
static_assert(alignof(UCharacterCreateWidget) == 0x000008, "Wrong alignment on UCharacterCreateWidget");
static_assert(sizeof(UCharacterCreateWidget) == 0x000548, "Wrong size on UCharacterCreateWidget");
static_assert(offsetof(UCharacterCreateWidget, SelectedCharacterClass) == 0x000488, "Member 'UCharacterCreateWidget::SelectedCharacterClass' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, SelectedGender) == 0x000489, "Member 'UCharacterCreateWidget::SelectedGender' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, bCanCreate) == 0x00048A, "Member 'UCharacterCreateWidget::bCanCreate' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, SelectedCharacterClassName) == 0x000490, "Member 'UCharacterCreateWidget::SelectedCharacterClassName' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, SelectedCharacterClassDialog) == 0x0004A8, "Member 'UCharacterCreateWidget::SelectedCharacterClassDialog' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, SelectedCharacterClassInfo) == 0x0004C0, "Member 'UCharacterCreateWidget::SelectedCharacterClassInfo' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, AccountBluestoneShardValue) == 0x0004D8, "Member 'UCharacterCreateWidget::AccountBluestoneShardValue' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, AccountRedstoneShardValue) == 0x0004DC, "Member 'UCharacterCreateWidget::AccountRedstoneShardValue' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, SelectedCharacterIllustration) == 0x0004E0, "Member 'UCharacterCreateWidget::SelectedCharacterIllustration' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, ClassSelectTileView) == 0x0004E8, "Member 'UCharacterCreateWidget::ClassSelectTileView' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, ClassAttributeTileView) == 0x0004F0, "Member 'UCharacterCreateWidget::ClassAttributeTileView' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, NickNameTextBox) == 0x0004F8, "Member 'UCharacterCreateWidget::NickNameTextBox' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, CaptureStudioWidget) == 0x000500, "Member 'UCharacterCreateWidget::CaptureStudioWidget' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, WB_Btn_Purchase) == 0x000508, "Member 'UCharacterCreateWidget::WB_Btn_Purchase' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, WB_Btn_LaunchShopURL) == 0x000510, "Member 'UCharacterCreateWidget::WB_Btn_LaunchShopURL' has a wrong offset!");
static_assert(offsetof(UCharacterCreateWidget, SelectedShopInfo) == 0x000518, "Member 'UCharacterCreateWidget::SelectedShopInfo' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementDetailEntryWidgetData
// 0x0018 (0x0040 - 0x0028)
class UDCQuestRequirementDetailEntryWidgetData final : public UObject
{
public:
	uint8                                         Pad_2417[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementDetailEntryWidgetData">();
	}
	static class UDCQuestRequirementDetailEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementDetailEntryWidgetData>();
	}
};
static_assert(alignof(UDCQuestRequirementDetailEntryWidgetData) == 0x000008, "Wrong alignment on UDCQuestRequirementDetailEntryWidgetData");
static_assert(sizeof(UDCQuestRequirementDetailEntryWidgetData) == 0x000040, "Wrong size on UDCQuestRequirementDetailEntryWidgetData");

// Class DungeonCrawler.DCArenaGameMode
// 0x0090 (0x0588 - 0x04F8)
class ADCArenaGameMode final : public ADCIngameGameMode
{
public:
	TSubclassOf<class APropsActorBase>            DoorClass;                                         // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADCArenaGameState*                      ArenaGameState;                                    // 0x0500(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCIngameGameSession*                   ArenaGameSession;                                  // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2418[0x8];                                     // 0x0510(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCArenaStartPoint>             ArenaStartPoints;                                  // 0x0518(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ADCPlayerStart*                         RedTeamStartPoint;                                 // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerStart*                         BlueTeamStartPoint;                                // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<struct FDCAccountId>                     ProcessedUsers;                                    // 0x0538(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCArenaGameMode">();
	}
	static class ADCArenaGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCArenaGameMode>();
	}
};
static_assert(alignof(ADCArenaGameMode) == 0x000008, "Wrong alignment on ADCArenaGameMode");
static_assert(sizeof(ADCArenaGameMode) == 0x000588, "Wrong size on ADCArenaGameMode");
static_assert(offsetof(ADCArenaGameMode, DoorClass) == 0x0004F8, "Member 'ADCArenaGameMode::DoorClass' has a wrong offset!");
static_assert(offsetof(ADCArenaGameMode, ArenaGameState) == 0x000500, "Member 'ADCArenaGameMode::ArenaGameState' has a wrong offset!");
static_assert(offsetof(ADCArenaGameMode, ArenaGameSession) == 0x000508, "Member 'ADCArenaGameMode::ArenaGameSession' has a wrong offset!");
static_assert(offsetof(ADCArenaGameMode, ArenaStartPoints) == 0x000518, "Member 'ADCArenaGameMode::ArenaStartPoints' has a wrong offset!");
static_assert(offsetof(ADCArenaGameMode, RedTeamStartPoint) == 0x000528, "Member 'ADCArenaGameMode::RedTeamStartPoint' has a wrong offset!");
static_assert(offsetof(ADCArenaGameMode, BlueTeamStartPoint) == 0x000530, "Member 'ADCArenaGameMode::BlueTeamStartPoint' has a wrong offset!");
static_assert(offsetof(ADCArenaGameMode, ProcessedUsers) == 0x000538, "Member 'ADCArenaGameMode::ProcessedUsers' has a wrong offset!");

// Class DungeonCrawler.DCDataComponent
// 0x0030 (0x00D0 - 0x00A0)
class UDCDataComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_2419[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        AssetId;                                           // 0x00B8(0x0010)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCDataAssetBase*                       DataAsset;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_AssetId(const struct FPrimaryAssetId& PrevAssetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDataComponent">();
	}
	static class UDCDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDataComponent>();
	}
};
static_assert(alignof(UDCDataComponent) == 0x000008, "Wrong alignment on UDCDataComponent");
static_assert(sizeof(UDCDataComponent) == 0x0000D0, "Wrong size on UDCDataComponent");
static_assert(offsetof(UDCDataComponent, AssetId) == 0x0000B8, "Member 'UDCDataComponent::AssetId' has a wrong offset!");
static_assert(offsetof(UDCDataComponent, DataAsset) == 0x0000C8, "Member 'UDCDataComponent::DataAsset' has a wrong offset!");

// Class DungeonCrawler.DCEmoteDataAsset
// 0x0080 (0x00C8 - 0x0048)
class UDCEmoteDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCEmoteDataAsset;                             // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EmoteTag;                                          // 0x0078(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataEmote>           ArtData;                                           // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEmoteDataAsset">();
	}
	static class UDCEmoteDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEmoteDataAsset>();
	}
};
static_assert(alignof(UDCEmoteDataAsset) == 0x000008, "Wrong alignment on UDCEmoteDataAsset");
static_assert(sizeof(UDCEmoteDataAsset) == 0x0000C8, "Wrong size on UDCEmoteDataAsset");
static_assert(offsetof(UDCEmoteDataAsset, Name_DCEmoteDataAsset) == 0x000048, "Member 'UDCEmoteDataAsset::Name_DCEmoteDataAsset' has a wrong offset!");
static_assert(offsetof(UDCEmoteDataAsset, FlavorText) == 0x000060, "Member 'UDCEmoteDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCEmoteDataAsset, EmoteTag) == 0x000078, "Member 'UDCEmoteDataAsset::EmoteTag' has a wrong offset!");
static_assert(offsetof(UDCEmoteDataAsset, ArtData) == 0x000080, "Member 'UDCEmoteDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCEmoteDataAsset, Abilities) == 0x0000A8, "Member 'UDCEmoteDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCEmoteDataAsset, Effects) == 0x0000B8, "Member 'UDCEmoteDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCCharacterDataComponent
// 0x0020 (0x00F0 - 0x00D0)
class UDCCharacterDataComponent final : public UDCDataComponent
{
public:
	uint8                                         Pad_241A[0x20];                                    // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterDataComponent">();
	}
	static class UDCCharacterDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterDataComponent>();
	}
};
static_assert(alignof(UDCCharacterDataComponent) == 0x000008, "Wrong alignment on UDCCharacterDataComponent");
static_assert(sizeof(UDCCharacterDataComponent) == 0x0000F0, "Wrong size on UDCCharacterDataComponent");

// Class DungeonCrawler.DCCharacterPartsComponent
// 0x0188 (0x0228 - 0x00A0)
class UDCCharacterPartsComponent final : public UDCActorComponent
{
public:
	TMap<EDCCharacterPart, class USkeletalMeshComponent*> BodyPartComponents;                                // 0x00A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<EDCCharacterPart, class USkeletalMeshComponent*> ArmorPartComponents;                               // 0x00F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDCCharacterPartsArtData*               CharacterPartsData;                                // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, struct FDCArmorPartInfo> ArmorPartInfoMap;                                  // 0x0148(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UDCArmorSkinDataAsset*>          ArmorSkins;                                        // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDCShapeShiftInfo                      ShapeShiftInfo;                                    // 0x01A8(0x0018)(Transient, NativeAccessSpecifierPrivate)
	bool                                          bUpdateHitBox;                                     // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241B[0x7];                                     // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDCHitBoxComponent*, struct FTransform> DefaultHitBoxMap;                                  // 0x01C8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UDCHitBoxComponent*>             DynamicHitBoxComps;                                // 0x0218(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterPartsComponent">();
	}
	static class UDCCharacterPartsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterPartsComponent>();
	}
};
static_assert(alignof(UDCCharacterPartsComponent) == 0x000008, "Wrong alignment on UDCCharacterPartsComponent");
static_assert(sizeof(UDCCharacterPartsComponent) == 0x000228, "Wrong size on UDCCharacterPartsComponent");
static_assert(offsetof(UDCCharacterPartsComponent, BodyPartComponents) == 0x0000A0, "Member 'UDCCharacterPartsComponent::BodyPartComponents' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, ArmorPartComponents) == 0x0000F0, "Member 'UDCCharacterPartsComponent::ArmorPartComponents' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, CharacterPartsData) == 0x000140, "Member 'UDCCharacterPartsComponent::CharacterPartsData' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, ArmorPartInfoMap) == 0x000148, "Member 'UDCCharacterPartsComponent::ArmorPartInfoMap' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, ArmorSkins) == 0x000198, "Member 'UDCCharacterPartsComponent::ArmorSkins' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, ShapeShiftInfo) == 0x0001A8, "Member 'UDCCharacterPartsComponent::ShapeShiftInfo' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, bUpdateHitBox) == 0x0001C0, "Member 'UDCCharacterPartsComponent::bUpdateHitBox' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, DefaultHitBoxMap) == 0x0001C8, "Member 'UDCCharacterPartsComponent::DefaultHitBoxMap' has a wrong offset!");
static_assert(offsetof(UDCCharacterPartsComponent, DynamicHitBoxComps) == 0x000218, "Member 'UDCCharacterPartsComponent::DynamicHitBoxComps' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetPerk
// 0x0098 (0x00E0 - 0x0048)
class UDesignDataAssetPerk final : public UDCDataAssetBase
{
public:
	struct FDesignDataPerk                        Item;                                              // 0x0048(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetPerk">();
	}
	static class UDesignDataAssetPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetPerk>();
	}
};
static_assert(alignof(UDesignDataAssetPerk) == 0x000008, "Wrong alignment on UDesignDataAssetPerk");
static_assert(sizeof(UDesignDataAssetPerk) == 0x0000E0, "Wrong size on UDesignDataAssetPerk");
static_assert(offsetof(UDesignDataAssetPerk, Item) == 0x000048, "Member 'UDesignDataAssetPerk::Item' has a wrong offset!");

// Class DungeonCrawler.DCGameModeAIControllerDungeonBase
// 0x0000 (0x0438 - 0x0438)
class ADCGameModeAIControllerDungeonBase : public ADCGameModeAIControllerGameBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerDungeonBase">();
	}
	static class ADCGameModeAIControllerDungeonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerDungeonBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerDungeonBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerDungeonBase");
static_assert(sizeof(ADCGameModeAIControllerDungeonBase) == 0x000438, "Wrong size on ADCGameModeAIControllerDungeonBase");

// Class DungeonCrawler.DCGameModeAIControllerDungeonBattleRoyalBase
// 0x0000 (0x0438 - 0x0438)
class ADCGameModeAIControllerDungeonBattleRoyalBase final : public ADCGameModeAIControllerDungeonBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerDungeonBattleRoyalBase">();
	}
	static class ADCGameModeAIControllerDungeonBattleRoyalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerDungeonBattleRoyalBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerDungeonBattleRoyalBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerDungeonBattleRoyalBase");
static_assert(sizeof(ADCGameModeAIControllerDungeonBattleRoyalBase) == 0x000438, "Wrong size on ADCGameModeAIControllerDungeonBattleRoyalBase");

// Class DungeonCrawler.GA_PlayRandomMontageWaitForEvent
// 0x0010 (0x05B0 - 0x05A0)
class UGA_PlayRandomMontageWaitForEvent : public UDCGameplayAbilityBase
{
public:
	TArray<class UAnimMontage*>                   MontagesToPlay;                                    // 0x05A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void EventReceivedBlueprint(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayRandomMontageWaitForEvent">();
	}
	static class UGA_PlayRandomMontageWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayRandomMontageWaitForEvent>();
	}
};
static_assert(alignof(UGA_PlayRandomMontageWaitForEvent) == 0x000008, "Wrong alignment on UGA_PlayRandomMontageWaitForEvent");
static_assert(sizeof(UGA_PlayRandomMontageWaitForEvent) == 0x0005B0, "Wrong size on UGA_PlayRandomMontageWaitForEvent");
static_assert(offsetof(UGA_PlayRandomMontageWaitForEvent, MontagesToPlay) == 0x0005A0, "Member 'UGA_PlayRandomMontageWaitForEvent::MontagesToPlay' has a wrong offset!");

// Class DungeonCrawler.CharacterSelectCharacterListWidgetData
// 0x0010 (0x0038 - 0x0028)
class UCharacterSelectCharacterListWidgetData final : public UObject
{
public:
	struct FCharacterSlotData                     CharacterSlotData;                                 // 0x0028(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectCharacterListWidgetData">();
	}
	static class UCharacterSelectCharacterListWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectCharacterListWidgetData>();
	}
};
static_assert(alignof(UCharacterSelectCharacterListWidgetData) == 0x000008, "Wrong alignment on UCharacterSelectCharacterListWidgetData");
static_assert(sizeof(UCharacterSelectCharacterListWidgetData) == 0x000038, "Wrong size on UCharacterSelectCharacterListWidgetData");
static_assert(offsetof(UCharacterSelectCharacterListWidgetData, CharacterSlotData) == 0x000028, "Member 'UCharacterSelectCharacterListWidgetData::CharacterSlotData' has a wrong offset!");

// Class DungeonCrawler.CharacterSelectCharListWidget
// 0x0030 (0x0388 - 0x0358)
class UCharacterSelectCharListWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_241C[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UListView*                              CharacterSlotListView;                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentPageIndex;                                  // 0x0368(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxCharacterCount;                                 // 0x036C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPageIndex;                                      // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241D[0x14];                                    // 0x0374(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESlateVisibility GetPageArrowVisibility();
	class UCharacterSelectCharacterSlotWidgetData* GetSelectedCharacterWidgetData();
	void HandleCharacterCreateClicked();
	void HandleCharacterDeleteClicked();
	void OnCharacterSlotData(const struct FCharacterSlotData& NewValue, const struct FCharacterSlotData& OldValue);
	void OnCharacterSlotListViewItemClicked(class UObject* Obj);
	void OnListLeftButtonClicked();
	void OnListRightButtonClicked();
	void OnPageNumber(const int32 CurrentPage, const int32 MaxPage);
	void OnSelectedCharacterId(const class FString& CharacterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectCharListWidget">();
	}
	static class UCharacterSelectCharListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectCharListWidget>();
	}
};
static_assert(alignof(UCharacterSelectCharListWidget) == 0x000008, "Wrong alignment on UCharacterSelectCharListWidget");
static_assert(sizeof(UCharacterSelectCharListWidget) == 0x000388, "Wrong size on UCharacterSelectCharListWidget");
static_assert(offsetof(UCharacterSelectCharListWidget, CharacterSlotListView) == 0x000360, "Member 'UCharacterSelectCharListWidget::CharacterSlotListView' has a wrong offset!");
static_assert(offsetof(UCharacterSelectCharListWidget, CurrentPageIndex) == 0x000368, "Member 'UCharacterSelectCharListWidget::CurrentPageIndex' has a wrong offset!");
static_assert(offsetof(UCharacterSelectCharListWidget, MaxCharacterCount) == 0x00036C, "Member 'UCharacterSelectCharListWidget::MaxCharacterCount' has a wrong offset!");
static_assert(offsetof(UCharacterSelectCharListWidget, MaxPageIndex) == 0x000370, "Member 'UCharacterSelectCharListWidget::MaxPageIndex' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetSpawner
// 0x0010 (0x0058 - 0x0048)
class UDesignDataAssetSpawner final : public UDCDataAssetBase
{
public:
	struct FDesignDataSpawner                     Item;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetSpawner">();
	}
	static class UDesignDataAssetSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetSpawner>();
	}
};
static_assert(alignof(UDesignDataAssetSpawner) == 0x000008, "Wrong alignment on UDesignDataAssetSpawner");
static_assert(sizeof(UDesignDataAssetSpawner) == 0x000058, "Wrong size on UDesignDataAssetSpawner");
static_assert(offsetof(UDesignDataAssetSpawner, Item) == 0x000048, "Member 'UDesignDataAssetSpawner::Item' has a wrong offset!");

// Class DungeonCrawler.CharacterSelectCharacterSlotWidgetData
// 0x00C8 (0x00F0 - 0x0028)
class UCharacterSelectCharacterSlotWidgetData final : public UObject
{
public:
	struct FCharacterSlot                         CharacterSlot;                                     // 0x0028(0x00C0)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCanSelect;                                        // 0x00E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241E[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectCharacterSlotWidgetData">();
	}
	static class UCharacterSelectCharacterSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectCharacterSlotWidgetData>();
	}
};
static_assert(alignof(UCharacterSelectCharacterSlotWidgetData) == 0x000008, "Wrong alignment on UCharacterSelectCharacterSlotWidgetData");
static_assert(sizeof(UCharacterSelectCharacterSlotWidgetData) == 0x0000F0, "Wrong size on UCharacterSelectCharacterSlotWidgetData");
static_assert(offsetof(UCharacterSelectCharacterSlotWidgetData, CharacterSlot) == 0x000028, "Member 'UCharacterSelectCharacterSlotWidgetData::CharacterSlot' has a wrong offset!");
static_assert(offsetof(UCharacterSelectCharacterSlotWidgetData, bCanSelect) == 0x0000E8, "Member 'UCharacterSelectCharacterSlotWidgetData::bCanSelect' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementCommonWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCQuestRequirementCommonWidgetData final : public UObject
{
public:
	uint8                                         Pad_241F[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementCommonWidgetData">();
	}
	static class UDCQuestRequirementCommonWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementCommonWidgetData>();
	}
};
static_assert(alignof(UDCQuestRequirementCommonWidgetData) == 0x000008, "Wrong alignment on UDCQuestRequirementCommonWidgetData");
static_assert(sizeof(UDCQuestRequirementCommonWidgetData) == 0x000038, "Wrong size on UDCQuestRequirementCommonWidgetData");

// Class DungeonCrawler.InjectionItemListEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UInjectionItemListEntryWidgetData final : public UObject
{
public:
	class UDCItemDataAsset*                       ItemData;                                          // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2420[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemListEntryWidgetData">();
	}
	static class UInjectionItemListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemListEntryWidgetData>();
	}
};
static_assert(alignof(UInjectionItemListEntryWidgetData) == 0x000008, "Wrong alignment on UInjectionItemListEntryWidgetData");
static_assert(sizeof(UInjectionItemListEntryWidgetData) == 0x000038, "Wrong size on UInjectionItemListEntryWidgetData");
static_assert(offsetof(UInjectionItemListEntryWidgetData, ItemData) == 0x000028, "Member 'UInjectionItemListEntryWidgetData::ItemData' has a wrong offset!");
static_assert(offsetof(UInjectionItemListEntryWidgetData, bIsSelected) == 0x000030, "Member 'UInjectionItemListEntryWidgetData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinDataAsset
// 0x00B0 (0x00F8 - 0x0048)
class UDCActionSkinDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCActionSkinDataAsset;                        // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EDCActionSkinType                             ActionSkinType;                                    // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2421[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCActionSkinArtData>    Art;                                               // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCGameplayAbilityDataAsset> TargetAction;                                      // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCGameplayAbilityDataAsset> SkinAction;                                        // 0x00D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinDataAsset">();
	}
	static class UDCActionSkinDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinDataAsset>();
	}
};
static_assert(alignof(UDCActionSkinDataAsset) == 0x000008, "Wrong alignment on UDCActionSkinDataAsset");
static_assert(sizeof(UDCActionSkinDataAsset) == 0x0000F8, "Wrong size on UDCActionSkinDataAsset");
static_assert(offsetof(UDCActionSkinDataAsset, Name_DCActionSkinDataAsset) == 0x000048, "Member 'UDCActionSkinDataAsset::Name_DCActionSkinDataAsset' has a wrong offset!");
static_assert(offsetof(UDCActionSkinDataAsset, FlavorText) == 0x000060, "Member 'UDCActionSkinDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCActionSkinDataAsset, ActionSkinType) == 0x000078, "Member 'UDCActionSkinDataAsset::ActionSkinType' has a wrong offset!");
static_assert(offsetof(UDCActionSkinDataAsset, Art) == 0x000080, "Member 'UDCActionSkinDataAsset::Art' has a wrong offset!");
static_assert(offsetof(UDCActionSkinDataAsset, TargetAction) == 0x0000A8, "Member 'UDCActionSkinDataAsset::TargetAction' has a wrong offset!");
static_assert(offsetof(UDCActionSkinDataAsset, SkinAction) == 0x0000D0, "Member 'UDCActionSkinDataAsset::SkinAction' has a wrong offset!");

// Class DungeonCrawler.CharacterSelectCharSlotWidget
// 0x00C8 (0x0420 - 0x0358)
class UCharacterSelectCharSlotWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2422[0xC8];                                    // 0x0358(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSelect();
	void OnCharacterSlot(const struct FCharacterSlot& NewValue, const struct FCharacterSlot& OldValue);
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);

	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectCharSlotWidget">();
	}
	static class UCharacterSelectCharSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectCharSlotWidget>();
	}
};
static_assert(alignof(UCharacterSelectCharSlotWidget) == 0x000008, "Wrong alignment on UCharacterSelectCharSlotWidget");
static_assert(sizeof(UCharacterSelectCharSlotWidget) == 0x000420, "Wrong size on UCharacterSelectCharSlotWidget");

// Class DungeonCrawler.CharacterSelectGroupWidgetBase
// 0x0020 (0x0378 - 0x0358)
class UCharacterSelectGroupWidgetBase : public UDCWidgetBase
{
public:
	EWidgetCharacterSelectGroupType               WidgetCharacterSelectGroupType;                    // 0x0358(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2423[0x7];                                     // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWidgetCharacterSelectGroupType>       NonCoexistWidgetCharacterSelectGroupTypeArray;     // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2424[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectGroupWidgetBase">();
	}
	static class UCharacterSelectGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectGroupWidgetBase>();
	}
};
static_assert(alignof(UCharacterSelectGroupWidgetBase) == 0x000008, "Wrong alignment on UCharacterSelectGroupWidgetBase");
static_assert(sizeof(UCharacterSelectGroupWidgetBase) == 0x000378, "Wrong size on UCharacterSelectGroupWidgetBase");
static_assert(offsetof(UCharacterSelectGroupWidgetBase, WidgetCharacterSelectGroupType) == 0x000358, "Member 'UCharacterSelectGroupWidgetBase::WidgetCharacterSelectGroupType' has a wrong offset!");
static_assert(offsetof(UCharacterSelectGroupWidgetBase, NonCoexistWidgetCharacterSelectGroupTypeArray) == 0x000360, "Member 'UCharacterSelectGroupWidgetBase::NonCoexistWidgetCharacterSelectGroupTypeArray' has a wrong offset!");

// Class DungeonCrawler.DCRecentMatchCharacterSlotWidget
// 0x0020 (0x0410 - 0x03F0)
class UDCRecentMatchCharacterSlotWidget final : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_2425[0x8];                                     // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    RequestFriendButton;                               // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    InvitePartyButton;                                 // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    CloseButton;                                       // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCloseClicked();
	void OnInvitePartyClicked();
	void OnRequestFriendClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRecentMatchCharacterSlotWidget">();
	}
	static class UDCRecentMatchCharacterSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRecentMatchCharacterSlotWidget>();
	}
};
static_assert(alignof(UDCRecentMatchCharacterSlotWidget) == 0x000008, "Wrong alignment on UDCRecentMatchCharacterSlotWidget");
static_assert(sizeof(UDCRecentMatchCharacterSlotWidget) == 0x000410, "Wrong size on UDCRecentMatchCharacterSlotWidget");
static_assert(offsetof(UDCRecentMatchCharacterSlotWidget, RequestFriendButton) == 0x0003F8, "Member 'UDCRecentMatchCharacterSlotWidget::RequestFriendButton' has a wrong offset!");
static_assert(offsetof(UDCRecentMatchCharacterSlotWidget, InvitePartyButton) == 0x000400, "Member 'UDCRecentMatchCharacterSlotWidget::InvitePartyButton' has a wrong offset!");
static_assert(offsetof(UDCRecentMatchCharacterSlotWidget, CloseButton) == 0x000408, "Member 'UDCRecentMatchCharacterSlotWidget::CloseButton' has a wrong offset!");

// Class DungeonCrawler.DCAttackerWidget
// 0x0060 (0x0320 - 0x02C0)
class UDCAttackerWidget final : public UUserWidget
{
public:
	struct FNickname                              Nickname;                                          // 0x02C0(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ClassName;                                         // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalDamage;                                       // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKiller;                                           // 0x031C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2426[0x3];                                     // 0x031D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttackerWidget">();
	}
	static class UDCAttackerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttackerWidget>();
	}
};
static_assert(alignof(UDCAttackerWidget) == 0x000008, "Wrong alignment on UDCAttackerWidget");
static_assert(sizeof(UDCAttackerWidget) == 0x000320, "Wrong size on UDCAttackerWidget");
static_assert(offsetof(UDCAttackerWidget, Nickname) == 0x0002C0, "Member 'UDCAttackerWidget::Nickname' has a wrong offset!");
static_assert(offsetof(UDCAttackerWidget, ClassName) == 0x000300, "Member 'UDCAttackerWidget::ClassName' has a wrong offset!");
static_assert(offsetof(UDCAttackerWidget, TotalDamage) == 0x000318, "Member 'UDCAttackerWidget::TotalDamage' has a wrong offset!");
static_assert(offsetof(UDCAttackerWidget, bKiller) == 0x00031C, "Member 'UDCAttackerWidget::bKiller' has a wrong offset!");

// Class DungeonCrawler.CharacterSelectWidget
// 0x0068 (0x04F0 - 0x0488)
class UCharacterSelectWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UCharacterSelectCharListWidget*         CharacterSelectCharListWidget;                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AccountBluestoneShardValue;                        // 0x0490(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AccountRedstoneShardValue;                         // 0x0494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    WB_Btn_Purchase;                                   // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    WB_Btn_LaunchShopURL;                              // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCCommonActivatableWidgetBase> LinkCrossPlatformPopupClass;                       // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCCharacterClass                             SelectedCharacterClass;                            // 0x04B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2427[0x7];                                     // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCClassPackageShopItemInfo            SelectedShopInfo;                                  // 0x04B8(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2428[0x8];                                     // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanEnterLobby();
	bool CanLaunchRedstoneShardShop();
	int32 GetCashPrice();
	int32 GetPrice();
	void HandleExitButtonClicked();
	void HandleLobbyButtonClicked();
	void HandleOptionButtonClicked();
	bool IsNeedPurchase();
	void OnLaunchShopURLButtonClicked();
	void OnPurchaseButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelectWidget">();
	}
	static class UCharacterSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSelectWidget>();
	}
};
static_assert(alignof(UCharacterSelectWidget) == 0x000008, "Wrong alignment on UCharacterSelectWidget");
static_assert(sizeof(UCharacterSelectWidget) == 0x0004F0, "Wrong size on UCharacterSelectWidget");
static_assert(offsetof(UCharacterSelectWidget, CharacterSelectCharListWidget) == 0x000488, "Member 'UCharacterSelectWidget::CharacterSelectCharListWidget' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, AccountBluestoneShardValue) == 0x000490, "Member 'UCharacterSelectWidget::AccountBluestoneShardValue' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, AccountRedstoneShardValue) == 0x000494, "Member 'UCharacterSelectWidget::AccountRedstoneShardValue' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, WB_Btn_Purchase) == 0x000498, "Member 'UCharacterSelectWidget::WB_Btn_Purchase' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, WB_Btn_LaunchShopURL) == 0x0004A0, "Member 'UCharacterSelectWidget::WB_Btn_LaunchShopURL' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, LinkCrossPlatformPopupClass) == 0x0004A8, "Member 'UCharacterSelectWidget::LinkCrossPlatformPopupClass' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, SelectedCharacterClass) == 0x0004B0, "Member 'UCharacterSelectWidget::SelectedCharacterClass' has a wrong offset!");
static_assert(offsetof(UCharacterSelectWidget, SelectedShopInfo) == 0x0004B8, "Member 'UCharacterSelectWidget::SelectedShopInfo' has a wrong offset!");

// Class DungeonCrawler.DCCharacterAbilityBase
// 0x0000 (0x05A0 - 0x05A0)
class UDCCharacterAbilityBase : public UDCGameplayAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterAbilityBase">();
	}
	static class UDCCharacterAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterAbilityBase>();
	}
};
static_assert(alignof(UDCCharacterAbilityBase) == 0x000008, "Wrong alignment on UDCCharacterAbilityBase");
static_assert(sizeof(UDCCharacterAbilityBase) == 0x0005A0, "Wrong size on UDCCharacterAbilityBase");

// Class DungeonCrawler.DCInventoryAbilityBase
// 0x01B0 (0x0750 - 0x05A0)
class UDCInventoryAbilityBase : public UDCCharacterAbilityBase
{
public:
	class ADCPlayerCharacterBase*                 OwnerCharacter;                                    // 0x05A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentComponent*                  EquipmentComponent;                                // 0x05B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCIngameInventoryControllerComponent*  InventoryControllerComponent;                      // 0x05B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCInventoryEventData                  InventoryEventData;                                // 0x05C0(0x0188)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           InventoryEventDataSyncTimerHandle;                 // 0x0748(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryAbilityBase">();
	}
	static class UDCInventoryAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryAbilityBase>();
	}
};
static_assert(alignof(UDCInventoryAbilityBase) == 0x000008, "Wrong alignment on UDCInventoryAbilityBase");
static_assert(sizeof(UDCInventoryAbilityBase) == 0x000750, "Wrong size on UDCInventoryAbilityBase");
static_assert(offsetof(UDCInventoryAbilityBase, OwnerCharacter) == 0x0005A0, "Member 'UDCInventoryAbilityBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UDCInventoryAbilityBase, InventoryComponent) == 0x0005A8, "Member 'UDCInventoryAbilityBase::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UDCInventoryAbilityBase, EquipmentComponent) == 0x0005B0, "Member 'UDCInventoryAbilityBase::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(UDCInventoryAbilityBase, InventoryControllerComponent) == 0x0005B8, "Member 'UDCInventoryAbilityBase::InventoryControllerComponent' has a wrong offset!");
static_assert(offsetof(UDCInventoryAbilityBase, InventoryEventData) == 0x0005C0, "Member 'UDCInventoryAbilityBase::InventoryEventData' has a wrong offset!");
static_assert(offsetof(UDCInventoryAbilityBase, InventoryEventDataSyncTimerHandle) == 0x000748, "Member 'UDCInventoryAbilityBase::InventoryEventDataSyncTimerHandle' has a wrong offset!");

// Class DungeonCrawler.CharacterStatusDetailWidget
// 0x0CA0 (0x0FF8 - 0x0358)
class UCharacterStatusDetailWidget final : public UDCWidgetBase
{
public:
	struct FCharacterStatusDetailWidgetData       WidgetData;                                        // 0x0358(0x0878)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2429[0x370];                                   // 0x0BD0(0x0370)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveTable*                            CurveTablePhysicalPower;                           // 0x0F40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            CurveTableArmorRating;                             // 0x0F48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            CurveTableMagicalPower;                            // 0x0F50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            CurveTableMagicResistance;                         // 0x0F58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_242A[0x18];                                    // 0x0F60(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0F78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCEquipmentComponent*                  EquipmentComponent;                                // 0x0F80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0F88(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayAttribute>             TargetAttributes;                                  // 0x0F90(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_242B[0x58];                                    // 0x0FA0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnAgility(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnAirMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnAirMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnAirMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnAirMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnArcaneMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnArcaneMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnArcaneMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnArcaneMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnArmorPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnArmorRating(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnBuffDurationMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnCooldownReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDarkMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDarkMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDarkMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDarkMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDebuffDurationMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDemonReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDexterity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDivineMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDivineMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDivineMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDivineMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEarthMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEarthMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEarthMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEarthMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEvilMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEvilMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEvilMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnEvilMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnFireMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnFireMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnFireMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnFireMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnHeadshotReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnHealthRecoveryMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnIceMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnIceMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnIceMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnIceMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnImpactPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnItemEquipSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnKnowledge(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightningMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightningMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightningMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLightningMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnLuck(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalDamageAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalDamageBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalDamageModBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalDamageModMagicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalDamageTrue(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalHealBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalHealingReceiveMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalHealMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalInteractionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalReductionBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnManualDexterity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealthAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealthBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealthMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxSpellCountMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacityAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacityBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacityMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryMusicPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryRecoveryMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemorySpellPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMoveSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMoveSpeedAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMoveSpeedBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMoveSpeedMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMoveSpeedWithModifier(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnOverhealedHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPersuasiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageModBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageModPhysicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageTrue(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageWeaponPrimary(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalDamageWeaponSecondary(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalHeadshotPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalHealBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalHealingReceiveMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalHealMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalReductionArmorRating(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalReductionBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPhysicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnPrimaryAbilityWidgetArray(const TArray<class UItemTooltipStatWidgetData*>& NewValue, const TArray<class UItemTooltipStatWidgetData*>& OldValue);
	void OnPrimaryWeaponImpactPower(const float& NewValue, const float& OldValue);
	void OnProjectileReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnRegularInteractionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnRegularInteractionSpeedBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnResourcefulness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnSecondaryAbilityWidgetArray(const TArray<class UItemTooltipStatWidgetData*>& NewValue, const TArray<class UItemTooltipStatWidgetData*>& OldValue);
	void OnSecondaryWeaponImpactPower(const float& NewValue, const float& OldValue);
	void OnSpellCastingSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnSpiritMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnSpiritMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnSpiritMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnSpiritMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnStrength(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUndeadDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUndeadReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectivenessAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectivenessBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectivenessMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnVigor(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeight(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimit(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimitAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimitBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimitMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWill(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void SetupLobbyCharacter(const class ADCCharacterV2* InCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatusDetailWidget">();
	}
	static class UCharacterStatusDetailWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatusDetailWidget>();
	}
};
static_assert(alignof(UCharacterStatusDetailWidget) == 0x000008, "Wrong alignment on UCharacterStatusDetailWidget");
static_assert(sizeof(UCharacterStatusDetailWidget) == 0x000FF8, "Wrong size on UCharacterStatusDetailWidget");
static_assert(offsetof(UCharacterStatusDetailWidget, WidgetData) == 0x000358, "Member 'UCharacterStatusDetailWidget::WidgetData' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, CurveTablePhysicalPower) == 0x000F40, "Member 'UCharacterStatusDetailWidget::CurveTablePhysicalPower' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, CurveTableArmorRating) == 0x000F48, "Member 'UCharacterStatusDetailWidget::CurveTableArmorRating' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, CurveTableMagicalPower) == 0x000F50, "Member 'UCharacterStatusDetailWidget::CurveTableMagicalPower' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, CurveTableMagicResistance) == 0x000F58, "Member 'UCharacterStatusDetailWidget::CurveTableMagicResistance' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, AbilitySystemComponent) == 0x000F78, "Member 'UCharacterStatusDetailWidget::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, EquipmentComponent) == 0x000F80, "Member 'UCharacterStatusDetailWidget::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, AttributeSet) == 0x000F88, "Member 'UCharacterStatusDetailWidget::AttributeSet' has a wrong offset!");
static_assert(offsetof(UCharacterStatusDetailWidget, TargetAttributes) == 0x000F90, "Member 'UCharacterStatusDetailWidget::TargetAttributes' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_SendGameplayEventTagToSelf
// 0x0008 (0x0040 - 0x0038)
class UDCAnimNotify_SendGameplayEventTagToSelf final : public UAnimNotify
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_SendGameplayEventTagToSelf">();
	}
	static class UDCAnimNotify_SendGameplayEventTagToSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_SendGameplayEventTagToSelf>();
	}
};
static_assert(alignof(UDCAnimNotify_SendGameplayEventTagToSelf) == 0x000008, "Wrong alignment on UDCAnimNotify_SendGameplayEventTagToSelf");
static_assert(sizeof(UDCAnimNotify_SendGameplayEventTagToSelf) == 0x000040, "Wrong size on UDCAnimNotify_SendGameplayEventTagToSelf");
static_assert(offsetof(UDCAnimNotify_SendGameplayEventTagToSelf, EventTag) == 0x000038, "Member 'UDCAnimNotify_SendGameplayEventTagToSelf::EventTag' has a wrong offset!");

// Class DungeonCrawler.GA_StoppablePassiveBase
// 0x0028 (0x05C8 - 0x05A0)
class UGA_StoppablePassiveBase : public UDCGameplayAbilityBase
{
public:
	struct FGameplayTagContainer                  PassiveStopStateTagContainer;                      // 0x05A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_242C[0x8];                                     // 0x05C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllStopStateTagsRemoved();
	void OnAnyStopStateTagAdded();
	void OnPassiveStart();
	void OnPassiveStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_StoppablePassiveBase">();
	}
	static class UGA_StoppablePassiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_StoppablePassiveBase>();
	}
};
static_assert(alignof(UGA_StoppablePassiveBase) == 0x000008, "Wrong alignment on UGA_StoppablePassiveBase");
static_assert(sizeof(UGA_StoppablePassiveBase) == 0x0005C8, "Wrong size on UGA_StoppablePassiveBase");
static_assert(offsetof(UGA_StoppablePassiveBase, PassiveStopStateTagContainer) == 0x0005A0, "Member 'UGA_StoppablePassiveBase::PassiveStopStateTagContainer' has a wrong offset!");

// Class DungeonCrawler.GA_InteractPassive
// 0x0090 (0x0658 - 0x05C8)
class UGA_InteractPassive : public UGA_StoppablePassiveBase
{
public:
	uint8                                         Pad_242D[0x8];                                     // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCGATA_LineTraceInteractable*          TargetActor;                                       // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAT_WaitInteractableTarget*           WaitInteractableTargetTask;                        // 0x05D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityTargetDataHandle       CurrentTargetData;                                 // 0x05E0(0x0028)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FInteractionData> CurrentInteractableDatas;                          // 0x0608(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnFoundNewInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnLostInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnTargetGameplayTagChange(const struct FGameplayTag& InGameplayTag, int32 InCount);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void RefreshInteractionData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_InteractPassive">();
	}
	static class UGA_InteractPassive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_InteractPassive>();
	}
};
static_assert(alignof(UGA_InteractPassive) == 0x000008, "Wrong alignment on UGA_InteractPassive");
static_assert(sizeof(UGA_InteractPassive) == 0x000658, "Wrong size on UGA_InteractPassive");
static_assert(offsetof(UGA_InteractPassive, TargetActor) == 0x0005D0, "Member 'UGA_InteractPassive::TargetActor' has a wrong offset!");
static_assert(offsetof(UGA_InteractPassive, WaitInteractableTargetTask) == 0x0005D8, "Member 'UGA_InteractPassive::WaitInteractableTargetTask' has a wrong offset!");
static_assert(offsetof(UGA_InteractPassive, CurrentTargetData) == 0x0005E0, "Member 'UGA_InteractPassive::CurrentTargetData' has a wrong offset!");
static_assert(offsetof(UGA_InteractPassive, CurrentInteractableDatas) == 0x000608, "Member 'UGA_InteractPassive::CurrentInteractableDatas' has a wrong offset!");

// Class DungeonCrawler.CharacterStatusWidget
// 0x0230 (0x0588 - 0x0358)
class UCharacterStatusWidget final : public UDCWidgetBase
{
public:
	struct FCharacterStatusWidgetData             WidgetData;                                        // 0x0358(0x01C0)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0518(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAttribute>             TargetAttributes;                                  // 0x0528(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_242E[0x50];                                    // 0x0538(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAgility(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnDexterity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnKnowledge(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealthAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealthBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMaxHealthMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacityAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacityBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryCapacityMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemoryMusicPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnMemorySpellPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnOverhealedHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnResourcefulness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnStrength(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectivenessAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectivenessBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnUtilityEffectivenessMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnVigor(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeight(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimit(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimitAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimitBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWeightLimitMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);
	void OnWill(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatusWidget">();
	}
	static class UCharacterStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatusWidget>();
	}
};
static_assert(alignof(UCharacterStatusWidget) == 0x000008, "Wrong alignment on UCharacterStatusWidget");
static_assert(sizeof(UCharacterStatusWidget) == 0x000588, "Wrong size on UCharacterStatusWidget");
static_assert(offsetof(UCharacterStatusWidget, WidgetData) == 0x000358, "Member 'UCharacterStatusWidget::WidgetData' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, AbilitySystemComponent) == 0x000518, "Member 'UCharacterStatusWidget::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, AttributeSet) == 0x000520, "Member 'UCharacterStatusWidget::AttributeSet' has a wrong offset!");
static_assert(offsetof(UCharacterStatusWidget, TargetAttributes) == 0x000528, "Member 'UCharacterStatusWidget::TargetAttributes' has a wrong offset!");

// Class DungeonCrawler.DungeonSelectWidget
// 0x0038 (0x04C0 - 0x0488)
class UDungeonSelectWidget final : public UDCCommonActivatableWidgetBase
{
public:
	struct FDungeonSelectWidgetHandleData         WidgetHandleData;                                  // 0x0488(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_242F[0x24];                                    // 0x049C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastLegendaryStatusContentsSelected();
	void CancelSelected();
	void OnDungeonRotationTimerData(const struct FDungeonRotationTimerData& NewValue, const struct FDungeonRotationTimerData& OldValue);
	void OnGameType(EGameType NewValue, EGameType OldValue);
	void OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce);
	void OnMatchMode(EMatchMode NewValue, EMatchMode OldValue);
	void OnSetFeatureLockExpiredTime(const bool InIsLocked, const struct FTimespan& InRemainTime);
	void SetGameType(EMatchMode InMatchMode, EGameType InGameType);

	int32 GetArenaAssistStat() const;
	struct FDateTime GetArenaBeginTime() const;
	int32 GetArenaDeathStat() const;
	int32 GetArenaDrawStat() const;
	struct FDateTime GetArenaEndTime() const;
	int32 GetArenaKillStat() const;
	int32 GetArenaLoseStat() const;
	int32 GetArenaWinStat() const;
	bool IsDungeonRestricted(EGameType InGameType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSelectWidget">();
	}
	static class UDungeonSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSelectWidget>();
	}
};
static_assert(alignof(UDungeonSelectWidget) == 0x000008, "Wrong alignment on UDungeonSelectWidget");
static_assert(sizeof(UDungeonSelectWidget) == 0x0004C0, "Wrong size on UDungeonSelectWidget");
static_assert(offsetof(UDungeonSelectWidget, WidgetHandleData) == 0x000488, "Member 'UDungeonSelectWidget::WidgetHandleData' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeLobbyEmoteRadialWidget
// 0x00C0 (0x0418 - 0x0358)
class UDCCustomizeLobbyEmoteRadialWidget final : public UDCWidgetBase
{
public:
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_1;                      // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_2;                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_3;                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_4;                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_5;                      // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_6;                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_7;                      // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           LobbyEmoteRadialSlotWidget_8;                      // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2432[0x80];                                    // 0x0398(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeLobbyEmoteRadialWidget">();
	}
	static class UDCCustomizeLobbyEmoteRadialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeLobbyEmoteRadialWidget>();
	}
};
static_assert(alignof(UDCCustomizeLobbyEmoteRadialWidget) == 0x000008, "Wrong alignment on UDCCustomizeLobbyEmoteRadialWidget");
static_assert(sizeof(UDCCustomizeLobbyEmoteRadialWidget) == 0x000418, "Wrong size on UDCCustomizeLobbyEmoteRadialWidget");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_1) == 0x000358, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_1' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_2) == 0x000360, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_2' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_3) == 0x000368, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_3' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_4) == 0x000370, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_4' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_5) == 0x000378, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_5' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_6) == 0x000380, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_6' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_7) == 0x000388, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_7' has a wrong offset!");
static_assert(offsetof(UDCCustomizeLobbyEmoteRadialWidget, LobbyEmoteRadialSlotWidget_8) == 0x000390, "Member 'UDCCustomizeLobbyEmoteRadialWidget::LobbyEmoteRadialSlotWidget_8' has a wrong offset!");

// Class DungeonCrawler.GA_InteractRope
// 0x0040 (0x05E0 - 0x05A0)
class UGA_InteractRope : public UDCGameplayAbilityBase
{
public:
	uint8                                         Pad_2433[0x8];                                     // 0x05A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    RopeActiveGameplayEffectHandles;                   // 0x05A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlay;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InputConfigTags;                                   // 0x05C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void AbilityCancel();
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void HitKnockBackAttack();
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_InteractRope">();
	}
	static class UGA_InteractRope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_InteractRope>();
	}
};
static_assert(alignof(UGA_InteractRope) == 0x000008, "Wrong alignment on UGA_InteractRope");
static_assert(sizeof(UGA_InteractRope) == 0x0005E0, "Wrong size on UGA_InteractRope");
static_assert(offsetof(UGA_InteractRope, RopeActiveGameplayEffectHandles) == 0x0005A8, "Member 'UGA_InteractRope::RopeActiveGameplayEffectHandles' has a wrong offset!");
static_assert(offsetof(UGA_InteractRope, MontageToPlay) == 0x0005B8, "Member 'UGA_InteractRope::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_InteractRope, InputConfigTags) == 0x0005C0, "Member 'UGA_InteractRope::InputConfigTags' has a wrong offset!");

// Class DungeonCrawler.ChatEditWidgetBase
// 0x0078 (0x03D0 - 0x0358)
class UChatEditWidgetBase final : public UDCWidgetBase
{
public:
	class URichTextBlock*                         RichTextBlock;                                     // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEditableText*                        EditableText;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2434[0x68];                                    // 0x0368(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEditableTextHasFocus();
	void OnTextChanged(const class FText& InText);
	void OnTextCommitted(const class FText& InText, ETextCommit InCommitMethod);
	void SetUserFocusText(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatEditWidgetBase">();
	}
	static class UChatEditWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatEditWidgetBase>();
	}
};
static_assert(alignof(UChatEditWidgetBase) == 0x000008, "Wrong alignment on UChatEditWidgetBase");
static_assert(sizeof(UChatEditWidgetBase) == 0x0003D0, "Wrong size on UChatEditWidgetBase");
static_assert(offsetof(UChatEditWidgetBase, RichTextBlock) == 0x000358, "Member 'UChatEditWidgetBase::RichTextBlock' has a wrong offset!");
static_assert(offsetof(UChatEditWidgetBase, EditableText) == 0x000360, "Member 'UChatEditWidgetBase::EditableText' has a wrong offset!");

// Class DungeonCrawler.ChatFilterListEntryWidgetObject
// 0x0030 (0x0058 - 0x0028)
class UChatFilterListEntryWidgetObject final : public UObject
{
public:
	uint8                                         Pad_2436[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ChatFilterTag;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ChatFilterText;                                    // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bChecked;                                          // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2437[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatFilterListEntryWidgetObject">();
	}
	static class UChatFilterListEntryWidgetObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatFilterListEntryWidgetObject>();
	}
};
static_assert(alignof(UChatFilterListEntryWidgetObject) == 0x000008, "Wrong alignment on UChatFilterListEntryWidgetObject");
static_assert(sizeof(UChatFilterListEntryWidgetObject) == 0x000058, "Wrong size on UChatFilterListEntryWidgetObject");
static_assert(offsetof(UChatFilterListEntryWidgetObject, ChatFilterTag) == 0x000030, "Member 'UChatFilterListEntryWidgetObject::ChatFilterTag' has a wrong offset!");
static_assert(offsetof(UChatFilterListEntryWidgetObject, ChatFilterText) == 0x000038, "Member 'UChatFilterListEntryWidgetObject::ChatFilterText' has a wrong offset!");
static_assert(offsetof(UChatFilterListEntryWidgetObject, bChecked) == 0x000050, "Member 'UChatFilterListEntryWidgetObject::bChecked' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetEmote
// 0x0068 (0x00B0 - 0x0048)
class UDesignDataAssetEmote final : public UDCDataAssetBase
{
public:
	struct FDesignDataEmote                       Item;                                              // 0x0048(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetEmote">();
	}
	static class UDesignDataAssetEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetEmote>();
	}
};
static_assert(alignof(UDesignDataAssetEmote) == 0x000008, "Wrong alignment on UDesignDataAssetEmote");
static_assert(sizeof(UDesignDataAssetEmote) == 0x0000B0, "Wrong size on UDesignDataAssetEmote");
static_assert(offsetof(UDesignDataAssetEmote, Item) == 0x000048, "Member 'UDesignDataAssetEmote::Item' has a wrong offset!");

// Class DungeonCrawler.ChatFilterListEntryWidget
// 0x0030 (0x0388 - 0x0358)
class UChatFilterListEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2438[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckBox*                              FilterCheckBox;                                    // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2439[0x8];                                     // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ChatFilterText;                                    // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnCheckStateChanged(bool bIsChecked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatFilterListEntryWidget">();
	}
	static class UChatFilterListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatFilterListEntryWidget>();
	}
};
static_assert(alignof(UChatFilterListEntryWidget) == 0x000008, "Wrong alignment on UChatFilterListEntryWidget");
static_assert(sizeof(UChatFilterListEntryWidget) == 0x000388, "Wrong size on UChatFilterListEntryWidget");
static_assert(offsetof(UChatFilterListEntryWidget, FilterCheckBox) == 0x000360, "Member 'UChatFilterListEntryWidget::FilterCheckBox' has a wrong offset!");
static_assert(offsetof(UChatFilterListEntryWidget, ChatFilterText) == 0x000370, "Member 'UChatFilterListEntryWidget::ChatFilterText' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementTitleEntryWidget
// 0x0020 (0x0378 - 0x0358)
class UDCQuestRequirementTitleEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_243A[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCount;                                      // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxCount;                                          // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCompleted;                                      // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_243B[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         ContentTitleRichText;                              // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementTitleEntryWidget">();
	}
	static class UDCQuestRequirementTitleEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementTitleEntryWidget>();
	}
};
static_assert(alignof(UDCQuestRequirementTitleEntryWidget) == 0x000008, "Wrong alignment on UDCQuestRequirementTitleEntryWidget");
static_assert(sizeof(UDCQuestRequirementTitleEntryWidget) == 0x000378, "Wrong size on UDCQuestRequirementTitleEntryWidget");
static_assert(offsetof(UDCQuestRequirementTitleEntryWidget, CurrentCount) == 0x000360, "Member 'UDCQuestRequirementTitleEntryWidget::CurrentCount' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementTitleEntryWidget, MaxCount) == 0x000364, "Member 'UDCQuestRequirementTitleEntryWidget::MaxCount' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementTitleEntryWidget, bIsCompleted) == 0x000368, "Member 'UDCQuestRequirementTitleEntryWidget::bIsCompleted' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementTitleEntryWidget, ContentTitleRichText) == 0x000370, "Member 'UDCQuestRequirementTitleEntryWidget::ContentTitleRichText' has a wrong offset!");

// Class DungeonCrawler.InteractableTargetComponent
// 0x0120 (0x01C0 - 0x00A0)
class UInteractableTargetComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_243C[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FInteractionData> InteractableDataByStateMap;                        // 0x00F8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         Interacters;                                       // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    CurrentInteractPart;                               // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_243D[0x8];                                     // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionSucceedData>        InteractionSucceedDataArray;                       // 0x0168(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         RecordProgressDuration;                            // 0x0178(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_243E[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCAccountId                           KillerAccountId;                                   // 0x0180(0x0010)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_243F[0x30];                                    // 0x0190(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void CancelAllInteractions();
	bool CanInteract();
	void InteractFailed(class AActor* InteractingActor, const struct FGameplayTag& TriggerTag);
	void InteractSucceed(class AActor* InteractingActor, const struct FGameplayTag& TriggerTag, const struct FGameplayTag& StateTag, const struct FHitResult& HitResult);
	void RegisterInteracter(class AActor* InteractingActor);
	void SetInteractionData(const struct FDesignDataPropsInteract& InteractionData);
	void SetInteractionDataV2(const class UDCPropsInteractDataAsset* InteractionSettingData);
	bool ShouldCancelOthersWhenInteractSucceed(const struct FGameplayTag& StateTag);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void UnregisterInteracter(class AActor* InteractingActor);

	struct FInteractionData GetData(const struct FGameplayTag& StateTag) const;
	EDCInteractableType GetInteractability(class AActor* Interacter, struct FGameplayTag* OutInteractFailedTag) const;
	TMap<struct FGameplayTag, struct FInteractionData> GetInteractableDataByStateMap() const;
	struct FInteractTargetData GetInteractTargetData() const;
	int32 GetRemainingInteractCount() const;
	struct FGameplayTag GetStateTag(const struct FGameplayTag& TriggerTag) const;
	bool IsDetectable(class AActor* Interacter) const;
	bool ShouldConsumeHoldingItem(class AActor* Interacter, bool bIsInteractionSucceed) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableTargetComponent">();
	}
	static class UInteractableTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableTargetComponent>();
	}
};
static_assert(alignof(UInteractableTargetComponent) == 0x000008, "Wrong alignment on UInteractableTargetComponent");
static_assert(sizeof(UInteractableTargetComponent) == 0x0001C0, "Wrong size on UInteractableTargetComponent");
static_assert(offsetof(UInteractableTargetComponent, InteractableDataByStateMap) == 0x0000F8, "Member 'UInteractableTargetComponent::InteractableDataByStateMap' has a wrong offset!");
static_assert(offsetof(UInteractableTargetComponent, Interacters) == 0x000148, "Member 'UInteractableTargetComponent::Interacters' has a wrong offset!");
static_assert(offsetof(UInteractableTargetComponent, CurrentInteractPart) == 0x000158, "Member 'UInteractableTargetComponent::CurrentInteractPart' has a wrong offset!");
static_assert(offsetof(UInteractableTargetComponent, InteractionSucceedDataArray) == 0x000168, "Member 'UInteractableTargetComponent::InteractionSucceedDataArray' has a wrong offset!");
static_assert(offsetof(UInteractableTargetComponent, RecordProgressDuration) == 0x000178, "Member 'UInteractableTargetComponent::RecordProgressDuration' has a wrong offset!");
static_assert(offsetof(UInteractableTargetComponent, KillerAccountId) == 0x000180, "Member 'UInteractableTargetComponent::KillerAccountId' has a wrong offset!");

// Class DungeonCrawler.DCAkComponent
// 0x01E0 (0x0650 - 0x0470)
class UDCAkComponent final : public UAkComponent
{
public:
	uint8                                         Pad_2444[0x60];                                    // 0x0470(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FAkAudioVolumeInfo>       CurrentVolumeIdMap;                                // 0x04D0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint32                                        CurrentVolumeId;                                   // 0x0520(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2445[0x4];                                     // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UAkAudioEvent*> AkEvents;                                          // 0x0528(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FDCSoundDataContainer> AkSwitches;                                        // 0x0578(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FGameplayTagQuery> SoundPlayableCondition;                            // 0x05C8(0x0050)(NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        SoundDataId;                                       // 0x0618(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitedData;                                       // 0x0628(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2446[0x27];                                    // 0x0629(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void PostSoundEvent(const struct FGameplayTag& Tag);
	void SetSoundSwitch(const struct FGameplayTag& Tag, const EPhysicalSurface SurfaceType, const class FString& SwitchGroup, const class FString& SwitchState);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAkComponent">();
	}
	static class UDCAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAkComponent>();
	}
};
static_assert(alignof(UDCAkComponent) == 0x000010, "Wrong alignment on UDCAkComponent");
static_assert(sizeof(UDCAkComponent) == 0x000650, "Wrong size on UDCAkComponent");
static_assert(offsetof(UDCAkComponent, CurrentVolumeIdMap) == 0x0004D0, "Member 'UDCAkComponent::CurrentVolumeIdMap' has a wrong offset!");
static_assert(offsetof(UDCAkComponent, CurrentVolumeId) == 0x000520, "Member 'UDCAkComponent::CurrentVolumeId' has a wrong offset!");
static_assert(offsetof(UDCAkComponent, AkEvents) == 0x000528, "Member 'UDCAkComponent::AkEvents' has a wrong offset!");
static_assert(offsetof(UDCAkComponent, AkSwitches) == 0x000578, "Member 'UDCAkComponent::AkSwitches' has a wrong offset!");
static_assert(offsetof(UDCAkComponent, SoundPlayableCondition) == 0x0005C8, "Member 'UDCAkComponent::SoundPlayableCondition' has a wrong offset!");
static_assert(offsetof(UDCAkComponent, SoundDataId) == 0x000618, "Member 'UDCAkComponent::SoundDataId' has a wrong offset!");
static_assert(offsetof(UDCAkComponent, bInitedData) == 0x000628, "Member 'UDCAkComponent::bInitedData' has a wrong offset!");

// Class DungeonCrawler.ChatFilterWidget
// 0x0098 (0x03F0 - 0x0358)
class UChatFilterWidget final : public UDCWidgetBase
{
public:
	class UListView*                              ChatFilterListView;                                // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          EditableSearchText;                                // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2448[0x50];                                    // 0x0368(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UChatFilterListEntryWidgetObject*> ChatFilterListWidgetObjectArray;                   // 0x03B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2449[0x28];                                    // 0x03C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnAnyChatFilterTagSet(bool bInSet);
	void OnRemoveChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void RegenerateListItems(const class FText& FindFilter);
	void ResetChatFilter();
	void SetChatFilterListVisible(bool InbVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatFilterWidget">();
	}
	static class UChatFilterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatFilterWidget>();
	}
};
static_assert(alignof(UChatFilterWidget) == 0x000008, "Wrong alignment on UChatFilterWidget");
static_assert(sizeof(UChatFilterWidget) == 0x0003F0, "Wrong size on UChatFilterWidget");
static_assert(offsetof(UChatFilterWidget, ChatFilterListView) == 0x000358, "Member 'UChatFilterWidget::ChatFilterListView' has a wrong offset!");
static_assert(offsetof(UChatFilterWidget, EditableSearchText) == 0x000360, "Member 'UChatFilterWidget::EditableSearchText' has a wrong offset!");
static_assert(offsetof(UChatFilterWidget, ChatFilterListWidgetObjectArray) == 0x0003B8, "Member 'UChatFilterWidget::ChatFilterListWidgetObjectArray' has a wrong offset!");

// Class DungeonCrawler.ChatSetWidgetBase
// 0x01D8 (0x0530 - 0x0358)
class UChatSetWidgetBase : public UDCWidgetBase
{
public:
	class UListView*                              ChatListView;                                      // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatEditWidgetBase*                    ChatEditWidget;                                    // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAccountLink*                           AccountLink;                                       // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244A[0x68];                                    // 0x0370(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChannelChatWidgetData                 WidgetData;                                        // 0x03D8(0x0068)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_244B[0xD8];                                    // 0x0440(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFocus;                                          // 0x0518(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244C[0x3];                                     // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusTimerTime;                                    // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UChatWidgetData*>                ChatWidgetDataArray;                               // 0x0520(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddSystemChatItemLinkDesc();
	void ChatKeyboardFocusEvent();
	void ChatScrollToBottom();
	void HideChatWidget();
	void IsTimerStart(bool bIsFocused);
	void OnChatAccountData(const struct FChatAccountData& NewItemData, const struct FChatAccountData& OldItemData);
	void OnChatDataChanged(const class FText& InText);
	bool OnChatDataCommitted(const struct FChatData& InChatData);
	void OnChatEditFocus(bool InbFocus);
	void OnChatType(EChatType NewItemData, EChatType OldItemData);
	void OnEditableFocusLost();
	void OnPlayChatReceiveSound();
	void SetBindChatWidgetToComp();
	void SetChatKeyboardFocus();
	void SetIsChatFocused(bool bIsFocused);
	void SetTimerTime(bool IsStart, float TimerTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatSetWidgetBase">();
	}
	static class UChatSetWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatSetWidgetBase>();
	}
};
static_assert(alignof(UChatSetWidgetBase) == 0x000008, "Wrong alignment on UChatSetWidgetBase");
static_assert(sizeof(UChatSetWidgetBase) == 0x000530, "Wrong size on UChatSetWidgetBase");
static_assert(offsetof(UChatSetWidgetBase, ChatListView) == 0x000358, "Member 'UChatSetWidgetBase::ChatListView' has a wrong offset!");
static_assert(offsetof(UChatSetWidgetBase, ChatEditWidget) == 0x000360, "Member 'UChatSetWidgetBase::ChatEditWidget' has a wrong offset!");
static_assert(offsetof(UChatSetWidgetBase, AccountLink) == 0x000368, "Member 'UChatSetWidgetBase::AccountLink' has a wrong offset!");
static_assert(offsetof(UChatSetWidgetBase, WidgetData) == 0x0003D8, "Member 'UChatSetWidgetBase::WidgetData' has a wrong offset!");
static_assert(offsetof(UChatSetWidgetBase, bIsFocus) == 0x000518, "Member 'UChatSetWidgetBase::bIsFocus' has a wrong offset!");
static_assert(offsetof(UChatSetWidgetBase, FocusTimerTime) == 0x00051C, "Member 'UChatSetWidgetBase::FocusTimerTime' has a wrong offset!");
static_assert(offsetof(UChatSetWidgetBase, ChatWidgetDataArray) == 0x000520, "Member 'UChatSetWidgetBase::ChatWidgetDataArray' has a wrong offset!");

// Class DungeonCrawler.DCPostProcessingComponent
// 0x0090 (0x0130 - 0x00A0)
class UDCPostProcessingComponent final : public UDCActorComponent
{
public:
	TMap<class UMaterialInstanceDynamic*, class UDCCameraPostProcessTimelineData*> CameraPostProcessList;                             // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       PostProcessToDelete;                               // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         MaterialNameToDeleteList;                          // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCameraPostProcessComponentUpdate;                // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCameraPostProcessComponentFinished;              // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UMaterialInstanceDynamic* CreateCameraPostProcess(class UMaterialInstance* InMaterial, class UCurveFloat* InCurve, const TArray<class FName>& InParameterNames, class FName InMaterialName);
	class UMaterialInstanceDynamic* FindCameraPostProcessMID(class FName InMaterialName);
	bool IsCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey);
	void OnCameraPostProcessDataTimelineFinished(float DeltaTime, ETimelineDirection InTimelineDirection, class UMaterialInstanceDynamic* InMIDKey);
	void OnCameraPostProcessDataTimelineUpdate(float DeltaTime, ETimelineDirection InTimelineDirection, class UMaterialInstanceDynamic* InMIDKey);
	void PlayCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey);
	void PlayFromStartCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey);
	void RemoveCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, class FName InMaterialName);
	void RemoveDeletedPostProcessData();
	void ReverseFromEndPlayCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey);
	void ReversePlayCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey);
	bool SetCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, class UCurveFloat* InCurve, const TArray<class FName>& InParameterNames);
	void SetPlayPositionCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, float NewTime, bool bFireEvents, bool bFireUpdate);
	void SetPlayRateCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, float NewRate);
	void SetTimeCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, float NewTime);
	void StopCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPostProcessingComponent">();
	}
	static class UDCPostProcessingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPostProcessingComponent>();
	}
};
static_assert(alignof(UDCPostProcessingComponent) == 0x000008, "Wrong alignment on UDCPostProcessingComponent");
static_assert(sizeof(UDCPostProcessingComponent) == 0x000130, "Wrong size on UDCPostProcessingComponent");
static_assert(offsetof(UDCPostProcessingComponent, CameraPostProcessList) == 0x0000A0, "Member 'UDCPostProcessingComponent::CameraPostProcessList' has a wrong offset!");
static_assert(offsetof(UDCPostProcessingComponent, PostProcessToDelete) == 0x0000F0, "Member 'UDCPostProcessingComponent::PostProcessToDelete' has a wrong offset!");
static_assert(offsetof(UDCPostProcessingComponent, MaterialNameToDeleteList) == 0x000100, "Member 'UDCPostProcessingComponent::MaterialNameToDeleteList' has a wrong offset!");
static_assert(offsetof(UDCPostProcessingComponent, OnCameraPostProcessComponentUpdate) == 0x000110, "Member 'UDCPostProcessingComponent::OnCameraPostProcessComponentUpdate' has a wrong offset!");
static_assert(offsetof(UDCPostProcessingComponent, OnCameraPostProcessComponentFinished) == 0x000120, "Member 'UDCPostProcessingComponent::OnCameraPostProcessComponentFinished' has a wrong offset!");

// Class DungeonCrawler.CreateAccountNicknamePopup
// 0x0040 (0x04D0 - 0x0490)
class UCreateAccountNicknamePopup final : public UCommonPopupBase
{
public:
	class UCreateAccountNicknamePopupData*        CreateAccountNicknamePopupData;                    // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switcher_DuplicateCheck;                           // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switcher_CheckOrClear;                             // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEditableText*                        AccountNicknameEdit;                               // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AccountNameResultText;                             // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Check;                                         // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Create;                                        // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Clear;                                         // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTextChangedAccountNickname(const class FText& InAccountNickname);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateAccountNicknamePopup">();
	}
	static class UCreateAccountNicknamePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateAccountNicknamePopup>();
	}
};
static_assert(alignof(UCreateAccountNicknamePopup) == 0x000008, "Wrong alignment on UCreateAccountNicknamePopup");
static_assert(sizeof(UCreateAccountNicknamePopup) == 0x0004D0, "Wrong size on UCreateAccountNicknamePopup");
static_assert(offsetof(UCreateAccountNicknamePopup, CreateAccountNicknamePopupData) == 0x000490, "Member 'UCreateAccountNicknamePopup::CreateAccountNicknamePopupData' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, Switcher_DuplicateCheck) == 0x000498, "Member 'UCreateAccountNicknamePopup::Switcher_DuplicateCheck' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, Switcher_CheckOrClear) == 0x0004A0, "Member 'UCreateAccountNicknamePopup::Switcher_CheckOrClear' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, AccountNicknameEdit) == 0x0004A8, "Member 'UCreateAccountNicknamePopup::AccountNicknameEdit' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, AccountNameResultText) == 0x0004B0, "Member 'UCreateAccountNicknamePopup::AccountNameResultText' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, Btn_Check) == 0x0004B8, "Member 'UCreateAccountNicknamePopup::Btn_Check' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, Btn_Create) == 0x0004C0, "Member 'UCreateAccountNicknamePopup::Btn_Create' has a wrong offset!");
static_assert(offsetof(UCreateAccountNicknamePopup, Btn_Clear) == 0x0004C8, "Member 'UCreateAccountNicknamePopup::Btn_Clear' has a wrong offset!");

// Class DungeonCrawler.ChatWidgetData
// 0x00A8 (0x00D0 - 0x0028)
class UChatWidgetData final : public UObject
{
public:
	int64                                         ChatIndex;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatWidgetType                               ChatWidgetType;                                    // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatSetType                                  ChatSetType;                                       // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2456[0x6];                                     // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LocalDateTime;                                     // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountId;                                         // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0060(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x00A0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChatDataPiece>                 ChatDataPieceArray;                                // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EContextOptionType>                    ContextOptionArray;                                // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatWidgetData">();
	}
	static class UChatWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatWidgetData>();
	}
};
static_assert(alignof(UChatWidgetData) == 0x000008, "Wrong alignment on UChatWidgetData");
static_assert(sizeof(UChatWidgetData) == 0x0000D0, "Wrong size on UChatWidgetData");
static_assert(offsetof(UChatWidgetData, ChatIndex) == 0x000028, "Member 'UChatWidgetData::ChatIndex' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, ChatWidgetType) == 0x000030, "Member 'UChatWidgetData::ChatWidgetType' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, ChatSetType) == 0x000031, "Member 'UChatWidgetData::ChatSetType' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, LocalDateTime) == 0x000038, "Member 'UChatWidgetData::LocalDateTime' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, AccountId) == 0x000040, "Member 'UChatWidgetData::AccountId' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, CharacterId) == 0x000050, "Member 'UChatWidgetData::CharacterId' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, Nickname) == 0x000060, "Member 'UChatWidgetData::Nickname' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, PartyId) == 0x0000A0, "Member 'UChatWidgetData::PartyId' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, ChatDataPieceArray) == 0x0000B0, "Member 'UChatWidgetData::ChatDataPieceArray' has a wrong offset!");
static_assert(offsetof(UChatWidgetData, ContextOptionArray) == 0x0000C0, "Member 'UChatWidgetData::ContextOptionArray' has a wrong offset!");

// Class DungeonCrawler.ChatWidgetBase
// 0x00B0 (0x0408 - 0x0358)
class UChatWidgetBase final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2457[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UChatWidgetData*                        ChatWidgetData;                                    // 0x0368(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2458[0x98];                                    // 0x0370(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText ChangeDateTimeAsText(const struct FDateTime& DateTime);
	class FString FilterStreamingMode(const class FString& OriginalStr);
	void OnChatRecordData(const struct FChatRecord& NewValue, const struct FChatRecord& OldValue);
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatWidgetBase">();
	}
	static class UChatWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatWidgetBase>();
	}
};
static_assert(alignof(UChatWidgetBase) == 0x000008, "Wrong alignment on UChatWidgetBase");
static_assert(sizeof(UChatWidgetBase) == 0x000408, "Wrong size on UChatWidgetBase");
static_assert(offsetof(UChatWidgetBase, ChatWidgetData) == 0x000368, "Member 'UChatWidgetBase::ChatWidgetData' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_SendGameplayEventTagsToSelf
// 0x0018 (0x0048 - 0x0030)
class UDCAnimNotify_SendGameplayEventTagsToSelf final : public UAnimNotifyState
{
public:
	struct FGameplayTag                           BeginEventTag;                                     // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndEventTag;                                       // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0040(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_SendGameplayEventTagsToSelf">();
	}
	static class UDCAnimNotify_SendGameplayEventTagsToSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_SendGameplayEventTagsToSelf>();
	}
};
static_assert(alignof(UDCAnimNotify_SendGameplayEventTagsToSelf) == 0x000008, "Wrong alignment on UDCAnimNotify_SendGameplayEventTagsToSelf");
static_assert(sizeof(UDCAnimNotify_SendGameplayEventTagsToSelf) == 0x000048, "Wrong size on UDCAnimNotify_SendGameplayEventTagsToSelf");
static_assert(offsetof(UDCAnimNotify_SendGameplayEventTagsToSelf, BeginEventTag) == 0x000030, "Member 'UDCAnimNotify_SendGameplayEventTagsToSelf::BeginEventTag' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_SendGameplayEventTagsToSelf, EndEventTag) == 0x000038, "Member 'UDCAnimNotify_SendGameplayEventTagsToSelf::EndEventTag' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_SendGameplayEventTagsToSelf, EventTag) == 0x000040, "Member 'UDCAnimNotify_SendGameplayEventTagsToSelf::EventTag' has a wrong offset!");

// Class DungeonCrawler.GA_RangedAttackBase
// 0x00B8 (0x0658 - 0x05A0)
class UGA_RangedAttackBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnSourceObject;                       // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectileActor>           ProjectileActorClass;                              // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FireSocketName;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        FireSocketNameByEventTagMap;                       // 0x05C0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ProjectileSpeedMultiplier;                         // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2459[0x4];                                     // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsMultiFireProjectiles;                            // 0x0618(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245A[0x7];                                     // 0x0619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageCurve;                                       // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsAmmoToActivate;                              // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsAmmoToFire;                                  // 0x0629(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245B[0x2];                                     // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoUsage;                                         // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AmmoItemId;                                        // 0x0630(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayPullOnAnimationActivation;                    // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245C[0x7];                                     // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCGATA_AimTraceToSocket*               SocketTargetActor;                                 // 0x0648(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245D[0x8];                                     // 0x0650(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ActivateCrossHairPullAnimation(class APlayerController* PlayerController);
	void CreatedProjectile(class AProjectileActor* Projectile, const struct FHitResult& HitResult, const struct FGameplayTag& EventTag);
	void CreateProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower, const struct FVector& StartLocation);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void FireProjectile(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower);
	void FireSocketSightBlocked(const struct FGameplayAbilityTargetDataHandle& InData);
	void FireSocketSightUnblocked(const struct FGameplayAbilityTargetDataHandle& InData);
	void MultiFireProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ProjectileFired();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void UpdatedRangedWeaponCrosshairs(class APlayerController* PlayerController);

	TSubclassOf<class AProjectileActor> GetProjectileActorClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_RangedAttackBase">();
	}
	static class UGA_RangedAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_RangedAttackBase>();
	}
};
static_assert(alignof(UGA_RangedAttackBase) == 0x000008, "Wrong alignment on UGA_RangedAttackBase");
static_assert(sizeof(UGA_RangedAttackBase) == 0x000658, "Wrong size on UGA_RangedAttackBase");
static_assert(offsetof(UGA_RangedAttackBase, MontageToPlay) == 0x0005A0, "Member 'UGA_RangedAttackBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, MontageToPlayOnSourceObject) == 0x0005A8, "Member 'UGA_RangedAttackBase::MontageToPlayOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, ProjectileActorClass) == 0x0005B0, "Member 'UGA_RangedAttackBase::ProjectileActorClass' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, FireSocketName) == 0x0005B8, "Member 'UGA_RangedAttackBase::FireSocketName' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, FireSocketNameByEventTagMap) == 0x0005C0, "Member 'UGA_RangedAttackBase::FireSocketNameByEventTagMap' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, ProjectileSpeedMultiplier) == 0x000610, "Member 'UGA_RangedAttackBase::ProjectileSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, IsMultiFireProjectiles) == 0x000618, "Member 'UGA_RangedAttackBase::IsMultiFireProjectiles' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, DamageCurve) == 0x000620, "Member 'UGA_RangedAttackBase::DamageCurve' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, bNeedsAmmoToActivate) == 0x000628, "Member 'UGA_RangedAttackBase::bNeedsAmmoToActivate' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, bNeedsAmmoToFire) == 0x000629, "Member 'UGA_RangedAttackBase::bNeedsAmmoToFire' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, AmmoUsage) == 0x00062C, "Member 'UGA_RangedAttackBase::AmmoUsage' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, AmmoItemId) == 0x000630, "Member 'UGA_RangedAttackBase::AmmoItemId' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, bPlayPullOnAnimationActivation) == 0x000640, "Member 'UGA_RangedAttackBase::bPlayPullOnAnimationActivation' has a wrong offset!");
static_assert(offsetof(UGA_RangedAttackBase, SocketTargetActor) == 0x000648, "Member 'UGA_RangedAttackBase::SocketTargetActor' has a wrong offset!");

// Class DungeonCrawler.GA_MonsterRangedAttackBase
// 0x00F0 (0x0748 - 0x0658)
class UGA_MonsterRangedAttackBase : public UGA_RangedAttackBase
{
public:
	bool                                          bUsePremadeSpec;                                   // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2461[0x3];                                     // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CancleGameplayTag;                                 // 0x065C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHitBoxType                                   HitBoxType;                                        // 0x0664(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2462[0x3];                                     // 0x0665(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomRate;                                        // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomRange;                                       // 0x066C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultFirePower;                                  // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumDistance;                                   // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MultiShotCount;                                    // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MultiShotAngle;                                    // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2463[0x18];                                    // 0x0680(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEventData                     GameplayEventData;                                 // 0x0698(0x00B0)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MonsterRangedAttackBase">();
	}
	static class UGA_MonsterRangedAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MonsterRangedAttackBase>();
	}
};
static_assert(alignof(UGA_MonsterRangedAttackBase) == 0x000008, "Wrong alignment on UGA_MonsterRangedAttackBase");
static_assert(sizeof(UGA_MonsterRangedAttackBase) == 0x000748, "Wrong size on UGA_MonsterRangedAttackBase");
static_assert(offsetof(UGA_MonsterRangedAttackBase, bUsePremadeSpec) == 0x000658, "Member 'UGA_MonsterRangedAttackBase::bUsePremadeSpec' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, CancleGameplayTag) == 0x00065C, "Member 'UGA_MonsterRangedAttackBase::CancleGameplayTag' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, HitBoxType) == 0x000664, "Member 'UGA_MonsterRangedAttackBase::HitBoxType' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, RandomRate) == 0x000668, "Member 'UGA_MonsterRangedAttackBase::RandomRate' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, RandomRange) == 0x00066C, "Member 'UGA_MonsterRangedAttackBase::RandomRange' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, DefaultFirePower) == 0x000670, "Member 'UGA_MonsterRangedAttackBase::DefaultFirePower' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, MinimumDistance) == 0x000674, "Member 'UGA_MonsterRangedAttackBase::MinimumDistance' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, MultiShotCount) == 0x000678, "Member 'UGA_MonsterRangedAttackBase::MultiShotCount' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, MultiShotAngle) == 0x00067C, "Member 'UGA_MonsterRangedAttackBase::MultiShotAngle' has a wrong offset!");
static_assert(offsetof(UGA_MonsterRangedAttackBase, GameplayEventData) == 0x000698, "Member 'UGA_MonsterRangedAttackBase::GameplayEventData' has a wrong offset!");

// Class DungeonCrawler.GA_MonsterChargedRangedAttackBase
// 0x0010 (0x0758 - 0x0748)
class UGA_MonsterChargedRangedAttackBase : public UGA_MonsterRangedAttackBase
{
public:
	struct FGameplayTag                           NextGameplayTag;                                   // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireDelay;                                         // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2464[0x4];                                     // 0x0754(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MonsterChargedRangedAttackBase">();
	}
	static class UGA_MonsterChargedRangedAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MonsterChargedRangedAttackBase>();
	}
};
static_assert(alignof(UGA_MonsterChargedRangedAttackBase) == 0x000008, "Wrong alignment on UGA_MonsterChargedRangedAttackBase");
static_assert(sizeof(UGA_MonsterChargedRangedAttackBase) == 0x000758, "Wrong size on UGA_MonsterChargedRangedAttackBase");
static_assert(offsetof(UGA_MonsterChargedRangedAttackBase, NextGameplayTag) == 0x000748, "Member 'UGA_MonsterChargedRangedAttackBase::NextGameplayTag' has a wrong offset!");
static_assert(offsetof(UGA_MonsterChargedRangedAttackBase, FireDelay) == 0x000750, "Member 'UGA_MonsterChargedRangedAttackBase::FireDelay' has a wrong offset!");

// Class DungeonCrawler.ClassGroupWidgetBase
// 0x0020 (0x04A8 - 0x0488)
class UClassGroupWidgetBase : public UDCCommonActivatableWidgetBase
{
public:
	EWidgetClassGroupType                         WidgetClassGroupType;                              // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2465[0x7];                                     // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWidgetClassGroupType>                 NonCoexistWidgetWidgetClassGroupTypeArray;         // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2466[0x8];                                     // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassGroupWidgetBase">();
	}
	static class UClassGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassGroupWidgetBase>();
	}
};
static_assert(alignof(UClassGroupWidgetBase) == 0x000008, "Wrong alignment on UClassGroupWidgetBase");
static_assert(sizeof(UClassGroupWidgetBase) == 0x0004A8, "Wrong size on UClassGroupWidgetBase");
static_assert(offsetof(UClassGroupWidgetBase, WidgetClassGroupType) == 0x000488, "Member 'UClassGroupWidgetBase::WidgetClassGroupType' has a wrong offset!");
static_assert(offsetof(UClassGroupWidgetBase, NonCoexistWidgetWidgetClassGroupTypeArray) == 0x000490, "Member 'UClassGroupWidgetBase::NonCoexistWidgetWidgetClassGroupTypeArray' has a wrong offset!");

// Class DungeonCrawler.DCDrawbridge
// 0x0048 (0x0428 - 0x03E0)
class ADCDrawbridge : public APropsActorBase
{
public:
	class ADCDrawbridgeWheel*                     PlaybackWheel;                                     // 0x03E0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCDrawbridgeWheel*                     RewindWheel;                                       // 0x03E8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2467[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSkeletalMeshComponent*               DrawbridgeMeshComponent;                           // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCChildActorComponent*                 PlaybackWheelChildActorComponent;                  // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCChildActorComponent*                 RewindWheelChildActorComponent;                    // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAkComponent*                         AkComponent;                                       // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InteractFailedWheel(class AActor* Interacter);
	void InteractPlaybackWheel(class AActor* Interacter);
	void InteractRewindWheel(class AActor* Interacter);
	void OnRep_PlaybackWheel();
	void OnRep_RewindWheel();
	void SetPlaybackWheel(class APropsActorBase* InChildActor);
	void SetRewindWheel(class APropsActorBase* InChildActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDrawbridge">();
	}
	static class ADCDrawbridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCDrawbridge>();
	}
};
static_assert(alignof(ADCDrawbridge) == 0x000008, "Wrong alignment on ADCDrawbridge");
static_assert(sizeof(ADCDrawbridge) == 0x000428, "Wrong size on ADCDrawbridge");
static_assert(offsetof(ADCDrawbridge, PlaybackWheel) == 0x0003E0, "Member 'ADCDrawbridge::PlaybackWheel' has a wrong offset!");
static_assert(offsetof(ADCDrawbridge, RewindWheel) == 0x0003E8, "Member 'ADCDrawbridge::RewindWheel' has a wrong offset!");
static_assert(offsetof(ADCDrawbridge, RootSceneComponent) == 0x000400, "Member 'ADCDrawbridge::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ADCDrawbridge, DrawbridgeMeshComponent) == 0x000408, "Member 'ADCDrawbridge::DrawbridgeMeshComponent' has a wrong offset!");
static_assert(offsetof(ADCDrawbridge, PlaybackWheelChildActorComponent) == 0x000410, "Member 'ADCDrawbridge::PlaybackWheelChildActorComponent' has a wrong offset!");
static_assert(offsetof(ADCDrawbridge, RewindWheelChildActorComponent) == 0x000418, "Member 'ADCDrawbridge::RewindWheelChildActorComponent' has a wrong offset!");
static_assert(offsetof(ADCDrawbridge, AkComponent) == 0x000420, "Member 'ADCDrawbridge::AkComponent' has a wrong offset!");

// Class DungeonCrawler.GA_MeleeAttackBase
// 0x00C0 (0x0660 - 0x05A0)
class UGA_MeleeAttackBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnSourceObject;                       // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDesignDataAssetMeleeAttack*            MeleeAttackData;                                   // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CameraShakeOnStuckStaticObject;                    // 0x05B8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CameraShakeOnStuckCharacter;                       // 0x05C0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CameraShakeOnStuckShield;                          // 0x05C8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChangeCrossHairWhenEventTag;                       // 0x05D0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeCrossHairAngle;                              // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OnPinPoint;                                        // 0x05DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2468[0x3];                                     // 0x05DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateTime;                                        // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2469[0x4];                                     // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCGATA_LineCollision*                  TargetActor;                                       // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAT_WaitTargetData*                   TargetingTask;                                     // 0x05F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 OnHitTask;                                         // 0x05F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitDelay*                 OnStuckTask;                                       // 0x0600(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_246A[0x58];                                    // 0x0608(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);
	void ClientTargetDataReceived(const struct FGameplayTag& EventTag, const struct FGameplayTag& InChannelTag, const struct FGameplayEventData& EventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void MontageJumpToNextSection();
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnHitFinish();
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnInterruptFinish();
	void OnStuckFinish();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData);
	void ServerTargetDataReceived(const struct FGameplayTag& EventTag, const struct FGameplayTag& InChannelTag, const struct FGameplayEventData& EventData);

	const class UDesignDataAssetMeleeAttack* GetMeleeAttackData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MeleeAttackBase">();
	}
	static class UGA_MeleeAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MeleeAttackBase>();
	}
};
static_assert(alignof(UGA_MeleeAttackBase) == 0x000008, "Wrong alignment on UGA_MeleeAttackBase");
static_assert(sizeof(UGA_MeleeAttackBase) == 0x000660, "Wrong size on UGA_MeleeAttackBase");
static_assert(offsetof(UGA_MeleeAttackBase, MontageToPlay) == 0x0005A0, "Member 'UGA_MeleeAttackBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, MontageToPlayOnSourceObject) == 0x0005A8, "Member 'UGA_MeleeAttackBase::MontageToPlayOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, MeleeAttackData) == 0x0005B0, "Member 'UGA_MeleeAttackBase::MeleeAttackData' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, CameraShakeOnStuckStaticObject) == 0x0005B8, "Member 'UGA_MeleeAttackBase::CameraShakeOnStuckStaticObject' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, CameraShakeOnStuckCharacter) == 0x0005C0, "Member 'UGA_MeleeAttackBase::CameraShakeOnStuckCharacter' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, CameraShakeOnStuckShield) == 0x0005C8, "Member 'UGA_MeleeAttackBase::CameraShakeOnStuckShield' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, ChangeCrossHairWhenEventTag) == 0x0005D0, "Member 'UGA_MeleeAttackBase::ChangeCrossHairWhenEventTag' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, ChangeCrossHairAngle) == 0x0005D8, "Member 'UGA_MeleeAttackBase::ChangeCrossHairAngle' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, OnPinPoint) == 0x0005DC, "Member 'UGA_MeleeAttackBase::OnPinPoint' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, RotateTime) == 0x0005E0, "Member 'UGA_MeleeAttackBase::RotateTime' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, TargetActor) == 0x0005E8, "Member 'UGA_MeleeAttackBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, TargetingTask) == 0x0005F0, "Member 'UGA_MeleeAttackBase::TargetingTask' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, OnHitTask) == 0x0005F8, "Member 'UGA_MeleeAttackBase::OnHitTask' has a wrong offset!");
static_assert(offsetof(UGA_MeleeAttackBase, OnStuckTask) == 0x000600, "Member 'UGA_MeleeAttackBase::OnStuckTask' has a wrong offset!");

// Class DungeonCrawler.GA_MonsterMeleeAttackBase
// 0x0010 (0x0670 - 0x0660)
class UGA_MonsterMeleeAttackBase : public UGA_MeleeAttackBase
{
public:
	struct FGameplayTag                           CancleGameplayTag;                                 // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TransitionSectionName;                             // 0x0668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MonsterMeleeAttackBase">();
	}
	static class UGA_MonsterMeleeAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MonsterMeleeAttackBase>();
	}
};
static_assert(alignof(UGA_MonsterMeleeAttackBase) == 0x000008, "Wrong alignment on UGA_MonsterMeleeAttackBase");
static_assert(sizeof(UGA_MonsterMeleeAttackBase) == 0x000670, "Wrong size on UGA_MonsterMeleeAttackBase");
static_assert(offsetof(UGA_MonsterMeleeAttackBase, CancleGameplayTag) == 0x000660, "Member 'UGA_MonsterMeleeAttackBase::CancleGameplayTag' has a wrong offset!");
static_assert(offsetof(UGA_MonsterMeleeAttackBase, TransitionSectionName) == 0x000668, "Member 'UGA_MonsterMeleeAttackBase::TransitionSectionName' has a wrong offset!");

// Class DungeonCrawler.ClassIconGroupWidget
// 0x0018 (0x0370 - 0x0358)
class UClassIconGroupWidget final : public UDCWidgetBase
{
public:
	class UCommonTileView*                        ClassIconCommonTileView;                           // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             ClassIconSelectedDelegate;                         // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassIconGroupWidget">();
	}
	static class UClassIconGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassIconGroupWidget>();
	}
};
static_assert(alignof(UClassIconGroupWidget) == 0x000008, "Wrong alignment on UClassIconGroupWidget");
static_assert(sizeof(UClassIconGroupWidget) == 0x000370, "Wrong size on UClassIconGroupWidget");
static_assert(offsetof(UClassIconGroupWidget, ClassIconCommonTileView) == 0x000358, "Member 'UClassIconGroupWidget::ClassIconCommonTileView' has a wrong offset!");
static_assert(offsetof(UClassIconGroupWidget, ClassIconSelectedDelegate) == 0x000360, "Member 'UClassIconGroupWidget::ClassIconSelectedDelegate' has a wrong offset!");

// Class DungeonCrawler.ClassIconWidgetData
// 0x0140 (0x0168 - 0x0028)
class UClassIconWidgetData final : public UObject
{
public:
	int32                                         ItemIndex;                                         // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterClassId;                                  // 0x002C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246B[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataPlayerCharacter             DesignDataPlayerCharacter;                         // 0x0040(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassIconWidgetData">();
	}
	static class UClassIconWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassIconWidgetData>();
	}
};
static_assert(alignof(UClassIconWidgetData) == 0x000008, "Wrong alignment on UClassIconWidgetData");
static_assert(sizeof(UClassIconWidgetData) == 0x000168, "Wrong size on UClassIconWidgetData");
static_assert(offsetof(UClassIconWidgetData, ItemIndex) == 0x000028, "Member 'UClassIconWidgetData::ItemIndex' has a wrong offset!");
static_assert(offsetof(UClassIconWidgetData, CharacterClassId) == 0x00002C, "Member 'UClassIconWidgetData::CharacterClassId' has a wrong offset!");
static_assert(offsetof(UClassIconWidgetData, DesignDataPlayerCharacter) == 0x000040, "Member 'UClassIconWidgetData::DesignDataPlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.ClassIconWidget
// 0x0008 (0x0360 - 0x0358)
class UClassIconWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_246C[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickedClassIconButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassIconWidget">();
	}
	static class UClassIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassIconWidget>();
	}
};
static_assert(alignof(UClassIconWidget) == 0x000008, "Wrong alignment on UClassIconWidget");
static_assert(sizeof(UClassIconWidget) == 0x000360, "Wrong size on UClassIconWidget");

// Class DungeonCrawler.DCPoolManager
// 0x0060 (0x02F8 - 0x0298)
class ADCPoolManager final : public AActor
{
public:
	uint8                                         Pad_246D[0x58];                                    // 0x0298(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCPool*                                UObjectPool;                                       // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPoolManager">();
	}
	static class ADCPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPoolManager>();
	}
};
static_assert(alignof(ADCPoolManager) == 0x000008, "Wrong alignment on ADCPoolManager");
static_assert(sizeof(ADCPoolManager) == 0x0002F8, "Wrong size on ADCPoolManager");
static_assert(offsetof(ADCPoolManager, UObjectPool) == 0x0002F0, "Member 'ADCPoolManager::UObjectPool' has a wrong offset!");

// Class DungeonCrawler.InvitePartyWidget
// 0x0278 (0x05D0 - 0x0358)
class UInvitePartyWidget final : public UDCWidgetBase
{
public:
	class UMyStatusWidget*                        MyStatusWidget;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              PartySlotListView;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              PlayerSlotTileView;                                // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              FriendSlotTileView;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              BlockedSlotTileView;                               // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              ReceivedInvitationSlotTileView;                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              SentInvitationSlotTileView;                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          AccountNicknameEdit;                               // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_InviteFriend;                                  // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_InviteAcceptAll;                               // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_InviteDeclineAll;                              // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentPageIndex;                                  // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxCharacterCount;                                 // 0x03B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPageIndex;                                      // 0x03B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_246E[0x10];                                    // 0x03BC(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedTileViewIndex;                             // 0x03CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_246F[0x200];                                   // 0x03D0(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBackButtonClicked();
	void InitCurrentPageIndex();
	void OnBlockUserSlotData(const struct FBlockUserSlotData& NewValue, const struct FBlockUserSlotData& OldValue);
	void OnButtonInviteAcceptAll();
	void OnButtonInviteDeclineAll();
	void OnButtonInviteFriend();
	void OnDrawBlockList();
	void OnDrawFriendList();
	void OnDrawPartyList();
	void OnDrawPlayerList();
	void OnDrawReceivedInvitationList();
	void OnDrawSentInvitationList();
	void OnFriendLocateNumber(const int32 LobbyCount, const int32 DungeonCount, const int32 OfflineCount, const int32 BlockCount);
	void OnFriendSlotData(const struct FFriendSlotData& NewValue, const struct FFriendSlotData& OldValue);
	void OnInvitePartyUserSlotData(const struct FInvitePartyUserSlotData& NewValue, const struct FInvitePartyUserSlotData& OldValue);
	void OnLeftButtonCkicked();
	void OnPageNumber(const int32 CurrentPage, const int32 MaxPage);
	void OnPlayerLocateNumber(const int32 LobbyCount, const int32 DungeonCount, const int32 BlockCount);
	void OnPopupSWidgetFriendPartyInviteResult(EPopupResult PopupResult, const struct FDCFriendInfo& TargetUser);
	void OnPopupSWidgetPlayerPartyInviteResult(EPopupResult PopupResult, const struct FInvitePartyUserSlot& TargetUser);
	void OnReceivedInvitationSlotData(const struct FReceivedInvitationSlotData& NewValue, const struct FReceivedInvitationSlotData& OldValue);
	void OnRightButtonCkicked();
	void OnSentInvitationSlotData(const struct FSentInvitationSlotData& NewValue, const struct FSentInvitationSlotData& OldValue);
	bool OnTextChangedFindBlock(const class FText& AccountNickname);
	bool OnTextChangedFindFriend(const class FText& AccountNickname);
	bool OnTextChangedFindPlayer(const class FText& AccountNickname);
	void OnUserListFindPlayerClicked(const class FText& AccountNickname);
	void RefreshPlayerList();
	void TryFriendRequestInviteParty(const class UFriendSlotWidgetData* FriendSlotWidgetData);
	void TryPlayerRequestInviteParty(const class UPlayerSlotWidgetData* PlayerSlotWidgetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvitePartyWidget">();
	}
	static class UInvitePartyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvitePartyWidget>();
	}
};
static_assert(alignof(UInvitePartyWidget) == 0x000008, "Wrong alignment on UInvitePartyWidget");
static_assert(sizeof(UInvitePartyWidget) == 0x0005D0, "Wrong size on UInvitePartyWidget");
static_assert(offsetof(UInvitePartyWidget, MyStatusWidget) == 0x000358, "Member 'UInvitePartyWidget::MyStatusWidget' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, PartySlotListView) == 0x000360, "Member 'UInvitePartyWidget::PartySlotListView' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, PlayerSlotTileView) == 0x000368, "Member 'UInvitePartyWidget::PlayerSlotTileView' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, FriendSlotTileView) == 0x000370, "Member 'UInvitePartyWidget::FriendSlotTileView' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, BlockedSlotTileView) == 0x000378, "Member 'UInvitePartyWidget::BlockedSlotTileView' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, ReceivedInvitationSlotTileView) == 0x000380, "Member 'UInvitePartyWidget::ReceivedInvitationSlotTileView' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, SentInvitationSlotTileView) == 0x000388, "Member 'UInvitePartyWidget::SentInvitationSlotTileView' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, AccountNicknameEdit) == 0x000390, "Member 'UInvitePartyWidget::AccountNicknameEdit' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, Btn_InviteFriend) == 0x000398, "Member 'UInvitePartyWidget::Btn_InviteFriend' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, Btn_InviteAcceptAll) == 0x0003A0, "Member 'UInvitePartyWidget::Btn_InviteAcceptAll' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, Btn_InviteDeclineAll) == 0x0003A8, "Member 'UInvitePartyWidget::Btn_InviteDeclineAll' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, CurrentPageIndex) == 0x0003B0, "Member 'UInvitePartyWidget::CurrentPageIndex' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, MaxCharacterCount) == 0x0003B4, "Member 'UInvitePartyWidget::MaxCharacterCount' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, MaxPageIndex) == 0x0003B8, "Member 'UInvitePartyWidget::MaxPageIndex' has a wrong offset!");
static_assert(offsetof(UInvitePartyWidget, SelectedTileViewIndex) == 0x0003CC, "Member 'UInvitePartyWidget::SelectedTileViewIndex' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitForCharacterUnCrouch
// 0x0018 (0x0098 - 0x0080)
class UDCAT_WaitForCharacterUnCrouch final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnUnCrouch;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UDCAT_WaitForCharacterUnCrouch* WaitForCharacterUnCrouch(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitForCharacterUnCrouch">();
	}
	static class UDCAT_WaitForCharacterUnCrouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitForCharacterUnCrouch>();
	}
};
static_assert(alignof(UDCAT_WaitForCharacterUnCrouch) == 0x000008, "Wrong alignment on UDCAT_WaitForCharacterUnCrouch");
static_assert(sizeof(UDCAT_WaitForCharacterUnCrouch) == 0x000098, "Wrong size on UDCAT_WaitForCharacterUnCrouch");
static_assert(offsetof(UDCAT_WaitForCharacterUnCrouch, OnUnCrouch) == 0x000080, "Member 'UDCAT_WaitForCharacterUnCrouch::OnUnCrouch' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitForCharacterUnCrouch, CachedMovementComponent) == 0x000090, "Member 'UDCAT_WaitForCharacterUnCrouch::CachedMovementComponent' has a wrong offset!");

// Class DungeonCrawler.MusicSlotWidgetBase
// 0x0110 (0x0468 - 0x0358)
class UMusicSlotWidgetBase : public UDCWidgetBase
{
public:
	struct FMusicData                             MusicData;                                         // 0x0358(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2475[0x4];                                     // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       DesignDataMusic;                                   // 0x0380(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           DescTextArray;                                     // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UArtDataMusic*                          ArtData;                                           // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2476[0x4];                                     // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMusicDataChanged(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic);
	void OnReset();
	void OnSetMusicArtData(const class UArtDataMusic* InArtMusicData);
	void Reset();
	void SetMusicData(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicSlotWidgetBase">();
	}
	static class UMusicSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicSlotWidgetBase>();
	}
};
static_assert(alignof(UMusicSlotWidgetBase) == 0x000008, "Wrong alignment on UMusicSlotWidgetBase");
static_assert(sizeof(UMusicSlotWidgetBase) == 0x000468, "Wrong size on UMusicSlotWidgetBase");
static_assert(offsetof(UMusicSlotWidgetBase, MusicData) == 0x000358, "Member 'UMusicSlotWidgetBase::MusicData' has a wrong offset!");
static_assert(offsetof(UMusicSlotWidgetBase, DesignDataMusic) == 0x000380, "Member 'UMusicSlotWidgetBase::DesignDataMusic' has a wrong offset!");
static_assert(offsetof(UMusicSlotWidgetBase, DescTextArray) == 0x000448, "Member 'UMusicSlotWidgetBase::DescTextArray' has a wrong offset!");
static_assert(offsetof(UMusicSlotWidgetBase, ArtData) == 0x000458, "Member 'UMusicSlotWidgetBase::ArtData' has a wrong offset!");
static_assert(offsetof(UMusicSlotWidgetBase, SlotIndex) == 0x000460, "Member 'UMusicSlotWidgetBase::SlotIndex' has a wrong offset!");

// Class DungeonCrawler.MusicCapacitySlotWidget
// 0x0008 (0x0470 - 0x0468)
class UMusicCapacitySlotWidget : public UMusicSlotWidgetBase
{
public:
	int32                                         SequenceIndex;                                     // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2479[0x4];                                     // 0x046C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicCapacitySlotWidget">();
	}
	static class UMusicCapacitySlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicCapacitySlotWidget>();
	}
};
static_assert(alignof(UMusicCapacitySlotWidget) == 0x000008, "Wrong alignment on UMusicCapacitySlotWidget");
static_assert(sizeof(UMusicCapacitySlotWidget) == 0x000470, "Wrong size on UMusicCapacitySlotWidget");
static_assert(offsetof(UMusicCapacitySlotWidget, SequenceIndex) == 0x000468, "Member 'UMusicCapacitySlotWidget::SequenceIndex' has a wrong offset!");

// Class DungeonCrawler.DCPropsSkillCheckDataAsset
// 0x0030 (0x0078 - 0x0048)
class UDCPropsSkillCheckDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           SkillCheckType;                                    // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDuration;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSkillCheckInterval;                             // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSkillCheckInterval;                             // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSucceedSectionStartTime;                        // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedSectionSizeSeconds;                         // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedBonusTimeRatio;                             // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedSectionSizeSeconds;                  // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedBonusTimeRatio;                      // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FailedBonusTimeRatio;                              // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPropsSkillCheckDataAsset">();
	}
	static class UDCPropsSkillCheckDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPropsSkillCheckDataAsset>();
	}
};
static_assert(alignof(UDCPropsSkillCheckDataAsset) == 0x000008, "Wrong alignment on UDCPropsSkillCheckDataAsset");
static_assert(sizeof(UDCPropsSkillCheckDataAsset) == 0x000078, "Wrong size on UDCPropsSkillCheckDataAsset");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, SkillCheckType) == 0x000048, "Member 'UDCPropsSkillCheckDataAsset::SkillCheckType' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, MinDuration) == 0x000050, "Member 'UDCPropsSkillCheckDataAsset::MinDuration' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, MaxDuration) == 0x000054, "Member 'UDCPropsSkillCheckDataAsset::MaxDuration' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, MinSkillCheckInterval) == 0x000058, "Member 'UDCPropsSkillCheckDataAsset::MinSkillCheckInterval' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, MaxSkillCheckInterval) == 0x00005C, "Member 'UDCPropsSkillCheckDataAsset::MaxSkillCheckInterval' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, MinSucceedSectionStartTime) == 0x000060, "Member 'UDCPropsSkillCheckDataAsset::MinSucceedSectionStartTime' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, SucceedSectionSizeSeconds) == 0x000064, "Member 'UDCPropsSkillCheckDataAsset::SucceedSectionSizeSeconds' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, SucceedBonusTimeRatio) == 0x000068, "Member 'UDCPropsSkillCheckDataAsset::SucceedBonusTimeRatio' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, PerfectSucceedSectionSizeSeconds) == 0x00006C, "Member 'UDCPropsSkillCheckDataAsset::PerfectSucceedSectionSizeSeconds' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, PerfectSucceedBonusTimeRatio) == 0x000070, "Member 'UDCPropsSkillCheckDataAsset::PerfectSucceedBonusTimeRatio' has a wrong offset!");
static_assert(offsetof(UDCPropsSkillCheckDataAsset, FailedBonusTimeRatio) == 0x000074, "Member 'UDCPropsSkillCheckDataAsset::FailedBonusTimeRatio' has a wrong offset!");

// Class DungeonCrawler.DCAbilitySystemGlobals
// 0x0030 (0x02D8 - 0x02A8)
class UDCAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClassMMC;                            // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClassMMCSimple;                      // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClassInfiniteTagOnly;                // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClassDurationTagOnly;                // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClassInitialize;                     // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClassCalculation;                    // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAbilitySystemGlobals">();
	}
	static class UDCAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAbilitySystemGlobals>();
	}
};
static_assert(alignof(UDCAbilitySystemGlobals) == 0x000008, "Wrong alignment on UDCAbilitySystemGlobals");
static_assert(sizeof(UDCAbilitySystemGlobals) == 0x0002D8, "Wrong size on UDCAbilitySystemGlobals");
static_assert(offsetof(UDCAbilitySystemGlobals, GameplayEffectClassMMC) == 0x0002A8, "Member 'UDCAbilitySystemGlobals::GameplayEffectClassMMC' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemGlobals, GameplayEffectClassMMCSimple) == 0x0002B0, "Member 'UDCAbilitySystemGlobals::GameplayEffectClassMMCSimple' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemGlobals, GameplayEffectClassInfiniteTagOnly) == 0x0002B8, "Member 'UDCAbilitySystemGlobals::GameplayEffectClassInfiniteTagOnly' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemGlobals, GameplayEffectClassDurationTagOnly) == 0x0002C0, "Member 'UDCAbilitySystemGlobals::GameplayEffectClassDurationTagOnly' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemGlobals, GameplayEffectClassInitialize) == 0x0002C8, "Member 'UDCAbilitySystemGlobals::GameplayEffectClassInitialize' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemGlobals, GameplayEffectClassCalculation) == 0x0002D0, "Member 'UDCAbilitySystemGlobals::GameplayEffectClassCalculation' has a wrong offset!");

// Class DungeonCrawler.ClassMusicCapacitySlotWidget
// 0x0018 (0x0488 - 0x0470)
class UClassMusicCapacitySlotWidget final : public UMusicCapacitySlotWidget
{
public:
	class FText                                   SequenceText;                                      // 0x0470(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassMusicCapacitySlotWidget">();
	}
	static class UClassMusicCapacitySlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassMusicCapacitySlotWidget>();
	}
};
static_assert(alignof(UClassMusicCapacitySlotWidget) == 0x000008, "Wrong alignment on UClassMusicCapacitySlotWidget");
static_assert(sizeof(UClassMusicCapacitySlotWidget) == 0x000488, "Wrong size on UClassMusicCapacitySlotWidget");
static_assert(offsetof(UClassMusicCapacitySlotWidget, SequenceText) == 0x000470, "Member 'UClassMusicCapacitySlotWidget::SequenceText' has a wrong offset!");

// Class DungeonCrawler.DCQuestChapterDataAsset
// 0x0028 (0x0070 - 0x0048)
class UDCQuestChapterDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCQuestChapterDataAsset;                      // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCQuestDataAsset>> Quests;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestChapterDataAsset">();
	}
	static class UDCQuestChapterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestChapterDataAsset>();
	}
};
static_assert(alignof(UDCQuestChapterDataAsset) == 0x000008, "Wrong alignment on UDCQuestChapterDataAsset");
static_assert(sizeof(UDCQuestChapterDataAsset) == 0x000070, "Wrong size on UDCQuestChapterDataAsset");
static_assert(offsetof(UDCQuestChapterDataAsset, Name_DCQuestChapterDataAsset) == 0x000048, "Member 'UDCQuestChapterDataAsset::Name_DCQuestChapterDataAsset' has a wrong offset!");
static_assert(offsetof(UDCQuestChapterDataAsset, Quests) == 0x000060, "Member 'UDCQuestChapterDataAsset::Quests' has a wrong offset!");

// Class DungeonCrawler.MusicCapacityWidgetBase
// 0x0068 (0x04F0 - 0x0488)
class UMusicCapacityWidgetBase : public UDCCommonActivatableWidgetBase
{
public:
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_1;                               // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_2;                               // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_3;                               // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_4;                               // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_5;                               // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_6;                               // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_7;                               // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_8;                               // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_9;                               // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMusicCapacitySlotWidget*               MusicCapacitySlot_10;                              // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMusicCapacitySlotWidget*>       MusicCapacitySlots;                                // 0x04D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         MusicCurrentCapacity;                              // 0x04E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MusicMaxCapacity;                                  // 0x04EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMusicCapacityChanged(float InMusicCurrentCapacity, float InMusicMaxCapacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicCapacityWidgetBase">();
	}
	static class UMusicCapacityWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicCapacityWidgetBase>();
	}
};
static_assert(alignof(UMusicCapacityWidgetBase) == 0x000008, "Wrong alignment on UMusicCapacityWidgetBase");
static_assert(sizeof(UMusicCapacityWidgetBase) == 0x0004F0, "Wrong size on UMusicCapacityWidgetBase");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_1) == 0x000488, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_1' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_2) == 0x000490, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_2' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_3) == 0x000498, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_3' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_4) == 0x0004A0, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_4' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_5) == 0x0004A8, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_5' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_6) == 0x0004B0, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_6' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_7) == 0x0004B8, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_7' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_8) == 0x0004C0, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_8' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_9) == 0x0004C8, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_9' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlot_10) == 0x0004D0, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlot_10' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCapacitySlots) == 0x0004D8, "Member 'UMusicCapacityWidgetBase::MusicCapacitySlots' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicCurrentCapacity) == 0x0004E8, "Member 'UMusicCapacityWidgetBase::MusicCurrentCapacity' has a wrong offset!");
static_assert(offsetof(UMusicCapacityWidgetBase, MusicMaxCapacity) == 0x0004EC, "Member 'UMusicCapacityWidgetBase::MusicMaxCapacity' has a wrong offset!");

// Class DungeonCrawler.ItemTooltipRequirementListEntryWidgetData
// 0x0030 (0x0058 - 0x0028)
class UItemTooltipRequirementListEntryWidgetData final : public UObject
{
public:
	class FText                                   RequirementValueText;                              // 0x0028(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            RequirementValueTextColor;                         // 0x0040(0x0014)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_247A[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipRequirementListEntryWidgetData">();
	}
	static class UItemTooltipRequirementListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipRequirementListEntryWidgetData>();
	}
};
static_assert(alignof(UItemTooltipRequirementListEntryWidgetData) == 0x000008, "Wrong alignment on UItemTooltipRequirementListEntryWidgetData");
static_assert(sizeof(UItemTooltipRequirementListEntryWidgetData) == 0x000058, "Wrong size on UItemTooltipRequirementListEntryWidgetData");
static_assert(offsetof(UItemTooltipRequirementListEntryWidgetData, RequirementValueText) == 0x000028, "Member 'UItemTooltipRequirementListEntryWidgetData::RequirementValueText' has a wrong offset!");
static_assert(offsetof(UItemTooltipRequirementListEntryWidgetData, RequirementValueTextColor) == 0x000040, "Member 'UItemTooltipRequirementListEntryWidgetData::RequirementValueTextColor' has a wrong offset!");

// Class DungeonCrawler.ClassMusicCapacityWidget
// 0x00B8 (0x05A8 - 0x04F0)
class UClassMusicCapacityWidget final : public UMusicCapacityWidgetBase
{
public:
	class UImage*                                 CapacityGauge_1;                                   // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_2;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_3;                                   // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_4;                                   // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_5;                                   // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_6;                                   // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_7;                                   // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_8;                                   // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_9;                                   // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_10;                                  // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         CapacityGauges;                                    // 0x0540(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_1;                                  // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_2;                                  // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_3;                                  // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_4;                                  // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_5;                                  // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_6;                                  // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_7;                                  // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_8;                                  // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_9;                                  // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USpacer*>                        CapacitySpacers;                                   // 0x0598(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnMusicListChanged(const TArray<struct FMusicData>& InMusicDataArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassMusicCapacityWidget">();
	}
	static class UClassMusicCapacityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassMusicCapacityWidget>();
	}
};
static_assert(alignof(UClassMusicCapacityWidget) == 0x000008, "Wrong alignment on UClassMusicCapacityWidget");
static_assert(sizeof(UClassMusicCapacityWidget) == 0x0005A8, "Wrong size on UClassMusicCapacityWidget");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_1) == 0x0004F0, "Member 'UClassMusicCapacityWidget::CapacityGauge_1' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_2) == 0x0004F8, "Member 'UClassMusicCapacityWidget::CapacityGauge_2' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_3) == 0x000500, "Member 'UClassMusicCapacityWidget::CapacityGauge_3' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_4) == 0x000508, "Member 'UClassMusicCapacityWidget::CapacityGauge_4' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_5) == 0x000510, "Member 'UClassMusicCapacityWidget::CapacityGauge_5' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_6) == 0x000518, "Member 'UClassMusicCapacityWidget::CapacityGauge_6' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_7) == 0x000520, "Member 'UClassMusicCapacityWidget::CapacityGauge_7' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_8) == 0x000528, "Member 'UClassMusicCapacityWidget::CapacityGauge_8' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_9) == 0x000530, "Member 'UClassMusicCapacityWidget::CapacityGauge_9' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauge_10) == 0x000538, "Member 'UClassMusicCapacityWidget::CapacityGauge_10' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacityGauges) == 0x000540, "Member 'UClassMusicCapacityWidget::CapacityGauges' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_1) == 0x000550, "Member 'UClassMusicCapacityWidget::CapacitySpacer_1' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_2) == 0x000558, "Member 'UClassMusicCapacityWidget::CapacitySpacer_2' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_3) == 0x000560, "Member 'UClassMusicCapacityWidget::CapacitySpacer_3' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_4) == 0x000568, "Member 'UClassMusicCapacityWidget::CapacitySpacer_4' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_5) == 0x000570, "Member 'UClassMusicCapacityWidget::CapacitySpacer_5' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_6) == 0x000578, "Member 'UClassMusicCapacityWidget::CapacitySpacer_6' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_7) == 0x000580, "Member 'UClassMusicCapacityWidget::CapacitySpacer_7' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_8) == 0x000588, "Member 'UClassMusicCapacityWidget::CapacitySpacer_8' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacer_9) == 0x000590, "Member 'UClassMusicCapacityWidget::CapacitySpacer_9' has a wrong offset!");
static_assert(offsetof(UClassMusicCapacityWidget, CapacitySpacers) == 0x000598, "Member 'UClassMusicCapacityWidget::CapacitySpacers' has a wrong offset!");

// Class DungeonCrawler.ItemTooltipRequirementListWidget
// 0x0050 (0x03A8 - 0x0358)
class UItemTooltipRequirementListWidget : public UDCWidgetBase
{
public:
	TMap<EItemRequirementType, class UItemTooltipRequirementWidget*> ItemRequirementWidgetMap;                          // 0x0358(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipRequirementListWidget">();
	}
	static class UItemTooltipRequirementListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipRequirementListWidget>();
	}
};
static_assert(alignof(UItemTooltipRequirementListWidget) == 0x000008, "Wrong alignment on UItemTooltipRequirementListWidget");
static_assert(sizeof(UItemTooltipRequirementListWidget) == 0x0003A8, "Wrong size on UItemTooltipRequirementListWidget");
static_assert(offsetof(UItemTooltipRequirementListWidget, ItemRequirementWidgetMap) == 0x000358, "Member 'UItemTooltipRequirementListWidget::ItemRequirementWidgetMap' has a wrong offset!");

// Class DungeonCrawler.DCDungeonResultWidget
// 0x0018 (0x02D8 - 0x02C0)
class UDCDungeonResultWidget final : public UUserWidget
{
public:
	class UTexture2D*                             ClassIconTex;                                      // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeathCam;                                         // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGameOver;                                         // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_247B[0x6];                                     // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCArenaGameState*                      ArenaGameState;                                    // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBackToLastGameButtonClicked();
	void OnCloseButtonClicked();
	void OnDeathCamPlaybackButtonClicked();
	void OnExitButtonClicked();
	void SetGameResultInfo(const struct FGameResultInfo& InGameResultInfo);

	int32 GetArenaBlueTeamWinCount() const;
	int32 GetArenaRedTeamWinCount() const;
	int32 GetArenaRoundCount() const;
	class FText GetForceResultReason() const;
	bool HasWinner() const;
	bool IsWinner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonResultWidget">();
	}
	static class UDCDungeonResultWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDungeonResultWidget>();
	}
};
static_assert(alignof(UDCDungeonResultWidget) == 0x000008, "Wrong alignment on UDCDungeonResultWidget");
static_assert(sizeof(UDCDungeonResultWidget) == 0x0002D8, "Wrong size on UDCDungeonResultWidget");
static_assert(offsetof(UDCDungeonResultWidget, ClassIconTex) == 0x0002C0, "Member 'UDCDungeonResultWidget::ClassIconTex' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultWidget, bDeathCam) == 0x0002C8, "Member 'UDCDungeonResultWidget::bDeathCam' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultWidget, bGameOver) == 0x0002C9, "Member 'UDCDungeonResultWidget::bGameOver' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultWidget, ArenaGameState) == 0x0002D0, "Member 'UDCDungeonResultWidget::ArenaGameState' has a wrong offset!");

// Class DungeonCrawler.ClassMusicEquippedWidget
// 0x0000 (0x0488 - 0x0488)
class UClassMusicEquippedWidget final : public UDCCommonActivatableWidgetBase
{
public:
	void OnAddItem();
	void OnRemoveItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassMusicEquippedWidget">();
	}
	static class UClassMusicEquippedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassMusicEquippedWidget>();
	}
};
static_assert(alignof(UClassMusicEquippedWidget) == 0x000008, "Wrong alignment on UClassMusicEquippedWidget");
static_assert(sizeof(UClassMusicEquippedWidget) == 0x000488, "Wrong size on UClassMusicEquippedWidget");

// Class DungeonCrawler.DCAnimNotify_StartEmoteItemBoneModify
// 0x0000 (0x0038 - 0x0038)
class UDCAnimNotify_StartEmoteItemBoneModify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_StartEmoteItemBoneModify">();
	}
	static class UDCAnimNotify_StartEmoteItemBoneModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_StartEmoteItemBoneModify>();
	}
};
static_assert(alignof(UDCAnimNotify_StartEmoteItemBoneModify) == 0x000008, "Wrong alignment on UDCAnimNotify_StartEmoteItemBoneModify");
static_assert(sizeof(UDCAnimNotify_StartEmoteItemBoneModify) == 0x000038, "Wrong size on UDCAnimNotify_StartEmoteItemBoneModify");

// Class DungeonCrawler.DCProjectSettings
// 0x0000 (0x0118 - 0x0118)
class UDCProjectSettings final : public UGeneralProjectSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCProjectSettings">();
	}
	static class UDCProjectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCProjectSettings>();
	}
};
static_assert(alignof(UDCProjectSettings) == 0x000008, "Wrong alignment on UDCProjectSettings");
static_assert(sizeof(UDCProjectSettings) == 0x000118, "Wrong size on UDCProjectSettings");

// Class DungeonCrawler.DCGiftCodeRewardPopupData
// 0x0010 (0x0040 - 0x0030)
class UDCGiftCodeRewardPopupData final : public UPopupDataBase
{
public:
	TArray<struct FDCRewardInfo>                  RewardInfoArray;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGiftCodeRewardPopupData">();
	}
	static class UDCGiftCodeRewardPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGiftCodeRewardPopupData>();
	}
};
static_assert(alignof(UDCGiftCodeRewardPopupData) == 0x000008, "Wrong alignment on UDCGiftCodeRewardPopupData");
static_assert(sizeof(UDCGiftCodeRewardPopupData) == 0x000040, "Wrong size on UDCGiftCodeRewardPopupData");
static_assert(offsetof(UDCGiftCodeRewardPopupData, RewardInfoArray) == 0x000030, "Member 'UDCGiftCodeRewardPopupData::RewardInfoArray' has a wrong offset!");

// Class DungeonCrawler.ClassMusicListWidget
// 0x0000 (0x04E8 - 0x04E8)
class UClassMusicListWidget final : public UMusicListWidgetBase
{
public:
	void OnHideEquippableSlot();
	void OnShowEquippableSlot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassMusicListWidget">();
	}
	static class UClassMusicListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassMusicListWidget>();
	}
};
static_assert(alignof(UClassMusicListWidget) == 0x000008, "Wrong alignment on UClassMusicListWidget");
static_assert(sizeof(UClassMusicListWidget) == 0x0004E8, "Wrong size on UClassMusicListWidget");

// Class DungeonCrawler.NickNameWidgetBase
// 0x0050 (0x03A8 - 0x0358)
class UNickNameWidgetBase : public UDCWidgetBase
{
public:
	struct FNickNameWidgetData                    WidgetData;                                        // 0x0358(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_247C[0x40];                                    // 0x0368(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNickNameStr(const class FString& NewValue, const class FString& OldValue);
	void SetNickName(const struct FNickname& InNickName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NickNameWidgetBase">();
	}
	static class UNickNameWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNickNameWidgetBase>();
	}
};
static_assert(alignof(UNickNameWidgetBase) == 0x000008, "Wrong alignment on UNickNameWidgetBase");
static_assert(sizeof(UNickNameWidgetBase) == 0x0003A8, "Wrong size on UNickNameWidgetBase");
static_assert(offsetof(UNickNameWidgetBase, WidgetData) == 0x000358, "Member 'UNickNameWidgetBase::WidgetData' has a wrong offset!");

// Class DungeonCrawler.DCCommunitySubsystem
// 0x0240 (0x0270 - 0x0030)
class UDCCommunitySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_247D[0x30];                                    // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBlockCount;                                     // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_247E[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCCharacterId, struct FDCCommunityCharacterInfo> BlockInfos;                                        // 0x0068(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCAccountId, struct FDCCommunityCharacterInfo> RecentMatchCharacterInfos;                         // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_247F[0x60];                                    // 0x0108(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountNickname;                                   // 0x0168(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Status;                                            // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Privacy;                                           // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FDCAccountId, struct FDCFriendInfo> Friends;                                           // 0x0180(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCAccountId, struct FDCFriendReceivedInvitationInfo> ReceivedInvitations;                               // 0x01D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCAccountId, struct FDCFriendSentInvitationInfo> SentInvitations;                                   // 0x0220(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommunitySubsystem">();
	}
	static class UDCCommunitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommunitySubsystem>();
	}
};
static_assert(alignof(UDCCommunitySubsystem) == 0x000008, "Wrong alignment on UDCCommunitySubsystem");
static_assert(sizeof(UDCCommunitySubsystem) == 0x000270, "Wrong size on UDCCommunitySubsystem");
static_assert(offsetof(UDCCommunitySubsystem, MaxBlockCount) == 0x000060, "Member 'UDCCommunitySubsystem::MaxBlockCount' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, BlockInfos) == 0x000068, "Member 'UDCCommunitySubsystem::BlockInfos' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, RecentMatchCharacterInfos) == 0x0000B8, "Member 'UDCCommunitySubsystem::RecentMatchCharacterInfos' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, AccountNickname) == 0x000168, "Member 'UDCCommunitySubsystem::AccountNickname' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, Status) == 0x000178, "Member 'UDCCommunitySubsystem::Status' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, Privacy) == 0x00017C, "Member 'UDCCommunitySubsystem::Privacy' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, Friends) == 0x000180, "Member 'UDCCommunitySubsystem::Friends' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, ReceivedInvitations) == 0x0001D0, "Member 'UDCCommunitySubsystem::ReceivedInvitations' has a wrong offset!");
static_assert(offsetof(UDCCommunitySubsystem, SentInvitations) == 0x000220, "Member 'UDCCommunitySubsystem::SentInvitations' has a wrong offset!");

// Class DungeonCrawler.ClassMyCharacterStatusWidget
// 0x0010 (0x0368 - 0x0358)
class UClassMyCharacterStatusWidget final : public UDCWidgetBase
{
public:
	class UCharacterStatusDetailWidget*           CharacterStatusDetailWidget;                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassMyCharacterStatusWidget">();
	}
	static class UClassMyCharacterStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassMyCharacterStatusWidget>();
	}
};
static_assert(alignof(UClassMyCharacterStatusWidget) == 0x000008, "Wrong alignment on UClassMyCharacterStatusWidget");
static_assert(sizeof(UClassMyCharacterStatusWidget) == 0x000368, "Wrong size on UClassMyCharacterStatusWidget");
static_assert(offsetof(UClassMyCharacterStatusWidget, CharacterStatusDetailWidget) == 0x000358, "Member 'UClassMyCharacterStatusWidget::CharacterStatusDetailWidget' has a wrong offset!");
static_assert(offsetof(UClassMyCharacterStatusWidget, InventoryComponent) == 0x000360, "Member 'UClassMyCharacterStatusWidget::InventoryComponent' has a wrong offset!");

// Class DungeonCrawler.DCReligionKillWidget
// 0x0128 (0x0480 - 0x0358)
class UDCReligionKillWidget final : public UDCWidgetBase
{
public:
	class FString                                 MyReligionId;                                      // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TopReligionId;                                     // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MidReligionId;                                     // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotReligionId;                                     // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NoneReligionId;                                    // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ReligionName;                                      // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillCountTop;                                      // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillCountMid;                                      // 0x03B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillCountBot;                                      // 0x03C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillCountNon;                                      // 0x03C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillCountRebellion;                                // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillCountTotal;                                    // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, struct FSlateBrush>       ReligionImageBrushMapMine;                         // 0x03E0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FSlateBrush>       ReligionImageBrushMapEnemy;                        // 0x0430(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void SetImageEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionKillWidget">();
	}
	static class UDCReligionKillWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionKillWidget>();
	}
};
static_assert(alignof(UDCReligionKillWidget) == 0x000008, "Wrong alignment on UDCReligionKillWidget");
static_assert(sizeof(UDCReligionKillWidget) == 0x000480, "Wrong size on UDCReligionKillWidget");
static_assert(offsetof(UDCReligionKillWidget, MyReligionId) == 0x000358, "Member 'UDCReligionKillWidget::MyReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, TopReligionId) == 0x000368, "Member 'UDCReligionKillWidget::TopReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, MidReligionId) == 0x000378, "Member 'UDCReligionKillWidget::MidReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, BotReligionId) == 0x000388, "Member 'UDCReligionKillWidget::BotReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, NoneReligionId) == 0x000398, "Member 'UDCReligionKillWidget::NoneReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, ReligionName) == 0x0003A8, "Member 'UDCReligionKillWidget::ReligionName' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, KillCountTop) == 0x0003B0, "Member 'UDCReligionKillWidget::KillCountTop' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, KillCountMid) == 0x0003B8, "Member 'UDCReligionKillWidget::KillCountMid' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, KillCountBot) == 0x0003C0, "Member 'UDCReligionKillWidget::KillCountBot' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, KillCountNon) == 0x0003C8, "Member 'UDCReligionKillWidget::KillCountNon' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, KillCountRebellion) == 0x0003D0, "Member 'UDCReligionKillWidget::KillCountRebellion' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, KillCountTotal) == 0x0003D8, "Member 'UDCReligionKillWidget::KillCountTotal' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, ReligionImageBrushMapMine) == 0x0003E0, "Member 'UDCReligionKillWidget::ReligionImageBrushMapMine' has a wrong offset!");
static_assert(offsetof(UDCReligionKillWidget, ReligionImageBrushMapEnemy) == 0x000430, "Member 'UDCReligionKillWidget::ReligionImageBrushMapEnemy' has a wrong offset!");

// Class DungeonCrawler.DCAT_MoveWithInputVectorCurve
// 0x00D0 (0x0150 - 0x0080)
class UDCAT_MoveWithInputVectorCurve final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2480[0x20];                                    // 0x0090(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           VelocityVector;                                    // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              VelocityTimeline;                                  // 0x00B8(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UDCAT_MoveWithInputVectorCurve* MoveWithInputVectorCurve(class UGameplayAbility* OwningAbility, const struct FVector& DestLocation, class UCurveVector* InVelocityVector, float DistanceTolerance, bool bShouldTeleportWhenFinished);

	void HandleTimelineFinished();
	void HandleTimelineUpdate(const struct FVector& InVector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_MoveWithInputVectorCurve">();
	}
	static class UDCAT_MoveWithInputVectorCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_MoveWithInputVectorCurve>();
	}
};
static_assert(alignof(UDCAT_MoveWithInputVectorCurve) == 0x000008, "Wrong alignment on UDCAT_MoveWithInputVectorCurve");
static_assert(sizeof(UDCAT_MoveWithInputVectorCurve) == 0x000150, "Wrong size on UDCAT_MoveWithInputVectorCurve");
static_assert(offsetof(UDCAT_MoveWithInputVectorCurve, OnFinish) == 0x000080, "Member 'UDCAT_MoveWithInputVectorCurve::OnFinish' has a wrong offset!");
static_assert(offsetof(UDCAT_MoveWithInputVectorCurve, VelocityVector) == 0x0000B0, "Member 'UDCAT_MoveWithInputVectorCurve::VelocityVector' has a wrong offset!");
static_assert(offsetof(UDCAT_MoveWithInputVectorCurve, VelocityTimeline) == 0x0000B8, "Member 'UDCAT_MoveWithInputVectorCurve::VelocityTimeline' has a wrong offset!");

// Class DungeonCrawler.PerkListWidgetBase
// 0x0028 (0x0380 - 0x0358)
class UPerkListWidgetBase : public UDCWidgetBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LinkedAccountId;                                   // 0x0360(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CheckTargetAccountId;                              // 0x0370(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkListWidgetBase">();
	}
	static class UPerkListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkListWidgetBase>();
	}
};
static_assert(alignof(UPerkListWidgetBase) == 0x000008, "Wrong alignment on UPerkListWidgetBase");
static_assert(sizeof(UPerkListWidgetBase) == 0x000380, "Wrong size on UPerkListWidgetBase");
static_assert(offsetof(UPerkListWidgetBase, AccountLink) == 0x000358, "Member 'UPerkListWidgetBase::AccountLink' has a wrong offset!");
static_assert(offsetof(UPerkListWidgetBase, LinkedAccountId) == 0x000360, "Member 'UPerkListWidgetBase::LinkedAccountId' has a wrong offset!");
static_assert(offsetof(UPerkListWidgetBase, CheckTargetAccountId) == 0x000370, "Member 'UPerkListWidgetBase::CheckTargetAccountId' has a wrong offset!");

// Class DungeonCrawler.DCRewardDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCRewardDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCRewardItemData>              RewardItemArray;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRewardDataAsset">();
	}
	static class UDCRewardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRewardDataAsset>();
	}
};
static_assert(alignof(UDCRewardDataAsset) == 0x000008, "Wrong alignment on UDCRewardDataAsset");
static_assert(sizeof(UDCRewardDataAsset) == 0x000058, "Wrong size on UDCRewardDataAsset");
static_assert(offsetof(UDCRewardDataAsset, RewardItemArray) == 0x000048, "Member 'UDCRewardDataAsset::RewardItemArray' has a wrong offset!");

// Class DungeonCrawler.ClassPerkListWidgetBase
// 0x0038 (0x03B8 - 0x0380)
class UClassPerkListWidgetBase final : public UPerkListWidgetBase
{
public:
	TArray<class UPerkWidget*>                    PerkWidgetArray;                                   // 0x0380(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2482[0x28];                                    // 0x0390(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetSelectedSlotIndex();
	struct FPrimaryAssetId GetSelectedSlotPerkId();
	void OnAddItem();
	void OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint(const struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify& InMsg);
	void OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg);
	void OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg);
	void OnRemoveItem();
	void SetSelectedSlotIndex(int32 InSlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassPerkListWidgetBase">();
	}
	static class UClassPerkListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassPerkListWidgetBase>();
	}
};
static_assert(alignof(UClassPerkListWidgetBase) == 0x000008, "Wrong alignment on UClassPerkListWidgetBase");
static_assert(sizeof(UClassPerkListWidgetBase) == 0x0003B8, "Wrong size on UClassPerkListWidgetBase");
static_assert(offsetof(UClassPerkListWidgetBase, PerkWidgetArray) == 0x000380, "Member 'UClassPerkListWidgetBase::PerkWidgetArray' has a wrong offset!");

// Class DungeonCrawler.PlayWidget
// 0x0188 (0x0610 - 0x0488)
class UPlayWidget final : public UDCCommonActivatableWidgetBase
{
public:
	uint8                                         Pad_2483[0x10];                                    // 0x0488(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLobbyCharacterInfo                    LobbyCharacterData;                                // 0x0498(0x00C8)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAccountLink*                           AccountLink;                                       // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonPopupSWidget*                    WB_CommonPopup_S;                                  // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    StartButton;                                       // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCPlayUserInfoWidget*                  PlayUserInfoMine;                                  // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCPlayUserInfoWidget*                  PlayUserInfoLeft;                                  // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCPlayUserInfoWidget*                  PlayUserInfoRight;                                 // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonListView*                        RecentMatchPlayerList;                             // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2484[0x8];                                     // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCReportPlayerResultPopup> ReportPlayerResultPopupClass;                      // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCMerchantShortcutPopupBase> SquirePopupClass;                                  // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDCMerchantDataAsset>    SquireData;                                        // 0x05B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2485[0x20];                                    // 0x05D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNotRandomPartyMember;                             // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EForceRandomMatchType                         ForceRandomMatchType;                              // 0x05F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableRandomPartyMember;                         // 0x05FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomMatchmakingPolicy;                          // 0x05FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2486[0x4];                                     // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    Btn_SqurieShortCut;                                // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowSquireIndicator;                              // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2487[0x7];                                     // 0x0609(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoTeamRegisterSingle(bool IsRegister);
	void OnCancelButtonClicked();
	void OnChangedMatchingState(const bool IsInMatching);
	void OnClickedDungeonSelect();
	void OnDungeonMatchEvent(EDungeonMatchState InDungeonMatchState);
	void OnDungeonSelect(EMatchMode InMatchMode, EGameType GameType);
	void OnDungeonSelectListPopupOpen(const struct FDungeonSelectParam& InDungeonSelectParam);
	void OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce);
	void OnInvitePartyButtonClicked(const EWidgetPartyUserLocate& UserLocate);
	void OnKarmaButtonClicked();
	void OnLeaderUpdated(bool IsPartyLeader);
	void OnMatchCancel();
	void OnMatchStart(bool InbCanCancel, float InMatchCancelDelayTimeSec);
	void OnNotRandomPartyMemberChecked(bool bInNotRandomPartyMember);
	void OnPartyExitButtonClicked();
	void OnPartyReadyButtonClicked(bool IsReady);
	void OnPlayPartyReadyStateChanged(bool bMine, bool bReady);
	void OnPlayPartyUserInfo(const struct FPlayPartyUserInfo& PlayPartyUserInfo);
	void OnPlayPartyUserInfoData(const struct FPlayPartyUserInfoData& NewValue, const struct FPlayPartyUserInfoData& OldValue);
	void OnPopupSWidgetInvitePartyRequest(class UPopupDataBase* PopupData, const class FString& ReturnAccountID);
	void OnPopupSWidgetInvitePartyResponse(EPopupResult PopupResult, const class FString& ReturnAccountID);
	void OnQuestLogButtonClicked();
	void OnRegionDataSet(int32 RegionIndex);
	void OnRegionSelected(const int32 RegionIndex);
	void OnSqurieShortCutButtonClicked();
	void OnStartButtonClicked();
	void OnUpdateLobbyCharacterData(const struct FLobbyCharacterInfo& LobbyInfo);
	void UpdateQuestLogAvailable(bool bIsAvailable);
	void UpdateRandomPartyMember();

	bool IsDuo() const;
	bool IsSolo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayWidget">();
	}
	static class UPlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayWidget>();
	}
};
static_assert(alignof(UPlayWidget) == 0x000008, "Wrong alignment on UPlayWidget");
static_assert(sizeof(UPlayWidget) == 0x000610, "Wrong size on UPlayWidget");
static_assert(offsetof(UPlayWidget, LobbyCharacterData) == 0x000498, "Member 'UPlayWidget::LobbyCharacterData' has a wrong offset!");
static_assert(offsetof(UPlayWidget, AccountLink) == 0x000560, "Member 'UPlayWidget::AccountLink' has a wrong offset!");
static_assert(offsetof(UPlayWidget, WB_CommonPopup_S) == 0x000568, "Member 'UPlayWidget::WB_CommonPopup_S' has a wrong offset!");
static_assert(offsetof(UPlayWidget, StartButton) == 0x000570, "Member 'UPlayWidget::StartButton' has a wrong offset!");
static_assert(offsetof(UPlayWidget, PlayUserInfoMine) == 0x000578, "Member 'UPlayWidget::PlayUserInfoMine' has a wrong offset!");
static_assert(offsetof(UPlayWidget, PlayUserInfoLeft) == 0x000580, "Member 'UPlayWidget::PlayUserInfoLeft' has a wrong offset!");
static_assert(offsetof(UPlayWidget, PlayUserInfoRight) == 0x000588, "Member 'UPlayWidget::PlayUserInfoRight' has a wrong offset!");
static_assert(offsetof(UPlayWidget, RecentMatchPlayerList) == 0x000590, "Member 'UPlayWidget::RecentMatchPlayerList' has a wrong offset!");
static_assert(offsetof(UPlayWidget, ReportPlayerResultPopupClass) == 0x0005A0, "Member 'UPlayWidget::ReportPlayerResultPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayWidget, SquirePopupClass) == 0x0005A8, "Member 'UPlayWidget::SquirePopupClass' has a wrong offset!");
static_assert(offsetof(UPlayWidget, SquireData) == 0x0005B0, "Member 'UPlayWidget::SquireData' has a wrong offset!");
static_assert(offsetof(UPlayWidget, bNotRandomPartyMember) == 0x0005F8, "Member 'UPlayWidget::bNotRandomPartyMember' has a wrong offset!");
static_assert(offsetof(UPlayWidget, ForceRandomMatchType) == 0x0005F9, "Member 'UPlayWidget::ForceRandomMatchType' has a wrong offset!");
static_assert(offsetof(UPlayWidget, bDisableRandomPartyMember) == 0x0005FA, "Member 'UPlayWidget::bDisableRandomPartyMember' has a wrong offset!");
static_assert(offsetof(UPlayWidget, bRandomMatchmakingPolicy) == 0x0005FB, "Member 'UPlayWidget::bRandomMatchmakingPolicy' has a wrong offset!");
static_assert(offsetof(UPlayWidget, Btn_SqurieShortCut) == 0x000600, "Member 'UPlayWidget::Btn_SqurieShortCut' has a wrong offset!");
static_assert(offsetof(UPlayWidget, bShowSquireIndicator) == 0x000608, "Member 'UPlayWidget::bShowSquireIndicator' has a wrong offset!");

// Class DungeonCrawler.DCControlWidgetBase
// 0x0138 (0x0490 - 0x0358)
class UDCControlWidgetBase : public UDCWidgetBase
{
public:
	bool                                          bCanClick;                                         // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanDrag;                                          // 0x0359(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248B[0x136];                                   // 0x035A(0x0136)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCControlWidgetBase">();
	}
	static class UDCControlWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCControlWidgetBase>();
	}
};
static_assert(alignof(UDCControlWidgetBase) == 0x000008, "Wrong alignment on UDCControlWidgetBase");
static_assert(sizeof(UDCControlWidgetBase) == 0x000490, "Wrong size on UDCControlWidgetBase");
static_assert(offsetof(UDCControlWidgetBase, bCanClick) == 0x000358, "Member 'UDCControlWidgetBase::bCanClick' has a wrong offset!");
static_assert(offsetof(UDCControlWidgetBase, bCanDrag) == 0x000359, "Member 'UDCControlWidgetBase::bCanDrag' has a wrong offset!");

// Class DungeonCrawler.DCItemWidgetBase
// 0x01D0 (0x0660 - 0x0490)
class UDCItemWidgetBase : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_248C[0x30];                                    // 0x0490(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowInnerCount;                                   // 0x04C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248D[0x7];                                     // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCItemInfo                            ItemInfo;                                          // 0x04C8(0x0168)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Count;                                             // 0x0630(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReadOnly;                                       // 0x0634(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocked;                                         // 0x0635(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChecked;                                        // 0x0636(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoading;                                        // 0x0637(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemDataAsset*                       DataAsset;                                         // 0x0638(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtDataItem*                           ArtData;                                           // 0x0640(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSet;                                              // 0x0648(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248E[0x17];                                    // 0x0649(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemWidgetBase">();
	}
	static class UDCItemWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemWidgetBase>();
	}
};
static_assert(alignof(UDCItemWidgetBase) == 0x000008, "Wrong alignment on UDCItemWidgetBase");
static_assert(sizeof(UDCItemWidgetBase) == 0x000660, "Wrong size on UDCItemWidgetBase");
static_assert(offsetof(UDCItemWidgetBase, bShowInnerCount) == 0x0004C0, "Member 'UDCItemWidgetBase::bShowInnerCount' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, ItemInfo) == 0x0004C8, "Member 'UDCItemWidgetBase::ItemInfo' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, Count) == 0x000630, "Member 'UDCItemWidgetBase::Count' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, bIsReadOnly) == 0x000634, "Member 'UDCItemWidgetBase::bIsReadOnly' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, bIsLocked) == 0x000635, "Member 'UDCItemWidgetBase::bIsLocked' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, bIsChecked) == 0x000636, "Member 'UDCItemWidgetBase::bIsChecked' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, bIsLoading) == 0x000637, "Member 'UDCItemWidgetBase::bIsLoading' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, DataAsset) == 0x000638, "Member 'UDCItemWidgetBase::DataAsset' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, ArtData) == 0x000640, "Member 'UDCItemWidgetBase::ArtData' has a wrong offset!");
static_assert(offsetof(UDCItemWidgetBase, bSet) == 0x000648, "Member 'UDCItemWidgetBase::bSet' has a wrong offset!");

// Class DungeonCrawler.DCItemCommonWidget
// 0x0058 (0x06B8 - 0x0660)
class UDCItemCommonWidget : public UDCItemWidgetBase
{
public:
	TSubclassOf<class UDCItemTooltipWidget>       ItemTooltipWidgetClass;                            // 0x0660(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCSimpleTooltipWidget>     InvalidItemTooltipWidgetClass;                     // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCItemDragVisualWidget>    ItemDragVisualWidgetClass;                         // 0x0670(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemTooltipWidget*                   ItemTooltipWidget;                                 // 0x0678(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSimpleTooltipWidget*                 InvalidItemTooltipWidget;                          // 0x0680(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemDragVisualWidget*                ItemDragVisualWidget;                              // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDragging;                                       // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248F[0x7];                                     // 0x0691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ItemImage;                                         // 0x0698(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGoldContainer;                                  // 0x06A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2490[0x17];                                    // 0x06A1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidget* GetTooltipWidget();
	void OnDragDropFinished(class UDragDropOperation* Operation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemCommonWidget">();
	}
	static class UDCItemCommonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemCommonWidget>();
	}
};
static_assert(alignof(UDCItemCommonWidget) == 0x000008, "Wrong alignment on UDCItemCommonWidget");
static_assert(sizeof(UDCItemCommonWidget) == 0x0006B8, "Wrong size on UDCItemCommonWidget");
static_assert(offsetof(UDCItemCommonWidget, ItemTooltipWidgetClass) == 0x000660, "Member 'UDCItemCommonWidget::ItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, InvalidItemTooltipWidgetClass) == 0x000668, "Member 'UDCItemCommonWidget::InvalidItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, ItemDragVisualWidgetClass) == 0x000670, "Member 'UDCItemCommonWidget::ItemDragVisualWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, ItemTooltipWidget) == 0x000678, "Member 'UDCItemCommonWidget::ItemTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, InvalidItemTooltipWidget) == 0x000680, "Member 'UDCItemCommonWidget::InvalidItemTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, ItemDragVisualWidget) == 0x000688, "Member 'UDCItemCommonWidget::ItemDragVisualWidget' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, bIsDragging) == 0x000690, "Member 'UDCItemCommonWidget::bIsDragging' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, ItemImage) == 0x000698, "Member 'UDCItemCommonWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(UDCItemCommonWidget, bIsGoldContainer) == 0x0006A0, "Member 'UDCItemCommonWidget::bIsGoldContainer' has a wrong offset!");

// Class DungeonCrawler.DCBagItemWidget
// 0x0008 (0x06C0 - 0x06B8)
class UDCBagItemWidget final : public UDCItemCommonWidget
{
public:
	class USizeBox*                               ItemSizeBox;                                       // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsGold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCBagItemWidget">();
	}
	static class UDCBagItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCBagItemWidget>();
	}
};
static_assert(alignof(UDCBagItemWidget) == 0x000008, "Wrong alignment on UDCBagItemWidget");
static_assert(sizeof(UDCBagItemWidget) == 0x0006C0, "Wrong size on UDCBagItemWidget");
static_assert(offsetof(UDCBagItemWidget, ItemSizeBox) == 0x0006B8, "Member 'UDCBagItemWidget::ItemSizeBox' has a wrong offset!");

// Class DungeonCrawler.ClassRankIconBase
// 0x0000 (0x0358 - 0x0358)
class UClassRankIconBase : public UDCWidgetBase
{
public:
	void ClearRankData();
	void SetClassIcon(const class UTexture2D* InClassIconTex);
	void SetRankData(const class UDCLeaderboardRankDataAsset* InLeaderboardRankData);
	void SetRankGroupData(const class UDCLeaderboardRankGroupDataAsset* InLeaderboardRankGroupData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassRankIconBase">();
	}
	static class UClassRankIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassRankIconBase>();
	}
};
static_assert(alignof(UClassRankIconBase) == 0x000008, "Wrong alignment on UClassRankIconBase");
static_assert(sizeof(UClassRankIconBase) == 0x000358, "Wrong size on UClassRankIconBase");

// Class DungeonCrawler.DCReportPlayerResultPopupData
// 0x0030 (0x0060 - 0x0030)
class UDCReportPlayerResultPopupData final : public UPopupDataBase
{
public:
	class FText                                   PermanentBanListText;                              // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TemporaryBanListText;                              // 0x0048(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerResultPopupData">();
	}
	static class UDCReportPlayerResultPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerResultPopupData>();
	}
};
static_assert(alignof(UDCReportPlayerResultPopupData) == 0x000008, "Wrong alignment on UDCReportPlayerResultPopupData");
static_assert(sizeof(UDCReportPlayerResultPopupData) == 0x000060, "Wrong size on UDCReportPlayerResultPopupData");
static_assert(offsetof(UDCReportPlayerResultPopupData, PermanentBanListText) == 0x000030, "Member 'UDCReportPlayerResultPopupData::PermanentBanListText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerResultPopupData, TemporaryBanListText) == 0x000048, "Member 'UDCReportPlayerResultPopupData::TemporaryBanListText' has a wrong offset!");

// Class DungeonCrawler.ClassSelectAttributeItemWidgetData
// 0x0010 (0x0038 - 0x0028)
class UClassSelectAttributeItemWidgetData final : public UObject
{
public:
	struct FGameplayEffectDescData                AttrributeEffectDescData;                          // 0x0028(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2491[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectAttributeItemWidgetData">();
	}
	static class UClassSelectAttributeItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectAttributeItemWidgetData>();
	}
};
static_assert(alignof(UClassSelectAttributeItemWidgetData) == 0x000008, "Wrong alignment on UClassSelectAttributeItemWidgetData");
static_assert(sizeof(UClassSelectAttributeItemWidgetData) == 0x000038, "Wrong size on UClassSelectAttributeItemWidgetData");
static_assert(offsetof(UClassSelectAttributeItemWidgetData, AttrributeEffectDescData) == 0x000028, "Member 'UClassSelectAttributeItemWidgetData::AttrributeEffectDescData' has a wrong offset!");

// Class DungeonCrawler.ClassSelectAttributeItemWidget
// 0x0008 (0x0360 - 0x0358)
class UClassSelectAttributeItemWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2492[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectAttributeItemWidget">();
	}
	static class UClassSelectAttributeItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectAttributeItemWidget>();
	}
};
static_assert(alignof(UClassSelectAttributeItemWidget) == 0x000008, "Wrong alignment on UClassSelectAttributeItemWidget");
static_assert(sizeof(UClassSelectAttributeItemWidget) == 0x000360, "Wrong size on UClassSelectAttributeItemWidget");

// Class DungeonCrawler.DCAT_WaitMovementModeChange
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WaitMovementModeChange final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnMovementModeChanged;                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2493[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitMovementModeChange* WaitMovementModeChange(class UGameplayAbility* OwningAbility, EMovementMode NewMode, bool bOnlyTriggerOnce);

	void OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitMovementModeChange">();
	}
	static class UDCAT_WaitMovementModeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitMovementModeChange>();
	}
};
static_assert(alignof(UDCAT_WaitMovementModeChange) == 0x000008, "Wrong alignment on UDCAT_WaitMovementModeChange");
static_assert(sizeof(UDCAT_WaitMovementModeChange) == 0x0000A0, "Wrong size on UDCAT_WaitMovementModeChange");
static_assert(offsetof(UDCAT_WaitMovementModeChange, OnMovementModeChanged) == 0x000080, "Member 'UDCAT_WaitMovementModeChange::OnMovementModeChanged' has a wrong offset!");

// Class DungeonCrawler.DCGiftCodePopupBase
// 0x0058 (0x04E8 - 0x0490)
class UDCGiftCodePopupBase final : public UCommonPopupBase
{
public:
	class UDCGiftCodeEditableText*                EnterCode_1;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGiftCodeEditableText*                EnterCode_2;                                       // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGiftCodeEditableText*                EnterCode_3;                                       // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGiftCodeEditableText*                EnterCode_4;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Close;                                     // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Accept;                                    // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2496[0x8];                                     // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCGiftCodeEditableText*>        EnterCodeList;                                     // 0x04C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDCGiftCodePopupData*                   GiftCodePopupData;                                 // 0x04D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2497[0x8];                                     // 0x04E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	ESlateVisibility GetWarningTextVisibility();
	void MoveToNextCodeBlock(const class FText& InRemainText, const int32& InCodeBlockIndex);
	void MoveToPrevCodeBlock(const int32& InCodeBlockIndex);
	void OnAcceptButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGiftCodePopupBase">();
	}
	static class UDCGiftCodePopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGiftCodePopupBase>();
	}
};
static_assert(alignof(UDCGiftCodePopupBase) == 0x000008, "Wrong alignment on UDCGiftCodePopupBase");
static_assert(sizeof(UDCGiftCodePopupBase) == 0x0004E8, "Wrong size on UDCGiftCodePopupBase");
static_assert(offsetof(UDCGiftCodePopupBase, EnterCode_1) == 0x000490, "Member 'UDCGiftCodePopupBase::EnterCode_1' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, EnterCode_2) == 0x000498, "Member 'UDCGiftCodePopupBase::EnterCode_2' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, EnterCode_3) == 0x0004A0, "Member 'UDCGiftCodePopupBase::EnterCode_3' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, EnterCode_4) == 0x0004A8, "Member 'UDCGiftCodePopupBase::EnterCode_4' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, Btn_Two_Close) == 0x0004B0, "Member 'UDCGiftCodePopupBase::Btn_Two_Close' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, Btn_Two_Accept) == 0x0004B8, "Member 'UDCGiftCodePopupBase::Btn_Two_Accept' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, EnterCodeList) == 0x0004C8, "Member 'UDCGiftCodePopupBase::EnterCodeList' has a wrong offset!");
static_assert(offsetof(UDCGiftCodePopupBase, GiftCodePopupData) == 0x0004D8, "Member 'UDCGiftCodePopupBase::GiftCodePopupData' has a wrong offset!");

// Class DungeonCrawler.ClassSelectItemWidgetData
// 0x0008 (0x0030 - 0x0028)
class UClassSelectItemWidgetData final : public UObject
{
public:
	EDCCharacterClass                             CharacterClass;                                    // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x002A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2499[0x5];                                     // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectItemWidgetData">();
	}
	static class UClassSelectItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectItemWidgetData>();
	}
};
static_assert(alignof(UClassSelectItemWidgetData) == 0x000008, "Wrong alignment on UClassSelectItemWidgetData");
static_assert(sizeof(UClassSelectItemWidgetData) == 0x000030, "Wrong size on UClassSelectItemWidgetData");
static_assert(offsetof(UClassSelectItemWidgetData, CharacterClass) == 0x000028, "Member 'UClassSelectItemWidgetData::CharacterClass' has a wrong offset!");
static_assert(offsetof(UClassSelectItemWidgetData, Gender) == 0x000029, "Member 'UClassSelectItemWidgetData::Gender' has a wrong offset!");
static_assert(offsetof(UClassSelectItemWidgetData, bSelected) == 0x00002A, "Member 'UClassSelectItemWidgetData::bSelected' has a wrong offset!");

// Class DungeonCrawler.DCReligionKillPopupData
// 0x0010 (0x0040 - 0x0030)
class UDCReligionKillPopupData final : public UPopupDataBase
{
public:
	TArray<struct FDCReligionKillnfo>             ReligionKillInfo;                                  // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionKillPopupData">();
	}
	static class UDCReligionKillPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionKillPopupData>();
	}
};
static_assert(alignof(UDCReligionKillPopupData) == 0x000008, "Wrong alignment on UDCReligionKillPopupData");
static_assert(sizeof(UDCReligionKillPopupData) == 0x000040, "Wrong size on UDCReligionKillPopupData");
static_assert(offsetof(UDCReligionKillPopupData, ReligionKillInfo) == 0x000030, "Member 'UDCReligionKillPopupData::ReligionKillInfo' has a wrong offset!");

// Class DungeonCrawler.DCInventoryControllerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDCInventoryControllerComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_249A[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x00B8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryControllerComponent">();
	}
	static class UDCInventoryControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryControllerComponent>();
	}
};
static_assert(alignof(UDCInventoryControllerComponent) == 0x000008, "Wrong alignment on UDCInventoryControllerComponent");
static_assert(sizeof(UDCInventoryControllerComponent) == 0x0000C0, "Wrong size on UDCInventoryControllerComponent");
static_assert(offsetof(UDCInventoryControllerComponent, InventoryComponent) == 0x0000B8, "Member 'UDCInventoryControllerComponent::InventoryComponent' has a wrong offset!");

// Class DungeonCrawler.ClassSelectItemWidget
// 0x0030 (0x0388 - 0x0358)
class UClassSelectItemWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_249B[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Portrait;                                          // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0380(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249C[0x7];                                     // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectItemWidget">();
	}
	static class UClassSelectItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectItemWidget>();
	}
};
static_assert(alignof(UClassSelectItemWidget) == 0x000008, "Wrong alignment on UClassSelectItemWidget");
static_assert(sizeof(UClassSelectItemWidget) == 0x000388, "Wrong size on UClassSelectItemWidget");
static_assert(offsetof(UClassSelectItemWidget, Title) == 0x000360, "Member 'UClassSelectItemWidget::Title' has a wrong offset!");
static_assert(offsetof(UClassSelectItemWidget, Portrait) == 0x000378, "Member 'UClassSelectItemWidget::Portrait' has a wrong offset!");
static_assert(offsetof(UClassSelectItemWidget, bSelected) == 0x000380, "Member 'UClassSelectItemWidget::bSelected' has a wrong offset!");

// Class DungeonCrawler.DCCrossPlatformLinkPopupData
// 0x0000 (0x0030 - 0x0030)
class UDCCrossPlatformLinkPopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCrossPlatformLinkPopupData">();
	}
	static class UDCCrossPlatformLinkPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCrossPlatformLinkPopupData>();
	}
};
static_assert(alignof(UDCCrossPlatformLinkPopupData) == 0x000008, "Wrong alignment on UDCCrossPlatformLinkPopupData");
static_assert(sizeof(UDCCrossPlatformLinkPopupData) == 0x000030, "Wrong size on UDCCrossPlatformLinkPopupData");

// Class DungeonCrawler.ClassSelectPerkItemWidgetData
// 0x0010 (0x0038 - 0x0028)
class UClassSelectPerkItemWidgetData final : public UObject
{
public:
	class FString                                 PerkId;                                            // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectPerkItemWidgetData">();
	}
	static class UClassSelectPerkItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectPerkItemWidgetData>();
	}
};
static_assert(alignof(UClassSelectPerkItemWidgetData) == 0x000008, "Wrong alignment on UClassSelectPerkItemWidgetData");
static_assert(sizeof(UClassSelectPerkItemWidgetData) == 0x000038, "Wrong size on UClassSelectPerkItemWidgetData");
static_assert(offsetof(UClassSelectPerkItemWidgetData, PerkId) == 0x000028, "Member 'UClassSelectPerkItemWidgetData::PerkId' has a wrong offset!");

// Class DungeonCrawler.DCReportPlayerChecklistSlotWidget
// 0x0060 (0x0320 - 0x02C0)
class UDCReportPlayerChecklistSlotWidget final : public UUserWidget
{
public:
	uint8                                         Pad_249D[0x18];                                    // 0x02C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckBox*                              ReportCheckBox;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249E[0x8];                                     // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReportCategoryTitleText;                           // 0x02E8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReportCategoryDetailText;                          // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_249F[0x8];                                     // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetReportCheckBoxEnabled();
	ESlateVisibility GetReportedCategoryVisibility();
	void HandleChangedCheckState(bool bNewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerChecklistSlotWidget">();
	}
	static class UDCReportPlayerChecklistSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerChecklistSlotWidget>();
	}
};
static_assert(alignof(UDCReportPlayerChecklistSlotWidget) == 0x000008, "Wrong alignment on UDCReportPlayerChecklistSlotWidget");
static_assert(sizeof(UDCReportPlayerChecklistSlotWidget) == 0x000320, "Wrong size on UDCReportPlayerChecklistSlotWidget");
static_assert(offsetof(UDCReportPlayerChecklistSlotWidget, ReportCheckBox) == 0x0002D8, "Member 'UDCReportPlayerChecklistSlotWidget::ReportCheckBox' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerChecklistSlotWidget, ReportCategoryTitleText) == 0x0002E8, "Member 'UDCReportPlayerChecklistSlotWidget::ReportCategoryTitleText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerChecklistSlotWidget, ReportCategoryDetailText) == 0x000300, "Member 'UDCReportPlayerChecklistSlotWidget::ReportCategoryDetailText' has a wrong offset!");

// Class DungeonCrawler.DCAT_TickInvoke
// 0x0028 (0x00A8 - 0x0080)
class UDCAT_TickInvoke final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTickEvent;                                       // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A0[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnForceFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_TickInvoke">();
	}
	static class UDCAT_TickInvoke* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_TickInvoke>();
	}
};
static_assert(alignof(UDCAT_TickInvoke) == 0x000008, "Wrong alignment on UDCAT_TickInvoke");
static_assert(sizeof(UDCAT_TickInvoke) == 0x0000A8, "Wrong size on UDCAT_TickInvoke");
static_assert(offsetof(UDCAT_TickInvoke, OnFinish) == 0x000080, "Member 'UDCAT_TickInvoke::OnFinish' has a wrong offset!");
static_assert(offsetof(UDCAT_TickInvoke, OnTickEvent) == 0x000090, "Member 'UDCAT_TickInvoke::OnTickEvent' has a wrong offset!");

// Class DungeonCrawler.ClassSelectPerkItemWidget
// 0x0008 (0x0360 - 0x0358)
class UClassSelectPerkItemWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_24A1[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectPerkItemWidget">();
	}
	static class UClassSelectPerkItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectPerkItemWidget>();
	}
};
static_assert(alignof(UClassSelectPerkItemWidget) == 0x000008, "Wrong alignment on UClassSelectPerkItemWidget");
static_assert(sizeof(UClassSelectPerkItemWidget) == 0x000360, "Wrong size on UClassSelectPerkItemWidget");

// Class DungeonCrawler.ComboBoxWidget
// 0x0080 (0x0368 - 0x02E8)
class UComboBoxWidget : public UCommonUserWidget
{
public:
	class UButton*                                ComboButton;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ComboItemHolder;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ComboListView;                                     // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlaceHolderText;                                   // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UObject*                                LastSelectedItem;                                  // 0x0318(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        PreSelectedItems;                                  // 0x0320(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        CurrentSelectionItems;                             // 0x0330(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ESelectionMode                                SelectionMode;                                     // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnSelected;                                       // 0x0341(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A2[0x6];                                     // 0x0342(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ComboBoxItemSelectedDelegate;                      // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClearSelectionDelegate;                            // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddItem(class UObject* InItem);
	void ClearItems();
	class UObject* GetSelectedItem();
	void OnComboButtonPressed();
	void OnComboItemSelected(class UObject* InItem);
	void RegenerateAllEntries();
	void RemoveItem(class UObject* InItem);
	void SetPlaceHolderText(const class FText& InText);
	void SetSelectedIndex(int32 InIndex);

	int32 GetIndexForItem(const class UObject* InItem) const;
	int32 GetNumItems() const;
	bool IsItemSelected(class UObject* InItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBoxWidget">();
	}
	static class UComboBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBoxWidget>();
	}
};
static_assert(alignof(UComboBoxWidget) == 0x000008, "Wrong alignment on UComboBoxWidget");
static_assert(sizeof(UComboBoxWidget) == 0x000368, "Wrong size on UComboBoxWidget");
static_assert(offsetof(UComboBoxWidget, ComboButton) == 0x0002E8, "Member 'UComboBoxWidget::ComboButton' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, ComboItemHolder) == 0x0002F0, "Member 'UComboBoxWidget::ComboItemHolder' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, ComboListView) == 0x0002F8, "Member 'UComboBoxWidget::ComboListView' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, PlaceHolderText) == 0x000300, "Member 'UComboBoxWidget::PlaceHolderText' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, LastSelectedItem) == 0x000318, "Member 'UComboBoxWidget::LastSelectedItem' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, PreSelectedItems) == 0x000320, "Member 'UComboBoxWidget::PreSelectedItems' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, CurrentSelectionItems) == 0x000330, "Member 'UComboBoxWidget::CurrentSelectionItems' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, SelectionMode) == 0x000340, "Member 'UComboBoxWidget::SelectionMode' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, bUnSelected) == 0x000341, "Member 'UComboBoxWidget::bUnSelected' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, ComboBoxItemSelectedDelegate) == 0x000348, "Member 'UComboBoxWidget::ComboBoxItemSelectedDelegate' has a wrong offset!");
static_assert(offsetof(UComboBoxWidget, ClearSelectionDelegate) == 0x000358, "Member 'UComboBoxWidget::ClearSelectionDelegate' has a wrong offset!");

// Class DungeonCrawler.DCSearchableComboBoxWidget
// 0x0050 (0x03B8 - 0x0368)
class UDCSearchableComboBoxWidget final : public UComboBoxWidget
{
public:
	class UEditableText*                          EditableSearchText;                                // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    RefreshButton;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   FilterTitleText;                                   // 0x0378(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   MultiSelectText;                                   // 0x0390(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCSearchableComboBoxWidgetDataBase*> ComboBoxListItemArray;                             // 0x03A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void RefreshSelections();
	void RegenerateListItems(const class FText& FindFilter);
	void ResetSearchText(class UObject* SelectedItem);
	void UpdateFilterTitle(class UObject* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSearchableComboBoxWidget">();
	}
	static class UDCSearchableComboBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSearchableComboBoxWidget>();
	}
};
static_assert(alignof(UDCSearchableComboBoxWidget) == 0x000008, "Wrong alignment on UDCSearchableComboBoxWidget");
static_assert(sizeof(UDCSearchableComboBoxWidget) == 0x0003B8, "Wrong size on UDCSearchableComboBoxWidget");
static_assert(offsetof(UDCSearchableComboBoxWidget, EditableSearchText) == 0x000368, "Member 'UDCSearchableComboBoxWidget::EditableSearchText' has a wrong offset!");
static_assert(offsetof(UDCSearchableComboBoxWidget, RefreshButton) == 0x000370, "Member 'UDCSearchableComboBoxWidget::RefreshButton' has a wrong offset!");
static_assert(offsetof(UDCSearchableComboBoxWidget, FilterTitleText) == 0x000378, "Member 'UDCSearchableComboBoxWidget::FilterTitleText' has a wrong offset!");
static_assert(offsetof(UDCSearchableComboBoxWidget, MultiSelectText) == 0x000390, "Member 'UDCSearchableComboBoxWidget::MultiSelectText' has a wrong offset!");
static_assert(offsetof(UDCSearchableComboBoxWidget, ComboBoxListItemArray) == 0x0003A8, "Member 'UDCSearchableComboBoxWidget::ComboBoxListItemArray' has a wrong offset!");

// Class DungeonCrawler.ClassSelectWidget
// 0x0028 (0x0380 - 0x0358)
class UClassSelectWidget final : public UDCWidgetBase
{
public:
	class UTileView*                              ClassSelectTileView;                               // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              ClassAttributeTileView;                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ClassPerkTileView;                                 // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ClassSelectButton;                                 // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCCharacterClass                             CharacterClass;                                    // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCGender                                     Gender;                                            // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A5[0x6];                                     // 0x037A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClassSelectButtonClicked();
	void OnGenderClicked(const EDCGender InGender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSelectWidget">();
	}
	static class UClassSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSelectWidget>();
	}
};
static_assert(alignof(UClassSelectWidget) == 0x000008, "Wrong alignment on UClassSelectWidget");
static_assert(sizeof(UClassSelectWidget) == 0x000380, "Wrong size on UClassSelectWidget");
static_assert(offsetof(UClassSelectWidget, ClassSelectTileView) == 0x000358, "Member 'UClassSelectWidget::ClassSelectTileView' has a wrong offset!");
static_assert(offsetof(UClassSelectWidget, ClassAttributeTileView) == 0x000360, "Member 'UClassSelectWidget::ClassAttributeTileView' has a wrong offset!");
static_assert(offsetof(UClassSelectWidget, ClassPerkTileView) == 0x000368, "Member 'UClassSelectWidget::ClassPerkTileView' has a wrong offset!");
static_assert(offsetof(UClassSelectWidget, ClassSelectButton) == 0x000370, "Member 'UClassSelectWidget::ClassSelectButton' has a wrong offset!");
static_assert(offsetof(UClassSelectWidget, CharacterClass) == 0x000378, "Member 'UClassSelectWidget::CharacterClass' has a wrong offset!");
static_assert(offsetof(UClassSelectWidget, Gender) == 0x000379, "Member 'UClassSelectWidget::Gender' has a wrong offset!");

// Class DungeonCrawler.DCReportSystem
// 0x0018 (0x0040 - 0x0028)
class UDCReportSystem final : public UObject
{
public:
	uint8                                         Pad_24A6[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USentrySubsystem*                       SentrySubsystem;                                   // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USentryUser*                            UserData;                                          // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportSystem">();
	}
	static class UDCReportSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportSystem>();
	}
};
static_assert(alignof(UDCReportSystem) == 0x000008, "Wrong alignment on UDCReportSystem");
static_assert(sizeof(UDCReportSystem) == 0x000040, "Wrong size on UDCReportSystem");
static_assert(offsetof(UDCReportSystem, SentrySubsystem) == 0x000030, "Member 'UDCReportSystem::SentrySubsystem' has a wrong offset!");
static_assert(offsetof(UDCReportSystem, UserData) == 0x000038, "Member 'UDCReportSystem::UserData' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationKnowledge
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationKnowledge final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_24A7[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationKnowledge">();
	}
	static class UDCAttributeModMagnitudeCalculationKnowledge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationKnowledge>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationKnowledge) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationKnowledge");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationKnowledge) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationKnowledge");

// Class DungeonCrawler.DCPlayerCharacterClassComponent
// 0x0008 (0x00A8 - 0x00A0)
class UDCPlayerCharacterClassComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_24A8[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterClassComponent">();
	}
	static class UDCPlayerCharacterClassComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerCharacterClassComponent>();
	}
};
static_assert(alignof(UDCPlayerCharacterClassComponent) == 0x000008, "Wrong alignment on UDCPlayerCharacterClassComponent");
static_assert(sizeof(UDCPlayerCharacterClassComponent) == 0x0000A8, "Wrong size on UDCPlayerCharacterClassComponent");

// Class DungeonCrawler.DCRewardPopupData
// 0x0010 (0x0040 - 0x0030)
class UDCRewardPopupData final : public UPopupDataBase
{
public:
	TArray<struct FDCRewardInfo>                  RewardInfoArray;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRewardPopupData">();
	}
	static class UDCRewardPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRewardPopupData>();
	}
};
static_assert(alignof(UDCRewardPopupData) == 0x000008, "Wrong alignment on UDCRewardPopupData");
static_assert(sizeof(UDCRewardPopupData) == 0x000040, "Wrong size on UDCRewardPopupData");
static_assert(offsetof(UDCRewardPopupData, RewardInfoArray) == 0x000030, "Member 'UDCRewardPopupData::RewardInfoArray' has a wrong offset!");

// Class DungeonCrawler.ClassShapeShiftComponent
// 0x0080 (0x0128 - 0x00A8)
class UClassShapeShiftComponent final : public UDCPlayerCharacterClassComponent
{
public:
	uint8                                         Pad_24A9[0x70];                                    // 0x00A8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FShapeShiftData>                ShapeShiftDatas;                                   // 0x0118(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnRep_ShapeShiftDatas();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassShapeShiftComponent">();
	}
	static class UClassShapeShiftComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassShapeShiftComponent>();
	}
};
static_assert(alignof(UClassShapeShiftComponent) == 0x000008, "Wrong alignment on UClassShapeShiftComponent");
static_assert(sizeof(UClassShapeShiftComponent) == 0x000128, "Wrong size on UClassShapeShiftComponent");
static_assert(offsetof(UClassShapeShiftComponent, ShapeShiftDatas) == 0x000118, "Member 'UClassShapeShiftComponent::ShapeShiftDatas' has a wrong offset!");

// Class DungeonCrawler.ClassShapeShiftEquippedWidget
// 0x0000 (0x0488 - 0x0488)
class UClassShapeShiftEquippedWidget final : public UDCCommonActivatableWidgetBase
{
public:
	void OnAddItem();
	void OnRemoveItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassShapeShiftEquippedWidget">();
	}
	static class UClassShapeShiftEquippedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassShapeShiftEquippedWidget>();
	}
};
static_assert(alignof(UClassShapeShiftEquippedWidget) == 0x000008, "Wrong alignment on UClassShapeShiftEquippedWidget");
static_assert(sizeof(UClassShapeShiftEquippedWidget) == 0x000488, "Wrong size on UClassShapeShiftEquippedWidget");

// Class DungeonCrawler.DCHUD
// 0x0010 (0x0398 - 0x0388)
class ADCHUD : public AHUD
{
public:
	TSubclassOf<class UUserWidget>                HUDWidgetClass;                                    // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            HUDWidget;                                         // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCHUD">();
	}
	static class ADCHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCHUD>();
	}
};
static_assert(alignof(ADCHUD) == 0x000008, "Wrong alignment on ADCHUD");
static_assert(sizeof(ADCHUD) == 0x000398, "Wrong size on ADCHUD");
static_assert(offsetof(ADCHUD, HUDWidgetClass) == 0x000388, "Member 'ADCHUD::HUDWidgetClass' has a wrong offset!");
static_assert(offsetof(ADCHUD, HUDWidget) == 0x000390, "Member 'ADCHUD::HUDWidget' has a wrong offset!");

// Class DungeonCrawler.DCIngameHUD
// 0x0058 (0x03F0 - 0x0398)
class ADCIngameHUD final : public ADCHUD
{
public:
	TSubclassOf<class UUserWidget>                LocalTestWidgetClass;                              // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                SpectatorLoadingScreenClass;                       // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            LocalTestWidget;                                   // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            SpectatorLoadingScreen;                            // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADCCaptureStudioActor>      InventoryCaptureStudioActorClass;                  // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCCaptureStudioActor*                  InventoryCaptureStudioActor;                       // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24AA[0x18];                                    // 0x03C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                PauseScreenClass;                                  // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PauseScreenWidget;                                 // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIngameHUD">();
	}
	static class ADCIngameHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCIngameHUD>();
	}
};
static_assert(alignof(ADCIngameHUD) == 0x000008, "Wrong alignment on ADCIngameHUD");
static_assert(sizeof(ADCIngameHUD) == 0x0003F0, "Wrong size on ADCIngameHUD");
static_assert(offsetof(ADCIngameHUD, LocalTestWidgetClass) == 0x000398, "Member 'ADCIngameHUD::LocalTestWidgetClass' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, SpectatorLoadingScreenClass) == 0x0003A0, "Member 'ADCIngameHUD::SpectatorLoadingScreenClass' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, LocalTestWidget) == 0x0003A8, "Member 'ADCIngameHUD::LocalTestWidget' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, SpectatorLoadingScreen) == 0x0003B0, "Member 'ADCIngameHUD::SpectatorLoadingScreen' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, InventoryCaptureStudioActorClass) == 0x0003B8, "Member 'ADCIngameHUD::InventoryCaptureStudioActorClass' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, InventoryCaptureStudioActor) == 0x0003C0, "Member 'ADCIngameHUD::InventoryCaptureStudioActor' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, PauseScreenClass) == 0x0003E0, "Member 'ADCIngameHUD::PauseScreenClass' has a wrong offset!");
static_assert(offsetof(ADCIngameHUD, PauseScreenWidget) == 0x0003E8, "Member 'ADCIngameHUD::PauseScreenWidget' has a wrong offset!");

// Class DungeonCrawler.ShapeShiftListWidgetBase
// 0x0040 (0x04E8 - 0x04A8)
class UShapeShiftListWidgetBase : public UGameGroupWidgetBase
{
public:
	class UShapeShiftSlotWidgetBase*              ShapeShiftSlot_1;                                  // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeShiftSlotWidgetBase*              ShapeShiftSlot_2;                                  // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeShiftSlotWidgetBase*              ShapeShiftSlot_3;                                  // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeShiftSlotWidgetBase*              ShapeShiftSlot_4;                                  // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeShiftSlotWidgetBase*              ShapeShiftSlot_5;                                  // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UShapeShiftSlotWidgetBase*>      ShapeShiftSlots;                                   // 0x04D0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EWidgetShapeShiftSlotsType                    WidgetSlotType;                                    // 0x04E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24AB[0x7];                                     // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShapeShiftListWidgetBase">();
	}
	static class UShapeShiftListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShapeShiftListWidgetBase>();
	}
};
static_assert(alignof(UShapeShiftListWidgetBase) == 0x000008, "Wrong alignment on UShapeShiftListWidgetBase");
static_assert(sizeof(UShapeShiftListWidgetBase) == 0x0004E8, "Wrong size on UShapeShiftListWidgetBase");
static_assert(offsetof(UShapeShiftListWidgetBase, ShapeShiftSlot_1) == 0x0004A8, "Member 'UShapeShiftListWidgetBase::ShapeShiftSlot_1' has a wrong offset!");
static_assert(offsetof(UShapeShiftListWidgetBase, ShapeShiftSlot_2) == 0x0004B0, "Member 'UShapeShiftListWidgetBase::ShapeShiftSlot_2' has a wrong offset!");
static_assert(offsetof(UShapeShiftListWidgetBase, ShapeShiftSlot_3) == 0x0004B8, "Member 'UShapeShiftListWidgetBase::ShapeShiftSlot_3' has a wrong offset!");
static_assert(offsetof(UShapeShiftListWidgetBase, ShapeShiftSlot_4) == 0x0004C0, "Member 'UShapeShiftListWidgetBase::ShapeShiftSlot_4' has a wrong offset!");
static_assert(offsetof(UShapeShiftListWidgetBase, ShapeShiftSlot_5) == 0x0004C8, "Member 'UShapeShiftListWidgetBase::ShapeShiftSlot_5' has a wrong offset!");
static_assert(offsetof(UShapeShiftListWidgetBase, ShapeShiftSlots) == 0x0004D0, "Member 'UShapeShiftListWidgetBase::ShapeShiftSlots' has a wrong offset!");
static_assert(offsetof(UShapeShiftListWidgetBase, WidgetSlotType) == 0x0004E0, "Member 'UShapeShiftListWidgetBase::WidgetSlotType' has a wrong offset!");

// Class DungeonCrawler.DCReligionWidget
// 0x0018 (0x04A0 - 0x0488)
class UDCReligionWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UComboBoxWidget*                        SeasonComboBox;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCReligionKillPopup>       ReligionKillPopupClass;                            // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCReligionOfferingCompletePopup> ReligionOfferCompletePopupClass;                   // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnReligionKillDataEvent(const TArray<struct FDCReligionKillnfo>& Info);
	void OnSeasonComboBoxSelected(class UObject* InItem);
	void SetReligionTimer(const struct FReligionRankTimerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionWidget">();
	}
	static class UDCReligionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionWidget>();
	}
};
static_assert(alignof(UDCReligionWidget) == 0x000008, "Wrong alignment on UDCReligionWidget");
static_assert(sizeof(UDCReligionWidget) == 0x0004A0, "Wrong size on UDCReligionWidget");
static_assert(offsetof(UDCReligionWidget, SeasonComboBox) == 0x000488, "Member 'UDCReligionWidget::SeasonComboBox' has a wrong offset!");
static_assert(offsetof(UDCReligionWidget, ReligionKillPopupClass) == 0x000490, "Member 'UDCReligionWidget::ReligionKillPopupClass' has a wrong offset!");
static_assert(offsetof(UDCReligionWidget, ReligionOfferCompletePopupClass) == 0x000498, "Member 'UDCReligionWidget::ReligionOfferCompletePopupClass' has a wrong offset!");

// Class DungeonCrawler.DCInputConfigData
// 0x00A0 (0x00D0 - 0x0030)
class UDCInputConfigData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, class UPlayerMappableInputConfig*> PlayerMappableInputConfigMap;                      // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UDCInputConfig*> InputConfigMap;                                    // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInputConfigData">();
	}
	static class UDCInputConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInputConfigData>();
	}
};
static_assert(alignof(UDCInputConfigData) == 0x000008, "Wrong alignment on UDCInputConfigData");
static_assert(sizeof(UDCInputConfigData) == 0x0000D0, "Wrong size on UDCInputConfigData");
static_assert(offsetof(UDCInputConfigData, PlayerMappableInputConfigMap) == 0x000030, "Member 'UDCInputConfigData::PlayerMappableInputConfigMap' has a wrong offset!");
static_assert(offsetof(UDCInputConfigData, InputConfigMap) == 0x000080, "Member 'UDCInputConfigData::InputConfigMap' has a wrong offset!");

// Class DungeonCrawler.ClassShapeShiftListWidget
// 0x0000 (0x04E8 - 0x04E8)
class UClassShapeShiftListWidget final : public UShapeShiftListWidgetBase
{
public:
	void OnHideEquippableSlot();
	void OnShowEquippableSlot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassShapeShiftListWidget">();
	}
	static class UClassShapeShiftListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassShapeShiftListWidget>();
	}
};
static_assert(alignof(UClassShapeShiftListWidget) == 0x000008, "Wrong alignment on UClassShapeShiftListWidget");
static_assert(sizeof(UClassShapeShiftListWidget) == 0x0004E8, "Wrong size on UClassShapeShiftListWidget");

// Class DungeonCrawler.DCCustomizeEmoteRadialWidget
// 0x00C0 (0x0418 - 0x0358)
class UDCCustomizeEmoteRadialWidget final : public UDCWidgetBase
{
public:
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_1;                           // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_2;                           // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_3;                           // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_4;                           // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_5;                           // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_6;                           // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_7;                           // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCustomizeRadialSlotWidget*           EmoteRadialSlotWidget_8;                           // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24AC[0x80];                                    // 0x0398(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeEmoteRadialWidget">();
	}
	static class UDCCustomizeEmoteRadialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeEmoteRadialWidget>();
	}
};
static_assert(alignof(UDCCustomizeEmoteRadialWidget) == 0x000008, "Wrong alignment on UDCCustomizeEmoteRadialWidget");
static_assert(sizeof(UDCCustomizeEmoteRadialWidget) == 0x000418, "Wrong size on UDCCustomizeEmoteRadialWidget");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_1) == 0x000358, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_1' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_2) == 0x000360, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_2' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_3) == 0x000368, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_3' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_4) == 0x000370, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_4' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_5) == 0x000378, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_5' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_6) == 0x000380, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_6' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_7) == 0x000388, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_7' has a wrong offset!");
static_assert(offsetof(UDCCustomizeEmoteRadialWidget, EmoteRadialSlotWidget_8) == 0x000390, "Member 'UDCCustomizeEmoteRadialWidget::EmoteRadialSlotWidget_8' has a wrong offset!");

// Class DungeonCrawler.SkillListWidgetBase
// 0x0028 (0x0380 - 0x0358)
class USkillListWidgetBase : public UDCWidgetBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LinkedAccountId;                                   // 0x0360(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CheckTargetAccountId;                              // 0x0370(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillListWidgetBase">();
	}
	static class USkillListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillListWidgetBase>();
	}
};
static_assert(alignof(USkillListWidgetBase) == 0x000008, "Wrong alignment on USkillListWidgetBase");
static_assert(sizeof(USkillListWidgetBase) == 0x000380, "Wrong size on USkillListWidgetBase");
static_assert(offsetof(USkillListWidgetBase, AccountLink) == 0x000358, "Member 'USkillListWidgetBase::AccountLink' has a wrong offset!");
static_assert(offsetof(USkillListWidgetBase, LinkedAccountId) == 0x000360, "Member 'USkillListWidgetBase::LinkedAccountId' has a wrong offset!");
static_assert(offsetof(USkillListWidgetBase, CheckTargetAccountId) == 0x000370, "Member 'USkillListWidgetBase::CheckTargetAccountId' has a wrong offset!");

// Class DungeonCrawler.DCCharacterBase
// 0x0380 (0x0A00 - 0x0680)
class ADCCharacterBase : public ACharacter
{
public:
	uint8                                         Pad_24AD[0x78];                                    // 0x0678(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x06F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24AE[0x18];                                    // 0x06F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCUpdateRateOptimizeManagerComponent*  OptimizeComponent;                                 // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24AF[0x8];                                     // 0x0720(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         GenericTeamId;                                     // 0x0728(0x0001)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B0[0x7];                                     // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttackInputManagerComponent*           AttackInputManager;                                // 0x0730(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkillComponent*                        SkillComponent;                                    // 0x0738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeShiftComponent*                   ShapeShiftComponent;                               // 0x0740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B1[0x68];                                    // 0x0748(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x07B0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAccountLink*                           AccountLink;                                       // 0x07C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B2[0x8];                                     // 0x07C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAccountDataReplication                AccountDataReplication;                            // 0x07D0(0x0090)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsFirstPersonPerspective;                         // 0x0860(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDead;                                           // 0x0861(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B3[0x6];                                     // 0x0862(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ADCAoeBase>>      AoeArray;                                          // 0x0868(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FAccountDataReplication                AccountDataReplicationCached;                      // 0x0878(0x0090)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B4[0x10];                                    // 0x0908(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RemoteViewYaw;                                     // 0x0918(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B5[0x67];                                    // 0x0919(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AimRotationLockTags;                               // 0x0980(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CancelWithoutTags;                                 // 0x09A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDCInventoryComponent*                  InventoryComponentV2;                              // 0x09C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B6[0x8];                                     // 0x09C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADCPlayerController*>            Looters;                                           // 0x09D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B7[0x10];                                    // 0x09E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      HidePartyMaterial;                                 // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      CloakingMaterial;                                  // 0x09F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void FinishLooting();
	void GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount);
	class UCameraComponent* GetCameraComponent();
	struct FVector GetCapsuleBottomLocation();
	struct FVector GetCapsuleTopLocation();
	class UCameraComponent* GetPerspectiveCameraComponent(bool bFirstPersonPerspective);
	void InteractFound(class AActor* Interacter, class UPrimitiveComponent* InteractPart);
	void InteractLost(class AActor* Interacter);
	void InteractSucceed(class AActor* Interacter, const struct FGameplayTag& StateTag, const struct FGameplayTag& TriggerTag, const struct FHitResult& HitResult);
	void NPCInteractFinishEventBroadcast_Server();
	void OnCharacterMoved(float InDeltaSeconds, const struct FVector& InOldLocation, const struct FVector& InOldVelocity);
	void OnFMsgGASActorDieNotifyBlueprint(const struct FMsgGASActorDieNotify& InMsg);
	void OnGameState(const struct FGameStateData& InGameStateData);
	void OnRep_AccountId(const class FString& OldAccountId);
	void OnSetPerspective(class APlayerController* InPlayerController, const bool bInIsFirstPersonPerspective);
	void OnTarget(bool bTarget);
	void OnUpdateTeammateState(bool bIsTeammateWithLocalPlayer);
	void ReceivePreInitializeComponents();
	void RemoveAllLocalStateTags();
	void ServerSetRemoteViewYaw(uint8 InRemoteViewYaw);
	void SetForceHide(bool bInForceHide);
	void SetGenericTeamId(const struct FGenericTeamId& TeamID);
	void SetIsDead(bool IsDead);
	void StartInspecting(class ADCCharacterBase* Inspector);
	void StartLooting(class ADCPlayerCharacterBase* Looter, const struct FHitResult& HitResult);
	void TerminateBase();
	void TogglePerspective();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	class FString GetAccountId() const;
	struct FGenericTeamId GetGenericTeamId() const;
	bool GetHitBoxLocation(EHitBoxType HitBoxType, struct FVector* Location) const;
	struct FNickname GetNickNameCached() const;
	class FString GetPartyIdString() const;
	bool IsDead() const;
	bool IsInFirstPersonPerspective() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterBase">();
	}
	static class ADCCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCharacterBase>();
	}
};
static_assert(alignof(ADCCharacterBase) == 0x000010, "Wrong alignment on ADCCharacterBase");
static_assert(sizeof(ADCCharacterBase) == 0x000A00, "Wrong size on ADCCharacterBase");
static_assert(offsetof(ADCCharacterBase, BaseObject) == 0x0006F0, "Member 'ADCCharacterBase::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AbilitySystemComponent) == 0x000710, "Member 'ADCCharacterBase::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, OptimizeComponent) == 0x000718, "Member 'ADCCharacterBase::OptimizeComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, GenericTeamId) == 0x000728, "Member 'ADCCharacterBase::GenericTeamId' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AttackInputManager) == 0x000730, "Member 'ADCCharacterBase::AttackInputManager' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, SkillComponent) == 0x000738, "Member 'ADCCharacterBase::SkillComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, ShapeShiftComponent) == 0x000740, "Member 'ADCCharacterBase::ShapeShiftComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AccountId) == 0x0007B0, "Member 'ADCCharacterBase::AccountId' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AccountLink) == 0x0007C0, "Member 'ADCCharacterBase::AccountLink' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AccountDataReplication) == 0x0007D0, "Member 'ADCCharacterBase::AccountDataReplication' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, bIsFirstPersonPerspective) == 0x000860, "Member 'ADCCharacterBase::bIsFirstPersonPerspective' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, bIsDead) == 0x000861, "Member 'ADCCharacterBase::bIsDead' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AoeArray) == 0x000868, "Member 'ADCCharacterBase::AoeArray' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AccountDataReplicationCached) == 0x000878, "Member 'ADCCharacterBase::AccountDataReplicationCached' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, RemoteViewYaw) == 0x000918, "Member 'ADCCharacterBase::RemoteViewYaw' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, AimRotationLockTags) == 0x000980, "Member 'ADCCharacterBase::AimRotationLockTags' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, CancelWithoutTags) == 0x0009A0, "Member 'ADCCharacterBase::CancelWithoutTags' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, InventoryComponentV2) == 0x0009C0, "Member 'ADCCharacterBase::InventoryComponentV2' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, Looters) == 0x0009D0, "Member 'ADCCharacterBase::Looters' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, HidePartyMaterial) == 0x0009F0, "Member 'ADCCharacterBase::HidePartyMaterial' has a wrong offset!");
static_assert(offsetof(ADCCharacterBase, CloakingMaterial) == 0x0009F8, "Member 'ADCCharacterBase::CloakingMaterial' has a wrong offset!");

// Class DungeonCrawler.DCTrainingDummyCharacterBase
// 0x0020 (0x0A20 - 0x0A00)
class ADCTrainingDummyCharacterBase final : public ADCCharacterBase
{
public:
	struct FPrimaryAssetId                        TrainingDummyId;                                   // 0x0A00(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSameTeam;                                       // 0x0A10(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFootStep;                                      // 0x0A11(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24BD[0x2];                                     // 0x0A12(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootStepIntervalTime;                              // 0x0A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24BE[0x8];                                     // 0x0A18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingDummyCharacterBase">();
	}
	static class ADCTrainingDummyCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCTrainingDummyCharacterBase>();
	}
};
static_assert(alignof(ADCTrainingDummyCharacterBase) == 0x000010, "Wrong alignment on ADCTrainingDummyCharacterBase");
static_assert(sizeof(ADCTrainingDummyCharacterBase) == 0x000A20, "Wrong size on ADCTrainingDummyCharacterBase");
static_assert(offsetof(ADCTrainingDummyCharacterBase, TrainingDummyId) == 0x000A00, "Member 'ADCTrainingDummyCharacterBase::TrainingDummyId' has a wrong offset!");
static_assert(offsetof(ADCTrainingDummyCharacterBase, bIsSameTeam) == 0x000A10, "Member 'ADCTrainingDummyCharacterBase::bIsSameTeam' has a wrong offset!");
static_assert(offsetof(ADCTrainingDummyCharacterBase, bUseFootStep) == 0x000A11, "Member 'ADCTrainingDummyCharacterBase::bUseFootStep' has a wrong offset!");
static_assert(offsetof(ADCTrainingDummyCharacterBase, FootStepIntervalTime) == 0x000A14, "Member 'ADCTrainingDummyCharacterBase::FootStepIntervalTime' has a wrong offset!");

// Class DungeonCrawler.DCGiftCodePopupData
// 0x0000 (0x0030 - 0x0030)
class UDCGiftCodePopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGiftCodePopupData">();
	}
	static class UDCGiftCodePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGiftCodePopupData>();
	}
};
static_assert(alignof(UDCGiftCodePopupData) == 0x000008, "Wrong alignment on UDCGiftCodePopupData");
static_assert(sizeof(UDCGiftCodePopupData) == 0x000030, "Wrong size on UDCGiftCodePopupData");

// Class DungeonCrawler.DCClassTrainingWidgetBase
// 0x0008 (0x0490 - 0x0488)
class UDCClassTrainingWidgetBase final : public UDCCommonActivatableWidgetBase
{
public:
	uint8                                         Pad_24BF[0x8];                                     // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCanRedeemLearnTokenEnabled(bool bCanRedeem);
	void OnTrainingStateUpdated(EDCTrainingState InTrainingState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCClassTrainingWidgetBase">();
	}
	static class UDCClassTrainingWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCClassTrainingWidgetBase>();
	}
};
static_assert(alignof(UDCClassTrainingWidgetBase) == 0x000008, "Wrong alignment on UDCClassTrainingWidgetBase");
static_assert(sizeof(UDCClassTrainingWidgetBase) == 0x000490, "Wrong size on UDCClassTrainingWidgetBase");

// Class DungeonCrawler.ClassSkillListWidgetBase
// 0x0018 (0x0398 - 0x0380)
class UClassSkillListWidgetBase final : public USkillListWidgetBase
{
public:
	TArray<class USkillWidget*>                   SkillWidgetArray;                                  // 0x0380(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C0[0x8];                                     // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetSelectedSlotIndex();
	struct FPrimaryAssetId GetSelectedSlotSkillId();
	void OnAddItem();
	void OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint(const struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify& InMsg);
	void OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg);
	void OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg);
	void OnRemoveItem();
	void SetSelectedSlotIndex(int32 InSlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSkillListWidgetBase">();
	}
	static class UClassSkillListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSkillListWidgetBase>();
	}
};
static_assert(alignof(UClassSkillListWidgetBase) == 0x000008, "Wrong alignment on UClassSkillListWidgetBase");
static_assert(sizeof(UClassSkillListWidgetBase) == 0x000398, "Wrong size on UClassSkillListWidgetBase");
static_assert(offsetof(UClassSkillListWidgetBase, SkillWidgetArray) == 0x000380, "Member 'UClassSkillListWidgetBase::SkillWidgetArray' has a wrong offset!");

// Class DungeonCrawler.DCShopConfirmPurchasePopupBase
// 0x0040 (0x04D0 - 0x0490)
class UDCShopConfirmPurchasePopupBase : public UCommonPopupBase
{
public:
	class UDCShopItemSlotWidget*                  ShopItemSlot;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Cancel;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Confirm;                                       // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Price;                                             // 0x04A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C1[0x4];                                     // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PurchaseItemName;                                  // 0x04B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCShopConfirmPurchasePopupData*        ConfirmPurchasePopupData;                          // 0x04C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	ESlateVisibility GetBluestoneShardVisibility();
	ESlateVisibility GetRedstoneShardVisibility();
	void OnCancelClicked();
	void OnConfirmClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopConfirmPurchasePopupBase">();
	}
	static class UDCShopConfirmPurchasePopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopConfirmPurchasePopupBase>();
	}
};
static_assert(alignof(UDCShopConfirmPurchasePopupBase) == 0x000008, "Wrong alignment on UDCShopConfirmPurchasePopupBase");
static_assert(sizeof(UDCShopConfirmPurchasePopupBase) == 0x0004D0, "Wrong size on UDCShopConfirmPurchasePopupBase");
static_assert(offsetof(UDCShopConfirmPurchasePopupBase, ShopItemSlot) == 0x000490, "Member 'UDCShopConfirmPurchasePopupBase::ShopItemSlot' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupBase, Btn_Cancel) == 0x000498, "Member 'UDCShopConfirmPurchasePopupBase::Btn_Cancel' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupBase, Btn_Confirm) == 0x0004A0, "Member 'UDCShopConfirmPurchasePopupBase::Btn_Confirm' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupBase, Price) == 0x0004A8, "Member 'UDCShopConfirmPurchasePopupBase::Price' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupBase, PurchaseItemName) == 0x0004B0, "Member 'UDCShopConfirmPurchasePopupBase::PurchaseItemName' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupBase, ConfirmPurchasePopupData) == 0x0004C8, "Member 'UDCShopConfirmPurchasePopupBase::ConfirmPurchasePopupData' has a wrong offset!");

// Class DungeonCrawler.SpellSlotWidgetBase
// 0x0138 (0x0490 - 0x0358)
class USpellSlotWidgetBase : public UDCWidgetBase
{
public:
	struct FSpellData                             SpellData;                                         // 0x0358(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       DesignDataSpell;                                   // 0x0398(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           DescTextArray;                                     // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UArtDataSpell*                          ArtData;                                           // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C2[0x4];                                     // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReset();
	void OnSetSpellArtData(const class UArtDataSpell* InArtSpellData);
	void OnSpellDataChanged(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell);
	void Reset();
	void SetSpellData(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellSlotWidgetBase">();
	}
	static class USpellSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpellSlotWidgetBase>();
	}
};
static_assert(alignof(USpellSlotWidgetBase) == 0x000008, "Wrong alignment on USpellSlotWidgetBase");
static_assert(sizeof(USpellSlotWidgetBase) == 0x000490, "Wrong size on USpellSlotWidgetBase");
static_assert(offsetof(USpellSlotWidgetBase, SpellData) == 0x000358, "Member 'USpellSlotWidgetBase::SpellData' has a wrong offset!");
static_assert(offsetof(USpellSlotWidgetBase, DesignDataSpell) == 0x000398, "Member 'USpellSlotWidgetBase::DesignDataSpell' has a wrong offset!");
static_assert(offsetof(USpellSlotWidgetBase, DescTextArray) == 0x000470, "Member 'USpellSlotWidgetBase::DescTextArray' has a wrong offset!");
static_assert(offsetof(USpellSlotWidgetBase, ArtData) == 0x000480, "Member 'USpellSlotWidgetBase::ArtData' has a wrong offset!");
static_assert(offsetof(USpellSlotWidgetBase, SlotIndex) == 0x000488, "Member 'USpellSlotWidgetBase::SlotIndex' has a wrong offset!");

// Class DungeonCrawler.SkillActor
// 0x0128 (0x0420 - 0x02F8)
class ASkillActor final : public ADCActorBase
{
public:
	uint8                                         Pad_24C3[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillData                             SkillData;                                         // 0x0300(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C4[0xE0];                                    // 0x0330(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UArtDataSkill*                          ArtDataSkill;                                      // 0x0410(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundData*                             SoundData;                                         // 0x0418(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SkillData(const struct FSkillData& OldSkillData);

	class UArtDataSkill* GetArtDataSkill() const;
	struct FDesignDataSkill GetDesignDataSkill() const;
	struct FSkillData GetSkillData() const;
	class USoundData* GetSoundDataSkill() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillActor">();
	}
	static class ASkillActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkillActor>();
	}
};
static_assert(alignof(ASkillActor) == 0x000008, "Wrong alignment on ASkillActor");
static_assert(sizeof(ASkillActor) == 0x000420, "Wrong size on ASkillActor");
static_assert(offsetof(ASkillActor, SkillData) == 0x000300, "Member 'ASkillActor::SkillData' has a wrong offset!");
static_assert(offsetof(ASkillActor, ArtDataSkill) == 0x000410, "Member 'ASkillActor::ArtDataSkill' has a wrong offset!");
static_assert(offsetof(ASkillActor, SoundData) == 0x000418, "Member 'ASkillActor::SoundData' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationActionSpeed
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationActionSpeed final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_24C5[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationActionSpeed">();
	}
	static class UDCAttributeModMagnitudeCalculationActionSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationActionSpeed>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationActionSpeed) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationActionSpeed");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationActionSpeed) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationActionSpeed");

// Class DungeonCrawler.SpellCapacitySlotWidget
// 0x0008 (0x0498 - 0x0490)
class USpellCapacitySlotWidget : public USpellSlotWidgetBase
{
public:
	int32                                         SequenceIndex;                                     // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C6[0x4];                                     // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellCapacitySlotWidget">();
	}
	static class USpellCapacitySlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpellCapacitySlotWidget>();
	}
};
static_assert(alignof(USpellCapacitySlotWidget) == 0x000008, "Wrong alignment on USpellCapacitySlotWidget");
static_assert(sizeof(USpellCapacitySlotWidget) == 0x000498, "Wrong size on USpellCapacitySlotWidget");
static_assert(offsetof(USpellCapacitySlotWidget, SequenceIndex) == 0x000490, "Member 'USpellCapacitySlotWidget::SequenceIndex' has a wrong offset!");

// Class DungeonCrawler.DCSessionRuleComponent
// 0x0038 (0x00D8 - 0x00A0)
class UDCSessionRuleComponent final : public UDCActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDeathSwarmRuleFiredDelegate;                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlizzardRuleFiredDelegate;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFloorRuleFiredDelegate;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C7[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlizzardData(const struct FGameBlizzardData& InBlizzardData);
	void OnDeathSwarmData(const struct FGameDeathSwarmData& InDeathSwarmData);
	void OnFloorRuleActorRegistered(class AActor* InFloorRuleActor);
	void OnFloorRuleData(const struct FGameFloorRuleData& InFloorRuleData);

	void LogHandleBlizzardData(const class UObject* InHandler, const struct FGameBlizzardData& InBlizzardData) const;
	void LogHandleDeathSwarmData(const class UObject* InHandler, const struct FGameDeathSwarmData& InDeathSwarmData) const;
	void LogHandleFloorRuleData(const class UObject* InHandler, const struct FGameFloorRuleData& InFloorRuleData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSessionRuleComponent">();
	}
	static class UDCSessionRuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSessionRuleComponent>();
	}
};
static_assert(alignof(UDCSessionRuleComponent) == 0x000008, "Wrong alignment on UDCSessionRuleComponent");
static_assert(sizeof(UDCSessionRuleComponent) == 0x0000D8, "Wrong size on UDCSessionRuleComponent");
static_assert(offsetof(UDCSessionRuleComponent, OnDeathSwarmRuleFiredDelegate) == 0x0000A0, "Member 'UDCSessionRuleComponent::OnDeathSwarmRuleFiredDelegate' has a wrong offset!");
static_assert(offsetof(UDCSessionRuleComponent, OnBlizzardRuleFiredDelegate) == 0x0000B0, "Member 'UDCSessionRuleComponent::OnBlizzardRuleFiredDelegate' has a wrong offset!");
static_assert(offsetof(UDCSessionRuleComponent, OnFloorRuleFiredDelegate) == 0x0000C0, "Member 'UDCSessionRuleComponent::OnFloorRuleFiredDelegate' has a wrong offset!");

// Class DungeonCrawler.ClassSpellCapacitySlotWidget
// 0x0018 (0x04B0 - 0x0498)
class UClassSpellCapacitySlotWidget final : public USpellCapacitySlotWidget
{
public:
	class FText                                   SequenceText;                                      // 0x0498(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSpellCapacitySlotWidget">();
	}
	static class UClassSpellCapacitySlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSpellCapacitySlotWidget>();
	}
};
static_assert(alignof(UClassSpellCapacitySlotWidget) == 0x000008, "Wrong alignment on UClassSpellCapacitySlotWidget");
static_assert(sizeof(UClassSpellCapacitySlotWidget) == 0x0004B0, "Wrong size on UClassSpellCapacitySlotWidget");
static_assert(offsetof(UClassSpellCapacitySlotWidget, SequenceText) == 0x000498, "Member 'UClassSpellCapacitySlotWidget::SequenceText' has a wrong offset!");

// Class DungeonCrawler.SpellCapacityWidgetBase
// 0x0068 (0x04F0 - 0x0488)
class USpellCapacityWidgetBase : public UDCCommonActivatableWidgetBase
{
public:
	class USpellCapacitySlotWidget*               SpellCapacitySlot_1;                               // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_2;                               // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_3;                               // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_4;                               // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_5;                               // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_6;                               // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_7;                               // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_8;                               // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_9;                               // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellCapacitySlotWidget*               SpellCapacitySlot_10;                              // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USpellCapacitySlotWidget*>       SpellCapacitySlots;                                // 0x04D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         SpellCurrentCapacity;                              // 0x04E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpellMaxCapacity;                                  // 0x04EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSpellCapacityChanged(float InSpellCurrentCapacity, float InSpellMaxCapacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellCapacityWidgetBase">();
	}
	static class USpellCapacityWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpellCapacityWidgetBase>();
	}
};
static_assert(alignof(USpellCapacityWidgetBase) == 0x000008, "Wrong alignment on USpellCapacityWidgetBase");
static_assert(sizeof(USpellCapacityWidgetBase) == 0x0004F0, "Wrong size on USpellCapacityWidgetBase");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_1) == 0x000488, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_1' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_2) == 0x000490, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_2' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_3) == 0x000498, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_3' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_4) == 0x0004A0, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_4' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_5) == 0x0004A8, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_5' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_6) == 0x0004B0, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_6' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_7) == 0x0004B8, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_7' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_8) == 0x0004C0, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_8' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_9) == 0x0004C8, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_9' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlot_10) == 0x0004D0, "Member 'USpellCapacityWidgetBase::SpellCapacitySlot_10' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCapacitySlots) == 0x0004D8, "Member 'USpellCapacityWidgetBase::SpellCapacitySlots' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellCurrentCapacity) == 0x0004E8, "Member 'USpellCapacityWidgetBase::SpellCurrentCapacity' has a wrong offset!");
static_assert(offsetof(USpellCapacityWidgetBase, SpellMaxCapacity) == 0x0004EC, "Member 'USpellCapacityWidgetBase::SpellMaxCapacity' has a wrong offset!");

// Class DungeonCrawler.DCInputConfig
// 0x0010 (0x0040 - 0x0030)
class UDCInputConfig final : public UDataAsset
{
public:
	TArray<struct FDCInputAction>                 NativeInputActions;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInputConfig">();
	}
	static class UDCInputConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInputConfig>();
	}
};
static_assert(alignof(UDCInputConfig) == 0x000008, "Wrong alignment on UDCInputConfig");
static_assert(sizeof(UDCInputConfig) == 0x000040, "Wrong size on UDCInputConfig");
static_assert(offsetof(UDCInputConfig, NativeInputActions) == 0x000030, "Member 'UDCInputConfig::NativeInputActions' has a wrong offset!");

// Class DungeonCrawler.ClassSpellCapacityWidget
// 0x00B8 (0x05A8 - 0x04F0)
class UClassSpellCapacityWidget final : public USpellCapacityWidgetBase
{
public:
	class UImage*                                 CapacityGauge_1;                                   // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_2;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_3;                                   // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_4;                                   // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_5;                                   // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_6;                                   // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_7;                                   // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_8;                                   // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_9;                                   // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CapacityGauge_10;                                  // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         CapacityGauges;                                    // 0x0540(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_1;                                  // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_2;                                  // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_3;                                  // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_4;                                  // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_5;                                  // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_6;                                  // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_7;                                  // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_8;                                  // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CapacitySpacer_9;                                  // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USpacer*>                        CapacitySpacers;                                   // 0x0598(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnSpellListChanged(const TArray<struct FSpellData>& InSpellDataArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSpellCapacityWidget">();
	}
	static class UClassSpellCapacityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSpellCapacityWidget>();
	}
};
static_assert(alignof(UClassSpellCapacityWidget) == 0x000008, "Wrong alignment on UClassSpellCapacityWidget");
static_assert(sizeof(UClassSpellCapacityWidget) == 0x0005A8, "Wrong size on UClassSpellCapacityWidget");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_1) == 0x0004F0, "Member 'UClassSpellCapacityWidget::CapacityGauge_1' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_2) == 0x0004F8, "Member 'UClassSpellCapacityWidget::CapacityGauge_2' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_3) == 0x000500, "Member 'UClassSpellCapacityWidget::CapacityGauge_3' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_4) == 0x000508, "Member 'UClassSpellCapacityWidget::CapacityGauge_4' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_5) == 0x000510, "Member 'UClassSpellCapacityWidget::CapacityGauge_5' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_6) == 0x000518, "Member 'UClassSpellCapacityWidget::CapacityGauge_6' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_7) == 0x000520, "Member 'UClassSpellCapacityWidget::CapacityGauge_7' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_8) == 0x000528, "Member 'UClassSpellCapacityWidget::CapacityGauge_8' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_9) == 0x000530, "Member 'UClassSpellCapacityWidget::CapacityGauge_9' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauge_10) == 0x000538, "Member 'UClassSpellCapacityWidget::CapacityGauge_10' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacityGauges) == 0x000540, "Member 'UClassSpellCapacityWidget::CapacityGauges' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_1) == 0x000550, "Member 'UClassSpellCapacityWidget::CapacitySpacer_1' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_2) == 0x000558, "Member 'UClassSpellCapacityWidget::CapacitySpacer_2' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_3) == 0x000560, "Member 'UClassSpellCapacityWidget::CapacitySpacer_3' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_4) == 0x000568, "Member 'UClassSpellCapacityWidget::CapacitySpacer_4' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_5) == 0x000570, "Member 'UClassSpellCapacityWidget::CapacitySpacer_5' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_6) == 0x000578, "Member 'UClassSpellCapacityWidget::CapacitySpacer_6' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_7) == 0x000580, "Member 'UClassSpellCapacityWidget::CapacitySpacer_7' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_8) == 0x000588, "Member 'UClassSpellCapacityWidget::CapacitySpacer_8' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacer_9) == 0x000590, "Member 'UClassSpellCapacityWidget::CapacitySpacer_9' has a wrong offset!");
static_assert(offsetof(UClassSpellCapacityWidget, CapacitySpacers) == 0x000598, "Member 'UClassSpellCapacityWidget::CapacitySpacers' has a wrong offset!");

// Class DungeonCrawler.DCTrainingCharacterSlotWidgetData
// 0x00A0 (0x00C8 - 0x0028)
class UDCTrainingCharacterSlotWidgetData final : public UObject
{
public:
	struct FDCTrainingCharacterInfo               TrainingCharacterInfo;                             // 0x0028(0x0098)(NativeAccessSpecifierPublic)
	bool                                          bIsSetMaster;                                      // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C8[0x7];                                     // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingCharacterSlotWidgetData">();
	}
	static class UDCTrainingCharacterSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingCharacterSlotWidgetData>();
	}
};
static_assert(alignof(UDCTrainingCharacterSlotWidgetData) == 0x000008, "Wrong alignment on UDCTrainingCharacterSlotWidgetData");
static_assert(sizeof(UDCTrainingCharacterSlotWidgetData) == 0x0000C8, "Wrong size on UDCTrainingCharacterSlotWidgetData");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetData, TrainingCharacterInfo) == 0x000028, "Member 'UDCTrainingCharacterSlotWidgetData::TrainingCharacterInfo' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetData, bIsSetMaster) == 0x0000C0, "Member 'UDCTrainingCharacterSlotWidgetData::bIsSetMaster' has a wrong offset!");

// Class DungeonCrawler.DCInventoryMsgWrapperComponent
// 0x0070 (0x0110 - 0x00A0)
class UDCInventoryMsgWrapperComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_24C9[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCInventoryComponent*                  InvenComp;                                         // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCEquipmentComponent*                  EquipComp;                                         // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterAbilitySystemComponent*     ASC;                                               // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ClientShowMessage(const class FText& Msg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryMsgWrapperComponent">();
	}
	static class UDCInventoryMsgWrapperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryMsgWrapperComponent>();
	}
};
static_assert(alignof(UDCInventoryMsgWrapperComponent) == 0x000008, "Wrong alignment on UDCInventoryMsgWrapperComponent");
static_assert(sizeof(UDCInventoryMsgWrapperComponent) == 0x000110, "Wrong size on UDCInventoryMsgWrapperComponent");
static_assert(offsetof(UDCInventoryMsgWrapperComponent, InvenComp) == 0x0000F8, "Member 'UDCInventoryMsgWrapperComponent::InvenComp' has a wrong offset!");
static_assert(offsetof(UDCInventoryMsgWrapperComponent, EquipComp) == 0x000100, "Member 'UDCInventoryMsgWrapperComponent::EquipComp' has a wrong offset!");
static_assert(offsetof(UDCInventoryMsgWrapperComponent, ASC) == 0x000108, "Member 'UDCInventoryMsgWrapperComponent::ASC' has a wrong offset!");

// Class DungeonCrawler.ClassSpellEquippedWidget
// 0x0000 (0x0488 - 0x0488)
class UClassSpellEquippedWidget final : public UDCCommonActivatableWidgetBase
{
public:
	void OnAddItem();
	void OnRemoveItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSpellEquippedWidget">();
	}
	static class UClassSpellEquippedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSpellEquippedWidget>();
	}
};
static_assert(alignof(UClassSpellEquippedWidget) == 0x000008, "Wrong alignment on UClassSpellEquippedWidget");
static_assert(sizeof(UClassSpellEquippedWidget) == 0x000488, "Wrong size on UClassSpellEquippedWidget");

// Class DungeonCrawler.DCChannelChatWidget
// 0x0060 (0x0590 - 0x0530)
class UDCChannelChatWidget final : public UChatSetWidgetBase
{
public:
	uint8                                         Pad_24CA[0x10];                                    // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0540(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FString                                 Nickname;                                          // 0x0558(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EContextOptionType>                    ContextOptions;                                    // 0x0568(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_24CB[0x18];                                    // 0x0578(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNickname();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCChannelChatWidget">();
	}
	static class UDCChannelChatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCChannelChatWidget>();
	}
};
static_assert(alignof(UDCChannelChatWidget) == 0x000008, "Wrong alignment on UDCChannelChatWidget");
static_assert(sizeof(UDCChannelChatWidget) == 0x000590, "Wrong size on UDCChannelChatWidget");
static_assert(offsetof(UDCChannelChatWidget, Title) == 0x000540, "Member 'UDCChannelChatWidget::Title' has a wrong offset!");
static_assert(offsetof(UDCChannelChatWidget, Nickname) == 0x000558, "Member 'UDCChannelChatWidget::Nickname' has a wrong offset!");
static_assert(offsetof(UDCChannelChatWidget, ContextOptions) == 0x000568, "Member 'UDCChannelChatWidget::ContextOptions' has a wrong offset!");

// Class DungeonCrawler.DCGiftCodeEditableText
// 0x0040 (0x0550 - 0x0510)
class UDCGiftCodeEditableText final : public UEditableText
{
public:
	uint8                                         Pad_24CC[0x18];                                    // 0x0510(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_DCGiftCodeEditableText;                      // 0x0528(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24CD[0x4];                                     // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PrevText;                                          // 0x0530(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24CE[0x8];                                     // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCodeTextChanged(const class FText& InCodeText);
	void OnCodeTextCommitted(const class FText& InCodeText, ETextCommit CommitType);
	void OnGiftCodeFilledEvent__DelegateSignature(const class FText& RemainText, const int32& Param_Index);
	void OnGiftCodeWipedEvent__DelegateSignature(const int32& Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGiftCodeEditableText">();
	}
	static class UDCGiftCodeEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGiftCodeEditableText>();
	}
};
static_assert(alignof(UDCGiftCodeEditableText) == 0x000010, "Wrong alignment on UDCGiftCodeEditableText");
static_assert(sizeof(UDCGiftCodeEditableText) == 0x000550, "Wrong size on UDCGiftCodeEditableText");
static_assert(offsetof(UDCGiftCodeEditableText, Index_DCGiftCodeEditableText) == 0x000528, "Member 'UDCGiftCodeEditableText::Index_DCGiftCodeEditableText' has a wrong offset!");
static_assert(offsetof(UDCGiftCodeEditableText, PrevText) == 0x000530, "Member 'UDCGiftCodeEditableText::PrevText' has a wrong offset!");

// Class DungeonCrawler.SpellListWidgetBase
// 0x0040 (0x04E8 - 0x04A8)
class USpellListWidgetBase : public UGameGroupWidgetBase
{
public:
	class USpellSlotWidgetBase*                   SpellSlot_1;                                       // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellSlotWidgetBase*                   SpellSlot_2;                                       // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellSlotWidgetBase*                   SpellSlot_3;                                       // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellSlotWidgetBase*                   SpellSlot_4;                                       // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpellSlotWidgetBase*                   SpellSlot_5;                                       // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USpellSlotWidgetBase*>           SpellSlots;                                        // 0x04D0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EWidgetSpellSlotsType                         WidgetSlotType;                                    // 0x04E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24D1[0x7];                                     // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellListWidgetBase">();
	}
	static class USpellListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpellListWidgetBase>();
	}
};
static_assert(alignof(USpellListWidgetBase) == 0x000008, "Wrong alignment on USpellListWidgetBase");
static_assert(sizeof(USpellListWidgetBase) == 0x0004E8, "Wrong size on USpellListWidgetBase");
static_assert(offsetof(USpellListWidgetBase, SpellSlot_1) == 0x0004A8, "Member 'USpellListWidgetBase::SpellSlot_1' has a wrong offset!");
static_assert(offsetof(USpellListWidgetBase, SpellSlot_2) == 0x0004B0, "Member 'USpellListWidgetBase::SpellSlot_2' has a wrong offset!");
static_assert(offsetof(USpellListWidgetBase, SpellSlot_3) == 0x0004B8, "Member 'USpellListWidgetBase::SpellSlot_3' has a wrong offset!");
static_assert(offsetof(USpellListWidgetBase, SpellSlot_4) == 0x0004C0, "Member 'USpellListWidgetBase::SpellSlot_4' has a wrong offset!");
static_assert(offsetof(USpellListWidgetBase, SpellSlot_5) == 0x0004C8, "Member 'USpellListWidgetBase::SpellSlot_5' has a wrong offset!");
static_assert(offsetof(USpellListWidgetBase, SpellSlots) == 0x0004D0, "Member 'USpellListWidgetBase::SpellSlots' has a wrong offset!");
static_assert(offsetof(USpellListWidgetBase, WidgetSlotType) == 0x0004E0, "Member 'USpellListWidgetBase::WidgetSlotType' has a wrong offset!");

// Class DungeonCrawler.DCRewardItemWidget
// 0x01E0 (0x0538 - 0x0358)
class UDCRewardItemWidget : public UDCWidgetBase
{
public:
	class UTexture2D*                             RewardItemIcon;                                    // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCItemTooltipWidget>       ItemTooltipWidgetClass;                            // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RewardItemName;                                    // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RewardItemDescription;                             // 0x0388(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RewardItemFlavorText;                              // 0x03A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         RewardCount;                                       // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCRewardType                                 RewardType;                                        // 0x03BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24D2[0x3];                                     // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCGameTooltipWithFlavorTextWidget*     RewardItemTooltipWidget;                           // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCItemInfo                            RewardItemInfo;                                    // 0x03C8(0x0168)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArtDataRewardItem*                     ArtDataRewardItem;                                 // 0x0530(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetTooltipWidget();
	void SetRewardItem(const struct FDCRewardInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRewardItemWidget">();
	}
	static class UDCRewardItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRewardItemWidget>();
	}
};
static_assert(alignof(UDCRewardItemWidget) == 0x000008, "Wrong alignment on UDCRewardItemWidget");
static_assert(sizeof(UDCRewardItemWidget) == 0x000538, "Wrong size on UDCRewardItemWidget");
static_assert(offsetof(UDCRewardItemWidget, RewardItemIcon) == 0x000358, "Member 'UDCRewardItemWidget::RewardItemIcon' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, TooltipWidgetClass) == 0x000360, "Member 'UDCRewardItemWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, ItemTooltipWidgetClass) == 0x000368, "Member 'UDCRewardItemWidget::ItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardItemName) == 0x000370, "Member 'UDCRewardItemWidget::RewardItemName' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardItemDescription) == 0x000388, "Member 'UDCRewardItemWidget::RewardItemDescription' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardItemFlavorText) == 0x0003A0, "Member 'UDCRewardItemWidget::RewardItemFlavorText' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardCount) == 0x0003B8, "Member 'UDCRewardItemWidget::RewardCount' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardType) == 0x0003BC, "Member 'UDCRewardItemWidget::RewardType' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardItemTooltipWidget) == 0x0003C0, "Member 'UDCRewardItemWidget::RewardItemTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, RewardItemInfo) == 0x0003C8, "Member 'UDCRewardItemWidget::RewardItemInfo' has a wrong offset!");
static_assert(offsetof(UDCRewardItemWidget, ArtDataRewardItem) == 0x000530, "Member 'UDCRewardItemWidget::ArtDataRewardItem' has a wrong offset!");

// Class DungeonCrawler.DCTwitchDropsItemWidget
// 0x0008 (0x0540 - 0x0538)
class UDCTwitchDropsItemWidget final : public UDCRewardItemWidget
{
public:
	class UOverlay*                               Item_Num;                                          // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTwitchDropsItemWidget">();
	}
	static class UDCTwitchDropsItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTwitchDropsItemWidget>();
	}
};
static_assert(alignof(UDCTwitchDropsItemWidget) == 0x000008, "Wrong alignment on UDCTwitchDropsItemWidget");
static_assert(sizeof(UDCTwitchDropsItemWidget) == 0x000540, "Wrong size on UDCTwitchDropsItemWidget");
static_assert(offsetof(UDCTwitchDropsItemWidget, Item_Num) == 0x000538, "Member 'UDCTwitchDropsItemWidget::Item_Num' has a wrong offset!");

// Class DungeonCrawler.DCGameSession
// 0x0148 (0x03F8 - 0x02B0)
class ADCGameSession : public AGameSession
{
public:
	uint8                                         Pad_24D3[0x148];                                   // 0x02B0(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void CharacterResurrection(const class FString& AccountId, TSubclassOf<class ADCCharacterBase> DCCharacterClass, const TArray<struct FDCGameplayEffectData>& InInitGameplayEffectDataArray, bool bIsRemoveAllItem, class ACharacter* ResurrectionCharacter);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSession">();
	}
	static class ADCGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameSession>();
	}
};
static_assert(alignof(ADCGameSession) == 0x000008, "Wrong alignment on ADCGameSession");
static_assert(sizeof(ADCGameSession) == 0x0003F8, "Wrong size on ADCGameSession");

// Class DungeonCrawler.DCIngameGameSession
// 0x0000 (0x03F8 - 0x03F8)
class ADCIngameGameSession final : public ADCGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIngameGameSession">();
	}
	static class ADCIngameGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCIngameGameSession>();
	}
};
static_assert(alignof(ADCIngameGameSession) == 0x000008, "Wrong alignment on ADCIngameGameSession");
static_assert(sizeof(ADCIngameGameSession) == 0x0003F8, "Wrong size on ADCIngameGameSession");

// Class DungeonCrawler.ClassSpellListWidget
// 0x0000 (0x04E8 - 0x04E8)
class UClassSpellListWidget final : public USpellListWidgetBase
{
public:
	void OnHideEquippableSlot();
	void OnShowEquippableSlot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSpellListWidget">();
	}
	static class UClassSpellListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSpellListWidget>();
	}
};
static_assert(alignof(UClassSpellListWidget) == 0x000008, "Wrong alignment on UClassSpellListWidget");
static_assert(sizeof(UClassSpellListWidget) == 0x0004E8, "Wrong size on UClassSpellListWidget");

// Class DungeonCrawler.DCRecruitChannelListWidget
// 0x0038 (0x04F0 - 0x04B8)
class UDCRecruitChannelListWidget final : public ULobbyGroupWidgetBase
{
public:
	TArray<struct FDCRecruitChannelInfo>          Channels;                                          // 0x04B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           ServerRegionVerticalBox;                           // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCRecruitChannelListEntryWidget> ChannelEntryWidgetClass;                           // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   JoinMinLevelText;                                  // 0x04D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRecruitChannelListWidget">();
	}
	static class UDCRecruitChannelListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRecruitChannelListWidget>();
	}
};
static_assert(alignof(UDCRecruitChannelListWidget) == 0x000008, "Wrong alignment on UDCRecruitChannelListWidget");
static_assert(sizeof(UDCRecruitChannelListWidget) == 0x0004F0, "Wrong size on UDCRecruitChannelListWidget");
static_assert(offsetof(UDCRecruitChannelListWidget, Channels) == 0x0004B8, "Member 'UDCRecruitChannelListWidget::Channels' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelListWidget, ServerRegionVerticalBox) == 0x0004C8, "Member 'UDCRecruitChannelListWidget::ServerRegionVerticalBox' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelListWidget, ChannelEntryWidgetClass) == 0x0004D0, "Member 'UDCRecruitChannelListWidget::ChannelEntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelListWidget, JoinMinLevelText) == 0x0004D8, "Member 'UDCRecruitChannelListWidget::JoinMinLevelText' has a wrong offset!");

// Class DungeonCrawler.ClassSpellSkillListWidgetBase
// 0x0010 (0x0390 - 0x0380)
class UClassSpellSkillListWidgetBase final : public USkillListWidgetBase
{
public:
	TArray<class USkillWidget*>                   SkillWidgetArray;                                  // 0x0380(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg);
	void OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassSpellSkillListWidgetBase">();
	}
	static class UClassSpellSkillListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassSpellSkillListWidgetBase>();
	}
};
static_assert(alignof(UClassSpellSkillListWidgetBase) == 0x000008, "Wrong alignment on UClassSpellSkillListWidgetBase");
static_assert(sizeof(UClassSpellSkillListWidgetBase) == 0x000390, "Wrong size on UClassSpellSkillListWidgetBase");
static_assert(offsetof(UClassSpellSkillListWidgetBase, SkillWidgetArray) == 0x000380, "Member 'UClassSpellSkillListWidgetBase::SkillWidgetArray' has a wrong offset!");

// Class DungeonCrawler.LoginVoipInitializePopupData
// 0x0000 (0x0030 - 0x0030)
class ULoginVoipInitializePopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginVoipInitializePopupData">();
	}
	static class ULoginVoipInitializePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginVoipInitializePopupData>();
	}
};
static_assert(alignof(ULoginVoipInitializePopupData) == 0x000008, "Wrong alignment on ULoginVoipInitializePopupData");
static_assert(sizeof(ULoginVoipInitializePopupData) == 0x000030, "Wrong size on ULoginVoipInitializePopupData");

// Class DungeonCrawler.DCAT_InteractionSkillCheck
// 0x0068 (0x00E8 - 0x0080)
class UDCAT_InteractionSkillCheck final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnPerfectSucceed;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSucceed;                                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D5[0x38];                                    // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_InteractionSkillCheck* InteractionSkillCheck(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float Duration, float SucceedSectionStartTime, float SucceedSectionEndTime, float PerfectSucceedSectionStartTime, float PerfectSucceedSectionEndTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_InteractionSkillCheck">();
	}
	static class UDCAT_InteractionSkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_InteractionSkillCheck>();
	}
};
static_assert(alignof(UDCAT_InteractionSkillCheck) == 0x000008, "Wrong alignment on UDCAT_InteractionSkillCheck");
static_assert(sizeof(UDCAT_InteractionSkillCheck) == 0x0000E8, "Wrong size on UDCAT_InteractionSkillCheck");
static_assert(offsetof(UDCAT_InteractionSkillCheck, OnPerfectSucceed) == 0x000080, "Member 'UDCAT_InteractionSkillCheck::OnPerfectSucceed' has a wrong offset!");
static_assert(offsetof(UDCAT_InteractionSkillCheck, OnSucceed) == 0x000090, "Member 'UDCAT_InteractionSkillCheck::OnSucceed' has a wrong offset!");
static_assert(offsetof(UDCAT_InteractionSkillCheck, OnFailed) == 0x0000A0, "Member 'UDCAT_InteractionSkillCheck::OnFailed' has a wrong offset!");

// Class DungeonCrawler.ClassTabMenuWidget
// 0x0000 (0x1580 - 0x1580)
class UClassTabMenuWidget final : public UCommonButtonBase
{
public:
	void OnSkillClassAbilitiesUpdated_BP(const TArray<EDCSkillClassAbility>& SkillClassAbilities);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassTabMenuWidget">();
	}
	static class UClassTabMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassTabMenuWidget>();
	}
};
static_assert(alignof(UClassTabMenuWidget) == 0x000010, "Wrong alignment on UClassTabMenuWidget");
static_assert(sizeof(UClassTabMenuWidget) == 0x001580, "Wrong size on UClassTabMenuWidget");

// Class DungeonCrawler.DCShopCurrencyTypeSelectPopupBase
// 0x0040 (0x04D0 - 0x0490)
class UDCShopCurrencyTypeSelectPopupBase : public UCommonPopupBase
{
public:
	class UVerticalBox*                           VBox_CurrencyTypeSlot;                             // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Cancel;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Confirm;                                       // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCShopCurrencyTypeSlotWidgetBase> CurrencyTypeSlotWidgetClass;                       // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCShopCurrencyType                           SelectedType;                                      // 0x04B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24D7[0x3];                                     // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x04B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDCShopCurrencyTypeSlotWidgetBase*> CurrencySelectSlots;                               // 0x04B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDCShopCurrencyTypeSelectPopupData*     SelectCurrencyPopupData;                           // 0x04C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsBluestoneShardSelected();
	bool IsRedstoneShardSelected();
	void OnCancelClicked();
	void OnConfirmClicked();
	void OnCurrencySelected(const EDCShopCurrencyType CurrencyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopCurrencyTypeSelectPopupBase">();
	}
	static class UDCShopCurrencyTypeSelectPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopCurrencyTypeSelectPopupBase>();
	}
};
static_assert(alignof(UDCShopCurrencyTypeSelectPopupBase) == 0x000008, "Wrong alignment on UDCShopCurrencyTypeSelectPopupBase");
static_assert(sizeof(UDCShopCurrencyTypeSelectPopupBase) == 0x0004D0, "Wrong size on UDCShopCurrencyTypeSelectPopupBase");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, VBox_CurrencyTypeSlot) == 0x000490, "Member 'UDCShopCurrencyTypeSelectPopupBase::VBox_CurrencyTypeSlot' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, Btn_Cancel) == 0x000498, "Member 'UDCShopCurrencyTypeSelectPopupBase::Btn_Cancel' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, Btn_Confirm) == 0x0004A0, "Member 'UDCShopCurrencyTypeSelectPopupBase::Btn_Confirm' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, CurrencyTypeSlotWidgetClass) == 0x0004A8, "Member 'UDCShopCurrencyTypeSelectPopupBase::CurrencyTypeSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, SelectedType) == 0x0004B0, "Member 'UDCShopCurrencyTypeSelectPopupBase::SelectedType' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, Price) == 0x0004B4, "Member 'UDCShopCurrencyTypeSelectPopupBase::Price' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, CurrencySelectSlots) == 0x0004B8, "Member 'UDCShopCurrencyTypeSelectPopupBase::CurrencySelectSlots' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupBase, SelectCurrencyPopupData) == 0x0004C8, "Member 'UDCShopCurrencyTypeSelectPopupBase::SelectCurrencyPopupData' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentMusicItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class UClassUnEquipmentMusicItemWidgetData final : public UObject
{
public:
	struct FPrimaryAssetId                        ID;                                                // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Selected;                                          // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D8[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentMusicItemWidgetData">();
	}
	static class UClassUnEquipmentMusicItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentMusicItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentMusicItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentMusicItemWidgetData");
static_assert(sizeof(UClassUnEquipmentMusicItemWidgetData) == 0x000040, "Wrong size on UClassUnEquipmentMusicItemWidgetData");
static_assert(offsetof(UClassUnEquipmentMusicItemWidgetData, ID) == 0x000028, "Member 'UClassUnEquipmentMusicItemWidgetData::ID' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentMusicItemWidgetData, Selected) == 0x000038, "Member 'UClassUnEquipmentMusicItemWidgetData::Selected' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentMusicListWidget
// 0x0008 (0x0490 - 0x0488)
class UClassUnEquipmentMusicListWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UListView*                              MusicListView;                                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentMusicListWidget">();
	}
	static class UClassUnEquipmentMusicListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentMusicListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentMusicListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentMusicListWidget");
static_assert(sizeof(UClassUnEquipmentMusicListWidget) == 0x000490, "Wrong size on UClassUnEquipmentMusicListWidget");
static_assert(offsetof(UClassUnEquipmentMusicListWidget, MusicListView) == 0x000488, "Member 'UClassUnEquipmentMusicListWidget::MusicListView' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationMoveSpeed
// 0x0180 (0x01C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationMoveSpeed final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_24D9[0x180];                                   // 0x0040(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationMoveSpeed">();
	}
	static class UDCAttributeModMagnitudeCalculationMoveSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationMoveSpeed>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationMoveSpeed) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationMoveSpeed");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationMoveSpeed) == 0x0001C0, "Wrong size on UDCAttributeModMagnitudeCalculationMoveSpeed");

// Class DungeonCrawler.DCInventoryGearScoreWidget
// 0x0018 (0x02D8 - 0x02C0)
class UDCInventoryGearScoreWidget final : public UUserWidget
{
public:
	int32                                         GearScore;                                         // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DA[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCInventoryBase*>               Targets;                                           // 0x02C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryGearScoreWidget">();
	}
	static class UDCInventoryGearScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryGearScoreWidget>();
	}
};
static_assert(alignof(UDCInventoryGearScoreWidget) == 0x000008, "Wrong alignment on UDCInventoryGearScoreWidget");
static_assert(sizeof(UDCInventoryGearScoreWidget) == 0x0002D8, "Wrong size on UDCInventoryGearScoreWidget");
static_assert(offsetof(UDCInventoryGearScoreWidget, GearScore) == 0x0002C0, "Member 'UDCInventoryGearScoreWidget::GearScore' has a wrong offset!");
static_assert(offsetof(UDCInventoryGearScoreWidget, Targets) == 0x0002C8, "Member 'UDCInventoryGearScoreWidget::Targets' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentMusicTypeItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class UClassUnEquipmentMusicTypeItemWidgetData final : public UObject
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                MusicIds;                                          // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentMusicTypeItemWidgetData">();
	}
	static class UClassUnEquipmentMusicTypeItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentMusicTypeItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentMusicTypeItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentMusicTypeItemWidgetData");
static_assert(sizeof(UClassUnEquipmentMusicTypeItemWidgetData) == 0x000040, "Wrong size on UClassUnEquipmentMusicTypeItemWidgetData");
static_assert(offsetof(UClassUnEquipmentMusicTypeItemWidgetData, TypeTag) == 0x000028, "Member 'UClassUnEquipmentMusicTypeItemWidgetData::TypeTag' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentMusicTypeItemWidgetData, MusicIds) == 0x000030, "Member 'UClassUnEquipmentMusicTypeItemWidgetData::MusicIds' has a wrong offset!");

// Class DungeonCrawler.DCTrainingTokenRedeemResultWidgetBase
// 0x0098 (0x0358 - 0x02C0)
class UDCTrainingTokenRedeemResultWidgetBase final : public UUserWidget
{
public:
	class UDCCommonButtonBase*                    ReceiveButton;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTrainingOptionSlotWidgetBase*        Option01;                                          // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTrainingOptionSlotWidgetBase*        Option02;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTrainingOptionSlotWidgetBase*        Option03;                                          // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRewardSelected;                                 // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DB[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MasterClassIcon;                                   // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDCTrainingOptionSlotWidgetBase*> TrainingOptionWidgetArray;                         // 0x02F0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EDCTrainingState                              TargetState;                                       // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DC[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCTrainingReceiveCheckPopup> ReceiveCheckPopupClass;                            // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCTrainingOptionInfo                  SelectedTrainingOption;                            // 0x0310(0x0040)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	EDCTrainingState                              LastTrainingState;                                 // 0x0350(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24DD[0x7];                                     // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOptionsUpdated();
	void OnReceiveButtonClicked();

	bool IsEnableReceiveButton() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingTokenRedeemResultWidgetBase">();
	}
	static class UDCTrainingTokenRedeemResultWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingTokenRedeemResultWidgetBase>();
	}
};
static_assert(alignof(UDCTrainingTokenRedeemResultWidgetBase) == 0x000008, "Wrong alignment on UDCTrainingTokenRedeemResultWidgetBase");
static_assert(sizeof(UDCTrainingTokenRedeemResultWidgetBase) == 0x000358, "Wrong size on UDCTrainingTokenRedeemResultWidgetBase");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, ReceiveButton) == 0x0002C0, "Member 'UDCTrainingTokenRedeemResultWidgetBase::ReceiveButton' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, Option01) == 0x0002C8, "Member 'UDCTrainingTokenRedeemResultWidgetBase::Option01' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, Option02) == 0x0002D0, "Member 'UDCTrainingTokenRedeemResultWidgetBase::Option02' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, Option03) == 0x0002D8, "Member 'UDCTrainingTokenRedeemResultWidgetBase::Option03' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, bIsRewardSelected) == 0x0002E0, "Member 'UDCTrainingTokenRedeemResultWidgetBase::bIsRewardSelected' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, MasterClassIcon) == 0x0002E8, "Member 'UDCTrainingTokenRedeemResultWidgetBase::MasterClassIcon' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, TrainingOptionWidgetArray) == 0x0002F0, "Member 'UDCTrainingTokenRedeemResultWidgetBase::TrainingOptionWidgetArray' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, TargetState) == 0x000300, "Member 'UDCTrainingTokenRedeemResultWidgetBase::TargetState' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, ReceiveCheckPopupClass) == 0x000308, "Member 'UDCTrainingTokenRedeemResultWidgetBase::ReceiveCheckPopupClass' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, SelectedTrainingOption) == 0x000310, "Member 'UDCTrainingTokenRedeemResultWidgetBase::SelectedTrainingOption' has a wrong offset!");
static_assert(offsetof(UDCTrainingTokenRedeemResultWidgetBase, LastTrainingState) == 0x000350, "Member 'UDCTrainingTokenRedeemResultWidgetBase::LastTrainingState' has a wrong offset!");

// Class DungeonCrawler.SoundData
// 0x00F0 (0x0138 - 0x0048)
class USoundData final : public UDCDataAssetBase
{
public:
	TMap<struct FGameplayTag, class UAkAudioEvent*> AkEventByGameplayTag;                              // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FDCSoundDataContainer> AkSwitchesByGameplayTag;                           // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagQuery> SoundPlayableTagQuery;                             // 0x00E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundData">();
	}
	static class USoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundData>();
	}
};
static_assert(alignof(USoundData) == 0x000008, "Wrong alignment on USoundData");
static_assert(sizeof(USoundData) == 0x000138, "Wrong size on USoundData");
static_assert(offsetof(USoundData, AkEventByGameplayTag) == 0x000048, "Member 'USoundData::AkEventByGameplayTag' has a wrong offset!");
static_assert(offsetof(USoundData, AkSwitchesByGameplayTag) == 0x000098, "Member 'USoundData::AkSwitchesByGameplayTag' has a wrong offset!");
static_assert(offsetof(USoundData, SoundPlayableTagQuery) == 0x0000E8, "Member 'USoundData::SoundPlayableTagQuery' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationSkillVictoryStrike
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationSkillVictoryStrike final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_24DE[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationSkillVictoryStrike">();
	}
	static class UDCAttributeModMagnitudeCalculationSkillVictoryStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationSkillVictoryStrike>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationSkillVictoryStrike) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationSkillVictoryStrike");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationSkillVictoryStrike) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationSkillVictoryStrike");

// Class DungeonCrawler.ClassUnEquipmentMusicTypeListWidget
// 0x0018 (0x0370 - 0x0358)
class UClassUnEquipmentMusicTypeListWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_24DF[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TypeName;                                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              MusicTileView;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentMusicTypeListWidget">();
	}
	static class UClassUnEquipmentMusicTypeListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentMusicTypeListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentMusicTypeListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentMusicTypeListWidget");
static_assert(sizeof(UClassUnEquipmentMusicTypeListWidget) == 0x000370, "Wrong size on UClassUnEquipmentMusicTypeListWidget");
static_assert(offsetof(UClassUnEquipmentMusicTypeListWidget, TypeName) == 0x000360, "Member 'UClassUnEquipmentMusicTypeListWidget::TypeName' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentMusicTypeListWidget, MusicTileView) == 0x000368, "Member 'UClassUnEquipmentMusicTypeListWidget::MusicTileView' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentPerkandSkillItemWidgetData
// 0x0020 (0x0048 - 0x0028)
class UClassUnEquipmentPerkandSkillItemWidgetData final : public UObject
{
public:
	struct FPrimaryAssetId                        ID;                                                // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Selected;                                          // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E0[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x0040(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentPerkandSkillItemWidgetData">();
	}
	static class UClassUnEquipmentPerkandSkillItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentPerkandSkillItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentPerkandSkillItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentPerkandSkillItemWidgetData");
static_assert(sizeof(UClassUnEquipmentPerkandSkillItemWidgetData) == 0x000048, "Wrong size on UClassUnEquipmentPerkandSkillItemWidgetData");
static_assert(offsetof(UClassUnEquipmentPerkandSkillItemWidgetData, ID) == 0x000028, "Member 'UClassUnEquipmentPerkandSkillItemWidgetData::ID' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentPerkandSkillItemWidgetData, Selected) == 0x000038, "Member 'UClassUnEquipmentPerkandSkillItemWidgetData::Selected' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentPerkandSkillItemWidgetData, Widget) == 0x000040, "Member 'UClassUnEquipmentPerkandSkillItemWidgetData::Widget' has a wrong offset!");

// Class DungeonCrawler.DCShopArtData
// 0x0008 (0x0050 - 0x0048)
class UDCShopArtData final : public UArtDataBase
{
public:
	class UTexture2D*                             ShopIconTexture;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopArtData">();
	}
	static class UDCShopArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopArtData>();
	}
};
static_assert(alignof(UDCShopArtData) == 0x000008, "Wrong alignment on UDCShopArtData");
static_assert(sizeof(UDCShopArtData) == 0x000050, "Wrong size on UDCShopArtData");
static_assert(offsetof(UDCShopArtData, ShopIconTexture) == 0x000048, "Member 'UDCShopArtData::ShopIconTexture' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitVelocityChange
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WaitVelocityChange final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnVelocityChange;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMovementComponent*                     CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E1[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitVelocityChange* WaitVelocityChange(class UGameplayAbility* OwningAbility, float MinimumMagnitude);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitVelocityChange">();
	}
	static class UDCAT_WaitVelocityChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitVelocityChange>();
	}
};
static_assert(alignof(UDCAT_WaitVelocityChange) == 0x000008, "Wrong alignment on UDCAT_WaitVelocityChange");
static_assert(sizeof(UDCAT_WaitVelocityChange) == 0x0000A0, "Wrong size on UDCAT_WaitVelocityChange");
static_assert(offsetof(UDCAT_WaitVelocityChange, OnVelocityChange) == 0x000080, "Member 'UDCAT_WaitVelocityChange::OnVelocityChange' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitVelocityChange, CachedMovementComponent) == 0x000090, "Member 'UDCAT_WaitVelocityChange::CachedMovementComponent' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget
// 0x0010 (0x0498 - 0x0488)
class UClassUnEquipmentPerkandSkillListWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UTileView*                              PerkTileView;                                      // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              SkillTileView;                                     // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FPrimaryAssetId GetSelectedPerkId();
	struct FPrimaryAssetId GetSelectedSkillId();
	void OnCompletedPerkTileViewRegenerateAllEntries();
	void OnCompletedSkillTileViewRegenerateAllEntries();
	void OnSetCompletedPerkTileView();
	void OnSetCompletedSkillTileView();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentPerkandSkillListWidget">();
	}
	static class UClassUnEquipmentPerkandSkillListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentPerkandSkillListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentPerkandSkillListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentPerkandSkillListWidget");
static_assert(sizeof(UClassUnEquipmentPerkandSkillListWidget) == 0x000498, "Wrong size on UClassUnEquipmentPerkandSkillListWidget");
static_assert(offsetof(UClassUnEquipmentPerkandSkillListWidget, PerkTileView) == 0x000488, "Member 'UClassUnEquipmentPerkandSkillListWidget::PerkTileView' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentPerkandSkillListWidget, SkillTileView) == 0x000490, "Member 'UClassUnEquipmentPerkandSkillListWidget::SkillTileView' has a wrong offset!");

// Class DungeonCrawler.DCPreLobbyHUD
// 0x0010 (0x03A8 - 0x0398)
class ADCPreLobbyHUD : public ADCHUD
{
public:
	TSubclassOf<class ADCCaptureStudioActor>      LobbyCreateStudioActorClass;                       // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCCaptureStudioActor*                  LobbyCreateStudioActor;                            // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPreLobbyHUD">();
	}
	static class ADCPreLobbyHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPreLobbyHUD>();
	}
};
static_assert(alignof(ADCPreLobbyHUD) == 0x000008, "Wrong alignment on ADCPreLobbyHUD");
static_assert(sizeof(ADCPreLobbyHUD) == 0x0003A8, "Wrong size on ADCPreLobbyHUD");
static_assert(offsetof(ADCPreLobbyHUD, LobbyCreateStudioActorClass) == 0x000398, "Member 'ADCPreLobbyHUD::LobbyCreateStudioActorClass' has a wrong offset!");
static_assert(offsetof(ADCPreLobbyHUD, LobbyCreateStudioActor) == 0x0003A0, "Member 'ADCPreLobbyHUD::LobbyCreateStudioActor' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentShapeShiftItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class UClassUnEquipmentShapeShiftItemWidgetData final : public UObject
{
public:
	struct FPrimaryAssetId                        ID;                                                // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Selected;                                          // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E3[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentShapeShiftItemWidgetData">();
	}
	static class UClassUnEquipmentShapeShiftItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentShapeShiftItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentShapeShiftItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentShapeShiftItemWidgetData");
static_assert(sizeof(UClassUnEquipmentShapeShiftItemWidgetData) == 0x000040, "Wrong size on UClassUnEquipmentShapeShiftItemWidgetData");
static_assert(offsetof(UClassUnEquipmentShapeShiftItemWidgetData, ID) == 0x000028, "Member 'UClassUnEquipmentShapeShiftItemWidgetData::ID' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentShapeShiftItemWidgetData, Selected) == 0x000038, "Member 'UClassUnEquipmentShapeShiftItemWidgetData::Selected' has a wrong offset!");

// Class DungeonCrawler.InjectionItemSelectedPropertyWidgetBase
// 0x0048 (0x0330 - 0x02E8)
class UInjectionItemSelectedPropertyWidgetBase final : public UCommonUserWidget
{
public:
	uint8                                         Pad_24E4[0x10];                                    // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditableText*                          EditableText;                                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemPropertyType;                                  // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         PropertyValue;                                     // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E5[0x14];                                    // 0x031C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPropertyValueChanged(const class FText& Text);
	void OnPropertyValueSet(const class FText& Text, ETextCommit CommitMethod);
	void OnSelectedPropertyValueChanged__DelegateSignature(const struct FPrimaryAssetId& PropertyTypeAssetId, int32 Param_PropertyValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemSelectedPropertyWidgetBase">();
	}
	static class UInjectionItemSelectedPropertyWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemSelectedPropertyWidgetBase>();
	}
};
static_assert(alignof(UInjectionItemSelectedPropertyWidgetBase) == 0x000008, "Wrong alignment on UInjectionItemSelectedPropertyWidgetBase");
static_assert(sizeof(UInjectionItemSelectedPropertyWidgetBase) == 0x000330, "Wrong size on UInjectionItemSelectedPropertyWidgetBase");
static_assert(offsetof(UInjectionItemSelectedPropertyWidgetBase, EditableText) == 0x0002F8, "Member 'UInjectionItemSelectedPropertyWidgetBase::EditableText' has a wrong offset!");
static_assert(offsetof(UInjectionItemSelectedPropertyWidgetBase, ItemPropertyType) == 0x000300, "Member 'UInjectionItemSelectedPropertyWidgetBase::ItemPropertyType' has a wrong offset!");
static_assert(offsetof(UInjectionItemSelectedPropertyWidgetBase, PropertyValue) == 0x000318, "Member 'UInjectionItemSelectedPropertyWidgetBase::PropertyValue' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinWidget
// 0x0078 (0x0508 - 0x0490)
class UDCActionSkinWidget : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_24E7[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionSkinName;                                    // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ActionSkinFlavorText;                              // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ActionSkinIconTexture;                             // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        ActionSkinId;                                      // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E8[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameTooltipWithFlavorTextWidget*     SkinTooltipWidget;                                 // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UUserWidget* GetActionSkinTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinWidget">();
	}
	static class UDCActionSkinWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinWidget>();
	}
};
static_assert(alignof(UDCActionSkinWidget) == 0x000008, "Wrong alignment on UDCActionSkinWidget");
static_assert(sizeof(UDCActionSkinWidget) == 0x000508, "Wrong size on UDCActionSkinWidget");
static_assert(offsetof(UDCActionSkinWidget, ActionSkinName) == 0x0004A8, "Member 'UDCActionSkinWidget::ActionSkinName' has a wrong offset!");
static_assert(offsetof(UDCActionSkinWidget, ActionSkinFlavorText) == 0x0004C0, "Member 'UDCActionSkinWidget::ActionSkinFlavorText' has a wrong offset!");
static_assert(offsetof(UDCActionSkinWidget, ActionSkinIconTexture) == 0x0004D8, "Member 'UDCActionSkinWidget::ActionSkinIconTexture' has a wrong offset!");
static_assert(offsetof(UDCActionSkinWidget, ActionSkinId) == 0x0004E0, "Member 'UDCActionSkinWidget::ActionSkinId' has a wrong offset!");
static_assert(offsetof(UDCActionSkinWidget, bIsEquipped) == 0x0004F0, "Member 'UDCActionSkinWidget::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UDCActionSkinWidget, TooltipWidgetClass) == 0x0004F8, "Member 'UDCActionSkinWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCActionSkinWidget, SkinTooltipWidget) == 0x000500, "Member 'UDCActionSkinWidget::SkinTooltipWidget' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinListEntryWidget
// 0x0010 (0x0518 - 0x0508)
class UDCActionSkinListEntryWidget final : public UDCActionSkinWidget
{
public:
	uint8                                         Pad_24E9[0x10];                                    // 0x0508(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinListEntryWidget">();
	}
	static class UDCActionSkinListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinListEntryWidget>();
	}
};
static_assert(alignof(UDCActionSkinListEntryWidget) == 0x000008, "Wrong alignment on UDCActionSkinListEntryWidget");
static_assert(sizeof(UDCActionSkinListEntryWidget) == 0x000518, "Wrong size on UDCActionSkinListEntryWidget");

// Class DungeonCrawler.ClassUnEquipmentShapeShiftListWidget
// 0x0008 (0x0490 - 0x0488)
class UClassUnEquipmentShapeShiftListWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UListView*                              ShapeShiftListView;                                // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentShapeShiftListWidget">();
	}
	static class UClassUnEquipmentShapeShiftListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentShapeShiftListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentShapeShiftListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentShapeShiftListWidget");
static_assert(sizeof(UClassUnEquipmentShapeShiftListWidget) == 0x000490, "Wrong size on UClassUnEquipmentShapeShiftListWidget");
static_assert(offsetof(UClassUnEquipmentShapeShiftListWidget, ShapeShiftListView) == 0x000488, "Member 'UClassUnEquipmentShapeShiftListWidget::ShapeShiftListView' has a wrong offset!");

// Class DungeonCrawler.DCPoolingUObject
// 0x0000 (0x0028 - 0x0028)
class IDCPoolingUObject final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPoolingUObject">();
	}
	static class IDCPoolingUObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCPoolingUObject>();
	}
};
static_assert(alignof(IDCPoolingUObject) == 0x000008, "Wrong alignment on IDCPoolingUObject");
static_assert(sizeof(IDCPoolingUObject) == 0x000028, "Wrong size on IDCPoolingUObject");

// Class DungeonCrawler.ClassUnEquipmentShapeShiftTypeItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class UClassUnEquipmentShapeShiftTypeItemWidgetData final : public UObject
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ShapeShiftIds;                                     // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentShapeShiftTypeItemWidgetData">();
	}
	static class UClassUnEquipmentShapeShiftTypeItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentShapeShiftTypeItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentShapeShiftTypeItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentShapeShiftTypeItemWidgetData");
static_assert(sizeof(UClassUnEquipmentShapeShiftTypeItemWidgetData) == 0x000040, "Wrong size on UClassUnEquipmentShapeShiftTypeItemWidgetData");
static_assert(offsetof(UClassUnEquipmentShapeShiftTypeItemWidgetData, TypeTag) == 0x000028, "Member 'UClassUnEquipmentShapeShiftTypeItemWidgetData::TypeTag' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentShapeShiftTypeItemWidgetData, ShapeShiftIds) == 0x000030, "Member 'UClassUnEquipmentShapeShiftTypeItemWidgetData::ShapeShiftIds' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentShapeShiftTypeListWidget
// 0x0018 (0x0370 - 0x0358)
class UClassUnEquipmentShapeShiftTypeListWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_24EA[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TypeName;                                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              ShapeShiftTileView;                                // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentShapeShiftTypeListWidget">();
	}
	static class UClassUnEquipmentShapeShiftTypeListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentShapeShiftTypeListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentShapeShiftTypeListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentShapeShiftTypeListWidget");
static_assert(sizeof(UClassUnEquipmentShapeShiftTypeListWidget) == 0x000370, "Wrong size on UClassUnEquipmentShapeShiftTypeListWidget");
static_assert(offsetof(UClassUnEquipmentShapeShiftTypeListWidget, TypeName) == 0x000360, "Member 'UClassUnEquipmentShapeShiftTypeListWidget::TypeName' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentShapeShiftTypeListWidget, ShapeShiftTileView) == 0x000368, "Member 'UClassUnEquipmentShapeShiftTypeListWidget::ShapeShiftTileView' has a wrong offset!");

// Class DungeonCrawler.DCAccountStatusUpgradeCompletePopupData
// 0x0000 (0x0030 - 0x0030)
class UDCAccountStatusUpgradeCompletePopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountStatusUpgradeCompletePopupData">();
	}
	static class UDCAccountStatusUpgradeCompletePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountStatusUpgradeCompletePopupData>();
	}
};
static_assert(alignof(UDCAccountStatusUpgradeCompletePopupData) == 0x000008, "Wrong alignment on UDCAccountStatusUpgradeCompletePopupData");
static_assert(sizeof(UDCAccountStatusUpgradeCompletePopupData) == 0x000030, "Wrong size on UDCAccountStatusUpgradeCompletePopupData");

// Class DungeonCrawler.ClassUnEquipmentSpellItemWidgetData
// 0x0048 (0x0070 - 0x0028)
class UClassUnEquipmentSpellItemWidgetData final : public UObject
{
public:
	struct FSpellData                             SpellData;                                         // 0x0028(0x0040)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Selected;                                          // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24EB[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentSpellItemWidgetData">();
	}
	static class UClassUnEquipmentSpellItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentSpellItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentSpellItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentSpellItemWidgetData");
static_assert(sizeof(UClassUnEquipmentSpellItemWidgetData) == 0x000070, "Wrong size on UClassUnEquipmentSpellItemWidgetData");
static_assert(offsetof(UClassUnEquipmentSpellItemWidgetData, SpellData) == 0x000028, "Member 'UClassUnEquipmentSpellItemWidgetData::SpellData' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentSpellItemWidgetData, Selected) == 0x000068, "Member 'UClassUnEquipmentSpellItemWidgetData::Selected' has a wrong offset!");

// Class DungeonCrawler.DCShapeShiftReferenceCharacter
// 0x0020 (0x06A0 - 0x0680)
class ADCShapeShiftReferenceCharacter final : public ACharacter
{
public:
	class USkeletalMeshComponent*                 PartHead;                                          // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAkComponent*                         DCAk;                                              // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSceneCaptureComponent2D*             PortraitCaptureComponent;                          // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterShapeShiftArtData*          ShapeShiftArtData;                                 // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24EC[0x8];                                     // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShapeShiftReferenceCharacter">();
	}
	static class ADCShapeShiftReferenceCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCShapeShiftReferenceCharacter>();
	}
};
static_assert(alignof(ADCShapeShiftReferenceCharacter) == 0x000010, "Wrong alignment on ADCShapeShiftReferenceCharacter");
static_assert(sizeof(ADCShapeShiftReferenceCharacter) == 0x0006A0, "Wrong size on ADCShapeShiftReferenceCharacter");
static_assert(offsetof(ADCShapeShiftReferenceCharacter, PartHead) == 0x000678, "Member 'ADCShapeShiftReferenceCharacter::PartHead' has a wrong offset!");
static_assert(offsetof(ADCShapeShiftReferenceCharacter, DCAk) == 0x000680, "Member 'ADCShapeShiftReferenceCharacter::DCAk' has a wrong offset!");
static_assert(offsetof(ADCShapeShiftReferenceCharacter, PortraitCaptureComponent) == 0x000688, "Member 'ADCShapeShiftReferenceCharacter::PortraitCaptureComponent' has a wrong offset!");
static_assert(offsetof(ADCShapeShiftReferenceCharacter, ShapeShiftArtData) == 0x000690, "Member 'ADCShapeShiftReferenceCharacter::ShapeShiftArtData' has a wrong offset!");

// Class DungeonCrawler.LootDropDataInterface
// 0x0000 (0x0028 - 0x0028)
class ILootDropDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootDropDataInterface">();
	}
	static class ILootDropDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILootDropDataInterface>();
	}
};
static_assert(alignof(ILootDropDataInterface) == 0x000008, "Wrong alignment on ILootDropDataInterface");
static_assert(sizeof(ILootDropDataInterface) == 0x000028, "Wrong size on ILootDropDataInterface");

// Class DungeonCrawler.DCAT_OverlapActorsInRadius
// 0x0040 (0x00C0 - 0x0080)
class UDCAT_OverlapActorsInRadius final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTargetActorOverlapBegin;                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTargetActorOverlapEnd;                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24ED[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_OverlapActorsInRadius* OverlapActorsInRadius(class UGameplayAbility* OwningAbility, float Radius, class FName CollisionProfileName, class UClass* OverlapTargetClass);

	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_OverlapActorsInRadius">();
	}
	static class UDCAT_OverlapActorsInRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_OverlapActorsInRadius>();
	}
};
static_assert(alignof(UDCAT_OverlapActorsInRadius) == 0x000008, "Wrong alignment on UDCAT_OverlapActorsInRadius");
static_assert(sizeof(UDCAT_OverlapActorsInRadius) == 0x0000C0, "Wrong size on UDCAT_OverlapActorsInRadius");
static_assert(offsetof(UDCAT_OverlapActorsInRadius, OnTargetActorOverlapBegin) == 0x000080, "Member 'UDCAT_OverlapActorsInRadius::OnTargetActorOverlapBegin' has a wrong offset!");
static_assert(offsetof(UDCAT_OverlapActorsInRadius, OnTargetActorOverlapEnd) == 0x000090, "Member 'UDCAT_OverlapActorsInRadius::OnTargetActorOverlapEnd' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentSpellListWidget
// 0x0008 (0x0490 - 0x0488)
class UClassUnEquipmentSpellListWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UListView*                              SpellListView;                                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentSpellListWidget">();
	}
	static class UClassUnEquipmentSpellListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentSpellListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentSpellListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentSpellListWidget");
static_assert(sizeof(UClassUnEquipmentSpellListWidget) == 0x000490, "Wrong size on UClassUnEquipmentSpellListWidget");
static_assert(offsetof(UClassUnEquipmentSpellListWidget, SpellListView) == 0x000488, "Member 'UClassUnEquipmentSpellListWidget::SpellListView' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentSpellTierItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class UClassUnEquipmentSpellTierItemWidgetData final : public UObject
{
public:
	int32                                         Tier;                                              // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F1[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpellData>                     SpellDatas;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentSpellTierItemWidgetData">();
	}
	static class UClassUnEquipmentSpellTierItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentSpellTierItemWidgetData>();
	}
};
static_assert(alignof(UClassUnEquipmentSpellTierItemWidgetData) == 0x000008, "Wrong alignment on UClassUnEquipmentSpellTierItemWidgetData");
static_assert(sizeof(UClassUnEquipmentSpellTierItemWidgetData) == 0x000040, "Wrong size on UClassUnEquipmentSpellTierItemWidgetData");
static_assert(offsetof(UClassUnEquipmentSpellTierItemWidgetData, Tier) == 0x000028, "Member 'UClassUnEquipmentSpellTierItemWidgetData::Tier' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentSpellTierItemWidgetData, SpellDatas) == 0x000030, "Member 'UClassUnEquipmentSpellTierItemWidgetData::SpellDatas' has a wrong offset!");

// Class DungeonCrawler.DCShopDataAsset
// 0x0060 (0x00A8 - 0x0048)
class UDCShopDataAsset : public UDCTableDataAsset
{
public:
	TSoftObjectPtr<class UDCShopArtData>          ArtData;                                           // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSale;                                          // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F2[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountPrice;                                     // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashPrice;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountCashPrice;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F3[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCShopSalesChannelType                       SalesChannel;                                      // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F4[0x3];                                     // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ExclusiveSourceText;                               // 0x0090(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopDataAsset">();
	}
	static class UDCShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopDataAsset>();
	}
};
static_assert(alignof(UDCShopDataAsset) == 0x000008, "Wrong alignment on UDCShopDataAsset");
static_assert(sizeof(UDCShopDataAsset) == 0x0000A8, "Wrong size on UDCShopDataAsset");
static_assert(offsetof(UDCShopDataAsset, ArtData) == 0x000048, "Member 'UDCShopDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, IsOnSale) == 0x000070, "Member 'UDCShopDataAsset::IsOnSale' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, Price) == 0x000074, "Member 'UDCShopDataAsset::Price' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, DiscountPrice) == 0x000078, "Member 'UDCShopDataAsset::DiscountPrice' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, CashPrice) == 0x00007C, "Member 'UDCShopDataAsset::CashPrice' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, DiscountCashPrice) == 0x000080, "Member 'UDCShopDataAsset::DiscountCashPrice' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, IsNew) == 0x000084, "Member 'UDCShopDataAsset::IsNew' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, SortOrder) == 0x000088, "Member 'UDCShopDataAsset::SortOrder' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, SalesChannel) == 0x00008C, "Member 'UDCShopDataAsset::SalesChannel' has a wrong offset!");
static_assert(offsetof(UDCShopDataAsset, ExclusiveSourceText) == 0x000090, "Member 'UDCShopDataAsset::ExclusiveSourceText' has a wrong offset!");

// Class DungeonCrawler.DCItemSkinShopDataAsset
// 0x0030 (0x00D8 - 0x00A8)
class UDCItemSkinShopDataAsset final : public UDCShopDataAsset
{
public:
	TArray<TSoftObjectPtr<class UDCItemSkinDataAsset>> StockDatas;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   PackageName;                                       // 0x00B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDCItemPreviewDataAsset*                PackagePreview;                                    // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinShopDataAsset">();
	}
	static class UDCItemSkinShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinShopDataAsset>();
	}
};
static_assert(alignof(UDCItemSkinShopDataAsset) == 0x000008, "Wrong alignment on UDCItemSkinShopDataAsset");
static_assert(sizeof(UDCItemSkinShopDataAsset) == 0x0000D8, "Wrong size on UDCItemSkinShopDataAsset");
static_assert(offsetof(UDCItemSkinShopDataAsset, StockDatas) == 0x0000A8, "Member 'UDCItemSkinShopDataAsset::StockDatas' has a wrong offset!");
static_assert(offsetof(UDCItemSkinShopDataAsset, PackageName) == 0x0000B8, "Member 'UDCItemSkinShopDataAsset::PackageName' has a wrong offset!");
static_assert(offsetof(UDCItemSkinShopDataAsset, PackagePreview) == 0x0000D0, "Member 'UDCItemSkinShopDataAsset::PackagePreview' has a wrong offset!");

// Class DungeonCrawler.DCBagWidget
// 0x00F8 (0x04D8 - 0x03E0)
class UDCBagWidget final : public UDCInventoryWidgetBase
{
public:
	TSubclassOf<class UDCBagSlotWidget>           SlotWidgetClass;                                   // 0x03E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCBagItemWidget>           ItemWidgetClass;                                   // 0x03E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCInputNumberWidget>       SplitWidgetClass;                                  // 0x03F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           SplitInputAction;                                  // 0x03F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SlotRowsVerticalBox;                               // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ItemAreaCanvas;                                    // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        Inventory;                                         // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInputNumberWidget*                   SplitWidget;                                       // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, class UDCBagItemWidget*> ItemWidgets;                                       // 0x0420(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24F5[0x68];                                    // 0x0470(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDragCanceled(class UDragDropOperation* Operation);

	int32 GetGoldAmount() const;
	class FText GetInventoryName() const;
	const TMap<struct FDCItemId, class UDCBagItemWidget*> GetItemWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCBagWidget">();
	}
	static class UDCBagWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCBagWidget>();
	}
};
static_assert(alignof(UDCBagWidget) == 0x000008, "Wrong alignment on UDCBagWidget");
static_assert(sizeof(UDCBagWidget) == 0x0004D8, "Wrong size on UDCBagWidget");
static_assert(offsetof(UDCBagWidget, SlotWidgetClass) == 0x0003E0, "Member 'UDCBagWidget::SlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, ItemWidgetClass) == 0x0003E8, "Member 'UDCBagWidget::ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, SplitWidgetClass) == 0x0003F0, "Member 'UDCBagWidget::SplitWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, SplitInputAction) == 0x0003F8, "Member 'UDCBagWidget::SplitInputAction' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, SlotRowsVerticalBox) == 0x000400, "Member 'UDCBagWidget::SlotRowsVerticalBox' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, ItemAreaCanvas) == 0x000408, "Member 'UDCBagWidget::ItemAreaCanvas' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, Inventory) == 0x000410, "Member 'UDCBagWidget::Inventory' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, SplitWidget) == 0x000418, "Member 'UDCBagWidget::SplitWidget' has a wrong offset!");
static_assert(offsetof(UDCBagWidget, ItemWidgets) == 0x000420, "Member 'UDCBagWidget::ItemWidgets' has a wrong offset!");

// Class DungeonCrawler.ClassUnEquipmentSpellTierListWidget
// 0x0020 (0x0378 - 0x0358)
class UClassUnEquipmentSpellTierListWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_24F6[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TierNumber;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CostNumber;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              SpellTileView;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClassUnEquipmentSpellTierListWidget">();
	}
	static class UClassUnEquipmentSpellTierListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClassUnEquipmentSpellTierListWidget>();
	}
};
static_assert(alignof(UClassUnEquipmentSpellTierListWidget) == 0x000008, "Wrong alignment on UClassUnEquipmentSpellTierListWidget");
static_assert(sizeof(UClassUnEquipmentSpellTierListWidget) == 0x000378, "Wrong size on UClassUnEquipmentSpellTierListWidget");
static_assert(offsetof(UClassUnEquipmentSpellTierListWidget, TierNumber) == 0x000360, "Member 'UClassUnEquipmentSpellTierListWidget::TierNumber' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentSpellTierListWidget, CostNumber) == 0x000368, "Member 'UClassUnEquipmentSpellTierListWidget::CostNumber' has a wrong offset!");
static_assert(offsetof(UClassUnEquipmentSpellTierListWidget, SpellTileView) == 0x000370, "Member 'UClassUnEquipmentSpellTierListWidget::SpellTileView' has a wrong offset!");

// Class DungeonCrawler.DCPropsDataAsset
// 0x00D0 (0x0118 - 0x0048)
class UDCPropsDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCPropsDataAsset;                             // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IdTag;                                             // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x0068(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCLootDropGroupDataAsset> LootDropGroup;                                     // 0x0070(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0098(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropsActorBase>            ActorClass;                                        // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionMinCount;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionMaxCount;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCPropsInteractDataAsset>> InteractionSettingDatas;                           // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTagQueryData>>   DestructibleTagQueryData;                          // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         AdvPoint;                                          // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpPoint;                                          // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPropsDataAsset">();
	}
	static class UDCPropsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPropsDataAsset>();
	}
};
static_assert(alignof(UDCPropsDataAsset) == 0x000008, "Wrong alignment on UDCPropsDataAsset");
static_assert(sizeof(UDCPropsDataAsset) == 0x000118, "Wrong size on UDCPropsDataAsset");
static_assert(offsetof(UDCPropsDataAsset, Name_DCPropsDataAsset) == 0x000048, "Member 'UDCPropsDataAsset::Name_DCPropsDataAsset' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, IdTag) == 0x000060, "Member 'UDCPropsDataAsset::IdTag' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, GradeType) == 0x000068, "Member 'UDCPropsDataAsset::GradeType' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, LootDropGroup) == 0x000070, "Member 'UDCPropsDataAsset::LootDropGroup' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, SoundData) == 0x000098, "Member 'UDCPropsDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, ActorClass) == 0x0000C0, "Member 'UDCPropsDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, InteractionMinCount) == 0x0000C8, "Member 'UDCPropsDataAsset::InteractionMinCount' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, InteractionMaxCount) == 0x0000CC, "Member 'UDCPropsDataAsset::InteractionMaxCount' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, InteractionSettingDatas) == 0x0000D0, "Member 'UDCPropsDataAsset::InteractionSettingDatas' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, DestructibleTagQueryData) == 0x0000E0, "Member 'UDCPropsDataAsset::DestructibleTagQueryData' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, Abilities) == 0x0000F0, "Member 'UDCPropsDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, Effects) == 0x000100, "Member 'UDCPropsDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, AdvPoint) == 0x000110, "Member 'UDCPropsDataAsset::AdvPoint' has a wrong offset!");
static_assert(offsetof(UDCPropsDataAsset, ExpPoint) == 0x000114, "Member 'UDCPropsDataAsset::ExpPoint' has a wrong offset!");

// Class DungeonCrawler.SubSystemReplyMsg
// 0x0020 (0x0048 - 0x0028)
class USubSystemReplyMsg final : public UObject
{
public:
	uint8                                         Pad_24F7[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CreateAt;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F8[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubSystemReplyMsg">();
	}
	static class USubSystemReplyMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubSystemReplyMsg>();
	}
};
static_assert(alignof(USubSystemReplyMsg) == 0x000008, "Wrong alignment on USubSystemReplyMsg");
static_assert(sizeof(USubSystemReplyMsg) == 0x000048, "Wrong size on USubSystemReplyMsg");
static_assert(offsetof(USubSystemReplyMsg, CreateAt) == 0x000040, "Member 'USubSystemReplyMsg::CreateAt' has a wrong offset!");

// Class DungeonCrawler.InventorySkillListWidgetBase
// 0x0068 (0x03E8 - 0x0380)
class UInventorySkillListWidgetBase final : public USkillListWidgetBase
{
public:
	TSubclassOf<class USkillWidget>               SkillWidgetClass;                                  // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPanelWidget*>                   SkillWidgetParentArray;                            // 0x0388(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UPanelWidget*, class USkillWidget*> SkillWidgetMap;                                    // 0x0398(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySkillListWidgetBase">();
	}
	static class UInventorySkillListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySkillListWidgetBase>();
	}
};
static_assert(alignof(UInventorySkillListWidgetBase) == 0x000008, "Wrong alignment on UInventorySkillListWidgetBase");
static_assert(sizeof(UInventorySkillListWidgetBase) == 0x0003E8, "Wrong size on UInventorySkillListWidgetBase");
static_assert(offsetof(UInventorySkillListWidgetBase, SkillWidgetClass) == 0x000380, "Member 'UInventorySkillListWidgetBase::SkillWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventorySkillListWidgetBase, SkillWidgetParentArray) == 0x000388, "Member 'UInventorySkillListWidgetBase::SkillWidgetParentArray' has a wrong offset!");
static_assert(offsetof(UInventorySkillListWidgetBase, SkillWidgetMap) == 0x000398, "Member 'UInventorySkillListWidgetBase::SkillWidgetMap' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitDelayRestartable
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WaitDelayRestartable final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24F9[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitDelayRestartable* WaitDelay(class UGameplayAbility* OwningAbility, float Time);

	void RestartTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitDelayRestartable">();
	}
	static class UDCAT_WaitDelayRestartable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitDelayRestartable>();
	}
};
static_assert(alignof(UDCAT_WaitDelayRestartable) == 0x000008, "Wrong alignment on UDCAT_WaitDelayRestartable");
static_assert(sizeof(UDCAT_WaitDelayRestartable) == 0x0000A0, "Wrong size on UDCAT_WaitDelayRestartable");
static_assert(offsetof(UDCAT_WaitDelayRestartable, OnFinish) == 0x000080, "Member 'UDCAT_WaitDelayRestartable::OnFinish' has a wrong offset!");

// Class DungeonCrawler.ClientAccountSubsystem
// 0x0A00 (0x0A30 - 0x0030)
class alignas(0x10) UClientAccountSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_24FB[0x518];                                   // 0x0030(0x0518)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int16, class USubSystemReplyMsg*>        ResponseLambdaPointerMap;                          // 0x0548(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FC[0x18];                                    // 0x0598(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTcpSocket*                             TcpSocketObject;                                   // 0x05B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FD[0x118];                                   // 0x05B8(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    LatencyUrlMap;                                     // 0x06D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FE[0xE8];                                    // 0x0720(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPrimaryAssetId, class UDCAnnounceDataAsset*> AnnounceDatas;                                     // 0x0808(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FDCMarketplaceSimpleInfo               MarketplaceSimpleInfo;                             // 0x0858(0x0001)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FF[0x107];                                   // 0x0859(0x0107)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCQuestLogInfo>                QuestLogList;                                      // 0x0960(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCMerchantInfo>                MerchantInfos;                                     // 0x0970(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FString                                 SelectedQuestLogChapterId;                         // 0x0980(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SelectedQuestLogMerchantId;                        // 0x0990(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2500[0x90];                                    // 0x09A0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientAccountSubsystem">();
	}
	static class UClientAccountSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientAccountSubsystem>();
	}
};
static_assert(alignof(UClientAccountSubsystem) == 0x000010, "Wrong alignment on UClientAccountSubsystem");
static_assert(sizeof(UClientAccountSubsystem) == 0x000A30, "Wrong size on UClientAccountSubsystem");
static_assert(offsetof(UClientAccountSubsystem, ResponseLambdaPointerMap) == 0x000548, "Member 'UClientAccountSubsystem::ResponseLambdaPointerMap' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, TcpSocketObject) == 0x0005B0, "Member 'UClientAccountSubsystem::TcpSocketObject' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, LatencyUrlMap) == 0x0006D0, "Member 'UClientAccountSubsystem::LatencyUrlMap' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, AnnounceDatas) == 0x000808, "Member 'UClientAccountSubsystem::AnnounceDatas' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, MarketplaceSimpleInfo) == 0x000858, "Member 'UClientAccountSubsystem::MarketplaceSimpleInfo' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, QuestLogList) == 0x000960, "Member 'UClientAccountSubsystem::QuestLogList' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, MerchantInfos) == 0x000970, "Member 'UClientAccountSubsystem::MerchantInfos' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, SelectedQuestLogChapterId) == 0x000980, "Member 'UClientAccountSubsystem::SelectedQuestLogChapterId' has a wrong offset!");
static_assert(offsetof(UClientAccountSubsystem, SelectedQuestLogMerchantId) == 0x000990, "Member 'UClientAccountSubsystem::SelectedQuestLogMerchantId' has a wrong offset!");

// Class DungeonCrawler.DCAttributeSet
// 0x0A90 (0x0AC0 - 0x0030)
class UDCAttributeSet : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 Strength;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthBase;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthMod;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Vigor;                                             // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 VigorBase;                                         // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 VigorMod;                                          // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Agility;                                           // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AgilityBase;                                       // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AgilityMod;                                        // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Dexterity;                                         // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DexterityBase;                                     // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DexterityMod;                                      // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Will;                                              // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WillBase;                                          // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WillMod;                                           // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Knowledge;                                         // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KnowledgeBase;                                     // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KnowledgeMod;                                      // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Resourcefulness;                                   // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ResourcefulnessBase;                               // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ResourcefulnessMod;                                // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageWeaponPrimary;                       // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageWeaponSecondary;                     // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageBase;                                // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPower;                                     // 0x01B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageMod;                                 // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageAdd;                                 // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageTrue;                                // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalBackstabPower;                             // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHeadshotPower;                             // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHeadshotPenetration;                       // 0x0210(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArmorPenetration;                                  // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArmorRating;                                       // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ItemArmorRating;                                   // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ItemArmorRatingMod;                                // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalReduction;                                 // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalReductionMod;                              // 0x0270(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalAbsoluteReduction;                         // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageWeaponPrimary;                        // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageWeaponSecondary;                      // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageBase;                                 // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPower;                                      // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageMod;                                  // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageAdd;                                  // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageTrue;                                 // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicPenetration;                                  // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalFireDamageBase;                             // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalFireDamageMod;                              // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalFireDamageAdd;                              // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalIceDamageBase;                              // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalIceDamageMod;                               // 0x0350(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalIceDamageAdd;                               // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalArcaneDamageBase;                           // 0x0370(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalArcaneDamageMod;                            // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalArcaneDamageAdd;                            // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDarkDamageBase;                             // 0x03A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDarkDamageMod;                              // 0x03B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDarkDamageAdd;                              // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDivineDamageBase;                           // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDivineDamageMod;                            // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDivineDamageAdd;                            // 0x03F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalSpiritDamageBase;                           // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalSpiritDamageMod;                            // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalSpiritDamageAdd;                            // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UndeadDamageMod;                                   // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicResistance;                                   // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalReduction;                                  // 0x0450(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalReductionMod;                               // 0x0460(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalAbsoluteReduction;                          // 0x0470(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicResistance;                               // 0x0480(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicalReduction;                              // 0x0490(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicalReductionMod;                           // 0x04A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicResistance;                                // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicalReduction;                               // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicalReductionMod;                            // 0x04D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicResistance;                          // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicalReduction;                         // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicalReductionMod;                      // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicResistance;                              // 0x0510(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicalReduction;                             // 0x0520(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicalReductionMod;                          // 0x0530(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicResistance;                              // 0x0540(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicalReduction;                             // 0x0550(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicalReductionMod;                          // 0x0560(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicResistance;                               // 0x0570(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicalReduction;                              // 0x0580(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicalReductionMod;                           // 0x0590(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicResistance;                             // 0x05A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicalReduction;                            // 0x05B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicalReductionMod;                         // 0x05C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicResistance;                             // 0x05D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicalReduction;                            // 0x05E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicalReductionMod;                         // 0x05F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicResistance;                               // 0x0600(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicalReduction;                              // 0x0610(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicalReductionMod;                           // 0x0620(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicResistance;                                // 0x0630(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicalReduction;                               // 0x0640(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicalReductionMod;                            // 0x0650(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicResistance;                             // 0x0660(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicalReduction;                            // 0x0670(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicalReductionMod;                         // 0x0680(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HeadshotReductionMod;                              // 0x0690(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ProjectileReductionMod;                            // 0x06A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UndeadReductionMod;                                // 0x06B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DemonReductionMod;                                 // 0x06C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ImpactPower;                                       // 0x06D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ImpactResistance;                                  // 0x06E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ImpactEndurance;                                   // 0x06F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxImpactEndurance;                                // 0x0700(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_2501[0x8];                                     // 0x0710(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 PhysicalHealBase;                                  // 0x0718(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHealMod;                                   // 0x0728(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHealingReceiveMod;                         // 0x0738(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalHealBase;                                   // 0x0748(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalHealMod;                                    // 0x0758(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalHealingReceiveMod;                          // 0x0768(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealthRecoveryMod;                                 // 0x0778(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryRecoveryMod;                                 // 0x0788(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RecoverableHealth;                                 // 0x0798(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Health;                                            // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OverhealedHealth;                                  // 0x07B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x07C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_2502[0x8];                                     // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 MaxHealthBase;                                     // 0x07E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthMod;                                      // 0x07F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthAdd;                                      // 0x0800(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalShield;                                    // 0x0810(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxPhysicalShield;                                 // 0x0820(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalShield;                                     // 0x0830(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxMagicalShield;                                  // 0x0840(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 TotalShield;                                       // 0x0850(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxTotalShield;                                    // 0x0860(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemorySpellPayload;                                // 0x0870(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryMusicPayload;                                // 0x0880(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacity;                                    // 0x0890(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacityBase;                                // 0x08A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacityMod;                                 // 0x08B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacityAdd;                                 // 0x08C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxSpellCountMod;                                  // 0x08D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeed;                                         // 0x08E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedBase;                                     // 0x08F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedMod;                                      // 0x0900(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedAdd;                                      // 0x0910(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedArmorPenalty;                             // 0x0920(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedArmorPenaltyMod;                          // 0x0930(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedWithModifier;                             // 0x0940(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ActionSpeed;                                       // 0x0950(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpellCastingSpeed;                                 // 0x0960(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ItemEquipSpeed;                                    // 0x0970(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RegularInteractionSpeedBase;                       // 0x0980(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RegularInteractionSpeed;                           // 0x0990(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalInteractionSpeed;                           // 0x09A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BuffDurationMod;                                   // 0x09B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DebuffDurationMod;                                 // 0x09C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CooldownReductionMod;                              // 0x09D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectiveness;                              // 0x09E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectivenessBase;                          // 0x09F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectivenessMod;                           // 0x0A00(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectivenessAdd;                           // 0x0A10(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Weight;                                            // 0x0A20(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimit;                                       // 0x0A30(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimitBase;                                   // 0x0A40(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimitMod;                                    // 0x0A50(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimitAdd;                                    // 0x0A60(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Luck;                                              // 0x0A70(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ManualDexterity;                                   // 0x0A80(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Persuasiveness;                                    // 0x0A90(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Rigidity;                                          // 0x0AA0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Coldness;                                          // 0x0AB0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_ActionSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_Agility(const struct FGameplayAttributeData& OldValue);
	void OnRep_AgilityBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_AgilityMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_AirMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_AirMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_AirMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_ArcaneMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_ArcaneMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_ArcaneMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_ArmorPenetration(const struct FGameplayAttributeData& OldValue);
	void OnRep_ArmorRating(const struct FGameplayAttributeData& OldValue);
	void OnRep_BuffDurationMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Coldness(const struct FGameplayAttributeData& OldValue);
	void OnRep_CooldownReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_DarkMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_DarkMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_DarkMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_DebuffDurationMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_DemonReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Dexterity(const struct FGameplayAttributeData& OldValue);
	void OnRep_DexterityBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_DexterityMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_DivineMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_DivineMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_DivineMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_EarthMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_EarthMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_EarthMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_EvilMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_EvilMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_EvilMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_FireMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_FireMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_FireMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_HeadshotReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Health(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealthRecoveryMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_IceMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_IceMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_IceMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_ImpactEndurance(const struct FGameplayAttributeData& OldValue);
	void OnRep_ImpactPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_ImpactResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_ItemArmorRating(const struct FGameplayAttributeData& OldValue);
	void OnRep_ItemArmorRatingMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_ItemEquipSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_Knowledge(const struct FGameplayAttributeData& OldValue);
	void OnRep_KnowledgeBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_KnowledgeMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightningMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightningMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_LightningMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_Luck(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalAbsoluteReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalArcaneDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalArcaneDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalArcaneDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDamageTrue(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDamageWeaponPrimary(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDamageWeaponSecondary(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDarkDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDarkDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDarkDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDivineDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDivineDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalDivineDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalFireDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalFireDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalFireDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalHealBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalHealingReceiveMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalHealMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalIceDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalIceDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalIceDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalInteractionSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalSpiritDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalSpiritDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalSpiritDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicPenetration(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_ManualDexterity(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxImpactEndurance(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxMagicalShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxPhysicalShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxSpellCountMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxTotalShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemoryCapacity(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemoryCapacityAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemoryCapacityBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemoryCapacityMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemoryMusicPayload(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemoryRecoveryMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MemorySpellPayload(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedArmorPenalty(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedArmorPenaltyMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_MoveSpeedWithModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_OverhealedHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_Persuasiveness(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalAbsoluteReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalBackstabPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalDamageAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalDamageBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalDamageTrue(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalDamageWeaponPrimary(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalDamageWeaponSecondary(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalHeadshotPenetration(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalHeadshotPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalHealBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalHealingReceiveMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalHealMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_ProjectileReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_RecoverableHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_RegularInteractionSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_RegularInteractionSpeedBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_Resourcefulness(const struct FGameplayAttributeData& OldValue);
	void OnRep_ResourcefulnessBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_ResourcefulnessMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Rigidity(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpellCastingSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpiritMagicalReduction(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpiritMagicalReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpiritMagicResistance(const struct FGameplayAttributeData& OldValue);
	void OnRep_Strength(const struct FGameplayAttributeData& OldValue);
	void OnRep_StrengthBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_StrengthMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_TotalShield(const struct FGameplayAttributeData& OldValue);
	void OnRep_UndeadDamageMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_UndeadReductionMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_UtilityEffectiveness(const struct FGameplayAttributeData& OldValue);
	void OnRep_UtilityEffectivenessAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_UtilityEffectivenessBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_UtilityEffectivenessMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Vigor(const struct FGameplayAttributeData& OldValue);
	void OnRep_VigorBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_VigorMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Weight(const struct FGameplayAttributeData& OldValue);
	void OnRep_WeightLimit(const struct FGameplayAttributeData& OldValue);
	void OnRep_WeightLimitAdd(const struct FGameplayAttributeData& OldValue);
	void OnRep_WeightLimitBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_WeightLimitMod(const struct FGameplayAttributeData& OldValue);
	void OnRep_Will(const struct FGameplayAttributeData& OldValue);
	void OnRep_WillBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_WillMod(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeSet">();
	}
	static class UDCAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeSet>();
	}
};
static_assert(alignof(UDCAttributeSet) == 0x000008, "Wrong alignment on UDCAttributeSet");
static_assert(sizeof(UDCAttributeSet) == 0x000AC0, "Wrong size on UDCAttributeSet");
static_assert(offsetof(UDCAttributeSet, Strength) == 0x000030, "Member 'UDCAttributeSet::Strength' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, StrengthBase) == 0x000040, "Member 'UDCAttributeSet::StrengthBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, StrengthMod) == 0x000050, "Member 'UDCAttributeSet::StrengthMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Vigor) == 0x000060, "Member 'UDCAttributeSet::Vigor' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, VigorBase) == 0x000070, "Member 'UDCAttributeSet::VigorBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, VigorMod) == 0x000080, "Member 'UDCAttributeSet::VigorMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Agility) == 0x000090, "Member 'UDCAttributeSet::Agility' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, AgilityBase) == 0x0000A0, "Member 'UDCAttributeSet::AgilityBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, AgilityMod) == 0x0000B0, "Member 'UDCAttributeSet::AgilityMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Dexterity) == 0x0000C0, "Member 'UDCAttributeSet::Dexterity' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DexterityBase) == 0x0000D0, "Member 'UDCAttributeSet::DexterityBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DexterityMod) == 0x0000E0, "Member 'UDCAttributeSet::DexterityMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Will) == 0x0000F0, "Member 'UDCAttributeSet::Will' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, WillBase) == 0x000100, "Member 'UDCAttributeSet::WillBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, WillMod) == 0x000110, "Member 'UDCAttributeSet::WillMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Knowledge) == 0x000120, "Member 'UDCAttributeSet::Knowledge' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, KnowledgeBase) == 0x000130, "Member 'UDCAttributeSet::KnowledgeBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, KnowledgeMod) == 0x000140, "Member 'UDCAttributeSet::KnowledgeMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Resourcefulness) == 0x000150, "Member 'UDCAttributeSet::Resourcefulness' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ResourcefulnessBase) == 0x000160, "Member 'UDCAttributeSet::ResourcefulnessBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ResourcefulnessMod) == 0x000170, "Member 'UDCAttributeSet::ResourcefulnessMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalDamageWeaponPrimary) == 0x000180, "Member 'UDCAttributeSet::PhysicalDamageWeaponPrimary' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalDamageWeaponSecondary) == 0x000190, "Member 'UDCAttributeSet::PhysicalDamageWeaponSecondary' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalDamageBase) == 0x0001A0, "Member 'UDCAttributeSet::PhysicalDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalPower) == 0x0001B0, "Member 'UDCAttributeSet::PhysicalPower' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalDamageMod) == 0x0001C0, "Member 'UDCAttributeSet::PhysicalDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalDamageAdd) == 0x0001D0, "Member 'UDCAttributeSet::PhysicalDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalDamageTrue) == 0x0001E0, "Member 'UDCAttributeSet::PhysicalDamageTrue' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalBackstabPower) == 0x0001F0, "Member 'UDCAttributeSet::PhysicalBackstabPower' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalHeadshotPower) == 0x000200, "Member 'UDCAttributeSet::PhysicalHeadshotPower' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalHeadshotPenetration) == 0x000210, "Member 'UDCAttributeSet::PhysicalHeadshotPenetration' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ArmorPenetration) == 0x000220, "Member 'UDCAttributeSet::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ArmorRating) == 0x000230, "Member 'UDCAttributeSet::ArmorRating' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ItemArmorRating) == 0x000240, "Member 'UDCAttributeSet::ItemArmorRating' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ItemArmorRatingMod) == 0x000250, "Member 'UDCAttributeSet::ItemArmorRatingMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalReduction) == 0x000260, "Member 'UDCAttributeSet::PhysicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalReductionMod) == 0x000270, "Member 'UDCAttributeSet::PhysicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalAbsoluteReduction) == 0x000280, "Member 'UDCAttributeSet::PhysicalAbsoluteReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDamageWeaponPrimary) == 0x000290, "Member 'UDCAttributeSet::MagicalDamageWeaponPrimary' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDamageWeaponSecondary) == 0x0002A0, "Member 'UDCAttributeSet::MagicalDamageWeaponSecondary' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDamageBase) == 0x0002B0, "Member 'UDCAttributeSet::MagicalDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalPower) == 0x0002C0, "Member 'UDCAttributeSet::MagicalPower' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDamageMod) == 0x0002D0, "Member 'UDCAttributeSet::MagicalDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDamageAdd) == 0x0002E0, "Member 'UDCAttributeSet::MagicalDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDamageTrue) == 0x0002F0, "Member 'UDCAttributeSet::MagicalDamageTrue' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicPenetration) == 0x000300, "Member 'UDCAttributeSet::MagicPenetration' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalFireDamageBase) == 0x000310, "Member 'UDCAttributeSet::MagicalFireDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalFireDamageMod) == 0x000320, "Member 'UDCAttributeSet::MagicalFireDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalFireDamageAdd) == 0x000330, "Member 'UDCAttributeSet::MagicalFireDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalIceDamageBase) == 0x000340, "Member 'UDCAttributeSet::MagicalIceDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalIceDamageMod) == 0x000350, "Member 'UDCAttributeSet::MagicalIceDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalIceDamageAdd) == 0x000360, "Member 'UDCAttributeSet::MagicalIceDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalArcaneDamageBase) == 0x000370, "Member 'UDCAttributeSet::MagicalArcaneDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalArcaneDamageMod) == 0x000380, "Member 'UDCAttributeSet::MagicalArcaneDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalArcaneDamageAdd) == 0x000390, "Member 'UDCAttributeSet::MagicalArcaneDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDarkDamageBase) == 0x0003A0, "Member 'UDCAttributeSet::MagicalDarkDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDarkDamageMod) == 0x0003B0, "Member 'UDCAttributeSet::MagicalDarkDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDarkDamageAdd) == 0x0003C0, "Member 'UDCAttributeSet::MagicalDarkDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDivineDamageBase) == 0x0003D0, "Member 'UDCAttributeSet::MagicalDivineDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDivineDamageMod) == 0x0003E0, "Member 'UDCAttributeSet::MagicalDivineDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalDivineDamageAdd) == 0x0003F0, "Member 'UDCAttributeSet::MagicalDivineDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalSpiritDamageBase) == 0x000400, "Member 'UDCAttributeSet::MagicalSpiritDamageBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalSpiritDamageMod) == 0x000410, "Member 'UDCAttributeSet::MagicalSpiritDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalSpiritDamageAdd) == 0x000420, "Member 'UDCAttributeSet::MagicalSpiritDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, UndeadDamageMod) == 0x000430, "Member 'UDCAttributeSet::UndeadDamageMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicResistance) == 0x000440, "Member 'UDCAttributeSet::MagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalReduction) == 0x000450, "Member 'UDCAttributeSet::MagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalReductionMod) == 0x000460, "Member 'UDCAttributeSet::MagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalAbsoluteReduction) == 0x000470, "Member 'UDCAttributeSet::MagicalAbsoluteReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, FireMagicResistance) == 0x000480, "Member 'UDCAttributeSet::FireMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, FireMagicalReduction) == 0x000490, "Member 'UDCAttributeSet::FireMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, FireMagicalReductionMod) == 0x0004A0, "Member 'UDCAttributeSet::FireMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, IceMagicResistance) == 0x0004B0, "Member 'UDCAttributeSet::IceMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, IceMagicalReduction) == 0x0004C0, "Member 'UDCAttributeSet::IceMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, IceMagicalReductionMod) == 0x0004D0, "Member 'UDCAttributeSet::IceMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, LightningMagicResistance) == 0x0004E0, "Member 'UDCAttributeSet::LightningMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, LightningMagicalReduction) == 0x0004F0, "Member 'UDCAttributeSet::LightningMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, LightningMagicalReductionMod) == 0x000500, "Member 'UDCAttributeSet::LightningMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, EarthMagicResistance) == 0x000510, "Member 'UDCAttributeSet::EarthMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, EarthMagicalReduction) == 0x000520, "Member 'UDCAttributeSet::EarthMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, EarthMagicalReductionMod) == 0x000530, "Member 'UDCAttributeSet::EarthMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, LightMagicResistance) == 0x000540, "Member 'UDCAttributeSet::LightMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, LightMagicalReduction) == 0x000550, "Member 'UDCAttributeSet::LightMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, LightMagicalReductionMod) == 0x000560, "Member 'UDCAttributeSet::LightMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DarkMagicResistance) == 0x000570, "Member 'UDCAttributeSet::DarkMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DarkMagicalReduction) == 0x000580, "Member 'UDCAttributeSet::DarkMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DarkMagicalReductionMod) == 0x000590, "Member 'UDCAttributeSet::DarkMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ArcaneMagicResistance) == 0x0005A0, "Member 'UDCAttributeSet::ArcaneMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ArcaneMagicalReduction) == 0x0005B0, "Member 'UDCAttributeSet::ArcaneMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ArcaneMagicalReductionMod) == 0x0005C0, "Member 'UDCAttributeSet::ArcaneMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DivineMagicResistance) == 0x0005D0, "Member 'UDCAttributeSet::DivineMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DivineMagicalReduction) == 0x0005E0, "Member 'UDCAttributeSet::DivineMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DivineMagicalReductionMod) == 0x0005F0, "Member 'UDCAttributeSet::DivineMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, EvilMagicResistance) == 0x000600, "Member 'UDCAttributeSet::EvilMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, EvilMagicalReduction) == 0x000610, "Member 'UDCAttributeSet::EvilMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, EvilMagicalReductionMod) == 0x000620, "Member 'UDCAttributeSet::EvilMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, AirMagicResistance) == 0x000630, "Member 'UDCAttributeSet::AirMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, AirMagicalReduction) == 0x000640, "Member 'UDCAttributeSet::AirMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, AirMagicalReductionMod) == 0x000650, "Member 'UDCAttributeSet::AirMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, SpiritMagicResistance) == 0x000660, "Member 'UDCAttributeSet::SpiritMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, SpiritMagicalReduction) == 0x000670, "Member 'UDCAttributeSet::SpiritMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, SpiritMagicalReductionMod) == 0x000680, "Member 'UDCAttributeSet::SpiritMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, HeadshotReductionMod) == 0x000690, "Member 'UDCAttributeSet::HeadshotReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ProjectileReductionMod) == 0x0006A0, "Member 'UDCAttributeSet::ProjectileReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, UndeadReductionMod) == 0x0006B0, "Member 'UDCAttributeSet::UndeadReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DemonReductionMod) == 0x0006C0, "Member 'UDCAttributeSet::DemonReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ImpactPower) == 0x0006D0, "Member 'UDCAttributeSet::ImpactPower' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ImpactResistance) == 0x0006E0, "Member 'UDCAttributeSet::ImpactResistance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ImpactEndurance) == 0x0006F0, "Member 'UDCAttributeSet::ImpactEndurance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxImpactEndurance) == 0x000700, "Member 'UDCAttributeSet::MaxImpactEndurance' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalHealBase) == 0x000718, "Member 'UDCAttributeSet::PhysicalHealBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalHealMod) == 0x000728, "Member 'UDCAttributeSet::PhysicalHealMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalHealingReceiveMod) == 0x000738, "Member 'UDCAttributeSet::PhysicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalHealBase) == 0x000748, "Member 'UDCAttributeSet::MagicalHealBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalHealMod) == 0x000758, "Member 'UDCAttributeSet::MagicalHealMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalHealingReceiveMod) == 0x000768, "Member 'UDCAttributeSet::MagicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, HealthRecoveryMod) == 0x000778, "Member 'UDCAttributeSet::HealthRecoveryMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemoryRecoveryMod) == 0x000788, "Member 'UDCAttributeSet::MemoryRecoveryMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, RecoverableHealth) == 0x000798, "Member 'UDCAttributeSet::RecoverableHealth' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Health) == 0x0007A8, "Member 'UDCAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, OverhealedHealth) == 0x0007B8, "Member 'UDCAttributeSet::OverhealedHealth' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxHealth) == 0x0007C8, "Member 'UDCAttributeSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxHealthBase) == 0x0007E0, "Member 'UDCAttributeSet::MaxHealthBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxHealthMod) == 0x0007F0, "Member 'UDCAttributeSet::MaxHealthMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxHealthAdd) == 0x000800, "Member 'UDCAttributeSet::MaxHealthAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, PhysicalShield) == 0x000810, "Member 'UDCAttributeSet::PhysicalShield' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxPhysicalShield) == 0x000820, "Member 'UDCAttributeSet::MaxPhysicalShield' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalShield) == 0x000830, "Member 'UDCAttributeSet::MagicalShield' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxMagicalShield) == 0x000840, "Member 'UDCAttributeSet::MaxMagicalShield' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, TotalShield) == 0x000850, "Member 'UDCAttributeSet::TotalShield' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxTotalShield) == 0x000860, "Member 'UDCAttributeSet::MaxTotalShield' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemorySpellPayload) == 0x000870, "Member 'UDCAttributeSet::MemorySpellPayload' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemoryMusicPayload) == 0x000880, "Member 'UDCAttributeSet::MemoryMusicPayload' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemoryCapacity) == 0x000890, "Member 'UDCAttributeSet::MemoryCapacity' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemoryCapacityBase) == 0x0008A0, "Member 'UDCAttributeSet::MemoryCapacityBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemoryCapacityMod) == 0x0008B0, "Member 'UDCAttributeSet::MemoryCapacityMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MemoryCapacityAdd) == 0x0008C0, "Member 'UDCAttributeSet::MemoryCapacityAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MaxSpellCountMod) == 0x0008D0, "Member 'UDCAttributeSet::MaxSpellCountMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeed) == 0x0008E0, "Member 'UDCAttributeSet::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeedBase) == 0x0008F0, "Member 'UDCAttributeSet::MoveSpeedBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeedMod) == 0x000900, "Member 'UDCAttributeSet::MoveSpeedMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeedAdd) == 0x000910, "Member 'UDCAttributeSet::MoveSpeedAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeedArmorPenalty) == 0x000920, "Member 'UDCAttributeSet::MoveSpeedArmorPenalty' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeedArmorPenaltyMod) == 0x000930, "Member 'UDCAttributeSet::MoveSpeedArmorPenaltyMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MoveSpeedWithModifier) == 0x000940, "Member 'UDCAttributeSet::MoveSpeedWithModifier' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ActionSpeed) == 0x000950, "Member 'UDCAttributeSet::ActionSpeed' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, SpellCastingSpeed) == 0x000960, "Member 'UDCAttributeSet::SpellCastingSpeed' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ItemEquipSpeed) == 0x000970, "Member 'UDCAttributeSet::ItemEquipSpeed' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, RegularInteractionSpeedBase) == 0x000980, "Member 'UDCAttributeSet::RegularInteractionSpeedBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, RegularInteractionSpeed) == 0x000990, "Member 'UDCAttributeSet::RegularInteractionSpeed' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, MagicalInteractionSpeed) == 0x0009A0, "Member 'UDCAttributeSet::MagicalInteractionSpeed' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, BuffDurationMod) == 0x0009B0, "Member 'UDCAttributeSet::BuffDurationMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, DebuffDurationMod) == 0x0009C0, "Member 'UDCAttributeSet::DebuffDurationMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, CooldownReductionMod) == 0x0009D0, "Member 'UDCAttributeSet::CooldownReductionMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, UtilityEffectiveness) == 0x0009E0, "Member 'UDCAttributeSet::UtilityEffectiveness' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, UtilityEffectivenessBase) == 0x0009F0, "Member 'UDCAttributeSet::UtilityEffectivenessBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, UtilityEffectivenessMod) == 0x000A00, "Member 'UDCAttributeSet::UtilityEffectivenessMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, UtilityEffectivenessAdd) == 0x000A10, "Member 'UDCAttributeSet::UtilityEffectivenessAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Weight) == 0x000A20, "Member 'UDCAttributeSet::Weight' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, WeightLimit) == 0x000A30, "Member 'UDCAttributeSet::WeightLimit' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, WeightLimitBase) == 0x000A40, "Member 'UDCAttributeSet::WeightLimitBase' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, WeightLimitMod) == 0x000A50, "Member 'UDCAttributeSet::WeightLimitMod' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, WeightLimitAdd) == 0x000A60, "Member 'UDCAttributeSet::WeightLimitAdd' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Luck) == 0x000A70, "Member 'UDCAttributeSet::Luck' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, ManualDexterity) == 0x000A80, "Member 'UDCAttributeSet::ManualDexterity' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Persuasiveness) == 0x000A90, "Member 'UDCAttributeSet::Persuasiveness' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Rigidity) == 0x000AA0, "Member 'UDCAttributeSet::Rigidity' has a wrong offset!");
static_assert(offsetof(UDCAttributeSet, Coldness) == 0x000AB0, "Member 'UDCAttributeSet::Coldness' has a wrong offset!");

// Class DungeonCrawler.DCProjectileAttributeSet
// 0x0000 (0x0AC0 - 0x0AC0)
class UDCProjectileAttributeSet final : public UDCAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCProjectileAttributeSet">();
	}
	static class UDCProjectileAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCProjectileAttributeSet>();
	}
};
static_assert(alignof(UDCProjectileAttributeSet) == 0x000008, "Wrong alignment on UDCProjectileAttributeSet");
static_assert(sizeof(UDCProjectileAttributeSet) == 0x000AC0, "Wrong size on UDCProjectileAttributeSet");

// Class DungeonCrawler.ClientAgeRatingSubsystem
// 0x0040 (0x0070 - 0x0030)
class UClientAgeRatingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2503[0x40];                                    // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientAgeRatingSubsystem">();
	}
	static class UClientAgeRatingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientAgeRatingSubsystem>();
	}
};
static_assert(alignof(UClientAgeRatingSubsystem) == 0x000008, "Wrong alignment on UClientAgeRatingSubsystem");
static_assert(sizeof(UClientAgeRatingSubsystem) == 0x000070, "Wrong size on UClientAgeRatingSubsystem");

// Class DungeonCrawler.ClientPartySubsystem
// 0x01B8 (0x01E8 - 0x0030)
class UClientPartySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2504[0x1B8];                                   // 0x0030(0x01B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientPartySubsystem">();
	}
	static class UClientPartySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientPartySubsystem>();
	}
};
static_assert(alignof(UClientPartySubsystem) == 0x000008, "Wrong alignment on UClientPartySubsystem");
static_assert(sizeof(UClientPartySubsystem) == 0x0001E8, "Wrong size on UClientPartySubsystem");

// Class DungeonCrawler.ClientShopSubsystem
// 0x0120 (0x0150 - 0x0030)
class UClientShopSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2505[0x118];                                   // 0x0030(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCClientShopSimpleInfo                ShopSimpleInfo;                                    // 0x0148(0x0001)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2506[0x7];                                     // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientShopSubsystem">();
	}
	static class UClientShopSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientShopSubsystem>();
	}
};
static_assert(alignof(UClientShopSubsystem) == 0x000008, "Wrong alignment on UClientShopSubsystem");
static_assert(sizeof(UClientShopSubsystem) == 0x000150, "Wrong size on UClientShopSubsystem");
static_assert(offsetof(UClientShopSubsystem, ShopSimpleInfo) == 0x000148, "Member 'UClientShopSubsystem::ShopSimpleInfo' has a wrong offset!");

// Class DungeonCrawler.MetaGBMMInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaGBMMInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaGBMMInterface">();
	}
	static class IMetaGBMMInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaGBMMInterface>();
	}
};
static_assert(alignof(IMetaGBMMInterface) == 0x000008, "Wrong alignment on IMetaGBMMInterface");
static_assert(sizeof(IMetaGBMMInterface) == 0x000028, "Wrong size on IMetaGBMMInterface");

// Class DungeonCrawler.DCAT_WaitAimDirChangedFromLoc
// 0x0040 (0x00C0 - 0x0080)
class UDCAT_WaitAimDirChangedFromLoc final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnDirectionChanged;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2507[0x30];                                    // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitAimDirChangedFromLoc* WaitAimDirectionChangedFromLocation(class UGameplayAbility* OwningAbility, const struct FVector& InitialAimTargetLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitAimDirChangedFromLoc">();
	}
	static class UDCAT_WaitAimDirChangedFromLoc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitAimDirChangedFromLoc>();
	}
};
static_assert(alignof(UDCAT_WaitAimDirChangedFromLoc) == 0x000008, "Wrong alignment on UDCAT_WaitAimDirChangedFromLoc");
static_assert(sizeof(UDCAT_WaitAimDirChangedFromLoc) == 0x0000C0, "Wrong size on UDCAT_WaitAimDirChangedFromLoc");
static_assert(offsetof(UDCAT_WaitAimDirChangedFromLoc, OnDirectionChanged) == 0x000080, "Member 'UDCAT_WaitAimDirChangedFromLoc::OnDirectionChanged' has a wrong offset!");

// Class DungeonCrawler.CommemorativePlaqueTextWidget
// 0x0000 (0x0358 - 0x0358)
class UCommemorativePlaqueTextWidget final : public UDCWidgetBase
{
public:
	void SetCommemorativePlaqueText(const struct FPrimaryAssetId& ScriptId, const struct FVector& Location);
	void SnedWidgetToggleMsg();
	void UpdateCommenorativePlaqueText(const TArray<class FText>& InText, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommemorativePlaqueTextWidget">();
	}
	static class UCommemorativePlaqueTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommemorativePlaqueTextWidget>();
	}
};
static_assert(alignof(UCommemorativePlaqueTextWidget) == 0x000008, "Wrong alignment on UCommemorativePlaqueTextWidget");
static_assert(sizeof(UCommemorativePlaqueTextWidget) == 0x000358, "Wrong size on UCommemorativePlaqueTextWidget");

// Class DungeonCrawler.DCRedstoneShardShopListWidgetBase
// 0x0030 (0x0388 - 0x0358)
class UDCRedstoneShardShopListWidgetBase final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2508[0x18];                                    // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           ShopItemListWidget;                                // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2509[0x10];                                    // 0x0378(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRedstoneShardShopListWidgetBase">();
	}
	static class UDCRedstoneShardShopListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRedstoneShardShopListWidgetBase>();
	}
};
static_assert(alignof(UDCRedstoneShardShopListWidgetBase) == 0x000008, "Wrong alignment on UDCRedstoneShardShopListWidgetBase");
static_assert(sizeof(UDCRedstoneShardShopListWidgetBase) == 0x000388, "Wrong size on UDCRedstoneShardShopListWidgetBase");
static_assert(offsetof(UDCRedstoneShardShopListWidgetBase, ShopItemListWidget) == 0x000370, "Member 'UDCRedstoneShardShopListWidgetBase::ShopItemListWidget' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationMaxHealthBase
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationMaxHealthBase final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_250A[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationMaxHealthBase">();
	}
	static class UDCAttributeModMagnitudeCalculationMaxHealthBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationMaxHealthBase>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationMaxHealthBase) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationMaxHealthBase");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationMaxHealthBase) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationMaxHealthBase");

// Class DungeonCrawler.ItemCountSelectWidgetData
// 0x0010 (0x0040 - 0x0030)
class UItemCountSelectWidgetData final : public UPopupDataBase
{
public:
	EPopupButtonType                              PopupButtonType;                                   // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCountSelectWidgetType                    ItemCountSelectType;                               // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250B[0x2];                                     // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItemCount;                                      // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinItemCount;                                      // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedItemCount;                                 // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCountSelectWidgetData">();
	}
	static class UItemCountSelectWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCountSelectWidgetData>();
	}
};
static_assert(alignof(UItemCountSelectWidgetData) == 0x000008, "Wrong alignment on UItemCountSelectWidgetData");
static_assert(sizeof(UItemCountSelectWidgetData) == 0x000040, "Wrong size on UItemCountSelectWidgetData");
static_assert(offsetof(UItemCountSelectWidgetData, PopupButtonType) == 0x000030, "Member 'UItemCountSelectWidgetData::PopupButtonType' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidgetData, ItemCountSelectType) == 0x000031, "Member 'UItemCountSelectWidgetData::ItemCountSelectType' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidgetData, MaxItemCount) == 0x000034, "Member 'UItemCountSelectWidgetData::MaxItemCount' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidgetData, MinItemCount) == 0x000038, "Member 'UItemCountSelectWidgetData::MinItemCount' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidgetData, SelectedItemCount) == 0x00003C, "Member 'UItemCountSelectWidgetData::SelectedItemCount' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitGameplayEffectAdd
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WaitGameplayEffectAdd final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnApplied;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_250C[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitGameplayEffectAdd* WaitGameplayEffectAdded(class UGameplayAbility* OwningAbility, bool TriggerOnce);

	void OnApplyGameplayEffectCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitGameplayEffectAdd">();
	}
	static class UDCAT_WaitGameplayEffectAdd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitGameplayEffectAdd>();
	}
};
static_assert(alignof(UDCAT_WaitGameplayEffectAdd) == 0x000008, "Wrong alignment on UDCAT_WaitGameplayEffectAdd");
static_assert(sizeof(UDCAT_WaitGameplayEffectAdd) == 0x0000A0, "Wrong size on UDCAT_WaitGameplayEffectAdd");
static_assert(offsetof(UDCAT_WaitGameplayEffectAdd, OnApplied) == 0x000080, "Member 'UDCAT_WaitGameplayEffectAdd::OnApplied' has a wrong offset!");

// Class DungeonCrawler.CommonPopupManageWidget
// 0x0078 (0x03D0 - 0x0358)
class UCommonPopupManageWidget : public UDCWidgetBase
{
public:
	class UCanvasPanel*                           PopupCanvas;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCCommonActivatableWidgetBase> DefaultPopupWidgetClass;                           // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FMsgPopup>                 ReplyPointerMap;                                   // 0x0368(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_250E[0x18];                                    // 0x03B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonPopupManageWidget">();
	}
	static class UCommonPopupManageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonPopupManageWidget>();
	}
};
static_assert(alignof(UCommonPopupManageWidget) == 0x000008, "Wrong alignment on UCommonPopupManageWidget");
static_assert(sizeof(UCommonPopupManageWidget) == 0x0003D0, "Wrong size on UCommonPopupManageWidget");
static_assert(offsetof(UCommonPopupManageWidget, PopupCanvas) == 0x000358, "Member 'UCommonPopupManageWidget::PopupCanvas' has a wrong offset!");
static_assert(offsetof(UCommonPopupManageWidget, DefaultPopupWidgetClass) == 0x000360, "Member 'UCommonPopupManageWidget::DefaultPopupWidgetClass' has a wrong offset!");
static_assert(offsetof(UCommonPopupManageWidget, ReplyPointerMap) == 0x000368, "Member 'UCommonPopupManageWidget::ReplyPointerMap' has a wrong offset!");

// Class DungeonCrawler.DCPurchaseConfirmPopupWidget
// 0x0020 (0x04B0 - 0x0490)
class UDCPurchaseConfirmPopupWidget final : public UCommonPopupBase
{
public:
	class UTextBlock*                             Message;                                           // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCPriceWidget*                         Price;                                             // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    OkButton;                                          // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    CancelButton;                                      // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPurchaseConfirmPopupWidget">();
	}
	static class UDCPurchaseConfirmPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPurchaseConfirmPopupWidget>();
	}
};
static_assert(alignof(UDCPurchaseConfirmPopupWidget) == 0x000008, "Wrong alignment on UDCPurchaseConfirmPopupWidget");
static_assert(sizeof(UDCPurchaseConfirmPopupWidget) == 0x0004B0, "Wrong size on UDCPurchaseConfirmPopupWidget");
static_assert(offsetof(UDCPurchaseConfirmPopupWidget, Message) == 0x000490, "Member 'UDCPurchaseConfirmPopupWidget::Message' has a wrong offset!");
static_assert(offsetof(UDCPurchaseConfirmPopupWidget, Price) == 0x000498, "Member 'UDCPurchaseConfirmPopupWidget::Price' has a wrong offset!");
static_assert(offsetof(UDCPurchaseConfirmPopupWidget, OkButton) == 0x0004A0, "Member 'UDCPurchaseConfirmPopupWidget::OkButton' has a wrong offset!");
static_assert(offsetof(UDCPurchaseConfirmPopupWidget, CancelButton) == 0x0004A8, "Member 'UDCPurchaseConfirmPopupWidget::CancelButton' has a wrong offset!");

// Class DungeonCrawler.PopupDataSWidget
// 0x0038 (0x0068 - 0x0030)
class UPopupDataSWidget final : public UPopupDataBase
{
public:
	EPopupButtonType                              PopupButtonType;                                   // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250F[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescMessage;                                       // 0x0038(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 Nickname;                                          // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2510[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Cancel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupDataSWidget">();
	}
	static class UPopupDataSWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupDataSWidget>();
	}
};
static_assert(alignof(UPopupDataSWidget) == 0x000008, "Wrong alignment on UPopupDataSWidget");
static_assert(sizeof(UPopupDataSWidget) == 0x000068, "Wrong size on UPopupDataSWidget");
static_assert(offsetof(UPopupDataSWidget, PopupButtonType) == 0x000030, "Member 'UPopupDataSWidget::PopupButtonType' has a wrong offset!");
static_assert(offsetof(UPopupDataSWidget, DescMessage) == 0x000038, "Member 'UPopupDataSWidget::DescMessage' has a wrong offset!");
static_assert(offsetof(UPopupDataSWidget, Nickname) == 0x000050, "Member 'UPopupDataSWidget::Nickname' has a wrong offset!");

// Class DungeonCrawler.CommonPopupSWidget
// 0x0048 (0x04D8 - 0x0490)
class UCommonPopupSWidget : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_Two_Left;                                      // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Right;                                     // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Single;                                        // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Single_Confirm;                                // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Left_DeleteCharacter;                      // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Right_DeleteCharacter;                     // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          NicknameText;                                      // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPopupDataSWidget*                      PopupDataSWidget;                                  // 0x04C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OpenSound;                                         // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckBanAppealVisibleType();
	void HandleLeftButtonClicked();
	void HandleLeftDeleteCharacterButtonClicked();
	void HandleRightButtonClicked();
	void HandleRightDeleteCharacterButtonClicked();
	void HandleSingleButtonClicked();
	void OnCreatePopup(const struct FPopupSWidgetData& PopupSWidgetData);
	void OnRemovePopup();
	void PlayOpenSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonPopupSWidget">();
	}
	static class UCommonPopupSWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonPopupSWidget>();
	}
};
static_assert(alignof(UCommonPopupSWidget) == 0x000008, "Wrong alignment on UCommonPopupSWidget");
static_assert(sizeof(UCommonPopupSWidget) == 0x0004D8, "Wrong size on UCommonPopupSWidget");
static_assert(offsetof(UCommonPopupSWidget, Btn_Two_Left) == 0x000490, "Member 'UCommonPopupSWidget::Btn_Two_Left' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, Btn_Two_Right) == 0x000498, "Member 'UCommonPopupSWidget::Btn_Two_Right' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, Btn_Single) == 0x0004A0, "Member 'UCommonPopupSWidget::Btn_Single' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, Btn_Single_Confirm) == 0x0004A8, "Member 'UCommonPopupSWidget::Btn_Single_Confirm' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, Btn_Two_Left_DeleteCharacter) == 0x0004B0, "Member 'UCommonPopupSWidget::Btn_Two_Left_DeleteCharacter' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, Btn_Two_Right_DeleteCharacter) == 0x0004B8, "Member 'UCommonPopupSWidget::Btn_Two_Right_DeleteCharacter' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, NicknameText) == 0x0004C0, "Member 'UCommonPopupSWidget::NicknameText' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, PopupDataSWidget) == 0x0004C8, "Member 'UCommonPopupSWidget::PopupDataSWidget' has a wrong offset!");
static_assert(offsetof(UCommonPopupSWidget, OpenSound) == 0x0004D0, "Member 'UCommonPopupSWidget::OpenSound' has a wrong offset!");

// Class DungeonCrawler.DCAnimInstanceBase
// 0x00E0 (0x0430 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UDCAnimInstanceBase : public UAnimInstance
{
public:
	uint8                                         Pad_2511[0x58];                                    // 0x0348(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AnimationLODFrameRate;                             // 0x03A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOptimizeAnim;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2512[0x3];                                     // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalMovingThreshold;                         // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NativeVelocity;                                    // 0x03B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NativeRelativeHorizontalVelocity;                  // 0x03D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NativeSpeed;                                       // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NativeHorizontalSpeed;                             // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NativeDirectionAngle;                              // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMontagePlaying;                                 // 0x03F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHorizontalMoving;                               // 0x03F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2513[0x2];                                     // 0x03F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           IdleAnimSequenceGameplayTag;                       // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2514[0x28];                                    // 0x0400(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void EventAllMontageInstancesEnded();
	void EventMontageStarted(class UAnimMontage* InMontage);
	class AActor* GetOriginActor();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimInstanceBase">();
	}
	static class UDCAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimInstanceBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDCAnimInstanceBase) == 0x000010, "Wrong alignment on UDCAnimInstanceBase");
static_assert(sizeof(UDCAnimInstanceBase) == 0x000430, "Wrong size on UDCAnimInstanceBase");
static_assert(offsetof(UDCAnimInstanceBase, AnimationLODFrameRate) == 0x0003A0, "Member 'UDCAnimInstanceBase::AnimationLODFrameRate' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, bOptimizeAnim) == 0x0003B0, "Member 'UDCAnimInstanceBase::bOptimizeAnim' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, HorizontalMovingThreshold) == 0x0003B4, "Member 'UDCAnimInstanceBase::HorizontalMovingThreshold' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, NativeVelocity) == 0x0003B8, "Member 'UDCAnimInstanceBase::NativeVelocity' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, NativeRelativeHorizontalVelocity) == 0x0003D0, "Member 'UDCAnimInstanceBase::NativeRelativeHorizontalVelocity' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, NativeSpeed) == 0x0003E8, "Member 'UDCAnimInstanceBase::NativeSpeed' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, NativeHorizontalSpeed) == 0x0003EC, "Member 'UDCAnimInstanceBase::NativeHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, NativeDirectionAngle) == 0x0003F0, "Member 'UDCAnimInstanceBase::NativeDirectionAngle' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, bIsMontagePlaying) == 0x0003F4, "Member 'UDCAnimInstanceBase::bIsMontagePlaying' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, bIsHorizontalMoving) == 0x0003F5, "Member 'UDCAnimInstanceBase::bIsHorizontalMoving' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceBase, IdleAnimSequenceGameplayTag) == 0x0003F8, "Member 'UDCAnimInstanceBase::IdleAnimSequenceGameplayTag' has a wrong offset!");

// Class DungeonCrawler.DCRedeemLearningTokenCheckPopup
// 0x0070 (0x0500 - 0x0490)
class UDCRedeemLearningTokenCheckPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    RedeemButton;                                      // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelButton;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ClassNameText;                                     // 0x04A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FNickname                              CharacterNickname;                                 // 0x04B8(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UDCRedeemLearningTokenCheckPopupData*   RedeemCheckLearningTokenPopupData;                 // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelButtonClicked();
	void OnRedeemButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRedeemLearningTokenCheckPopup">();
	}
	static class UDCRedeemLearningTokenCheckPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRedeemLearningTokenCheckPopup>();
	}
};
static_assert(alignof(UDCRedeemLearningTokenCheckPopup) == 0x000008, "Wrong alignment on UDCRedeemLearningTokenCheckPopup");
static_assert(sizeof(UDCRedeemLearningTokenCheckPopup) == 0x000500, "Wrong size on UDCRedeemLearningTokenCheckPopup");
static_assert(offsetof(UDCRedeemLearningTokenCheckPopup, RedeemButton) == 0x000490, "Member 'UDCRedeemLearningTokenCheckPopup::RedeemButton' has a wrong offset!");
static_assert(offsetof(UDCRedeemLearningTokenCheckPopup, CancelButton) == 0x000498, "Member 'UDCRedeemLearningTokenCheckPopup::CancelButton' has a wrong offset!");
static_assert(offsetof(UDCRedeemLearningTokenCheckPopup, ClassNameText) == 0x0004A0, "Member 'UDCRedeemLearningTokenCheckPopup::ClassNameText' has a wrong offset!");
static_assert(offsetof(UDCRedeemLearningTokenCheckPopup, CharacterNickname) == 0x0004B8, "Member 'UDCRedeemLearningTokenCheckPopup::CharacterNickname' has a wrong offset!");
static_assert(offsetof(UDCRedeemLearningTokenCheckPopup, RedeemCheckLearningTokenPopupData) == 0x0004F8, "Member 'UDCRedeemLearningTokenCheckPopup::RedeemCheckLearningTokenPopupData' has a wrong offset!");

// Class DungeonCrawler.MetaStatisticsInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaStatisticsInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaStatisticsInterface">();
	}
	static class IMetaStatisticsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaStatisticsInterface>();
	}
};
static_assert(alignof(IMetaStatisticsInterface) == 0x000008, "Wrong alignment on IMetaStatisticsInterface");
static_assert(sizeof(IMetaStatisticsInterface) == 0x000028, "Wrong size on IMetaStatisticsInterface");

// Class DungeonCrawler.DCClientAccountManager
// 0x0138 (0x0168 - 0x0030)
class UDCClientAccountManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_2515[0x58];                                    // 0x0030(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCAccountId, struct FDCClientAccountInfo> Infos;                                             // 0x0088(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2516[0x90];                                    // 0x00D8(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCClientAccountManager">();
	}
	static class UDCClientAccountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCClientAccountManager>();
	}
};
static_assert(alignof(UDCClientAccountManager) == 0x000008, "Wrong alignment on UDCClientAccountManager");
static_assert(sizeof(UDCClientAccountManager) == 0x000168, "Wrong size on UDCClientAccountManager");
static_assert(offsetof(UDCClientAccountManager, Infos) == 0x000088, "Member 'UDCClientAccountManager::Infos' has a wrong offset!");

// Class DungeonCrawler.ContainerInventoryGroupWidget
// 0x00B0 (0x0430 - 0x0380)
class UContainerInventoryGroupWidget final : public UDCPlayerCharacterBasedWidget
{
public:
	class UPanelWidget*                           ContainerInventoryParent;                          // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ItemCountSelectWidgetClass;                        // 0x0388(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UContainerInventoryWidget>  ContainerInventoryWidgetClass;                     // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UContainerInventoryWidget>  ReadOnlyContainerInventoryWidgetClass;             // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWidgetInventoryGroupType                     InventoryGroupType;                                // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2517[0x7];                                     // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInventoryCountChanged;                           // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UDCBoxInventory*, class UContainerInventoryWidget*> Data;                                              // 0x03D8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        OldLootTarget;                                     // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnItemDropDetected(const struct FItemData& ItemData, const struct FVector2D& DropScreenPos, class AActor* OldOwnerActor);
	void OnPopItemSelectWidget(const struct FItemData& ItemData, const struct FVector2D& DropScreenPos, class AActor* OldOwnerActor);
	void ResetContainerInventoryWidgets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainerInventoryGroupWidget">();
	}
	static class UContainerInventoryGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContainerInventoryGroupWidget>();
	}
};
static_assert(alignof(UContainerInventoryGroupWidget) == 0x000008, "Wrong alignment on UContainerInventoryGroupWidget");
static_assert(sizeof(UContainerInventoryGroupWidget) == 0x000430, "Wrong size on UContainerInventoryGroupWidget");
static_assert(offsetof(UContainerInventoryGroupWidget, ContainerInventoryParent) == 0x000380, "Member 'UContainerInventoryGroupWidget::ContainerInventoryParent' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, ItemCountSelectWidgetClass) == 0x000388, "Member 'UContainerInventoryGroupWidget::ItemCountSelectWidgetClass' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, ContainerInventoryWidgetClass) == 0x0003B0, "Member 'UContainerInventoryGroupWidget::ContainerInventoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, ReadOnlyContainerInventoryWidgetClass) == 0x0003B8, "Member 'UContainerInventoryGroupWidget::ReadOnlyContainerInventoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, InventoryGroupType) == 0x0003C0, "Member 'UContainerInventoryGroupWidget::InventoryGroupType' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, OnInventoryCountChanged) == 0x0003C8, "Member 'UContainerInventoryGroupWidget::OnInventoryCountChanged' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, Data) == 0x0003D8, "Member 'UContainerInventoryGroupWidget::Data' has a wrong offset!");
static_assert(offsetof(UContainerInventoryGroupWidget, OldLootTarget) == 0x000428, "Member 'UContainerInventoryGroupWidget::OldLootTarget' has a wrong offset!");

// Class DungeonCrawler.ContainerInventoryWidget
// 0x0140 (0x0498 - 0x0358)
class UContainerInventoryWidget final : public UDCWidgetBase
{
public:
	class UGridPanel*                             ContainerSlotGridPanel;                            // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ContainerItemOvelay;                               // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UContainerSlotWidget>       ContainerSlotWidgetClass;                          // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ContainerSlotSize;                                 // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2518[0x4];                                     // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FContainerSlotArrayData>   ContainerSlotWidgetMap;                            // 0x0378(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        Inventory;                                         // 0x03C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UItemWidget>                ItemWidgetClass;                                   // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FDCItemId, class UItemWidget*>    ItemWidgetMap;                                     // 0x03D8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2519[0x8];                                     // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DragDetectedContainerSlotId;                       // 0x0430(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251A[0x4];                                     // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UContainerSlotWidget*>           OverlapContainerSlots;                             // 0x0438(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, bool>                  CanEquipMap;                                       // 0x0448(0x0050)(NativeAccessSpecifierPrivate)

public:
	bool CanSetItemAt(const struct FItemData& ItemData, const int32 SlotId);
	int32 GetSlotIdByScreenPosition(const struct FVector2D& ScreenPos);
	class UItemWidget* OnAddItem(const struct FItemData& InItemData);
	void OnItemDragDetected(const struct FItemData& ItemData, const struct FVector2D& DragScreenPos);
	void OnItemWidgetDropOrLeave();
	void OnMoveItem(const struct FItemData& OldItemData, const struct FItemData& NewItemData);
	void OnRemoveItem(const struct FItemData& InItemData);
	void UpdateItemCanBeSet(const struct FItemData& InItemData, const int32 SlotId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainerInventoryWidget">();
	}
	static class UContainerInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContainerInventoryWidget>();
	}
};
static_assert(alignof(UContainerInventoryWidget) == 0x000008, "Wrong alignment on UContainerInventoryWidget");
static_assert(sizeof(UContainerInventoryWidget) == 0x000498, "Wrong size on UContainerInventoryWidget");
static_assert(offsetof(UContainerInventoryWidget, ContainerSlotGridPanel) == 0x000358, "Member 'UContainerInventoryWidget::ContainerSlotGridPanel' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, ContainerItemOvelay) == 0x000360, "Member 'UContainerInventoryWidget::ContainerItemOvelay' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, ContainerSlotWidgetClass) == 0x000368, "Member 'UContainerInventoryWidget::ContainerSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, ContainerSlotSize) == 0x000370, "Member 'UContainerInventoryWidget::ContainerSlotSize' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, ContainerSlotWidgetMap) == 0x000378, "Member 'UContainerInventoryWidget::ContainerSlotWidgetMap' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, Inventory) == 0x0003C8, "Member 'UContainerInventoryWidget::Inventory' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, ItemWidgetClass) == 0x0003D0, "Member 'UContainerInventoryWidget::ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, ItemWidgetMap) == 0x0003D8, "Member 'UContainerInventoryWidget::ItemWidgetMap' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, DragDetectedContainerSlotId) == 0x000430, "Member 'UContainerInventoryWidget::DragDetectedContainerSlotId' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, OverlapContainerSlots) == 0x000438, "Member 'UContainerInventoryWidget::OverlapContainerSlots' has a wrong offset!");
static_assert(offsetof(UContainerInventoryWidget, CanEquipMap) == 0x000448, "Member 'UContainerInventoryWidget::CanEquipMap' has a wrong offset!");

// Class DungeonCrawler.DCReligionConvertPopUp
// 0x0038 (0x04C8 - 0x0490)
class UDCReligionConvertPopUp final : public UCommonPopupBase
{
public:
	class UTextBlock*                             ReligionNameText;                                  // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingNameText;                                  // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_One_Cancel;                                    // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ImageSize;                                         // 0x04B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionConvertPopupData*            ReligionBurfPopupData;                             // 0x04C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelButtonClicked();
	void OnConfirmButtonClicked();
	void SetReligionImageEvent(const struct FSlateBrush& Bursh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionConvertPopUp">();
	}
	static class UDCReligionConvertPopUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionConvertPopUp>();
	}
};
static_assert(alignof(UDCReligionConvertPopUp) == 0x000008, "Wrong alignment on UDCReligionConvertPopUp");
static_assert(sizeof(UDCReligionConvertPopUp) == 0x0004C8, "Wrong size on UDCReligionConvertPopUp");
static_assert(offsetof(UDCReligionConvertPopUp, ReligionNameText) == 0x000490, "Member 'UDCReligionConvertPopUp::ReligionNameText' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopUp, BlessingNameText) == 0x000498, "Member 'UDCReligionConvertPopUp::BlessingNameText' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopUp, Btn_One_Confirm) == 0x0004A0, "Member 'UDCReligionConvertPopUp::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopUp, Btn_One_Cancel) == 0x0004A8, "Member 'UDCReligionConvertPopUp::Btn_One_Cancel' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopUp, ImageSize) == 0x0004B0, "Member 'UDCReligionConvertPopUp::ImageSize' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopUp, ReligionBurfPopupData) == 0x0004C0, "Member 'UDCReligionConvertPopUp::ReligionBurfPopupData' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationWeightLimit
// 0x00C0 (0x0100 - 0x0040)
class UDCAttributeModMagnitudeCalculationWeightLimit final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_251E[0xC0];                                    // 0x0040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationWeightLimit">();
	}
	static class UDCAttributeModMagnitudeCalculationWeightLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationWeightLimit>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationWeightLimit) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationWeightLimit");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationWeightLimit) == 0x000100, "Wrong size on UDCAttributeModMagnitudeCalculationWeightLimit");

// Class DungeonCrawler.ContainerSlotWidget
// 0x0038 (0x0390 - 0x0358)
class UContainerSlotWidget final : public UDCWidgetBase
{
public:
	struct FLinearColor                           ItemSetColor;                                      // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InvalidSlotColor;                                  // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ValidSlotColor;                                    // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasItem;                                          // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251F[0x7];                                     // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeaveItemWidget();
	void OnOverlapItemWidget(bool bCanSetItem);
	void OnRemoveItem();
	void OnSetNewItem(bool bFullfilledAll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainerSlotWidget">();
	}
	static class UContainerSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContainerSlotWidget>();
	}
};
static_assert(alignof(UContainerSlotWidget) == 0x000008, "Wrong alignment on UContainerSlotWidget");
static_assert(sizeof(UContainerSlotWidget) == 0x000390, "Wrong size on UContainerSlotWidget");
static_assert(offsetof(UContainerSlotWidget, ItemSetColor) == 0x000358, "Member 'UContainerSlotWidget::ItemSetColor' has a wrong offset!");
static_assert(offsetof(UContainerSlotWidget, InvalidSlotColor) == 0x000368, "Member 'UContainerSlotWidget::InvalidSlotColor' has a wrong offset!");
static_assert(offsetof(UContainerSlotWidget, ValidSlotColor) == 0x000378, "Member 'UContainerSlotWidget::ValidSlotColor' has a wrong offset!");
static_assert(offsetof(UContainerSlotWidget, bHasItem) == 0x000388, "Member 'UContainerSlotWidget::bHasItem' has a wrong offset!");

// Class DungeonCrawler.DCReportPlayerComboBoxWidgetData
// 0x0068 (0x0090 - 0x0028)
class UDCReportPlayerComboBoxWidgetData final : public UObject
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0028(0x0010)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0038(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ClassText;                                         // 0x0078(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerComboBoxWidgetData">();
	}
	static class UDCReportPlayerComboBoxWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerComboBoxWidgetData>();
	}
};
static_assert(alignof(UDCReportPlayerComboBoxWidgetData) == 0x000008, "Wrong alignment on UDCReportPlayerComboBoxWidgetData");
static_assert(sizeof(UDCReportPlayerComboBoxWidgetData) == 0x000090, "Wrong size on UDCReportPlayerComboBoxWidgetData");
static_assert(offsetof(UDCReportPlayerComboBoxWidgetData, AccountId) == 0x000028, "Member 'UDCReportPlayerComboBoxWidgetData::AccountId' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerComboBoxWidgetData, Nickname) == 0x000038, "Member 'UDCReportPlayerComboBoxWidgetData::Nickname' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerComboBoxWidgetData, ClassText) == 0x000078, "Member 'UDCReportPlayerComboBoxWidgetData::ClassText' has a wrong offset!");

// Class DungeonCrawler.ContextMenuHolderInterface
// 0x0000 (0x0028 - 0x0028)
class IContextMenuHolderInterface final : public IInterface
{
public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextMenuHolderInterface">();
	}
	static class IContextMenuHolderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContextMenuHolderInterface>();
	}
};
static_assert(alignof(IContextMenuHolderInterface) == 0x000008, "Wrong alignment on IContextMenuHolderInterface");
static_assert(sizeof(IContextMenuHolderInterface) == 0x000028, "Wrong size on IContextMenuHolderInterface");

// Class DungeonCrawler.PartyChatWidget
// 0x0000 (0x0530 - 0x0530)
class UPartyChatWidget final : public UChatSetWidgetBase
{
public:
	void OnPartyChatFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyChatWidget">();
	}
	static class UPartyChatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyChatWidget>();
	}
};
static_assert(alignof(UPartyChatWidget) == 0x000008, "Wrong alignment on UPartyChatWidget");
static_assert(sizeof(UPartyChatWidget) == 0x000530, "Wrong size on UPartyChatWidget");

// Class DungeonCrawler.DCAT_WaitTargetData
// 0x0000 (0x00C0 - 0x00C0)
class UDCAT_WaitTargetData final : public UAbilityTask_WaitTargetData
{
public:
	static class UDCAT_WaitTargetData* DCWaitTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, class AGameplayAbilityTargetActor* InTargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitTargetData">();
	}
	static class UDCAT_WaitTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitTargetData>();
	}
};
static_assert(alignof(UDCAT_WaitTargetData) == 0x000008, "Wrong alignment on UDCAT_WaitTargetData");
static_assert(sizeof(UDCAT_WaitTargetData) == 0x0000C0, "Wrong size on UDCAT_WaitTargetData");

// Class DungeonCrawler.ContextMenuWidgetBase
// 0x0018 (0x0370 - 0x0358)
class UContextMenuWidgetBase : public UDCWidgetBase
{
public:
	class UListView*                              ListView_ContextOptions;                           // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_ContextMenu;                               // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetPosition;                                      // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2521[0x7];                                     // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestCloseMenu();
	void SetContextMenuWidgetPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextMenuWidgetBase">();
	}
	static class UContextMenuWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextMenuWidgetBase>();
	}
};
static_assert(alignof(UContextMenuWidgetBase) == 0x000008, "Wrong alignment on UContextMenuWidgetBase");
static_assert(sizeof(UContextMenuWidgetBase) == 0x000370, "Wrong size on UContextMenuWidgetBase");
static_assert(offsetof(UContextMenuWidgetBase, ListView_ContextOptions) == 0x000358, "Member 'UContextMenuWidgetBase::ListView_ContextOptions' has a wrong offset!");
static_assert(offsetof(UContextMenuWidgetBase, Overlay_ContextMenu) == 0x000360, "Member 'UContextMenuWidgetBase::Overlay_ContextMenu' has a wrong offset!");
static_assert(offsetof(UContextMenuWidgetBase, bSetPosition) == 0x000368, "Member 'UContextMenuWidgetBase::bSetPosition' has a wrong offset!");

// Class DungeonCrawler.DCQuestContentKillDataAsset
// 0x0030 (0x0090 - 0x0060)
class UDCQuestContentKillDataAsset final : public UDCQuestContentDataAsset
{
public:
	EDCQuestContentKillType                       KillType;                                          // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2522[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           KillTag;                                           // 0x0064(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x006C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SingleSession;                                     // 0x0074(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0075(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x0076(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2523[0x1];                                     // 0x0077(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2524[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTagQueryData>>   TagQueryData;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentKillDataAsset">();
	}
	static class UDCQuestContentKillDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentKillDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentKillDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentKillDataAsset");
static_assert(sizeof(UDCQuestContentKillDataAsset) == 0x000090, "Wrong size on UDCQuestContentKillDataAsset");
static_assert(offsetof(UDCQuestContentKillDataAsset, KillType) == 0x000060, "Member 'UDCQuestContentKillDataAsset::KillType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, KillTag) == 0x000064, "Member 'UDCQuestContentKillDataAsset::KillTag' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, GradeType) == 0x00006C, "Member 'UDCQuestContentKillDataAsset::GradeType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, SingleSession) == 0x000074, "Member 'UDCQuestContentKillDataAsset::SingleSession' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, MustEscape) == 0x000075, "Member 'UDCQuestContentKillDataAsset::MustEscape' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, HealthRequirementType) == 0x000076, "Member 'UDCQuestContentKillDataAsset::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, HealthRequirementRatio) == 0x000078, "Member 'UDCQuestContentKillDataAsset::HealthRequirementRatio' has a wrong offset!");
static_assert(offsetof(UDCQuestContentKillDataAsset, TagQueryData) == 0x000080, "Member 'UDCQuestContentKillDataAsset::TagQueryData' has a wrong offset!");

// Class DungeonCrawler.ContextOptionListEntryWidgetData
// 0x0008 (0x0030 - 0x0028)
class UContextOptionListEntryWidgetData final : public UObject
{
public:
	EContextOptionType                            ContextOption;                                     // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2525[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextOptionListEntryWidgetData">();
	}
	static class UContextOptionListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextOptionListEntryWidgetData>();
	}
};
static_assert(alignof(UContextOptionListEntryWidgetData) == 0x000008, "Wrong alignment on UContextOptionListEntryWidgetData");
static_assert(sizeof(UContextOptionListEntryWidgetData) == 0x000030, "Wrong size on UContextOptionListEntryWidgetData");
static_assert(offsetof(UContextOptionListEntryWidgetData, ContextOption) == 0x000028, "Member 'UContextOptionListEntryWidgetData::ContextOption' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitForInputAction
// 0x0048 (0x00C8 - 0x0080)
class UDCAT_WaitForInputAction final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             InputActionStarted;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InputActionCompleted;                              // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2526[0x20];                                    // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitForInputAction* WaitForInputAction(class UGameplayAbility* OwningAbility, const class UInputAction* InInputAction, bool bOnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitForInputAction">();
	}
	static class UDCAT_WaitForInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitForInputAction>();
	}
};
static_assert(alignof(UDCAT_WaitForInputAction) == 0x000008, "Wrong alignment on UDCAT_WaitForInputAction");
static_assert(sizeof(UDCAT_WaitForInputAction) == 0x0000C8, "Wrong size on UDCAT_WaitForInputAction");
static_assert(offsetof(UDCAT_WaitForInputAction, InputActionStarted) == 0x000080, "Member 'UDCAT_WaitForInputAction::InputActionStarted' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitForInputAction, InputActionCompleted) == 0x000090, "Member 'UDCAT_WaitForInputAction::InputActionCompleted' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitForInputAction, InputAction) == 0x0000A0, "Member 'UDCAT_WaitForInputAction::InputAction' has a wrong offset!");

// Class DungeonCrawler.ContextOptionListEntryWidgetBase
// 0x0000 (0x1660 - 0x1660)
class UContextOptionListEntryWidgetBase : public UDCCommonButtonBase
{
public:
	void OnSelect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextOptionListEntryWidgetBase">();
	}
	static class UContextOptionListEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextOptionListEntryWidgetBase>();
	}
};
static_assert(alignof(UContextOptionListEntryWidgetBase) == 0x000010, "Wrong alignment on UContextOptionListEntryWidgetBase");
static_assert(sizeof(UContextOptionListEntryWidgetBase) == 0x001660, "Wrong size on UContextOptionListEntryWidgetBase");

// Class DungeonCrawler.DCReligionComponent
// 0x0288 (0x0328 - 0x00A0)
class UDCReligionComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2528[0x288];                                   // 0x00A0(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionComponent">();
	}
	static class UDCReligionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionComponent>();
	}
};
static_assert(alignof(UDCReligionComponent) == 0x000008, "Wrong alignment on UDCReligionComponent");
static_assert(sizeof(UDCReligionComponent) == 0x000328, "Wrong size on UDCReligionComponent");

// Class DungeonCrawler.CreateAccountNicknamePopupData
// 0x0000 (0x0030 - 0x0030)
class UCreateAccountNicknamePopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateAccountNicknamePopupData">();
	}
	static class UCreateAccountNicknamePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateAccountNicknamePopupData>();
	}
};
static_assert(alignof(UCreateAccountNicknamePopupData) == 0x000008, "Wrong alignment on UCreateAccountNicknamePopupData");
static_assert(sizeof(UCreateAccountNicknamePopupData) == 0x000030, "Wrong size on UCreateAccountNicknamePopupData");

// Class DungeonCrawler.DCPreloadDataInterface
// 0x0000 (0x0028 - 0x0028)
class IDCPreloadDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPreloadDataInterface">();
	}
	static class IDCPreloadDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCPreloadDataInterface>();
	}
};
static_assert(alignof(IDCPreloadDataInterface) == 0x000008, "Wrong alignment on IDCPreloadDataInterface");
static_assert(sizeof(IDCPreloadDataInterface) == 0x000028, "Wrong size on IDCPreloadDataInterface");

// Class DungeonCrawler.LeaderboardRankRecordMineWidget
// 0x0080 (0x03D8 - 0x0358)
class ULeaderboardRankRecordMineWidget final : public UDCWidgetBase
{
public:
	struct FLeaderboardRankRecordMineWidgetHandleData WidgetHandleData;                                  // 0x0358(0x0080)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);
	void OnLeaderboardRankRecordMineData(const struct FLeaderboardRankRecordMineData& NewValue, const struct FLeaderboardRankRecordMineData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardRankRecordMineWidget">();
	}
	static class ULeaderboardRankRecordMineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardRankRecordMineWidget>();
	}
};
static_assert(alignof(ULeaderboardRankRecordMineWidget) == 0x000008, "Wrong alignment on ULeaderboardRankRecordMineWidget");
static_assert(sizeof(ULeaderboardRankRecordMineWidget) == 0x0003D8, "Wrong size on ULeaderboardRankRecordMineWidget");
static_assert(offsetof(ULeaderboardRankRecordMineWidget, WidgetHandleData) == 0x000358, "Member 'ULeaderboardRankRecordMineWidget::WidgetHandleData' has a wrong offset!");

// Class DungeonCrawler.DCAbilityActorBase
// 0x0010 (0x0308 - 0x02F8)
class ADCAbilityActorBase : public ADCActorBase
{
public:
	uint8                                         Pad_2529[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAbilityActorBase">();
	}
	static class ADCAbilityActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCAbilityActorBase>();
	}
};
static_assert(alignof(ADCAbilityActorBase) == 0x000008, "Wrong alignment on ADCAbilityActorBase");
static_assert(sizeof(ADCAbilityActorBase) == 0x000308, "Wrong size on ADCAbilityActorBase");
static_assert(offsetof(ADCAbilityActorBase, AbilitySystemComponent) == 0x000300, "Member 'ADCAbilityActorBase::AbilitySystemComponent' has a wrong offset!");

// Class DungeonCrawler.DCAbilityRelationshipTagGroupDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCAbilityRelationshipTagGroupDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCAbilityRelationshipTagGroupItemData> AbilityRelationshipTagGroupItemArray;              // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAbilityRelationshipTagGroupDataAsset">();
	}
	static class UDCAbilityRelationshipTagGroupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAbilityRelationshipTagGroupDataAsset>();
	}
};
static_assert(alignof(UDCAbilityRelationshipTagGroupDataAsset) == 0x000008, "Wrong alignment on UDCAbilityRelationshipTagGroupDataAsset");
static_assert(sizeof(UDCAbilityRelationshipTagGroupDataAsset) == 0x000058, "Wrong size on UDCAbilityRelationshipTagGroupDataAsset");
static_assert(offsetof(UDCAbilityRelationshipTagGroupDataAsset, AbilityRelationshipTagGroupItemArray) == 0x000048, "Member 'UDCAbilityRelationshipTagGroupDataAsset::AbilityRelationshipTagGroupItemArray' has a wrong offset!");

// Class DungeonCrawler.DCAbilitySystemComponent
// 0x1130 (0x2380 - 0x1250)
class UDCAbilitySystemComponent : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_252A[0xD8];                                    // 0x1250(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AttributeChangesFlushNextTickTimerHandle;          // 0x1328(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FPredictionKey, struct FDCInventoryEventDataCache> InventoryEventDataCaches;                          // 0x1330(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FActorDieData                          ActorDieData;                                      // 0x1380(0x06D0)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FActorRigidData                        ActorRigidData;                                    // 0x1A50(0x0040)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FImpactEnduranceExhaustedData          ImpactEnduranceExhaustedData;                      // 0x1A90(0x06C8)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_252B[0x70];                                    // 0x2158(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCGameplayAbilityHandleData>   AbilityHandleDataArray;                            // 0x21C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_252C[0x50];                                    // 0x21D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAbilityRelationshipTagGroupDataAsset* AbilityTagRelationshipDataAsset;                   // 0x2228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTagMessageRelationshipData*    GameplayTagMessageRelationshipData;                // 0x2230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameplayCueTagGroupDataAsset*        GameplayCueRelationGroup;                          // 0x2238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameplayCueTagGroupDataAsset*        LocalOnlyGameplayCueRelationGroup;                 // 0x2240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameplayCueTagGroupDataAsset*        OverrideGameplayCueRelationGroup;                  // 0x2248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDCGameplayEffectContainerSpec> PremadeContainerSpecArray;                         // 0x2250(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTagQueryData*>                  HitTagQueryDataArray;                              // 0x2260(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTagQueryData*>                  BeHitTagQueryDataArray;                            // 0x2270(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_252D[0xA0];                                    // 0x2280(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCAbilitySystemComponent*>      DamageTransferLinkedAbilitySystemComponents;       // 0x2320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_252E[0x50];                                    // 0x2330(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDamageTransferLink(class UDCAbilitySystemComponent* InAbilitySystemComponent);
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	TArray<struct FDCGameplayEffectContainerSpec> GetContainerSpecArray();
	void OnRep_AbilityHandleDataArray(const TArray<struct FDCGameplayAbilityHandleData>& InOldAbilityHandleDataArray);
	void OnRep_ActorDieData(const struct FActorDieData& InOldActorDieData);
	void OnRep_ActorRigidData(const struct FActorRigidData& OldActorRigidData);
	void OnRep_ImpactEnduranceExhaustedData(const struct FImpactEnduranceExhaustedData& OldImpactEnduranceExhaustedData);
	void PlayMontageOnSourceObject(class UGameplayAbility* InAnimatingAbility, const struct FGameplayAbilityActivationInfo& ActivationInfo, class UAnimMontage* NewAnimMontage, float InPlayRate, class FName StartSectionName, float StartTimeSeconds);
	void RemoveDamageTransferLink(class UDCAbilitySystemComponent* InAbilitySystemComponent);
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag);
	void SendInventoryEventData_Server(const struct FPredictionKey& PredictionKey, const struct FDCInventoryEventData& EventData);
	void SetTagQueryData(const TArray<struct FPrimaryAssetId>& InHitTagQueryDataIdArray, const TArray<struct FPrimaryAssetId>& InBeHitTagQueryDataIdArray);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAbilitySystemComponent">();
	}
	static class UDCAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAbilitySystemComponent>();
	}
};
static_assert(alignof(UDCAbilitySystemComponent) == 0x000008, "Wrong alignment on UDCAbilitySystemComponent");
static_assert(sizeof(UDCAbilitySystemComponent) == 0x002380, "Wrong size on UDCAbilitySystemComponent");
static_assert(offsetof(UDCAbilitySystemComponent, AttributeChangesFlushNextTickTimerHandle) == 0x001328, "Member 'UDCAbilitySystemComponent::AttributeChangesFlushNextTickTimerHandle' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, InventoryEventDataCaches) == 0x001330, "Member 'UDCAbilitySystemComponent::InventoryEventDataCaches' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, ActorDieData) == 0x001380, "Member 'UDCAbilitySystemComponent::ActorDieData' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, ActorRigidData) == 0x001A50, "Member 'UDCAbilitySystemComponent::ActorRigidData' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, ImpactEnduranceExhaustedData) == 0x001A90, "Member 'UDCAbilitySystemComponent::ImpactEnduranceExhaustedData' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, AbilityHandleDataArray) == 0x0021C8, "Member 'UDCAbilitySystemComponent::AbilityHandleDataArray' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, AbilityTagRelationshipDataAsset) == 0x002228, "Member 'UDCAbilitySystemComponent::AbilityTagRelationshipDataAsset' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, GameplayTagMessageRelationshipData) == 0x002230, "Member 'UDCAbilitySystemComponent::GameplayTagMessageRelationshipData' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, GameplayCueRelationGroup) == 0x002238, "Member 'UDCAbilitySystemComponent::GameplayCueRelationGroup' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, LocalOnlyGameplayCueRelationGroup) == 0x002240, "Member 'UDCAbilitySystemComponent::LocalOnlyGameplayCueRelationGroup' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, OverrideGameplayCueRelationGroup) == 0x002248, "Member 'UDCAbilitySystemComponent::OverrideGameplayCueRelationGroup' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, PremadeContainerSpecArray) == 0x002250, "Member 'UDCAbilitySystemComponent::PremadeContainerSpecArray' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, HitTagQueryDataArray) == 0x002260, "Member 'UDCAbilitySystemComponent::HitTagQueryDataArray' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, BeHitTagQueryDataArray) == 0x002270, "Member 'UDCAbilitySystemComponent::BeHitTagQueryDataArray' has a wrong offset!");
static_assert(offsetof(UDCAbilitySystemComponent, DamageTransferLinkedAbilitySystemComponents) == 0x002320, "Member 'UDCAbilitySystemComponent::DamageTransferLinkedAbilitySystemComponents' has a wrong offset!");

// Class DungeonCrawler.DCAccountNameChangeShopConfirmPopupData
// 0x0048 (0x0078 - 0x0030)
class UDCAccountNameChangeShopConfirmPopupData final : public UPopupDataBase
{
public:
	class FText                                   OldAccountName;                                    // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   NewAccountName;                                    // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDCAccountNameChangeShopInfo           ShopInfo;                                          // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountNameChangeShopConfirmPopupData">();
	}
	static class UDCAccountNameChangeShopConfirmPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountNameChangeShopConfirmPopupData>();
	}
};
static_assert(alignof(UDCAccountNameChangeShopConfirmPopupData) == 0x000008, "Wrong alignment on UDCAccountNameChangeShopConfirmPopupData");
static_assert(sizeof(UDCAccountNameChangeShopConfirmPopupData) == 0x000078, "Wrong size on UDCAccountNameChangeShopConfirmPopupData");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopupData, OldAccountName) == 0x000030, "Member 'UDCAccountNameChangeShopConfirmPopupData::OldAccountName' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopupData, NewAccountName) == 0x000048, "Member 'UDCAccountNameChangeShopConfirmPopupData::NewAccountName' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopConfirmPopupData, ShopInfo) == 0x000060, "Member 'UDCAccountNameChangeShopConfirmPopupData::ShopInfo' has a wrong offset!");

// Class DungeonCrawler.DCAccountNameChangeShopWidget
// 0x0098 (0x03F0 - 0x0358)
class UDCAccountNameChangeShopWidget final : public UDCWidgetBase
{
public:
	TSubclassOf<class UDCCommonActivatableWidgetBase> ConfirmPopupWidgetClass;                           // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252F[0x10];                                    // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    AccountNameChangeButton;                           // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEditableText*                        OldAccountNameEdit;                                // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    OldAccountNameCheckButton;                         // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEditableText*                        NewAccountNameEdit;                                // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    NewAccountNameCheckButton;                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCAccountNameCheckState                      OldAccountNameCheckState;                          // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2530[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OldAccountName;                                    // 0x03A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EDCAccountNameCheckState                      NewAccountNameCheckState;                          // 0x03B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2531[0x7];                                     // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NewAccountName;                                    // 0x03C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDCAccountNameChangeShopInfo           ShopInfo;                                          // 0x03D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnAccountNameChangeButtonClicked();
	void OnAccountNameCheckState();
	void OnNewAccountNameCheckButtonClicked();
	void OnOldAccountNameCheckButtonClicked();
	void OnSetShopInfo(const struct FDCAccountNameChangeShopInfo& InShopInfo);
	void OnTextChangedNewAccountName(const class FText& InAccountName);
	void OnTextChangedOldAccountName(const class FText& InAccountName);
	void ResetData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountNameChangeShopWidget">();
	}
	static class UDCAccountNameChangeShopWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountNameChangeShopWidget>();
	}
};
static_assert(alignof(UDCAccountNameChangeShopWidget) == 0x000008, "Wrong alignment on UDCAccountNameChangeShopWidget");
static_assert(sizeof(UDCAccountNameChangeShopWidget) == 0x0003F0, "Wrong size on UDCAccountNameChangeShopWidget");
static_assert(offsetof(UDCAccountNameChangeShopWidget, ConfirmPopupWidgetClass) == 0x000358, "Member 'UDCAccountNameChangeShopWidget::ConfirmPopupWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, AccountNameChangeButton) == 0x000370, "Member 'UDCAccountNameChangeShopWidget::AccountNameChangeButton' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, OldAccountNameEdit) == 0x000378, "Member 'UDCAccountNameChangeShopWidget::OldAccountNameEdit' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, OldAccountNameCheckButton) == 0x000380, "Member 'UDCAccountNameChangeShopWidget::OldAccountNameCheckButton' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, NewAccountNameEdit) == 0x000388, "Member 'UDCAccountNameChangeShopWidget::NewAccountNameEdit' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, NewAccountNameCheckButton) == 0x000390, "Member 'UDCAccountNameChangeShopWidget::NewAccountNameCheckButton' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, OldAccountNameCheckState) == 0x000398, "Member 'UDCAccountNameChangeShopWidget::OldAccountNameCheckState' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, OldAccountName) == 0x0003A0, "Member 'UDCAccountNameChangeShopWidget::OldAccountName' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, NewAccountNameCheckState) == 0x0003B8, "Member 'UDCAccountNameChangeShopWidget::NewAccountNameCheckState' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, NewAccountName) == 0x0003C0, "Member 'UDCAccountNameChangeShopWidget::NewAccountName' has a wrong offset!");
static_assert(offsetof(UDCAccountNameChangeShopWidget, ShopInfo) == 0x0003D8, "Member 'UDCAccountNameChangeShopWidget::ShopInfo' has a wrong offset!");

// Class DungeonCrawler.DCAccountStatusUpgradeCompletePopup
// 0x0010 (0x04A0 - 0x0490)
class UDCAccountStatusUpgradeCompletePopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    OkButton;                                          // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAccountStatusUpgradeCompletePopupData* AccountStatusUpgradeCompletePopupData;             // 0x0498(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Close();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountStatusUpgradeCompletePopup">();
	}
	static class UDCAccountStatusUpgradeCompletePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountStatusUpgradeCompletePopup>();
	}
};
static_assert(alignof(UDCAccountStatusUpgradeCompletePopup) == 0x000008, "Wrong alignment on UDCAccountStatusUpgradeCompletePopup");
static_assert(sizeof(UDCAccountStatusUpgradeCompletePopup) == 0x0004A0, "Wrong size on UDCAccountStatusUpgradeCompletePopup");
static_assert(offsetof(UDCAccountStatusUpgradeCompletePopup, OkButton) == 0x000490, "Member 'UDCAccountStatusUpgradeCompletePopup::OkButton' has a wrong offset!");
static_assert(offsetof(UDCAccountStatusUpgradeCompletePopup, AccountStatusUpgradeCompletePopupData) == 0x000498, "Member 'UDCAccountStatusUpgradeCompletePopup::AccountStatusUpgradeCompletePopupData' has a wrong offset!");

// Class DungeonCrawler.DCAccountStatusWidget
// 0x0000 (0x1660 - 0x1660)
class UDCAccountStatusWidget : public UDCCommonButtonBase
{
public:
	TSubclassOf<class UDCLegendaryStatusPopup>    LegendaryStatusPopupClass;                         // 0x1658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAccountStatusUpdated(const EDCAccountStatus InAccountStatus);
	void ShowLegendaryStatusPopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAccountStatusWidget">();
	}
	static class UDCAccountStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAccountStatusWidget>();
	}
};
static_assert(alignof(UDCAccountStatusWidget) == 0x000010, "Wrong alignment on UDCAccountStatusWidget");
static_assert(sizeof(UDCAccountStatusWidget) == 0x001660, "Wrong size on UDCAccountStatusWidget");
static_assert(offsetof(UDCAccountStatusWidget, LegendaryStatusPopupClass) == 0x001658, "Member 'UDCAccountStatusWidget::LegendaryStatusPopupClass' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinComponent
// 0x0060 (0x0100 - 0x00A0)
class UDCActionSkinComponent final : public UDCActorComponent
{
public:
	TArray<class UDCActionSkinDataAsset*>         Datas;                                             // 0x00A0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2532[0x50];                                    // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Datas(const TArray<class UDCActionSkinDataAsset*>& OldDatas);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinComponent">();
	}
	static class UDCActionSkinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinComponent>();
	}
};
static_assert(alignof(UDCActionSkinComponent) == 0x000008, "Wrong alignment on UDCActionSkinComponent");
static_assert(sizeof(UDCActionSkinComponent) == 0x000100, "Wrong size on UDCActionSkinComponent");
static_assert(offsetof(UDCActionSkinComponent, Datas) == 0x0000A0, "Member 'UDCActionSkinComponent::Datas' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinListEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCActionSkinListEntryWidgetData final : public UObject
{
public:
	struct FDCActionSkinInfo                      ActionSkinInfo;                                    // 0x0028(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinListEntryWidgetData">();
	}
	static class UDCActionSkinListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinListEntryWidgetData>();
	}
};
static_assert(alignof(UDCActionSkinListEntryWidgetData) == 0x000008, "Wrong alignment on UDCActionSkinListEntryWidgetData");
static_assert(sizeof(UDCActionSkinListEntryWidgetData) == 0x000038, "Wrong size on UDCActionSkinListEntryWidgetData");
static_assert(offsetof(UDCActionSkinListEntryWidgetData, ActionSkinInfo) == 0x000028, "Member 'UDCActionSkinListEntryWidgetData::ActionSkinInfo' has a wrong offset!");

// Class DungeonCrawler.DCActorStatusComponent
// 0x0090 (0x0130 - 0x00A0)
class UDCActorStatusComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2533[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskEffectStackChanged*           EffectStackAsyncTask;                              // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAsyncTaskEffectInhibitionChanged*      EffectInhibitAsyncTask;                            // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FActorStatusData>               ActorStatusDatas;                                  // 0x0108(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2534[0x18];                                    // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void GameplayEffectDurationChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, float NewStartWorldTime, float NewDuration);
	void GameplayEffectInhibitChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, bool bIsInhibited);
	void GameplayEffectStackChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount);
	void OnRep_ActorStatusDatas(const TArray<struct FActorStatusData>& OldActorStatusDatas);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActorStatusComponent">();
	}
	static class UDCActorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActorStatusComponent>();
	}
};
static_assert(alignof(UDCActorStatusComponent) == 0x000008, "Wrong alignment on UDCActorStatusComponent");
static_assert(sizeof(UDCActorStatusComponent) == 0x000130, "Wrong size on UDCActorStatusComponent");
static_assert(offsetof(UDCActorStatusComponent, EffectStackAsyncTask) == 0x0000F8, "Member 'UDCActorStatusComponent::EffectStackAsyncTask' has a wrong offset!");
static_assert(offsetof(UDCActorStatusComponent, EffectInhibitAsyncTask) == 0x000100, "Member 'UDCActorStatusComponent::EffectInhibitAsyncTask' has a wrong offset!");
static_assert(offsetof(UDCActorStatusComponent, ActorStatusDatas) == 0x000108, "Member 'UDCActorStatusComponent::ActorStatusDatas' has a wrong offset!");

// Class DungeonCrawler.DCAkAcousticPortal
// 0x0000 (0x02E0 - 0x02E0)
class ADCAkAcousticPortal final : public AAkAcousticPortal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAkAcousticPortal">();
	}
	static class ADCAkAcousticPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCAkAcousticPortal>();
	}
};
static_assert(alignof(ADCAkAcousticPortal) == 0x000008, "Wrong alignment on ADCAkAcousticPortal");
static_assert(sizeof(ADCAkAcousticPortal) == 0x0002E0, "Wrong size on ADCAkAcousticPortal");

// Class DungeonCrawler.DCAkSpatialAudioVolume
// 0x00A8 (0x0390 - 0x02E8)
class ADCAkSpatialAudioVolume final : public AAkSpatialAudioVolume
{
public:
	uint8                                         Pad_2536[0x58];                                    // 0x02E8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Priority;                                          // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2537[0x4];                                     // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEventBeginOverlap;                               // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkStateValue*                          AkStateValueBeginOverlap;                          // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                RtpcBeginOverlap;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RtpcValueBeginOverlap;                             // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2538[0x4];                                     // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEventEndOverlap;                                 // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkStateValue*                          AkStateValueEndOverlap;                            // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAccountLink*                           AccountLink;                                       // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2539[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnTargetPlayerPawnEnterVolume();
	void OnTargetPlayerPawnExitVolume();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAkSpatialAudioVolume">();
	}
	static class ADCAkSpatialAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCAkSpatialAudioVolume>();
	}
};
static_assert(alignof(ADCAkSpatialAudioVolume) == 0x000008, "Wrong alignment on ADCAkSpatialAudioVolume");
static_assert(sizeof(ADCAkSpatialAudioVolume) == 0x000390, "Wrong size on ADCAkSpatialAudioVolume");
static_assert(offsetof(ADCAkSpatialAudioVolume, BaseObject) == 0x000340, "Member 'ADCAkSpatialAudioVolume::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, Priority) == 0x000348, "Member 'ADCAkSpatialAudioVolume::Priority' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, AkEventBeginOverlap) == 0x000350, "Member 'ADCAkSpatialAudioVolume::AkEventBeginOverlap' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, AkStateValueBeginOverlap) == 0x000358, "Member 'ADCAkSpatialAudioVolume::AkStateValueBeginOverlap' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, RtpcBeginOverlap) == 0x000360, "Member 'ADCAkSpatialAudioVolume::RtpcBeginOverlap' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, RtpcValueBeginOverlap) == 0x000368, "Member 'ADCAkSpatialAudioVolume::RtpcValueBeginOverlap' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, AkEventEndOverlap) == 0x000370, "Member 'ADCAkSpatialAudioVolume::AkEventEndOverlap' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, AkStateValueEndOverlap) == 0x000378, "Member 'ADCAkSpatialAudioVolume::AkStateValueEndOverlap' has a wrong offset!");
static_assert(offsetof(ADCAkSpatialAudioVolume, AccountLink) == 0x000380, "Member 'ADCAkSpatialAudioVolume::AccountLink' has a wrong offset!");

// Class DungeonCrawler.DCAnimInstanceV2
// 0x00B0 (0x0400 - 0x0350)
class UDCAnimInstanceV2 : public UAnimInstance
{
public:
	bool                                          bIsModifyBone;                                     // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_253C[0x7];                                     // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCPlayerCharacterKey, class UAnimSequence*> IdleAnims;                                         // 0x0350(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_253D[0x60];                                    // 0x03A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequence* GetIdleAnim() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimInstanceV2">();
	}
	static class UDCAnimInstanceV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimInstanceV2>();
	}
};
static_assert(alignof(UDCAnimInstanceV2) == 0x000010, "Wrong alignment on UDCAnimInstanceV2");
static_assert(sizeof(UDCAnimInstanceV2) == 0x000400, "Wrong size on UDCAnimInstanceV2");
static_assert(offsetof(UDCAnimInstanceV2, bIsModifyBone) == 0x000348, "Member 'UDCAnimInstanceV2::bIsModifyBone' has a wrong offset!");
static_assert(offsetof(UDCAnimInstanceV2, IdleAnims) == 0x000350, "Member 'UDCAnimInstanceV2::IdleAnims' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_MontageJumpToSectionOnSourceObject
// 0x0008 (0x0040 - 0x0038)
class UDCAnimNotify_MontageJumpToSectionOnSourceObject final : public UAnimNotify
{
public:
	class FName                                   SectionName;                                       // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_MontageJumpToSectionOnSourceObject">();
	}
	static class UDCAnimNotify_MontageJumpToSectionOnSourceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_MontageJumpToSectionOnSourceObject>();
	}
};
static_assert(alignof(UDCAnimNotify_MontageJumpToSectionOnSourceObject) == 0x000008, "Wrong alignment on UDCAnimNotify_MontageJumpToSectionOnSourceObject");
static_assert(sizeof(UDCAnimNotify_MontageJumpToSectionOnSourceObject) == 0x000040, "Wrong size on UDCAnimNotify_MontageJumpToSectionOnSourceObject");
static_assert(offsetof(UDCAnimNotify_MontageJumpToSectionOnSourceObject, SectionName) == 0x000038, "Member 'UDCAnimNotify_MontageJumpToSectionOnSourceObject::SectionName' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_PreReduceAmmoCountOnSourceObject
// 0x0008 (0x0040 - 0x0038)
class UDCAnimNotify_PreReduceAmmoCountOnSourceObject final : public UAnimNotify
{
public:
	int32                                         ReduceCount;                                       // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253E[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_PreReduceAmmoCountOnSourceObject">();
	}
	static class UDCAnimNotify_PreReduceAmmoCountOnSourceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_PreReduceAmmoCountOnSourceObject>();
	}
};
static_assert(alignof(UDCAnimNotify_PreReduceAmmoCountOnSourceObject) == 0x000008, "Wrong alignment on UDCAnimNotify_PreReduceAmmoCountOnSourceObject");
static_assert(sizeof(UDCAnimNotify_PreReduceAmmoCountOnSourceObject) == 0x000040, "Wrong size on UDCAnimNotify_PreReduceAmmoCountOnSourceObject");
static_assert(offsetof(UDCAnimNotify_PreReduceAmmoCountOnSourceObject, ReduceCount) == 0x000038, "Member 'UDCAnimNotify_PreReduceAmmoCountOnSourceObject::ReduceCount' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_SoundEvent
// 0x0010 (0x0048 - 0x0038)
class UDCAnimNotify_SoundEvent final : public UAnimNotify
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DefaultAkEvent;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_SoundEvent">();
	}
	static class UDCAnimNotify_SoundEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_SoundEvent>();
	}
};
static_assert(alignof(UDCAnimNotify_SoundEvent) == 0x000008, "Wrong alignment on UDCAnimNotify_SoundEvent");
static_assert(sizeof(UDCAnimNotify_SoundEvent) == 0x000048, "Wrong size on UDCAnimNotify_SoundEvent");
static_assert(offsetof(UDCAnimNotify_SoundEvent, EventTag) == 0x000038, "Member 'UDCAnimNotify_SoundEvent::EventTag' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_SoundEvent, DefaultAkEvent) == 0x000040, "Member 'UDCAnimNotify_SoundEvent::DefaultAkEvent' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_InitializeEmoteItemBoneModify
// 0x0000 (0x0038 - 0x0038)
class UDCAnimNotify_InitializeEmoteItemBoneModify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_InitializeEmoteItemBoneModify">();
	}
	static class UDCAnimNotify_InitializeEmoteItemBoneModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_InitializeEmoteItemBoneModify>();
	}
};
static_assert(alignof(UDCAnimNotify_InitializeEmoteItemBoneModify) == 0x000008, "Wrong alignment on UDCAnimNotify_InitializeEmoteItemBoneModify");
static_assert(sizeof(UDCAnimNotify_InitializeEmoteItemBoneModify) == 0x000038, "Wrong size on UDCAnimNotify_InitializeEmoteItemBoneModify");

// Class DungeonCrawler.DCAnimNotify_EndEmoteItemBoneModify
// 0x0000 (0x0038 - 0x0038)
class UDCAnimNotify_EndEmoteItemBoneModify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_EndEmoteItemBoneModify">();
	}
	static class UDCAnimNotify_EndEmoteItemBoneModify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_EndEmoteItemBoneModify>();
	}
};
static_assert(alignof(UDCAnimNotify_EndEmoteItemBoneModify) == 0x000008, "Wrong alignment on UDCAnimNotify_EndEmoteItemBoneModify");
static_assert(sizeof(UDCAnimNotify_EndEmoteItemBoneModify) == 0x000038, "Wrong size on UDCAnimNotify_EndEmoteItemBoneModify");

// Class DungeonCrawler.DCAnimNotify_TimedNiagaraEffect
// 0x0150 (0x0238 - 0x00E8)
class UDCAnimNotify_TimedNiagaraEffect final : public UAnimNotifyState_TimedNiagaraEffectAdvanced
{
public:
	TMap<class FName, float>                      ParameterFloatValues;                              // 0x00E8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      ParameterIntValues;                                // 0x0138(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ParameterColorValues;                              // 0x0188(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ParameterVectorValues;                             // 0x01D8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShouldAttached;                                   // 0x0228(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253F[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemComponent*                     SpawnedFXComponent;                                // 0x0230(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_TimedNiagaraEffect">();
	}
	static class UDCAnimNotify_TimedNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_TimedNiagaraEffect>();
	}
};
static_assert(alignof(UDCAnimNotify_TimedNiagaraEffect) == 0x000008, "Wrong alignment on UDCAnimNotify_TimedNiagaraEffect");
static_assert(sizeof(UDCAnimNotify_TimedNiagaraEffect) == 0x000238, "Wrong size on UDCAnimNotify_TimedNiagaraEffect");
static_assert(offsetof(UDCAnimNotify_TimedNiagaraEffect, ParameterFloatValues) == 0x0000E8, "Member 'UDCAnimNotify_TimedNiagaraEffect::ParameterFloatValues' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_TimedNiagaraEffect, ParameterIntValues) == 0x000138, "Member 'UDCAnimNotify_TimedNiagaraEffect::ParameterIntValues' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_TimedNiagaraEffect, ParameterColorValues) == 0x000188, "Member 'UDCAnimNotify_TimedNiagaraEffect::ParameterColorValues' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_TimedNiagaraEffect, ParameterVectorValues) == 0x0001D8, "Member 'UDCAnimNotify_TimedNiagaraEffect::ParameterVectorValues' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_TimedNiagaraEffect, bShouldAttached) == 0x000228, "Member 'UDCAnimNotify_TimedNiagaraEffect::bShouldAttached' has a wrong offset!");
static_assert(offsetof(UDCAnimNotify_TimedNiagaraEffect, SpawnedFXComponent) == 0x000230, "Member 'UDCAnimNotify_TimedNiagaraEffect::SpawnedFXComponent' has a wrong offset!");

// Class DungeonCrawler.DCAnimNotify_ForceClientVisibilityBasedAnimTickOption
// 0x0008 (0x0038 - 0x0030)
class UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption final : public UAnimNotifyState
{
public:
	EVisibilityBasedAnimTickOption                VisibilityBasedAnimTickOption;                     // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2540[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnimNotify_ForceClientVisibilityBasedAnimTickOption">();
	}
	static class UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption>();
	}
};
static_assert(alignof(UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption) == 0x000008, "Wrong alignment on UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption");
static_assert(sizeof(UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption) == 0x000038, "Wrong size on UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption");
static_assert(offsetof(UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption, VisibilityBasedAnimTickOption) == 0x000030, "Member 'UDCAnimNotify_ForceClientVisibilityBasedAnimTickOption::VisibilityBasedAnimTickOption' has a wrong offset!");

// Class DungeonCrawler.DCAnnounceDataAsset
// 0x0018 (0x0060 - 0x0048)
class UDCAnnounceDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   AnnounceText;                                      // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAnnounceDataAsset">();
	}
	static class UDCAnnounceDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAnnounceDataAsset>();
	}
};
static_assert(alignof(UDCAnnounceDataAsset) == 0x000008, "Wrong alignment on UDCAnnounceDataAsset");
static_assert(sizeof(UDCAnnounceDataAsset) == 0x000060, "Wrong size on UDCAnnounceDataAsset");
static_assert(offsetof(UDCAnnounceDataAsset, AnnounceText) == 0x000048, "Member 'UDCAnnounceDataAsset::AnnounceText' has a wrong offset!");

// Class DungeonCrawler.DCAoeAIControllerBase
// 0x0060 (0x0420 - 0x03C0)
class ADCAoeAIControllerBase : public AAIController
{
public:
	uint8                                         Pad_2541[0x58];                                    // 0x03C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAoeAIControllerBase">();
	}
	static class ADCAoeAIControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCAoeAIControllerBase>();
	}
};
static_assert(alignof(ADCAoeAIControllerBase) == 0x000008, "Wrong alignment on ADCAoeAIControllerBase");
static_assert(sizeof(ADCAoeAIControllerBase) == 0x000420, "Wrong size on ADCAoeAIControllerBase");
static_assert(offsetof(ADCAoeAIControllerBase, BaseObject) == 0x000418, "Member 'ADCAoeAIControllerBase::BaseObject' has a wrong offset!");

// Class DungeonCrawler.GA_MusicBase
// 0x0260 (0x0800 - 0x05A0)
class UGA_MusicBase : public UDCGameplayAbilityBase
{
public:
	struct FGameplayEventData                     CurrentTriggerData;                                // 0x05A0(0x00B0)(NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTagOnTarget;                            // 0x0650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0658(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueParameters                 CurrentCueParams;                                  // 0x0660(0x00D8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FDesignDataMusic                       DesignDataMusic;                                   // 0x0738(0x00C8)(Protected, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ApplyToSelf();
	void ApplyToTarget(const struct FHitResult& HitResult);
	void OnApplied(class AActor* InTarget);

	float GetRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MusicBase">();
	}
	static class UGA_MusicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MusicBase>();
	}
};
static_assert(alignof(UGA_MusicBase) == 0x000008, "Wrong alignment on UGA_MusicBase");
static_assert(sizeof(UGA_MusicBase) == 0x000800, "Wrong size on UGA_MusicBase");
static_assert(offsetof(UGA_MusicBase, CurrentTriggerData) == 0x0005A0, "Member 'UGA_MusicBase::CurrentTriggerData' has a wrong offset!");
static_assert(offsetof(UGA_MusicBase, GameplayCueTagOnTarget) == 0x000650, "Member 'UGA_MusicBase::GameplayCueTagOnTarget' has a wrong offset!");
static_assert(offsetof(UGA_MusicBase, BuffTag) == 0x000658, "Member 'UGA_MusicBase::BuffTag' has a wrong offset!");
static_assert(offsetof(UGA_MusicBase, CurrentCueParams) == 0x000660, "Member 'UGA_MusicBase::CurrentCueParams' has a wrong offset!");
static_assert(offsetof(UGA_MusicBase, DesignDataMusic) == 0x000738, "Member 'UGA_MusicBase::DesignDataMusic' has a wrong offset!");

// Class DungeonCrawler.GA_MusicChannelingBase
// 0x0050 (0x0850 - 0x0800)
class UGA_MusicChannelingBase : public UGA_MusicBase
{
public:
	TMap<TWeakObjectPtr<class AActor>, struct FMusicChannelingTargetData> MusicChannelingTargetDataMap;                      // 0x0800(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ApplyToOverlappedTargets();
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnTargetActorBeginOverlap(class AActor* Target);
	void OnTargetActorEndOverlap(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MusicChannelingBase">();
	}
	static class UGA_MusicChannelingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MusicChannelingBase>();
	}
};
static_assert(alignof(UGA_MusicChannelingBase) == 0x000008, "Wrong alignment on UGA_MusicChannelingBase");
static_assert(sizeof(UGA_MusicChannelingBase) == 0x000850, "Wrong size on UGA_MusicChannelingBase");
static_assert(offsetof(UGA_MusicChannelingBase, MusicChannelingTargetDataMap) == 0x000800, "Member 'UGA_MusicChannelingBase::MusicChannelingTargetDataMap' has a wrong offset!");

// Class DungeonCrawler.DCAoeBase
// 0x0090 (0x0710 - 0x0680)
class ADCAoeBase : public ACharacter
{
public:
	uint8                                         Pad_2542[0x68];                                    // 0x0678(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x06E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2543[0x8];                                     // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAoeDataAsset*                        AoeDataAsset;                                      // 0x06F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDestroyedWhenOwnerDie;                           // 0x06F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyContinuousDamage;                             // 0x06F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2544[0x6];                                     // 0x06FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ADCCharacterBase>> TargetArray;                                       // 0x0700(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AddBeginOverlapActor(class ADCCharacterBase* CharacterBase);
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnSetAI();
	void RemoveEndOverlapActor(class ADCCharacterBase* CharacterBase);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAoeBase">();
	}
	static class ADCAoeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCAoeBase>();
	}
};
static_assert(alignof(ADCAoeBase) == 0x000010, "Wrong alignment on ADCAoeBase");
static_assert(sizeof(ADCAoeBase) == 0x000710, "Wrong size on ADCAoeBase");
static_assert(offsetof(ADCAoeBase, BaseObject) == 0x0006E0, "Member 'ADCAoeBase::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCAoeBase, AoeDataAsset) == 0x0006F0, "Member 'ADCAoeBase::AoeDataAsset' has a wrong offset!");
static_assert(offsetof(ADCAoeBase, IsDestroyedWhenOwnerDie) == 0x0006F8, "Member 'ADCAoeBase::IsDestroyedWhenOwnerDie' has a wrong offset!");
static_assert(offsetof(ADCAoeBase, ApplyContinuousDamage) == 0x0006F9, "Member 'ADCAoeBase::ApplyContinuousDamage' has a wrong offset!");
static_assert(offsetof(ADCAoeBase, TargetArray) == 0x000700, "Member 'ADCAoeBase::TargetArray' has a wrong offset!");

// Class DungeonCrawler.DCAoeSystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCAoeSystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DeferredAoeFinish(class ADCCharacterBase*& DCCharacterBase, class ADCAoeBase* Aoe, const struct FTransform& Transform, const struct FGameplayEventData& EventData, bool* bSuccessfully);
	static void DespawnAoeAll(class ADCCharacterBase* DCCharacterBase);
	static void DespawnAoeByPrimaryAssetId(class ADCCharacterBase*& DCCharacterBase, const struct FPrimaryAssetId& PrimaryAssetId);
	static void DespawnAoeByPrimaryAssetIdWithinDistance(class ADCCharacterBase*& DCCharacterBase, const struct FPrimaryAssetId& PrimaryAssetId, const struct FVector& Location, float Distance);
	static void DespawnAoeWithinDistance(class ADCCharacterBase*& DCCharacterBase, const struct FVector& Location, float Distance);
	static void FilterMonsterTargets(TArray<class ADCCharacterBase*>& TargetArray);
	static void FilterPlayerCharacterTargets(TArray<class ADCCharacterBase*>& TargetArray);
	static bool FilterTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag);
	static bool FilterTargetsOverDistance(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance);
	static bool FilterTargetsWithinDirectionAngleAndAllowedAngle(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, float DirectionalAngle, float AllowedAngle);
	static bool FilterTargetsWithinDistance(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance);
	static bool FilterUnTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag);
	static TArray<class ADCAoeBase*> GetAoeArrayByClass(const class AActor* InActor, TSubclassOf<class ADCAoeBase> InAoeClass);
	static int32 GetAoeCountByClass(const class AActor* InActor, TSubclassOf<class ADCAoeBase> InAoeClass);
	static TArray<struct FVector> GetCircularLocations(const struct FVector& InPivotLocation, const struct FVector& InOffsetLocation, const int32 InCount, const float InDistance);
	static bool GetTargetArray(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray);
	static class ADCCharacterBase* PickRandomTarget(TArray<class ADCCharacterBase*>& TargetArray);
	static class ADCCharacterBase* PickTarget(TArray<class ADCCharacterBase*>& TargetArray, int32 Param_Index);
	static bool SortTargetsByDistance(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, EAoeFilterSortingType AoeFilterSortingType);
	static class ADCCharacterBase* SortTargetsByDistanceAndPickTarget(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, EAoeFilterSortingType AoeFilterSortingType, int32 Param_Index);
	static class ADCAoeBase* SpawnAoe(class ADCCharacterBase*& DCCharacterBase, TSubclassOf<class ADCAoeBase> AoeClass, const struct FVector& Location, class UDCGameplayAbilityBase* DCGameplayAbilityBase, const struct FGameplayEventData& EventData, bool* bSuccessfully);
	static class ADCAoeBase* SpawnAoeDeferred(class ADCCharacterBase*& DCCharacterBase, TSubclassOf<class ADCAoeBase> AoeClass, class UDCGameplayAbilityBase* DCGameplayAbilityBase, const struct FGameplayEventData& EventData, bool* bSuccessfully);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAoeSystemBlueprintLibrary">();
	}
	static class UDCAoeSystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAoeSystemBlueprintLibrary>();
	}
};
static_assert(alignof(UDCAoeSystemBlueprintLibrary) == 0x000008, "Wrong alignment on UDCAoeSystemBlueprintLibrary");
static_assert(sizeof(UDCAoeSystemBlueprintLibrary) == 0x000028, "Wrong size on UDCAoeSystemBlueprintLibrary");

// Class DungeonCrawler.DCGameStateBase
// 0x04C0 (0x07B0 - 0x02F0)
class ADCGameStateBase : public AGameStateBase
{
public:
	uint8                                         Pad_2554[0x58];                                    // 0x02F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             FloorRuleActorRegisteredDelegate;                  // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 FloorRuleActor;                                    // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameStateType                                State;                                             // 0x0368(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2555[0x87];                                    // 0x0369(0x0087)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameStateData>                 GameStateDataArray;                                // 0x03F0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataReplication>        AccountDataReplicationArray;                       // 0x0400(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TMap<class FString, class UAccountSession*>   AccountSessionMap;                                 // 0x0410(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCAccountId, TWeakObjectPtr<class ADCCharacterBase>> RegisteredPlayerCharacters;                        // 0x0460(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2556[0x138];                                   // 0x04B0(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPartyData>                     PartyDataArray;                                    // 0x05E8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TMap<class FString, class UPartySession*>     PartySessionMap;                                   // 0x05F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FDCGameInfo                            GameInfo;                                          // 0x0648(0x0040)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2557[0x18];                                    // 0x0688(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           MonsterSet;                                        // 0x06A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           PropsSet;                                          // 0x06F0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, EDCActorOptimizeState>    AnimationOptimizeMap;                              // 0x0740(0x0050)(Protected, NativeAccessSpecifierProtected)
	float                                         ServerAverageFps;                                  // 0x0790(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ServerAverageMs;                                   // 0x0794(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalActor;                                        // 0x0798(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MonsterActive;                                     // 0x079C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PropsActive;                                       // 0x07A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActorOptimizeNone;                                 // 0x07A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActorOptimizeOptimize;                             // 0x07A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActorOptimizeFreeze;                               // 0x07AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnGameInfoSet(const struct FDCGameInfo& OldGameInfo);
	void OnRep_AccountDataReplicationArray(const TArray<struct FAccountDataReplication>& OldAccountDataReplicationArray);
	void OnRep_GameInfo(const struct FDCGameInfo& OldGameInfo);
	void OnRep_GameStateDataArray(const TArray<struct FGameStateData>& OldGameStateDataArray);
	void OnRep_PartyDataArray(const TArray<struct FPartyData>& OldPartyDataArray);
	void OnRep_State(const EGameStateType OldState);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	class AActor* GetFloorRuleActor() const;
	const struct FDCGameInfo GetGameInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameStateBase">();
	}
	static class ADCGameStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameStateBase>();
	}
};
static_assert(alignof(ADCGameStateBase) == 0x000008, "Wrong alignment on ADCGameStateBase");
static_assert(sizeof(ADCGameStateBase) == 0x0007B0, "Wrong size on ADCGameStateBase");
static_assert(offsetof(ADCGameStateBase, BaseObject) == 0x000348, "Member 'ADCGameStateBase::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, FloorRuleActorRegisteredDelegate) == 0x000350, "Member 'ADCGameStateBase::FloorRuleActorRegisteredDelegate' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, FloorRuleActor) == 0x000360, "Member 'ADCGameStateBase::FloorRuleActor' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, State) == 0x000368, "Member 'ADCGameStateBase::State' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, GameStateDataArray) == 0x0003F0, "Member 'ADCGameStateBase::GameStateDataArray' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, AccountDataReplicationArray) == 0x000400, "Member 'ADCGameStateBase::AccountDataReplicationArray' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, AccountSessionMap) == 0x000410, "Member 'ADCGameStateBase::AccountSessionMap' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, RegisteredPlayerCharacters) == 0x000460, "Member 'ADCGameStateBase::RegisteredPlayerCharacters' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, PartyDataArray) == 0x0005E8, "Member 'ADCGameStateBase::PartyDataArray' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, PartySessionMap) == 0x0005F8, "Member 'ADCGameStateBase::PartySessionMap' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, GameInfo) == 0x000648, "Member 'ADCGameStateBase::GameInfo' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, MonsterSet) == 0x0006A0, "Member 'ADCGameStateBase::MonsterSet' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, PropsSet) == 0x0006F0, "Member 'ADCGameStateBase::PropsSet' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, AnimationOptimizeMap) == 0x000740, "Member 'ADCGameStateBase::AnimationOptimizeMap' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, ServerAverageFps) == 0x000790, "Member 'ADCGameStateBase::ServerAverageFps' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, ServerAverageMs) == 0x000794, "Member 'ADCGameStateBase::ServerAverageMs' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, TotalActor) == 0x000798, "Member 'ADCGameStateBase::TotalActor' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, MonsterActive) == 0x00079C, "Member 'ADCGameStateBase::MonsterActive' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, PropsActive) == 0x0007A0, "Member 'ADCGameStateBase::PropsActive' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, ActorOptimizeNone) == 0x0007A4, "Member 'ADCGameStateBase::ActorOptimizeNone' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, ActorOptimizeOptimize) == 0x0007A8, "Member 'ADCGameStateBase::ActorOptimizeOptimize' has a wrong offset!");
static_assert(offsetof(ADCGameStateBase, ActorOptimizeFreeze) == 0x0007AC, "Member 'ADCGameStateBase::ActorOptimizeFreeze' has a wrong offset!");

// Class DungeonCrawler.ItemTooltipStatWidget
// 0x0008 (0x0360 - 0x0358)
class UItemTooltipStatWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2558[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipStatWidget">();
	}
	static class UItemTooltipStatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipStatWidget>();
	}
};
static_assert(alignof(UItemTooltipStatWidget) == 0x000008, "Wrong alignment on UItemTooltipStatWidget");
static_assert(sizeof(UItemTooltipStatWidget) == 0x000360, "Wrong size on UItemTooltipStatWidget");

// Class DungeonCrawler.DCArenaGameState
// 0x00B8 (0x0868 - 0x07B0)
class ADCArenaGameState final : public ADCGameStateBase
{
public:
	struct FTimespan                              RoundDuration;                                     // 0x07B0(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2559[0x18];                                    // 0x07B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoundEndWorldTime;                                 // 0x07D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WelcomeEndWorldTime;                               // 0x07D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IntermissionEndWorldTime;                          // 0x07D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255A[0x4];                                     // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDCArenaTeam>                          WinRecords;                                        // 0x07E0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EDCArenaTeam, struct FDCPartyId>         TeamParties;                                       // 0x07F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FDCPartyId                             RedTeamParty;                                      // 0x0840(0x0010)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCPartyId                             BlueTeamParty;                                     // 0x0850(0x0010)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCArenaForceResult                    ForceResult;                                       // 0x0860(0x0003)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255B[0x5];                                     // 0x0863(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCArenaGameState">();
	}
	static class ADCArenaGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCArenaGameState>();
	}
};
static_assert(alignof(ADCArenaGameState) == 0x000008, "Wrong alignment on ADCArenaGameState");
static_assert(sizeof(ADCArenaGameState) == 0x000868, "Wrong size on ADCArenaGameState");
static_assert(offsetof(ADCArenaGameState, RoundDuration) == 0x0007B0, "Member 'ADCArenaGameState::RoundDuration' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, RoundEndWorldTime) == 0x0007D0, "Member 'ADCArenaGameState::RoundEndWorldTime' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, WelcomeEndWorldTime) == 0x0007D4, "Member 'ADCArenaGameState::WelcomeEndWorldTime' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, IntermissionEndWorldTime) == 0x0007D8, "Member 'ADCArenaGameState::IntermissionEndWorldTime' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, WinRecords) == 0x0007E0, "Member 'ADCArenaGameState::WinRecords' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, TeamParties) == 0x0007F0, "Member 'ADCArenaGameState::TeamParties' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, RedTeamParty) == 0x000840, "Member 'ADCArenaGameState::RedTeamParty' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, BlueTeamParty) == 0x000850, "Member 'ADCArenaGameState::BlueTeamParty' has a wrong offset!");
static_assert(offsetof(ADCArenaGameState, ForceResult) == 0x000860, "Member 'ADCArenaGameState::ForceResult' has a wrong offset!");

// Class DungeonCrawler.DCArenaSubsystem
// 0x00F0 (0x0120 - 0x0030)
class UDCArenaSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_255C[0xF0];                                    // 0x0030(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCArenaSubsystem">();
	}
	static class UDCArenaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCArenaSubsystem>();
	}
};
static_assert(alignof(UDCArenaSubsystem) == 0x000008, "Wrong alignment on UDCArenaSubsystem");
static_assert(sizeof(UDCArenaSubsystem) == 0x000120, "Wrong size on UDCArenaSubsystem");

// Class DungeonCrawler.DCArmorSkinComponent
// 0x0028 (0x00C8 - 0x00A0)
class UDCArmorSkinComponent final : public UDCActorComponent
{
public:
	TArray<class UDCArmorSkinDataAsset*>          ArmorSkins;                                        // 0x00A0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255D[0x18];                                    // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddArmorSkinForDebug_Server(const class UDCArmorSkinDataAsset* ArmorSkin);
	void OnRep_ArmorSkins();
	void RemoveArmorSkinForDebug_Server(const class UDCArmorSkinDataAsset* ArmorSkin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCArmorSkinComponent">();
	}
	static class UDCArmorSkinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCArmorSkinComponent>();
	}
};
static_assert(alignof(UDCArmorSkinComponent) == 0x000008, "Wrong alignment on UDCArmorSkinComponent");
static_assert(sizeof(UDCArmorSkinComponent) == 0x0000C8, "Wrong size on UDCArmorSkinComponent");
static_assert(offsetof(UDCArmorSkinComponent, ArmorSkins) == 0x0000A0, "Member 'UDCArmorSkinComponent::ArmorSkins' has a wrong offset!");

// Class DungeonCrawler.DCAssetManager
// 0x0128 (0x05F8 - 0x04D0)
class UDCAssetManager final : public UAssetManager
{
public:
	TMap<struct FPrimaryAssetId, struct FLoadPrimaryAssetData> LoadPrimaryAssetDataMap;                           // 0x04D0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetType, struct FLoadPrimaryAssetType> LoadPrimaryAssetTypeMap;                           // 0x0520(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255E[0x38];                                    // 0x0570(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPrimaryAssetId, class UObject*>  PreloadDataAssetMap;                               // 0x05A8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAssetManager">();
	}
	static class UDCAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAssetManager>();
	}
};
static_assert(alignof(UDCAssetManager) == 0x000008, "Wrong alignment on UDCAssetManager");
static_assert(sizeof(UDCAssetManager) == 0x0005F8, "Wrong size on UDCAssetManager");
static_assert(offsetof(UDCAssetManager, LoadPrimaryAssetDataMap) == 0x0004D0, "Member 'UDCAssetManager::LoadPrimaryAssetDataMap' has a wrong offset!");
static_assert(offsetof(UDCAssetManager, LoadPrimaryAssetTypeMap) == 0x000520, "Member 'UDCAssetManager::LoadPrimaryAssetTypeMap' has a wrong offset!");
static_assert(offsetof(UDCAssetManager, PreloadDataAssetMap) == 0x0005A8, "Member 'UDCAssetManager::PreloadDataAssetMap' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationStrength
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationStrength final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_255F[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationStrength">();
	}
	static class UDCAttributeModMagnitudeCalculationStrength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationStrength>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationStrength) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationStrength");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationStrength) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationStrength");

// Class DungeonCrawler.LeaderboardContentWidget
// 0x0058 (0x03B0 - 0x0358)
class ULeaderboardContentWidget final : public UDCWidgetBase
{
public:
	class UListView*                              RankRecordListView;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULeaderboardRankRecordMineWidget*       LeaderboardRankRecordMineWidget;                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2560[0x48];                                    // 0x0368(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnContentDesc(const class FText& NewValue, const class FText& OldValue);
	void OnContentName(const class FText& NewValue, const class FText& OldValue);
	void OnContentScoreName(const class FText& NewValue, const class FText& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardContentWidget">();
	}
	static class ULeaderboardContentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardContentWidget>();
	}
};
static_assert(alignof(ULeaderboardContentWidget) == 0x000008, "Wrong alignment on ULeaderboardContentWidget");
static_assert(sizeof(ULeaderboardContentWidget) == 0x0003B0, "Wrong size on ULeaderboardContentWidget");
static_assert(offsetof(ULeaderboardContentWidget, RankRecordListView) == 0x000358, "Member 'ULeaderboardContentWidget::RankRecordListView' has a wrong offset!");
static_assert(offsetof(ULeaderboardContentWidget, LeaderboardRankRecordMineWidget) == 0x000360, "Member 'ULeaderboardContentWidget::LeaderboardRankRecordMineWidget' has a wrong offset!");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationVigor
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationVigor final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2561[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationVigor">();
	}
	static class UDCAttributeModMagnitudeCalculationVigor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationVigor>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationVigor) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationVigor");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationVigor) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationVigor");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationAgility
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationAgility final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2562[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationAgility">();
	}
	static class UDCAttributeModMagnitudeCalculationAgility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationAgility>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationAgility) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationAgility");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationAgility) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationAgility");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationWill
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationWill final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2563[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationWill">();
	}
	static class UDCAttributeModMagnitudeCalculationWill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationWill>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationWill) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationWill");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationWill) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationWill");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationResourcefulness
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationResourcefulness final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2564[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationResourcefulness">();
	}
	static class UDCAttributeModMagnitudeCalculationResourcefulness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationResourcefulness>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationResourcefulness) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationResourcefulness");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationResourcefulness) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationResourcefulness");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationMaxHealth
// 0x00C0 (0x0100 - 0x0040)
class UDCAttributeModMagnitudeCalculationMaxHealth final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2565[0xC0];                                    // 0x0040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationMaxHealth">();
	}
	static class UDCAttributeModMagnitudeCalculationMaxHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationMaxHealth>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationMaxHealth) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationMaxHealth");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationMaxHealth) == 0x000100, "Wrong size on UDCAttributeModMagnitudeCalculationMaxHealth");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationMemoryCapacity
// 0x00C0 (0x0100 - 0x0040)
class UDCAttributeModMagnitudeCalculationMemoryCapacity final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2566[0xC0];                                    // 0x0040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationMemoryCapacity">();
	}
	static class UDCAttributeModMagnitudeCalculationMemoryCapacity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationMemoryCapacity>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationMemoryCapacity) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationMemoryCapacity");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationMemoryCapacity) == 0x000100, "Wrong size on UDCAttributeModMagnitudeCalculationMemoryCapacity");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationRegularInteractionSpeedBase
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2567[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationRegularInteractionSpeedBase">();
	}
	static class UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationUtilityEffectiveness
// 0x00C0 (0x0100 - 0x0040)
class UDCAttributeModMagnitudeCalculationUtilityEffectiveness final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2568[0xC0];                                    // 0x0040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationUtilityEffectiveness">();
	}
	static class UDCAttributeModMagnitudeCalculationUtilityEffectiveness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationUtilityEffectiveness>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationUtilityEffectiveness) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationUtilityEffectiveness");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationUtilityEffectiveness) == 0x000100, "Wrong size on UDCAttributeModMagnitudeCalculationUtilityEffectiveness");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationPerkBerSerker
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationPerkBerSerker final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_2569[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationPerkBerSerker">();
	}
	static class UDCAttributeModMagnitudeCalculationPerkBerSerker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationPerkBerSerker>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationPerkBerSerker) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationPerkBerSerker");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationPerkBerSerker) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationPerkBerSerker");

// Class DungeonCrawler.DCAttributeModMagnitudeCalculationRigidity
// 0x0080 (0x00C0 - 0x0040)
class UDCAttributeModMagnitudeCalculationRigidity final : public UGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_256A[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAttributeModMagnitudeCalculationRigidity">();
	}
	static class UDCAttributeModMagnitudeCalculationRigidity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAttributeModMagnitudeCalculationRigidity>();
	}
};
static_assert(alignof(UDCAttributeModMagnitudeCalculationRigidity) == 0x000008, "Wrong alignment on UDCAttributeModMagnitudeCalculationRigidity");
static_assert(sizeof(UDCAttributeModMagnitudeCalculationRigidity) == 0x0000C0, "Wrong size on UDCAttributeModMagnitudeCalculationRigidity");

// Class DungeonCrawler.DCAT_DashToLocation
// 0x0038 (0x00B8 - 0x0080)
class UDCAT_DashToLocation final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_256B[0x28];                                    // 0x0090(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_DashToLocation* DashToLocation(class UGameplayAbility* OwningAbility, const struct FVector& DestLocation, float AllowedDistance, float Speed, bool Teleport);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_DashToLocation">();
	}
	static class UDCAT_DashToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_DashToLocation>();
	}
};
static_assert(alignof(UDCAT_DashToLocation) == 0x000008, "Wrong alignment on UDCAT_DashToLocation");
static_assert(sizeof(UDCAT_DashToLocation) == 0x0000B8, "Wrong size on UDCAT_DashToLocation");
static_assert(offsetof(UDCAT_DashToLocation, OnFinish) == 0x000080, "Member 'UDCAT_DashToLocation::OnFinish' has a wrong offset!");

// Class DungeonCrawler.GamePartyWidget
// 0x0040 (0x0398 - 0x0358)
class UGamePartyWidget final : public UDCWidgetBase
{
public:
	class UHorizontalBox*                         PartyMemberWidgetRow;                              // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGamePartyMemberWidget>     PartyMemberWidgetClass;                            // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGamePartyMemberWidget*>         PartyMemberWidgets;                                // 0x0368(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FDCAccountId                           TargetAccountId;                                   // 0x0378(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCPartyId                             TargetPartyId;                                     // 0x0388(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyWidget">();
	}
	static class UGamePartyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyWidget>();
	}
};
static_assert(alignof(UGamePartyWidget) == 0x000008, "Wrong alignment on UGamePartyWidget");
static_assert(sizeof(UGamePartyWidget) == 0x000398, "Wrong size on UGamePartyWidget");
static_assert(offsetof(UGamePartyWidget, PartyMemberWidgetRow) == 0x000358, "Member 'UGamePartyWidget::PartyMemberWidgetRow' has a wrong offset!");
static_assert(offsetof(UGamePartyWidget, PartyMemberWidgetClass) == 0x000360, "Member 'UGamePartyWidget::PartyMemberWidgetClass' has a wrong offset!");
static_assert(offsetof(UGamePartyWidget, PartyMemberWidgets) == 0x000368, "Member 'UGamePartyWidget::PartyMemberWidgets' has a wrong offset!");
static_assert(offsetof(UGamePartyWidget, TargetAccountId) == 0x000378, "Member 'UGamePartyWidget::TargetAccountId' has a wrong offset!");
static_assert(offsetof(UGamePartyWidget, TargetPartyId) == 0x000388, "Member 'UGamePartyWidget::TargetPartyId' has a wrong offset!");

// Class DungeonCrawler.DCAT_JudgeMusicPlay
// 0x0070 (0x00F0 - 0x0080)
class UDCAT_JudgeMusicPlay final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnPerfect;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGood;                                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBad;                                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMiss;                                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_256D[0x28];                                    // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_JudgeMusicPlay* JudgeMusicPlay(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const class UInputAction* InInputAction, float Duration, float GoodSectionStartTime, float GoodSectionEndTime, float PerfectSectionStartTime, float PerfectSectionEndTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_JudgeMusicPlay">();
	}
	static class UDCAT_JudgeMusicPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_JudgeMusicPlay>();
	}
};
static_assert(alignof(UDCAT_JudgeMusicPlay) == 0x000008, "Wrong alignment on UDCAT_JudgeMusicPlay");
static_assert(sizeof(UDCAT_JudgeMusicPlay) == 0x0000F0, "Wrong size on UDCAT_JudgeMusicPlay");
static_assert(offsetof(UDCAT_JudgeMusicPlay, OnPerfect) == 0x000080, "Member 'UDCAT_JudgeMusicPlay::OnPerfect' has a wrong offset!");
static_assert(offsetof(UDCAT_JudgeMusicPlay, OnGood) == 0x000090, "Member 'UDCAT_JudgeMusicPlay::OnGood' has a wrong offset!");
static_assert(offsetof(UDCAT_JudgeMusicPlay, OnBad) == 0x0000A0, "Member 'UDCAT_JudgeMusicPlay::OnBad' has a wrong offset!");
static_assert(offsetof(UDCAT_JudgeMusicPlay, OnMiss) == 0x0000B0, "Member 'UDCAT_JudgeMusicPlay::OnMiss' has a wrong offset!");
static_assert(offsetof(UDCAT_JudgeMusicPlay, InputAction) == 0x0000C0, "Member 'UDCAT_JudgeMusicPlay::InputAction' has a wrong offset!");

// Class DungeonCrawler.DCAT_OverlapActorsInComponent
// 0x0050 (0x00D0 - 0x0080)
class UDCAT_OverlapActorsInComponent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTargetActorOverlapBegin;                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTargetActorOverlapEnd;                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_256F[0x30];                                    // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_OverlapActorsInComponent* OverlapActorsInComponent(class UGameplayAbility* OwningAbility, class UPrimitiveComponent* OverlapPrimitiveComponent, class UClass* OverlapTargetClass, class AActor* InIgnoreActor);

	void AddIgnoreActors(const TArray<class AActor*>& InAddIgnoreActors);
	void ClearIgnoreActors();
	TArray<class AActor*> GetTargetList();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_OverlapActorsInComponent">();
	}
	static class UDCAT_OverlapActorsInComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_OverlapActorsInComponent>();
	}
};
static_assert(alignof(UDCAT_OverlapActorsInComponent) == 0x000008, "Wrong alignment on UDCAT_OverlapActorsInComponent");
static_assert(sizeof(UDCAT_OverlapActorsInComponent) == 0x0000D0, "Wrong size on UDCAT_OverlapActorsInComponent");
static_assert(offsetof(UDCAT_OverlapActorsInComponent, OnTargetActorOverlapBegin) == 0x000080, "Member 'UDCAT_OverlapActorsInComponent::OnTargetActorOverlapBegin' has a wrong offset!");
static_assert(offsetof(UDCAT_OverlapActorsInComponent, OnTargetActorOverlapEnd) == 0x000090, "Member 'UDCAT_OverlapActorsInComponent::OnTargetActorOverlapEnd' has a wrong offset!");

// Class DungeonCrawler.CannotMoveGameplayTagData
// 0x0020 (0x0050 - 0x0030)
class UCannotMoveGameplayTagData final : public UDataAsset
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CannotMoveGameplayTagData">();
	}
	static class UCannotMoveGameplayTagData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCannotMoveGameplayTagData>();
	}
};
static_assert(alignof(UCannotMoveGameplayTagData) == 0x000008, "Wrong alignment on UCannotMoveGameplayTagData");
static_assert(sizeof(UCannotMoveGameplayTagData) == 0x000050, "Wrong size on UCannotMoveGameplayTagData");
static_assert(offsetof(UCannotMoveGameplayTagData, TagContainer) == 0x000030, "Member 'UCannotMoveGameplayTagData::TagContainer' has a wrong offset!");

// Class DungeonCrawler.DCAT_PlayMontageAndWaitForEvent
// 0x00C0 (0x0140 - 0x0080)
class UDCAT_PlayMontageAndWaitForEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00D8(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x00FC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTimeSeconds;                                  // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x010C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2572[0x33];                                    // 0x010D(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_PlayMontageAndWaitForEvent* PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* Param_MontageToPlay, const struct FGameplayTagContainer& Param_EventTags, float Param_Rate, class FName Param_StartSection, bool Param_bStopWhenAbilityEnds, float Param_AnimRootMotionTranslationScale, float Param_StartTimeSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_PlayMontageAndWaitForEvent">();
	}
	static class UDCAT_PlayMontageAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_PlayMontageAndWaitForEvent>();
	}
};
static_assert(alignof(UDCAT_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on UDCAT_PlayMontageAndWaitForEvent");
static_assert(sizeof(UDCAT_PlayMontageAndWaitForEvent) == 0x000140, "Wrong size on UDCAT_PlayMontageAndWaitForEvent");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, OnCompleted) == 0x000080, "Member 'UDCAT_PlayMontageAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, OnBlendOut) == 0x000090, "Member 'UDCAT_PlayMontageAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, OnInterrupted) == 0x0000A0, "Member 'UDCAT_PlayMontageAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, OnCancelled) == 0x0000B0, "Member 'UDCAT_PlayMontageAndWaitForEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, EventReceived) == 0x0000C0, "Member 'UDCAT_PlayMontageAndWaitForEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, MontageToPlay) == 0x0000D0, "Member 'UDCAT_PlayMontageAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, EventTags) == 0x0000D8, "Member 'UDCAT_PlayMontageAndWaitForEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, Rate) == 0x0000F8, "Member 'UDCAT_PlayMontageAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, StartSection) == 0x0000FC, "Member 'UDCAT_PlayMontageAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, StartTimeSeconds) == 0x000104, "Member 'UDCAT_PlayMontageAndWaitForEvent::StartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, AnimRootMotionTranslationScale) == 0x000108, "Member 'UDCAT_PlayMontageAndWaitForEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UDCAT_PlayMontageAndWaitForEvent, bStopWhenAbilityEnds) == 0x00010C, "Member 'UDCAT_PlayMontageAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");

// Class DungeonCrawler.DCAT_RotateToActor
// 0x0018 (0x0098 - 0x0080)
class UDCAT_RotateToActor final : public UAbilityTask
{
public:
	uint8                                         Pad_2574[0x18];                                    // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_RotateToActor* RotateToActor(class UGameplayAbility* OwningAbility, class AActor* Actor, EHitBoxType HitBox, float Speed, bool WithoutPitch, bool WithoutRoll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_RotateToActor">();
	}
	static class UDCAT_RotateToActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_RotateToActor>();
	}
};
static_assert(alignof(UDCAT_RotateToActor) == 0x000008, "Wrong alignment on UDCAT_RotateToActor");
static_assert(sizeof(UDCAT_RotateToActor) == 0x000098, "Wrong size on UDCAT_RotateToActor");

// Class DungeonCrawler.DCAT_ServerWaitClientTargetData
// 0x0018 (0x0098 - 0x0080)
class UDCAT_ServerWaitClientTargetData final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             ValidData;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2577[0x8];                                     // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_ServerWaitClientTargetData* ServerWaitForClientTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, bool TriggerOnce);

	void OnTargetDataReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data, const struct FGameplayTag& ActivationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_ServerWaitClientTargetData">();
	}
	static class UDCAT_ServerWaitClientTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_ServerWaitClientTargetData>();
	}
};
static_assert(alignof(UDCAT_ServerWaitClientTargetData) == 0x000008, "Wrong alignment on UDCAT_ServerWaitClientTargetData");
static_assert(sizeof(UDCAT_ServerWaitClientTargetData) == 0x000098, "Wrong size on UDCAT_ServerWaitClientTargetData");
static_assert(offsetof(UDCAT_ServerWaitClientTargetData, ValidData) == 0x000080, "Member 'UDCAT_ServerWaitClientTargetData::ValidData' has a wrong offset!");

// Class DungeonCrawler.GameQuestComponent
// 0x0058 (0x00F8 - 0x00A0)
class UGameQuestComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2579[0x58];                                    // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameQuestComponent">();
	}
	static class UGameQuestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameQuestComponent>();
	}
};
static_assert(alignof(UGameQuestComponent) == 0x000008, "Wrong alignment on UGameQuestComponent");
static_assert(sizeof(UGameQuestComponent) == 0x0000F8, "Wrong size on UGameQuestComponent");

// Class DungeonCrawler.MailBoxWidgetBase
// 0x0008 (0x0360 - 0x0358)
class UMailBoxWidgetBase final : public UDCWidgetBase
{
public:
	class UListView*                              ListView;                                          // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FriendPrivacyOffBlueprint();
	void FriendPrivacyOnBlueprint();
	bool IsFriendPrivacyOn();
	bool IsPartyPrivacyOn();
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);
	void OnSetFriendPrivacy(bool bOn);
	void OnSetPartyPrivacy(bool bOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailBoxWidgetBase">();
	}
	static class UMailBoxWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailBoxWidgetBase>();
	}
};
static_assert(alignof(UMailBoxWidgetBase) == 0x000008, "Wrong alignment on UMailBoxWidgetBase");
static_assert(sizeof(UMailBoxWidgetBase) == 0x000360, "Wrong size on UMailBoxWidgetBase");
static_assert(offsetof(UMailBoxWidgetBase, ListView) == 0x000358, "Member 'UMailBoxWidgetBase::ListView' has a wrong offset!");

// Class DungeonCrawler.DCAT_SpawnProjectile
// 0x0090 (0x0110 - 0x0080)
class alignas(0x10) UDCAT_SpawnProjectile final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_257A[0x80];                                    // 0x0090(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_SpawnProjectile* SpawnProjectile(class UGameplayAbility* OwningAbility, class UClass* SpawnClass, const struct FTransform& SpawnTransform, float FirePower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_SpawnProjectile">();
	}
	static class UDCAT_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_SpawnProjectile>();
	}
};
static_assert(alignof(UDCAT_SpawnProjectile) == 0x000010, "Wrong alignment on UDCAT_SpawnProjectile");
static_assert(sizeof(UDCAT_SpawnProjectile) == 0x000110, "Wrong size on UDCAT_SpawnProjectile");
static_assert(offsetof(UDCAT_SpawnProjectile, OnSuccess) == 0x000080, "Member 'UDCAT_SpawnProjectile::OnSuccess' has a wrong offset!");

// Class DungeonCrawler.DCAT_TargetActorRadius
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_TargetActorRadius final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTargetActorOverlap;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_257C[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_TargetActorRadius* TargetActorRadius(class UGameplayAbility* OwningAbility, float Radius, ECollisionChannel CollisionChannel, class UClass* TargetingClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_TargetActorRadius">();
	}
	static class UDCAT_TargetActorRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_TargetActorRadius>();
	}
};
static_assert(alignof(UDCAT_TargetActorRadius) == 0x000008, "Wrong alignment on UDCAT_TargetActorRadius");
static_assert(sizeof(UDCAT_TargetActorRadius) == 0x0000A0, "Wrong size on UDCAT_TargetActorRadius");
static_assert(offsetof(UDCAT_TargetActorRadius, OnTargetActorOverlap) == 0x000080, "Member 'UDCAT_TargetActorRadius::OnTargetActorOverlap' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitAimDirChangedFromActor
// 0x0018 (0x0098 - 0x0080)
class UDCAT_WaitAimDirChangedFromActor final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnDirectionChanged;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_257E[0x8];                                     // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitAimDirChangedFromActor* WaitAimDirectionChangedFromActor(class UGameplayAbility* OwningAbility, class AActor* InTargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitAimDirChangedFromActor">();
	}
	static class UDCAT_WaitAimDirChangedFromActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitAimDirChangedFromActor>();
	}
};
static_assert(alignof(UDCAT_WaitAimDirChangedFromActor) == 0x000008, "Wrong alignment on UDCAT_WaitAimDirChangedFromActor");
static_assert(sizeof(UDCAT_WaitAimDirChangedFromActor) == 0x000098, "Wrong size on UDCAT_WaitAimDirChangedFromActor");
static_assert(offsetof(UDCAT_WaitAimDirChangedFromActor, OnDirectionChanged) == 0x000080, "Member 'UDCAT_WaitAimDirChangedFromActor::OnDirectionChanged' has a wrong offset!");

// Class DungeonCrawler.ShapeShiftSlotWidgetBase
// 0x0060 (0x03B8 - 0x0358)
class UShapeShiftSlotWidgetBase : public UDCWidgetBase
{
public:
	struct FShapeShiftData                        ShapeShiftData;                                    // 0x0358(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UDCShapeShiftDataAsset*                 ShapeShiftDataAsset;                               // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           DescTextArray;                                     // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   ShapeShiftName;                                    // 0x0390(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UDCCharacterShapeShiftArtData*          ArtData;                                           // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257F[0x4];                                     // 0x03B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReset();
	void OnSetShapeShiftArtData(const class UDCCharacterShapeShiftArtData* InShapeShiftArtData);
	void OnShapeShiftDataChanged(const struct FShapeShiftData& InShapeShiftData);
	void Reset();
	void SetShapeShiftData(const struct FShapeShiftData& InShapeShiftData, const class UDCShapeShiftDataAsset* InShapeShiftDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShapeShiftSlotWidgetBase">();
	}
	static class UShapeShiftSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShapeShiftSlotWidgetBase>();
	}
};
static_assert(alignof(UShapeShiftSlotWidgetBase) == 0x000008, "Wrong alignment on UShapeShiftSlotWidgetBase");
static_assert(sizeof(UShapeShiftSlotWidgetBase) == 0x0003B8, "Wrong size on UShapeShiftSlotWidgetBase");
static_assert(offsetof(UShapeShiftSlotWidgetBase, ShapeShiftData) == 0x000358, "Member 'UShapeShiftSlotWidgetBase::ShapeShiftData' has a wrong offset!");
static_assert(offsetof(UShapeShiftSlotWidgetBase, ShapeShiftDataAsset) == 0x000378, "Member 'UShapeShiftSlotWidgetBase::ShapeShiftDataAsset' has a wrong offset!");
static_assert(offsetof(UShapeShiftSlotWidgetBase, DescTextArray) == 0x000380, "Member 'UShapeShiftSlotWidgetBase::DescTextArray' has a wrong offset!");
static_assert(offsetof(UShapeShiftSlotWidgetBase, ShapeShiftName) == 0x000390, "Member 'UShapeShiftSlotWidgetBase::ShapeShiftName' has a wrong offset!");
static_assert(offsetof(UShapeShiftSlotWidgetBase, ArtData) == 0x0003A8, "Member 'UShapeShiftSlotWidgetBase::ArtData' has a wrong offset!");
static_assert(offsetof(UShapeShiftSlotWidgetBase, SlotIndex) == 0x0003B0, "Member 'UShapeShiftSlotWidgetBase::SlotIndex' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitAimDirectionChanged
// 0x0028 (0x00A8 - 0x0080)
class UDCAT_WaitAimDirectionChanged final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnDirectionChanged;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2580[0x18];                                    // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitAimDirectionChanged* WaitAimDirectionChanged(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitAimDirectionChanged">();
	}
	static class UDCAT_WaitAimDirectionChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitAimDirectionChanged>();
	}
};
static_assert(alignof(UDCAT_WaitAimDirectionChanged) == 0x000008, "Wrong alignment on UDCAT_WaitAimDirectionChanged");
static_assert(sizeof(UDCAT_WaitAimDirectionChanged) == 0x0000A8, "Wrong size on UDCAT_WaitAimDirectionChanged");
static_assert(offsetof(UDCAT_WaitAimDirectionChanged, OnDirectionChanged) == 0x000080, "Member 'UDCAT_WaitAimDirectionChanged::OnDirectionChanged' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitAttributeChangeByExecution
// 0x0030 (0x00B0 - 0x0080)
class UDCAT_WaitAttributeChangeByExecution final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnChange;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2581[0x18];                                    // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UDCAT_WaitAttributeChangeByExecution* WaitForAttributeChange(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute, bool TriggerOnce, class AActor* OptionalExternalOwner);
	static class UDCAT_WaitAttributeChangeByExecution* WaitForAttributesChange(class UGameplayAbility* OwningAbility, const TArray<struct FGameplayAttribute>& Attributes, bool TriggerOnce, class AActor* OptionalExternalOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitAttributeChangeByExecution">();
	}
	static class UDCAT_WaitAttributeChangeByExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitAttributeChangeByExecution>();
	}
};
static_assert(alignof(UDCAT_WaitAttributeChangeByExecution) == 0x000008, "Wrong alignment on UDCAT_WaitAttributeChangeByExecution");
static_assert(sizeof(UDCAT_WaitAttributeChangeByExecution) == 0x0000B0, "Wrong size on UDCAT_WaitAttributeChangeByExecution");
static_assert(offsetof(UDCAT_WaitAttributeChangeByExecution, OnChange) == 0x000080, "Member 'UDCAT_WaitAttributeChangeByExecution::OnChange' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitAttributeChangeByExecution, ExternalOwner) == 0x0000A8, "Member 'UDCAT_WaitAttributeChangeByExecution::ExternalOwner' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitDelayPausable
// 0x0050 (0x00D0 - 0x0080)
class UDCAT_WaitDelayPausable final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPause;                                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResume;                                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2584[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitDelayPausable* WaitDelay(class UGameplayAbility* OwningAbility, float Duration);

	void AddTimerElapsedTimeRatio(float AdditionalRatio);
	void PauseTimer();
	void ResumeTimer();

	float GetElapsedTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitDelayPausable">();
	}
	static class UDCAT_WaitDelayPausable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitDelayPausable>();
	}
};
static_assert(alignof(UDCAT_WaitDelayPausable) == 0x000008, "Wrong alignment on UDCAT_WaitDelayPausable");
static_assert(sizeof(UDCAT_WaitDelayPausable) == 0x0000D0, "Wrong size on UDCAT_WaitDelayPausable");
static_assert(offsetof(UDCAT_WaitDelayPausable, OnFinish) == 0x000080, "Member 'UDCAT_WaitDelayPausable::OnFinish' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitDelayPausable, OnCancelled) == 0x000090, "Member 'UDCAT_WaitDelayPausable::OnCancelled' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitDelayPausable, OnPause) == 0x0000A0, "Member 'UDCAT_WaitDelayPausable::OnPause' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitDelayPausable, OnResume) == 0x0000B0, "Member 'UDCAT_WaitDelayPausable::OnResume' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitDistChangeFromActor
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WaitDistChangeFromActor final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnDistanceChange;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2586[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitDistChangeFromActor* WaitDistanceChange(class UGameplayAbility* OwningAbility, class AActor* TargetActor, float MaximumDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitDistChangeFromActor">();
	}
	static class UDCAT_WaitDistChangeFromActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitDistChangeFromActor>();
	}
};
static_assert(alignof(UDCAT_WaitDistChangeFromActor) == 0x000008, "Wrong alignment on UDCAT_WaitDistChangeFromActor");
static_assert(sizeof(UDCAT_WaitDistChangeFromActor) == 0x0000A0, "Wrong size on UDCAT_WaitDistChangeFromActor");
static_assert(offsetof(UDCAT_WaitDistChangeFromActor, OnDistanceChange) == 0x000080, "Member 'UDCAT_WaitDistChangeFromActor::OnDistanceChange' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitDistChangeFromView
// 0x00B0 (0x0130 - 0x0080)
class UDCAT_WaitDistChangeFromView final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnDistanceChange;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2588[0xA0];                                    // 0x0090(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitDistChangeFromView* WaitDistanceChange(class UGameplayAbility* OwningAbility, class AActor* TargetActor, const struct FVector& TargetLocation, float MaximumDistance, float CollisionRadius, ECollisionChannel CollisionChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitDistChangeFromView">();
	}
	static class UDCAT_WaitDistChangeFromView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitDistChangeFromView>();
	}
};
static_assert(alignof(UDCAT_WaitDistChangeFromView) == 0x000008, "Wrong alignment on UDCAT_WaitDistChangeFromView");
static_assert(sizeof(UDCAT_WaitDistChangeFromView) == 0x000130, "Wrong size on UDCAT_WaitDistChangeFromView");
static_assert(offsetof(UDCAT_WaitDistChangeFromView, OnDistanceChange) == 0x000080, "Member 'UDCAT_WaitDistChangeFromView::OnDistanceChange' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitForGameplayEvents
// 0x0038 (0x00B8 - 0x0080)
class UDCAT_WaitForGameplayEvents final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EventTags;                                         // 0x0090(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_258A[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitForGameplayEvents* WaitForGameplayEvents(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& InEventTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitForGameplayEvents">();
	}
	static class UDCAT_WaitForGameplayEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitForGameplayEvents>();
	}
};
static_assert(alignof(UDCAT_WaitForGameplayEvents) == 0x000008, "Wrong alignment on UDCAT_WaitForGameplayEvents");
static_assert(sizeof(UDCAT_WaitForGameplayEvents) == 0x0000B8, "Wrong size on UDCAT_WaitForGameplayEvents");
static_assert(offsetof(UDCAT_WaitForGameplayEvents, EventReceived) == 0x000080, "Member 'UDCAT_WaitForGameplayEvents::EventReceived' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitForGameplayEvents, EventTags) == 0x000090, "Member 'UDCAT_WaitForGameplayEvents::EventTags' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd
// 0x0120 (0x01A0 - 0x0080)
class UDCAT_WaitGameplayAbilityActivateOrEnd final : public UAbilityTask
{
public:
	uint8                                         Pad_258B[0xE0];                                    // 0x0080(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAbilityActivated;                                // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAbilityEnded;                                    // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258C[0x18];                                    // 0x0188(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitGameplayAbilityActivateOrEnd* WaitForAbilityActivateOrEnd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, class AActor* InOptionalExternalTarget, bool bTriggerOnce);
	static class UDCAT_WaitGameplayAbilityActivateOrEnd* WaitForAbilityActivateOrEnd_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, class AActor* InOptionalExternalTarget, bool bTriggerOnce);
	static class UDCAT_WaitGameplayAbilityActivateOrEnd* WaitForAbilityActivateOrEndWithTagRequirements(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, class AActor* InOptionalExternalTarget, bool bTriggerOnce);

	void OnAbilityActivate(class UGameplayAbility* ActivatedAbility);
	void OnAbilityEnd(const struct FAbilityEndedData& AbilityEndedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitGameplayAbilityActivateOrEnd">();
	}
	static class UDCAT_WaitGameplayAbilityActivateOrEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitGameplayAbilityActivateOrEnd>();
	}
};
static_assert(alignof(UDCAT_WaitGameplayAbilityActivateOrEnd) == 0x000008, "Wrong alignment on UDCAT_WaitGameplayAbilityActivateOrEnd");
static_assert(sizeof(UDCAT_WaitGameplayAbilityActivateOrEnd) == 0x0001A0, "Wrong size on UDCAT_WaitGameplayAbilityActivateOrEnd");
static_assert(offsetof(UDCAT_WaitGameplayAbilityActivateOrEnd, OnAbilityActivated) == 0x000160, "Member 'UDCAT_WaitGameplayAbilityActivateOrEnd::OnAbilityActivated' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitGameplayAbilityActivateOrEnd, OnAbilityEnded) == 0x000170, "Member 'UDCAT_WaitGameplayAbilityActivateOrEnd::OnAbilityEnded' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitGameplayAbilityActivateOrEnd, OptionalExternalTarget) == 0x000180, "Member 'UDCAT_WaitGameplayAbilityActivateOrEnd::OptionalExternalTarget' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitGameplayTagsRemoved
// 0x0028 (0x0130 - 0x0108)
class UDCAT_WaitGameplayTagsRemoved final : public UDCAT_WaitGameplayTags
{
public:
	FMulticastInlineDelegateProperty_             Removed;                                           // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemovedOnTarget;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2590[0x8];                                     // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitGameplayTagsRemoved* WaitGameplayTagsRemoved(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& TagContainer, bool bIsWaitAnyTag, class AActor* InOptionalExternalTarget, bool bIsOnlyTriggerOnce, bool bShouldBroadcastImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitGameplayTagsRemoved">();
	}
	static class UDCAT_WaitGameplayTagsRemoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitGameplayTagsRemoved>();
	}
};
static_assert(alignof(UDCAT_WaitGameplayTagsRemoved) == 0x000008, "Wrong alignment on UDCAT_WaitGameplayTagsRemoved");
static_assert(sizeof(UDCAT_WaitGameplayTagsRemoved) == 0x000130, "Wrong size on UDCAT_WaitGameplayTagsRemoved");
static_assert(offsetof(UDCAT_WaitGameplayTagsRemoved, Removed) == 0x000108, "Member 'UDCAT_WaitGameplayTagsRemoved::Removed' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitGameplayTagsRemoved, RemovedOnTarget) == 0x000118, "Member 'UDCAT_WaitGameplayTagsRemoved::RemovedOnTarget' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitInteractableTarget
// 0x0028 (0x00A8 - 0x0080)
class UDCAT_WaitInteractableTarget final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             FoundNewInteractableTarget;                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LostInteractableTarget;                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ADCGATA_LineTraceInteractable*          InteractableTargetActor;                           // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UDCAT_WaitInteractableTarget* WaitInteractableTarget(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class ADCGATA_LineTraceInteractable* InTargetActor);

	void OnFoundNewInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnLostInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void ResetTargeting();
	void StartTargeting();
	void StopTargeting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitInteractableTarget">();
	}
	static class UDCAT_WaitInteractableTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitInteractableTarget>();
	}
};
static_assert(alignof(UDCAT_WaitInteractableTarget) == 0x000008, "Wrong alignment on UDCAT_WaitInteractableTarget");
static_assert(sizeof(UDCAT_WaitInteractableTarget) == 0x0000A8, "Wrong size on UDCAT_WaitInteractableTarget");
static_assert(offsetof(UDCAT_WaitInteractableTarget, FoundNewInteractableTarget) == 0x000080, "Member 'UDCAT_WaitInteractableTarget::FoundNewInteractableTarget' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitInteractableTarget, LostInteractableTarget) == 0x000090, "Member 'UDCAT_WaitInteractableTarget::LostInteractableTarget' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitInteractableTarget, InteractableTargetActor) == 0x0000A0, "Member 'UDCAT_WaitInteractableTarget::InteractableTargetActor' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitSocketBlockedStateChange
// 0x0028 (0x00A8 - 0x0080)
class UDCAT_WaitSocketBlockedStateChange final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             SocketSightBlocked;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SocketSightUnblocked;                              // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ADCGATA_AimTraceToSocket*               AimTraceActor;                                     // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UDCAT_WaitSocketBlockedStateChange* WaitSocketBlockedStateChange(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class ADCGATA_AimTraceToSocket* InTargetActor);

	void OnSocketSightBlocked(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnSocketSightUnblocked(const struct FGameplayAbilityTargetDataHandle& Data);
	void ResetTargeting();
	void StartTargeting();
	void StopTargeting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitSocketBlockedStateChange">();
	}
	static class UDCAT_WaitSocketBlockedStateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitSocketBlockedStateChange>();
	}
};
static_assert(alignof(UDCAT_WaitSocketBlockedStateChange) == 0x000008, "Wrong alignment on UDCAT_WaitSocketBlockedStateChange");
static_assert(sizeof(UDCAT_WaitSocketBlockedStateChange) == 0x0000A8, "Wrong size on UDCAT_WaitSocketBlockedStateChange");
static_assert(offsetof(UDCAT_WaitSocketBlockedStateChange, SocketSightBlocked) == 0x000080, "Member 'UDCAT_WaitSocketBlockedStateChange::SocketSightBlocked' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitSocketBlockedStateChange, SocketSightUnblocked) == 0x000090, "Member 'UDCAT_WaitSocketBlockedStateChange::SocketSightUnblocked' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitSocketBlockedStateChange, AimTraceActor) == 0x0000A0, "Member 'UDCAT_WaitSocketBlockedStateChange::AimTraceActor' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitTargetGameplayTagEvent
// 0x0060 (0x00E0 - 0x0080)
class UDCAT_WaitTargetGameplayTagEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             Added;                                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCountChanged;                                    // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Removed;                                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2593[0x10];                                    // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2594[0x18];                                    // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitTargetGameplayTagEvent* WaitTargetGameplayTagEvent(class UGameplayAbility* OwningAbility, const struct FGameplayTag& InTargetTag, class AActor* InOptionalExternalTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitTargetGameplayTagEvent">();
	}
	static class UDCAT_WaitTargetGameplayTagEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitTargetGameplayTagEvent>();
	}
};
static_assert(alignof(UDCAT_WaitTargetGameplayTagEvent) == 0x000008, "Wrong alignment on UDCAT_WaitTargetGameplayTagEvent");
static_assert(sizeof(UDCAT_WaitTargetGameplayTagEvent) == 0x0000E0, "Wrong size on UDCAT_WaitTargetGameplayTagEvent");
static_assert(offsetof(UDCAT_WaitTargetGameplayTagEvent, Added) == 0x000080, "Member 'UDCAT_WaitTargetGameplayTagEvent::Added' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitTargetGameplayTagEvent, OnCountChanged) == 0x000090, "Member 'UDCAT_WaitTargetGameplayTagEvent::OnCountChanged' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitTargetGameplayTagEvent, Removed) == 0x0000A0, "Member 'UDCAT_WaitTargetGameplayTagEvent::Removed' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitTargetGameplayTagEvent, OptionalExternalTarget) == 0x0000C0, "Member 'UDCAT_WaitTargetGameplayTagEvent::OptionalExternalTarget' has a wrong offset!");

// Class DungeonCrawler.DCAT_WaitVelocityZero
// 0x0018 (0x0098 - 0x0080)
class UDCAT_WaitVelocityZero final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnVelocityZero;                                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMovementComponent*                     CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UDCAT_WaitVelocityZero* WaitVelocityZero(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitVelocityZero">();
	}
	static class UDCAT_WaitVelocityZero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitVelocityZero>();
	}
};
static_assert(alignof(UDCAT_WaitVelocityZero) == 0x000008, "Wrong alignment on UDCAT_WaitVelocityZero");
static_assert(sizeof(UDCAT_WaitVelocityZero) == 0x000098, "Wrong size on UDCAT_WaitVelocityZero");
static_assert(offsetof(UDCAT_WaitVelocityZero, OnVelocityZero) == 0x000080, "Member 'UDCAT_WaitVelocityZero::OnVelocityZero' has a wrong offset!");
static_assert(offsetof(UDCAT_WaitVelocityZero, CachedMovementComponent) == 0x000090, "Member 'UDCAT_WaitVelocityZero::CachedMovementComponent' has a wrong offset!");

// Class DungeonCrawler.DCBagSlotWidget
// 0x0010 (0x02D0 - 0x02C0)
class UDCBagSlotWidget final : public UUserWidget
{
public:
	bool                                          bOccupied;                                         // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEquip;                                         // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCItemDropPreview                            ItemDropPreview;                                   // 0x02C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2595[0x5];                                     // 0x02C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeBox*                               SlotSizeBox;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCBagSlotWidget">();
	}
	static class UDCBagSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCBagSlotWidget>();
	}
};
static_assert(alignof(UDCBagSlotWidget) == 0x000008, "Wrong alignment on UDCBagSlotWidget");
static_assert(sizeof(UDCBagSlotWidget) == 0x0002D0, "Wrong size on UDCBagSlotWidget");
static_assert(offsetof(UDCBagSlotWidget, bOccupied) == 0x0002C0, "Member 'UDCBagSlotWidget::bOccupied' has a wrong offset!");
static_assert(offsetof(UDCBagSlotWidget, bCanEquip) == 0x0002C1, "Member 'UDCBagSlotWidget::bCanEquip' has a wrong offset!");
static_assert(offsetof(UDCBagSlotWidget, ItemDropPreview) == 0x0002C2, "Member 'UDCBagSlotWidget::ItemDropPreview' has a wrong offset!");
static_assert(offsetof(UDCBagSlotWidget, SlotSizeBox) == 0x0002C8, "Member 'UDCBagSlotWidget::SlotSizeBox' has a wrong offset!");

// Class DungeonCrawler.DCBalanceTestGameMode
// 0x0000 (0x0540 - 0x0540)
class ADCBalanceTestGameMode final : public ADCTestGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCBalanceTestGameMode">();
	}
	static class ADCBalanceTestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCBalanceTestGameMode>();
	}
};
static_assert(alignof(ADCBalanceTestGameMode) == 0x000008, "Wrong alignment on ADCBalanceTestGameMode");
static_assert(sizeof(ADCBalanceTestGameMode) == 0x000540, "Wrong size on ADCBalanceTestGameMode");

// Class DungeonCrawler.DCInventoryContainerComponent
// 0x00E0 (0x0180 - 0x00A0)
class UDCInventoryContainerComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_2596[0xD0];                                    // 0x00A0(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCInventoryBase*>               InventoryList;                                     // 0x0170(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_InventoryList(const TArray<class UDCInventoryBase*>& OldInventoryList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryContainerComponent">();
	}
	static class UDCInventoryContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryContainerComponent>();
	}
};
static_assert(alignof(UDCInventoryContainerComponent) == 0x000008, "Wrong alignment on UDCInventoryContainerComponent");
static_assert(sizeof(UDCInventoryContainerComponent) == 0x000180, "Wrong size on UDCInventoryContainerComponent");
static_assert(offsetof(UDCInventoryContainerComponent, InventoryList) == 0x000170, "Member 'UDCInventoryContainerComponent::InventoryList' has a wrong offset!");

// Class DungeonCrawler.DCButtonNumberSetterWidget
// 0x0048 (0x03A0 - 0x0358)
class UDCButtonNumberSetterWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2597[0x18];                                    // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultNumber;                                     // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinNumber;                                         // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumber;                                         // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Number;                                            // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InputLengthLimit;                                  // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2598[0x4];                                     // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCEditableText*                        InputNumberEditableText;                           // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    MinusOneButton;                                    // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    PlusOneButton;                                     // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInputTextChanged(const class FText& InText);
	void OnInputTextCommitted(const class FText& InText, ETextCommit InCommitType);
	void OnMinusOneButtonClicked();
	void OnPlusOneButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCButtonNumberSetterWidget">();
	}
	static class UDCButtonNumberSetterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCButtonNumberSetterWidget>();
	}
};
static_assert(alignof(UDCButtonNumberSetterWidget) == 0x000008, "Wrong alignment on UDCButtonNumberSetterWidget");
static_assert(sizeof(UDCButtonNumberSetterWidget) == 0x0003A0, "Wrong size on UDCButtonNumberSetterWidget");
static_assert(offsetof(UDCButtonNumberSetterWidget, DefaultNumber) == 0x000370, "Member 'UDCButtonNumberSetterWidget::DefaultNumber' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, MinNumber) == 0x000374, "Member 'UDCButtonNumberSetterWidget::MinNumber' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, MaxNumber) == 0x000378, "Member 'UDCButtonNumberSetterWidget::MaxNumber' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, Number) == 0x00037C, "Member 'UDCButtonNumberSetterWidget::Number' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, InputLengthLimit) == 0x000380, "Member 'UDCButtonNumberSetterWidget::InputLengthLimit' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, InputNumberEditableText) == 0x000388, "Member 'UDCButtonNumberSetterWidget::InputNumberEditableText' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, MinusOneButton) == 0x000390, "Member 'UDCButtonNumberSetterWidget::MinusOneButton' has a wrong offset!");
static_assert(offsetof(UDCButtonNumberSetterWidget, PlusOneButton) == 0x000398, "Member 'UDCButtonNumberSetterWidget::PlusOneButton' has a wrong offset!");

// Class DungeonCrawler.DCCameraPostProcessTimelineData
// 0x00E0 (0x0108 - 0x0028)
class UDCCameraPostProcessTimelineData final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCameraPostProcessDataTimelineUpdate;             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCameraPostProcessDataTimelineFinished;           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimeline                              CameraPostProcessTimeline;                         // 0x0048(0x0098)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            TimelineCurve;                                     // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETimelineDirection                            TimelineDirection;                                 // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259A[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ParameterNames;                                    // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MIDKey;                                            // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleTimelineFinished();
	void HandleTimelineUpdate(float UpdateValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCameraPostProcessTimelineData">();
	}
	static class UDCCameraPostProcessTimelineData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCameraPostProcessTimelineData>();
	}
};
static_assert(alignof(UDCCameraPostProcessTimelineData) == 0x000008, "Wrong alignment on UDCCameraPostProcessTimelineData");
static_assert(sizeof(UDCCameraPostProcessTimelineData) == 0x000108, "Wrong size on UDCCameraPostProcessTimelineData");
static_assert(offsetof(UDCCameraPostProcessTimelineData, OnCameraPostProcessDataTimelineUpdate) == 0x000028, "Member 'UDCCameraPostProcessTimelineData::OnCameraPostProcessDataTimelineUpdate' has a wrong offset!");
static_assert(offsetof(UDCCameraPostProcessTimelineData, OnCameraPostProcessDataTimelineFinished) == 0x000038, "Member 'UDCCameraPostProcessTimelineData::OnCameraPostProcessDataTimelineFinished' has a wrong offset!");
static_assert(offsetof(UDCCameraPostProcessTimelineData, CameraPostProcessTimeline) == 0x000048, "Member 'UDCCameraPostProcessTimelineData::CameraPostProcessTimeline' has a wrong offset!");
static_assert(offsetof(UDCCameraPostProcessTimelineData, TimelineCurve) == 0x0000E0, "Member 'UDCCameraPostProcessTimelineData::TimelineCurve' has a wrong offset!");
static_assert(offsetof(UDCCameraPostProcessTimelineData, TimelineDirection) == 0x0000E8, "Member 'UDCCameraPostProcessTimelineData::TimelineDirection' has a wrong offset!");
static_assert(offsetof(UDCCameraPostProcessTimelineData, ParameterNames) == 0x0000F0, "Member 'UDCCameraPostProcessTimelineData::ParameterNames' has a wrong offset!");
static_assert(offsetof(UDCCameraPostProcessTimelineData, MIDKey) == 0x000100, "Member 'UDCCameraPostProcessTimelineData::MIDKey' has a wrong offset!");

// Class DungeonCrawler.DCGameplayCueBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCGameplayCueBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FTransform CalculateProjectileHitNiagaraTransform(const class UObject* InSourceObject, const struct FHitResult& InHitResult);
	static class UNiagaraSystem* GetProjectileDefaultNiagaraSystem(const class UObject* InSourceObject);
	static class UNiagaraSystem* GetProjectileHitCharacterNiagaraSystem(const class UObject* InSourceObject);
	static float GetProjectileHitNiagaraSystemScale(const class UObject* InSourceObject);
	static class UNiagaraSystem* GetProjectileHitObjectNiagaraSystem(const class UObject* InSourceObject);
	static class UNiagaraSystem* GetProjectileHitShieldNiagaraSystem(const class UObject* InSourceObject);
	static void PlayHitDirectionWidget(class AActor* InHitActor, const class AActor* InInstigator);
	static void PlayHitDirectionWidgetWithParams(const struct FGameplayCueParameters& InCueParams);
	static void PlayHitReactionAnimation(class AActor* InHitActor, const class AActor* InInstigator);
	static void PlayHitReactionAnimationWithParams(const struct FGameplayCueParameters& InCueParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayCueBlueprintLibrary">();
	}
	static class UDCGameplayCueBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayCueBlueprintLibrary>();
	}
};
static_assert(alignof(UDCGameplayCueBlueprintLibrary) == 0x000008, "Wrong alignment on UDCGameplayCueBlueprintLibrary");
static_assert(sizeof(UDCGameplayCueBlueprintLibrary) == 0x000028, "Wrong size on UDCGameplayCueBlueprintLibrary");

// Class DungeonCrawler.DCCaptureStudioActor
// 0x0028 (0x02C0 - 0x0298)
class ADCCaptureStudioActor : public AActor
{
public:
	class UDCSceneCaptureComponent2D*             SceneCaptureComponent;                             // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCRotatorComponent*                    RotatorComponent;                                  // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   CaptureTargetComponent;                            // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUint32Point                           RenderTargetSize;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCaptureStudioActor">();
	}
	static class ADCCaptureStudioActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCaptureStudioActor>();
	}
};
static_assert(alignof(ADCCaptureStudioActor) == 0x000008, "Wrong alignment on ADCCaptureStudioActor");
static_assert(sizeof(ADCCaptureStudioActor) == 0x0002C0, "Wrong size on ADCCaptureStudioActor");
static_assert(offsetof(ADCCaptureStudioActor, SceneCaptureComponent) == 0x000298, "Member 'ADCCaptureStudioActor::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(ADCCaptureStudioActor, RotatorComponent) == 0x0002A0, "Member 'ADCCaptureStudioActor::RotatorComponent' has a wrong offset!");
static_assert(offsetof(ADCCaptureStudioActor, CaptureTargetComponent) == 0x0002A8, "Member 'ADCCaptureStudioActor::CaptureTargetComponent' has a wrong offset!");
static_assert(offsetof(ADCCaptureStudioActor, RenderTargetSize) == 0x0002B0, "Member 'ADCCaptureStudioActor::RenderTargetSize' has a wrong offset!");
static_assert(offsetof(ADCCaptureStudioActor, RenderTarget) == 0x0002B8, "Member 'ADCCaptureStudioActor::RenderTarget' has a wrong offset!");

// Class DungeonCrawler.DCCaptureStudioWidget
// 0x0020 (0x02E0 - 0x02C0)
class UDCCaptureStudioWidget : public UUserWidget
{
public:
	class UImage*                                 RenderTargetImage;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCCaptureStudioActor*                  CaptureStudioActor;                                // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynamicInstanceMaterial;                           // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDragging;                                       // 0x02D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRotatingLeft;                                   // 0x02D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRotatingRight;                                  // 0x02DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259C[0x5];                                     // 0x02DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCaptureStudioWidget">();
	}
	static class UDCCaptureStudioWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCaptureStudioWidget>();
	}
};
static_assert(alignof(UDCCaptureStudioWidget) == 0x000008, "Wrong alignment on UDCCaptureStudioWidget");
static_assert(sizeof(UDCCaptureStudioWidget) == 0x0002E0, "Wrong size on UDCCaptureStudioWidget");
static_assert(offsetof(UDCCaptureStudioWidget, RenderTargetImage) == 0x0002C0, "Member 'UDCCaptureStudioWidget::RenderTargetImage' has a wrong offset!");
static_assert(offsetof(UDCCaptureStudioWidget, CaptureStudioActor) == 0x0002C8, "Member 'UDCCaptureStudioWidget::CaptureStudioActor' has a wrong offset!");
static_assert(offsetof(UDCCaptureStudioWidget, DynamicInstanceMaterial) == 0x0002D0, "Member 'UDCCaptureStudioWidget::DynamicInstanceMaterial' has a wrong offset!");
static_assert(offsetof(UDCCaptureStudioWidget, bIsDragging) == 0x0002D8, "Member 'UDCCaptureStudioWidget::bIsDragging' has a wrong offset!");
static_assert(offsetof(UDCCaptureStudioWidget, bIsRotatingLeft) == 0x0002D9, "Member 'UDCCaptureStudioWidget::bIsRotatingLeft' has a wrong offset!");
static_assert(offsetof(UDCCaptureStudioWidget, bIsRotatingRight) == 0x0002DA, "Member 'UDCCaptureStudioWidget::bIsRotatingRight' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionBaseWidget
// 0x0048 (0x03A0 - 0x0358)
class UGameMenuOptionBaseWidget : public UDCWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             GameMenuOptionHoveredDelegate;                     // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        Switcher_Selected;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FText                                   DescText;                                          // 0x0388(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	void OnHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionBaseWidget">();
	}
	static class UGameMenuOptionBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionBaseWidget>();
	}
};
static_assert(alignof(UGameMenuOptionBaseWidget) == 0x000008, "Wrong alignment on UGameMenuOptionBaseWidget");
static_assert(sizeof(UGameMenuOptionBaseWidget) == 0x0003A0, "Wrong size on UGameMenuOptionBaseWidget");
static_assert(offsetof(UGameMenuOptionBaseWidget, GameMenuOptionHoveredDelegate) == 0x000358, "Member 'UGameMenuOptionBaseWidget::GameMenuOptionHoveredDelegate' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionBaseWidget, Switcher_Selected) == 0x000368, "Member 'UGameMenuOptionBaseWidget::Switcher_Selected' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionBaseWidget, TitleText) == 0x000370, "Member 'UGameMenuOptionBaseWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionBaseWidget, DescText) == 0x000388, "Member 'UGameMenuOptionBaseWidget::DescText' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionTwitchDropsWidget
// 0x0038 (0x03D8 - 0x03A0)
class UGameMenuOptionTwitchDropsWidget : public UGameMenuOptionBaseWidget
{
public:
	TSubclassOf<class UCommonPopupSWidget>        CommonPopupWidget;                                 // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonTwitchDrops;                                 // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ContentText;                                       // 0x03B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_259D[0x10];                                    // 0x03C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickTwitchDropsButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionTwitchDropsWidget">();
	}
	static class UGameMenuOptionTwitchDropsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionTwitchDropsWidget>();
	}
};
static_assert(alignof(UGameMenuOptionTwitchDropsWidget) == 0x000008, "Wrong alignment on UGameMenuOptionTwitchDropsWidget");
static_assert(sizeof(UGameMenuOptionTwitchDropsWidget) == 0x0003D8, "Wrong size on UGameMenuOptionTwitchDropsWidget");
static_assert(offsetof(UGameMenuOptionTwitchDropsWidget, CommonPopupWidget) == 0x0003A0, "Member 'UGameMenuOptionTwitchDropsWidget::CommonPopupWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionTwitchDropsWidget, ButtonTwitchDrops) == 0x0003A8, "Member 'UGameMenuOptionTwitchDropsWidget::ButtonTwitchDrops' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionTwitchDropsWidget, ContentText) == 0x0003B0, "Member 'UGameMenuOptionTwitchDropsWidget::ContentText' has a wrong offset!");

// Class DungeonCrawler.DCChannelPlayerListEntryWidgetData
// 0x0090 (0x00B8 - 0x0028)
class UDCChannelPlayerListEntryWidgetData final : public UObject
{
public:
	struct FDCChannelPlayerWidgetInfo             Info;                                              // 0x0028(0x0090)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCChannelPlayerListEntryWidgetData">();
	}
	static class UDCChannelPlayerListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCChannelPlayerListEntryWidgetData>();
	}
};
static_assert(alignof(UDCChannelPlayerListEntryWidgetData) == 0x000008, "Wrong alignment on UDCChannelPlayerListEntryWidgetData");
static_assert(sizeof(UDCChannelPlayerListEntryWidgetData) == 0x0000B8, "Wrong size on UDCChannelPlayerListEntryWidgetData");
static_assert(offsetof(UDCChannelPlayerListEntryWidgetData, Info) == 0x000028, "Member 'UDCChannelPlayerListEntryWidgetData::Info' has a wrong offset!");

// Class DungeonCrawler.VoipUserWidget
// 0x0048 (0x03A0 - 0x0358)
class UVoipUserWidget : public UDCWidgetBase
{
public:
	struct FVoipUserWidgetData                    WidgetData;                                        // 0x0358(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bMine;                                             // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSameParty;                                        // 0x0399(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259E[0x6];                                     // 0x039A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAccountId(const struct FDCAccountId& NewValue, const struct FDCAccountId& OldValue);
	void OnbVoipForceParty(bool NewValue, bool OldValue);
	void OnMuteButtonClicked();
	void OnVoipPartyData(const struct FVoipPartyData& NewValue, const struct FVoipPartyData& OldValue);
	void OnVoipUserData(const struct FVoipUserData& NewValue, const struct FVoipUserData& OldValue);
	void OnVoipVolumeChanged(float InVoipVolume);
	void SetAccountId(const struct FDCAccountId& InAccountId);
	void SetVoipForceParty(bool bInVoipForceParty);
	void SetVoipPartyData(const struct FVoipPartyData& InVoipPartyData);
	void SetVoipUserData(const struct FVoipUserData& InVoipUserData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipUserWidget">();
	}
	static class UVoipUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipUserWidget>();
	}
};
static_assert(alignof(UVoipUserWidget) == 0x000008, "Wrong alignment on UVoipUserWidget");
static_assert(sizeof(UVoipUserWidget) == 0x0003A0, "Wrong size on UVoipUserWidget");
static_assert(offsetof(UVoipUserWidget, WidgetData) == 0x000358, "Member 'UVoipUserWidget::WidgetData' has a wrong offset!");
static_assert(offsetof(UVoipUserWidget, bMine) == 0x000398, "Member 'UVoipUserWidget::bMine' has a wrong offset!");
static_assert(offsetof(UVoipUserWidget, bSameParty) == 0x000399, "Member 'UVoipUserWidget::bSameParty' has a wrong offset!");

// Class DungeonCrawler.DCInteractTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IDCInteractTargetInterface final : public IInterface
{
public:
	void InteractTargetInfoName(class FText* Param_Name);
	void InteractTargetInfoRarity(struct FGameplayTag* RarityTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInteractTargetInterface">();
	}
	static class IDCInteractTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCInteractTargetInterface>();
	}
};
static_assert(alignof(IDCInteractTargetInterface) == 0x000008, "Wrong alignment on IDCInteractTargetInterface");
static_assert(sizeof(IDCInteractTargetInterface) == 0x000028, "Wrong size on IDCInteractTargetInterface");

// Class DungeonCrawler.DCGameplayAbilityDataAsset
// 0x0080 (0x00C8 - 0x0048)
class UDCGameplayAbilityDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCGameplayAbilityDataAsset;                   // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackType;                                        // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           Class_DCGameplayAbilityDataAsset;                  // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               Desc;                                              // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCMovementModifierDataAsset>> MovementModifiers;                                 // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGEModifierDataAsset>> GEModifiers;                                       // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayAbilityDataAsset">();
	}
	static class UDCGameplayAbilityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayAbilityDataAsset>();
	}
};
static_assert(alignof(UDCGameplayAbilityDataAsset) == 0x000008, "Wrong alignment on UDCGameplayAbilityDataAsset");
static_assert(sizeof(UDCGameplayAbilityDataAsset) == 0x0000C8, "Wrong size on UDCGameplayAbilityDataAsset");
static_assert(offsetof(UDCGameplayAbilityDataAsset, Name_DCGameplayAbilityDataAsset) == 0x000048, "Member 'UDCGameplayAbilityDataAsset::Name_DCGameplayAbilityDataAsset' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityDataAsset, AttackType) == 0x000060, "Member 'UDCGameplayAbilityDataAsset::AttackType' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityDataAsset, Class_DCGameplayAbilityDataAsset) == 0x000068, "Member 'UDCGameplayAbilityDataAsset::Class_DCGameplayAbilityDataAsset' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityDataAsset, Effects) == 0x000070, "Member 'UDCGameplayAbilityDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityDataAsset, Desc) == 0x000080, "Member 'UDCGameplayAbilityDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityDataAsset, MovementModifiers) == 0x0000A8, "Member 'UDCGameplayAbilityDataAsset::MovementModifiers' has a wrong offset!");
static_assert(offsetof(UDCGameplayAbilityDataAsset, GEModifiers) == 0x0000B8, "Member 'UDCGameplayAbilityDataAsset::GEModifiers' has a wrong offset!");

// Class DungeonCrawler.DCChannelPlayerListWidget
// 0x0080 (0x0340 - 0x02C0)
class UDCChannelPlayerListWidget final : public UUserWidget
{
public:
	class UVerticalBox*                           LocalPlayersVerticalBox;                           // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCChannelPlayerListEntryWidget> ChannelPlayerListEntryWidgetClass;                 // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              PlayerListView;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       SearchTextBox;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FDCAccountId, class UDCChannelPlayerListEntryWidgetData*> ListItems;                                         // 0x02E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_259F[0x10];                                    // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSearchTextChanged(const class FText& Keyword);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCChannelPlayerListWidget">();
	}
	static class UDCChannelPlayerListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCChannelPlayerListWidget>();
	}
};
static_assert(alignof(UDCChannelPlayerListWidget) == 0x000008, "Wrong alignment on UDCChannelPlayerListWidget");
static_assert(sizeof(UDCChannelPlayerListWidget) == 0x000340, "Wrong size on UDCChannelPlayerListWidget");
static_assert(offsetof(UDCChannelPlayerListWidget, LocalPlayersVerticalBox) == 0x0002C0, "Member 'UDCChannelPlayerListWidget::LocalPlayersVerticalBox' has a wrong offset!");
static_assert(offsetof(UDCChannelPlayerListWidget, ChannelPlayerListEntryWidgetClass) == 0x0002C8, "Member 'UDCChannelPlayerListWidget::ChannelPlayerListEntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCChannelPlayerListWidget, PlayerListView) == 0x0002D0, "Member 'UDCChannelPlayerListWidget::PlayerListView' has a wrong offset!");
static_assert(offsetof(UDCChannelPlayerListWidget, SearchTextBox) == 0x0002D8, "Member 'UDCChannelPlayerListWidget::SearchTextBox' has a wrong offset!");
static_assert(offsetof(UDCChannelPlayerListWidget, ListItems) == 0x0002E0, "Member 'UDCChannelPlayerListWidget::ListItems' has a wrong offset!");

// Class DungeonCrawler.DCGameSessionPlayerInfoEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCGameSessionPlayerInfoEntryWidgetData final : public UObject
{
public:
	TArray<struct FDCPlayerInfo>                  PlayerInfos;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSessionPlayerInfoEntryWidgetData">();
	}
	static class UDCGameSessionPlayerInfoEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameSessionPlayerInfoEntryWidgetData>();
	}
};
static_assert(alignof(UDCGameSessionPlayerInfoEntryWidgetData) == 0x000008, "Wrong alignment on UDCGameSessionPlayerInfoEntryWidgetData");
static_assert(sizeof(UDCGameSessionPlayerInfoEntryWidgetData) == 0x000038, "Wrong size on UDCGameSessionPlayerInfoEntryWidgetData");
static_assert(offsetof(UDCGameSessionPlayerInfoEntryWidgetData, PlayerInfos) == 0x000028, "Member 'UDCGameSessionPlayerInfoEntryWidgetData::PlayerInfos' has a wrong offset!");

// Class DungeonCrawler.DCCharacterAbilitySystemComponent
// 0x0190 (0x2510 - 0x2380)
class UDCCharacterAbilitySystemComponent final : public UDCAbilitySystemComponent
{
public:
	class UDCEquipmentComponent*                  EquipComp;                                         // 0x2380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCCharacterGasInfo                    CharacterGasInfo;                                  // 0x2388(0x0040)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCPerkGasInfo> PerkGasInfos;                                      // 0x23C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCItemSkinGasInfo> ItemSkinGasInfos;                                  // 0x2418(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, struct FDCItemGasInfo> EquippedItemGasInfos;                              // 0x2468(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCItemId, struct FDCItemGasInfo> ActivatedItemGasInfos;                             // 0x24B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25A0[0x8];                                     // 0x2508(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterAbilitySystemComponent">();
	}
	static class UDCCharacterAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterAbilitySystemComponent>();
	}
};
static_assert(alignof(UDCCharacterAbilitySystemComponent) == 0x000008, "Wrong alignment on UDCCharacterAbilitySystemComponent");
static_assert(sizeof(UDCCharacterAbilitySystemComponent) == 0x002510, "Wrong size on UDCCharacterAbilitySystemComponent");
static_assert(offsetof(UDCCharacterAbilitySystemComponent, EquipComp) == 0x002380, "Member 'UDCCharacterAbilitySystemComponent::EquipComp' has a wrong offset!");
static_assert(offsetof(UDCCharacterAbilitySystemComponent, CharacterGasInfo) == 0x002388, "Member 'UDCCharacterAbilitySystemComponent::CharacterGasInfo' has a wrong offset!");
static_assert(offsetof(UDCCharacterAbilitySystemComponent, PerkGasInfos) == 0x0023C8, "Member 'UDCCharacterAbilitySystemComponent::PerkGasInfos' has a wrong offset!");
static_assert(offsetof(UDCCharacterAbilitySystemComponent, ItemSkinGasInfos) == 0x002418, "Member 'UDCCharacterAbilitySystemComponent::ItemSkinGasInfos' has a wrong offset!");
static_assert(offsetof(UDCCharacterAbilitySystemComponent, EquippedItemGasInfos) == 0x002468, "Member 'UDCCharacterAbilitySystemComponent::EquippedItemGasInfos' has a wrong offset!");
static_assert(offsetof(UDCCharacterAbilitySystemComponent, ActivatedItemGasInfos) == 0x0024B8, "Member 'UDCCharacterAbilitySystemComponent::ActivatedItemGasInfos' has a wrong offset!");

// Class DungeonCrawler.GamePartyManagePartyWidgetData
// 0x0020 (0x0048 - 0x0028)
class UGamePartyManagePartyWidgetData final : public UObject
{
public:
	struct FPartyData                             PartyData;                                         // 0x0028(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyManagePartyWidgetData">();
	}
	static class UGamePartyManagePartyWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyManagePartyWidgetData>();
	}
};
static_assert(alignof(UGamePartyManagePartyWidgetData) == 0x000008, "Wrong alignment on UGamePartyManagePartyWidgetData");
static_assert(sizeof(UGamePartyManagePartyWidgetData) == 0x000048, "Wrong size on UGamePartyManagePartyWidgetData");
static_assert(offsetof(UGamePartyManagePartyWidgetData, PartyData) == 0x000028, "Member 'UGamePartyManagePartyWidgetData::PartyData' has a wrong offset!");

// Class DungeonCrawler.DCGameplayCueNotify_Actor
// 0x0018 (0x0320 - 0x0308)
class ADCGameplayCueNotify_Actor final : public AGameplayCueNotify_Actor
{
public:
	uint8                                         Pad_25A1[0x18];                                    // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAkComponentRTPCValue();
	void SetAkComponentRTPCValue(class UAkComponent* AkComponent, const class UAkRtpc* RtpcValue, float InTickValue, float InTotalValue, float InMaxRTPCValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayCueNotify_Actor">();
	}
	static class ADCGameplayCueNotify_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameplayCueNotify_Actor>();
	}
};
static_assert(alignof(ADCGameplayCueNotify_Actor) == 0x000008, "Wrong alignment on ADCGameplayCueNotify_Actor");
static_assert(sizeof(ADCGameplayCueNotify_Actor) == 0x000320, "Wrong size on ADCGameplayCueNotify_Actor");

// Class DungeonCrawler.DCCharacterAnimInstanceBase
// 0x00D0 (0x0500 - 0x0430)
class UDCCharacterAnimInstanceBase : public UDCAnimInstanceBase
{
public:
	float                                         NativeYaw;                                         // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NativePitch;                                       // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFlying;                                         // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x0431(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCrouching;                                      // 0x0432(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSwimming;                                       // 0x0433(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0434(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A3[0x3];                                     // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RigidityMod;                                       // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRigid;                                            // 0x043C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A4[0x3];                                     // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          RigidPoseSnapshot;                                 // 0x0440(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FVector                                HitDirection;                                      // 0x0478(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTransitionToHit;                            // 0x0490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTransitionToHitReactionFlipFlop;            // 0x0491(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A5[0x2];                                     // 0x0492(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitReactionStateMachineName;                       // 0x0494(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HitReactionStateName;                              // 0x049C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HitReactionFlipFlopStateName;                      // 0x04A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A6[0x4];                                     // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          RigidPhysicsAsset;                                 // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A7[0x48];                                    // 0x04B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterAnimInstanceBase">();
	}
	static class UDCCharacterAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterAnimInstanceBase>();
	}
};
static_assert(alignof(UDCCharacterAnimInstanceBase) == 0x000010, "Wrong alignment on UDCCharacterAnimInstanceBase");
static_assert(sizeof(UDCCharacterAnimInstanceBase) == 0x000500, "Wrong size on UDCCharacterAnimInstanceBase");
static_assert(offsetof(UDCCharacterAnimInstanceBase, NativeYaw) == 0x000428, "Member 'UDCCharacterAnimInstanceBase::NativeYaw' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, NativePitch) == 0x00042C, "Member 'UDCCharacterAnimInstanceBase::NativePitch' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bIsFlying) == 0x000430, "Member 'UDCCharacterAnimInstanceBase::bIsFlying' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bIsFalling) == 0x000431, "Member 'UDCCharacterAnimInstanceBase::bIsFalling' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bIsCrouching) == 0x000432, "Member 'UDCCharacterAnimInstanceBase::bIsCrouching' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bIsSwimming) == 0x000433, "Member 'UDCCharacterAnimInstanceBase::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bIsDead) == 0x000434, "Member 'UDCCharacterAnimInstanceBase::bIsDead' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, RigidityMod) == 0x000438, "Member 'UDCCharacterAnimInstanceBase::RigidityMod' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bRigid) == 0x00043C, "Member 'UDCCharacterAnimInstanceBase::bRigid' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, RigidPoseSnapshot) == 0x000440, "Member 'UDCCharacterAnimInstanceBase::RigidPoseSnapshot' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, HitDirection) == 0x000478, "Member 'UDCCharacterAnimInstanceBase::HitDirection' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bShouldTransitionToHit) == 0x000490, "Member 'UDCCharacterAnimInstanceBase::bShouldTransitionToHit' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, bShouldTransitionToHitReactionFlipFlop) == 0x000491, "Member 'UDCCharacterAnimInstanceBase::bShouldTransitionToHitReactionFlipFlop' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, HitReactionStateMachineName) == 0x000494, "Member 'UDCCharacterAnimInstanceBase::HitReactionStateMachineName' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, HitReactionStateName) == 0x00049C, "Member 'UDCCharacterAnimInstanceBase::HitReactionStateName' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, HitReactionFlipFlopStateName) == 0x0004A4, "Member 'UDCCharacterAnimInstanceBase::HitReactionFlipFlopStateName' has a wrong offset!");
static_assert(offsetof(UDCCharacterAnimInstanceBase, RigidPhysicsAsset) == 0x0004B0, "Member 'UDCCharacterAnimInstanceBase::RigidPhysicsAsset' has a wrong offset!");

// Class DungeonCrawler.DCGameplayEffectDataAsset
// 0x02A0 (0x02E8 - 0x0048)
class UDCGameplayEffectDataAsset final : public UDCTableDataAsset
{
public:
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0050(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectTargetType                     TargetType;                                        // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A8[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Duration;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrengthBase;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrengthMod;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VigorBase;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VigorMod;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgilityBase;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgilityMod;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DexterityBase;                                     // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DexterityMod;                                      // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WillBase;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WillMod;                                           // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeBase;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeMod;                                      // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcefulnessBase;                               // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcefulnessMod;                                // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecDamageWeaponRatio;                             // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageWeapon;                              // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageBase;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPhysicalDamageBase;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalPower;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageMod;                                 // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageAdd;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageTrue;                                // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPhysicalDamageTrue;                            // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalBackstabPower;                             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHeadshotPower;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHeadshotPenetration;                       // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorPenetration;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecArmorPenetration;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorRating;                                       // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemArmorRatingMod;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalReduction;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalReductionMod;                              // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalAbsoluteReduction;                         // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageWeapon;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageBase;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicalDamageBase;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalPower;                                      // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageMod;                                  // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageAdd;                                  // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageTrue;                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicalDamageTrue;                             // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicPenetration;                                  // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicPenetration;                              // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalFireDamageBase;                             // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalFireDamageMod;                              // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalFireDamageAdd;                              // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalIceDamageBase;                              // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalIceDamageMod;                               // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalIceDamageAdd;                               // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalArcaneDamageBase;                           // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalArcaneDamageMod;                            // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalArcaneDamageAdd;                            // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDarkDamageBase;                             // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDarkDamageMod;                              // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDarkDamageAdd;                              // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDivineDamageBase;                           // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDivineDamageMod;                            // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDivineDamageAdd;                            // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSpiritDamageBase;                           // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSpiritDamageMod;                            // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSpiritDamageAdd;                            // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UndeadDamageMod;                                   // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicResistance;                                   // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalReduction;                                  // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalReductionMod;                               // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalAbsoluteReduction;                          // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireMagicResistance;                               // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireMagicalReduction;                              // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireMagicalReductionMod;                           // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceMagicResistance;                                // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceMagicalReduction;                               // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceMagicalReductionMod;                            // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningMagicResistance;                          // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningMagicalReduction;                         // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningMagicalReductionMod;                      // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarthMagicResistance;                              // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarthMagicalReduction;                             // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarthMagicalReductionMod;                          // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMagicResistance;                              // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMagicalReduction;                             // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMagicalReductionMod;                          // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkMagicResistance;                               // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkMagicalReduction;                              // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkMagicalReductionMod;                           // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneMagicResistance;                             // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneMagicalReduction;                            // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneMagicalReductionMod;                         // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivineMagicResistance;                             // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivineMagicalReduction;                            // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivineMagicalReductionMod;                         // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvilMagicResistance;                               // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvilMagicalReduction;                              // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvilMagicalReductionMod;                           // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirMagicResistance;                                // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirMagicalReduction;                               // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirMagicalReductionMod;                            // 0x01DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritMagicResistance;                             // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritMagicalReduction;                            // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritMagicalReductionMod;                         // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadshotReductionMod;                              // 0x01EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileReductionMod;                            // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UndeadReductionMod;                                // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DemonReductionMod;                                 // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImpactPower;                                       // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecImpactPower;                                   // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecImpactEnduranceRestore;                        // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImpactResistance;                                  // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxImpactEndurance;                                // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAddHealthByCurHealthRatio;                     // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAddHealthByMaxHealthRatio;                     // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAddRecoverableHealth;                          // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHealBase;                                  // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPhysicalHealBase;                              // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHealMod;                                   // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHealingReceiveMod;                         // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalHealBase;                                   // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicalHealBase;                               // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalHealMod;                                    // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalHealingReceiveMod;                          // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecRecoveryHealBase;                              // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHealthMod;                                      // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHealthAdd;                                      // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddtionalAggroMod;                                 // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPhysicalShield;                                 // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMagicalShield;                                  // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalShield;                                    // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemoryCapacityMod;                                 // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemoryCapacityAdd;                                 // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpellCountMod;                                  // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedBase;                                     // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedMod;                                      // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedAdd;                                      // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedArmorPenaltyMod;                          // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionSpeed;                                       // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpellCastingSpeed;                                 // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemEquipSpeed;                                    // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegularInteractionSpeed;                           // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalInteractionSpeed;                           // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffDurationMod;                                   // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebuffDurationMod;                                 // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CooldownReductionMod;                              // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UtilityEffectivenessMod;                           // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UtilityEffectivenessAdd;                           // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightLimitMod;                                    // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightLimitAdd;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Luck;                                              // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ManualDexterity;                                   // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Persuasiveness;                                    // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersuasivenessBonusRatio;                          // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAttributeBonusRatio;                           // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecHealthCost;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecColdness;                                      // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPrimitiveCalcAdd;                              // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPrimitiveCalcMultiply;                         // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   GrantedTags;                                       // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AssetTags;                                         // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayEffectDataAsset">();
	}
	static class UDCGameplayEffectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayEffectDataAsset>();
	}
};
static_assert(alignof(UDCGameplayEffectDataAsset) == 0x000008, "Wrong alignment on UDCGameplayEffectDataAsset");
static_assert(sizeof(UDCGameplayEffectDataAsset) == 0x0002E8, "Wrong size on UDCGameplayEffectDataAsset");
static_assert(offsetof(UDCGameplayEffectDataAsset, EffectClass) == 0x000048, "Member 'UDCGameplayEffectDataAsset::EffectClass' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EventTag) == 0x000050, "Member 'UDCGameplayEffectDataAsset::EventTag' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, TargetType) == 0x000058, "Member 'UDCGameplayEffectDataAsset::TargetType' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, Duration) == 0x00005C, "Member 'UDCGameplayEffectDataAsset::Duration' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, StrengthBase) == 0x000060, "Member 'UDCGameplayEffectDataAsset::StrengthBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, StrengthMod) == 0x000064, "Member 'UDCGameplayEffectDataAsset::StrengthMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, VigorBase) == 0x000068, "Member 'UDCGameplayEffectDataAsset::VigorBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, VigorMod) == 0x00006C, "Member 'UDCGameplayEffectDataAsset::VigorMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AgilityBase) == 0x000070, "Member 'UDCGameplayEffectDataAsset::AgilityBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AgilityMod) == 0x000074, "Member 'UDCGameplayEffectDataAsset::AgilityMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DexterityBase) == 0x000078, "Member 'UDCGameplayEffectDataAsset::DexterityBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DexterityMod) == 0x00007C, "Member 'UDCGameplayEffectDataAsset::DexterityMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, WillBase) == 0x000080, "Member 'UDCGameplayEffectDataAsset::WillBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, WillMod) == 0x000084, "Member 'UDCGameplayEffectDataAsset::WillMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, KnowledgeBase) == 0x000088, "Member 'UDCGameplayEffectDataAsset::KnowledgeBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, KnowledgeMod) == 0x00008C, "Member 'UDCGameplayEffectDataAsset::KnowledgeMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ResourcefulnessBase) == 0x000090, "Member 'UDCGameplayEffectDataAsset::ResourcefulnessBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ResourcefulnessMod) == 0x000094, "Member 'UDCGameplayEffectDataAsset::ResourcefulnessMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecDamageWeaponRatio) == 0x000098, "Member 'UDCGameplayEffectDataAsset::ExecDamageWeaponRatio' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalDamageWeapon) == 0x00009C, "Member 'UDCGameplayEffectDataAsset::PhysicalDamageWeapon' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalDamageBase) == 0x0000A0, "Member 'UDCGameplayEffectDataAsset::PhysicalDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecPhysicalDamageBase) == 0x0000A4, "Member 'UDCGameplayEffectDataAsset::ExecPhysicalDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalPower) == 0x0000A8, "Member 'UDCGameplayEffectDataAsset::PhysicalPower' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalDamageMod) == 0x0000AC, "Member 'UDCGameplayEffectDataAsset::PhysicalDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalDamageAdd) == 0x0000B0, "Member 'UDCGameplayEffectDataAsset::PhysicalDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalDamageTrue) == 0x0000B4, "Member 'UDCGameplayEffectDataAsset::PhysicalDamageTrue' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecPhysicalDamageTrue) == 0x0000B8, "Member 'UDCGameplayEffectDataAsset::ExecPhysicalDamageTrue' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalBackstabPower) == 0x0000BC, "Member 'UDCGameplayEffectDataAsset::PhysicalBackstabPower' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalHeadshotPower) == 0x0000C0, "Member 'UDCGameplayEffectDataAsset::PhysicalHeadshotPower' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalHeadshotPenetration) == 0x0000C4, "Member 'UDCGameplayEffectDataAsset::PhysicalHeadshotPenetration' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ArmorPenetration) == 0x0000C8, "Member 'UDCGameplayEffectDataAsset::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecArmorPenetration) == 0x0000CC, "Member 'UDCGameplayEffectDataAsset::ExecArmorPenetration' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ArmorRating) == 0x0000D0, "Member 'UDCGameplayEffectDataAsset::ArmorRating' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ItemArmorRatingMod) == 0x0000D4, "Member 'UDCGameplayEffectDataAsset::ItemArmorRatingMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalReduction) == 0x0000D8, "Member 'UDCGameplayEffectDataAsset::PhysicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalReductionMod) == 0x0000DC, "Member 'UDCGameplayEffectDataAsset::PhysicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalAbsoluteReduction) == 0x0000E0, "Member 'UDCGameplayEffectDataAsset::PhysicalAbsoluteReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDamageWeapon) == 0x0000E4, "Member 'UDCGameplayEffectDataAsset::MagicalDamageWeapon' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDamageBase) == 0x0000E8, "Member 'UDCGameplayEffectDataAsset::MagicalDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecMagicalDamageBase) == 0x0000EC, "Member 'UDCGameplayEffectDataAsset::ExecMagicalDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalPower) == 0x0000F0, "Member 'UDCGameplayEffectDataAsset::MagicalPower' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDamageMod) == 0x0000F4, "Member 'UDCGameplayEffectDataAsset::MagicalDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDamageAdd) == 0x0000F8, "Member 'UDCGameplayEffectDataAsset::MagicalDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDamageTrue) == 0x0000FC, "Member 'UDCGameplayEffectDataAsset::MagicalDamageTrue' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecMagicalDamageTrue) == 0x000100, "Member 'UDCGameplayEffectDataAsset::ExecMagicalDamageTrue' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicPenetration) == 0x000104, "Member 'UDCGameplayEffectDataAsset::MagicPenetration' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecMagicPenetration) == 0x000108, "Member 'UDCGameplayEffectDataAsset::ExecMagicPenetration' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalFireDamageBase) == 0x00010C, "Member 'UDCGameplayEffectDataAsset::MagicalFireDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalFireDamageMod) == 0x000110, "Member 'UDCGameplayEffectDataAsset::MagicalFireDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalFireDamageAdd) == 0x000114, "Member 'UDCGameplayEffectDataAsset::MagicalFireDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalIceDamageBase) == 0x000118, "Member 'UDCGameplayEffectDataAsset::MagicalIceDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalIceDamageMod) == 0x00011C, "Member 'UDCGameplayEffectDataAsset::MagicalIceDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalIceDamageAdd) == 0x000120, "Member 'UDCGameplayEffectDataAsset::MagicalIceDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalArcaneDamageBase) == 0x000124, "Member 'UDCGameplayEffectDataAsset::MagicalArcaneDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalArcaneDamageMod) == 0x000128, "Member 'UDCGameplayEffectDataAsset::MagicalArcaneDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalArcaneDamageAdd) == 0x00012C, "Member 'UDCGameplayEffectDataAsset::MagicalArcaneDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDarkDamageBase) == 0x000130, "Member 'UDCGameplayEffectDataAsset::MagicalDarkDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDarkDamageMod) == 0x000134, "Member 'UDCGameplayEffectDataAsset::MagicalDarkDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDarkDamageAdd) == 0x000138, "Member 'UDCGameplayEffectDataAsset::MagicalDarkDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDivineDamageBase) == 0x00013C, "Member 'UDCGameplayEffectDataAsset::MagicalDivineDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDivineDamageMod) == 0x000140, "Member 'UDCGameplayEffectDataAsset::MagicalDivineDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalDivineDamageAdd) == 0x000144, "Member 'UDCGameplayEffectDataAsset::MagicalDivineDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalSpiritDamageBase) == 0x000148, "Member 'UDCGameplayEffectDataAsset::MagicalSpiritDamageBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalSpiritDamageMod) == 0x00014C, "Member 'UDCGameplayEffectDataAsset::MagicalSpiritDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalSpiritDamageAdd) == 0x000150, "Member 'UDCGameplayEffectDataAsset::MagicalSpiritDamageAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, UndeadDamageMod) == 0x000154, "Member 'UDCGameplayEffectDataAsset::UndeadDamageMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicResistance) == 0x000158, "Member 'UDCGameplayEffectDataAsset::MagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalReduction) == 0x00015C, "Member 'UDCGameplayEffectDataAsset::MagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalReductionMod) == 0x000160, "Member 'UDCGameplayEffectDataAsset::MagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalAbsoluteReduction) == 0x000164, "Member 'UDCGameplayEffectDataAsset::MagicalAbsoluteReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, FireMagicResistance) == 0x000168, "Member 'UDCGameplayEffectDataAsset::FireMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, FireMagicalReduction) == 0x00016C, "Member 'UDCGameplayEffectDataAsset::FireMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, FireMagicalReductionMod) == 0x000170, "Member 'UDCGameplayEffectDataAsset::FireMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, IceMagicResistance) == 0x000174, "Member 'UDCGameplayEffectDataAsset::IceMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, IceMagicalReduction) == 0x000178, "Member 'UDCGameplayEffectDataAsset::IceMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, IceMagicalReductionMod) == 0x00017C, "Member 'UDCGameplayEffectDataAsset::IceMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, LightningMagicResistance) == 0x000180, "Member 'UDCGameplayEffectDataAsset::LightningMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, LightningMagicalReduction) == 0x000184, "Member 'UDCGameplayEffectDataAsset::LightningMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, LightningMagicalReductionMod) == 0x000188, "Member 'UDCGameplayEffectDataAsset::LightningMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EarthMagicResistance) == 0x00018C, "Member 'UDCGameplayEffectDataAsset::EarthMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EarthMagicalReduction) == 0x000190, "Member 'UDCGameplayEffectDataAsset::EarthMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EarthMagicalReductionMod) == 0x000194, "Member 'UDCGameplayEffectDataAsset::EarthMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, LightMagicResistance) == 0x000198, "Member 'UDCGameplayEffectDataAsset::LightMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, LightMagicalReduction) == 0x00019C, "Member 'UDCGameplayEffectDataAsset::LightMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, LightMagicalReductionMod) == 0x0001A0, "Member 'UDCGameplayEffectDataAsset::LightMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DarkMagicResistance) == 0x0001A4, "Member 'UDCGameplayEffectDataAsset::DarkMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DarkMagicalReduction) == 0x0001A8, "Member 'UDCGameplayEffectDataAsset::DarkMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DarkMagicalReductionMod) == 0x0001AC, "Member 'UDCGameplayEffectDataAsset::DarkMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ArcaneMagicResistance) == 0x0001B0, "Member 'UDCGameplayEffectDataAsset::ArcaneMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ArcaneMagicalReduction) == 0x0001B4, "Member 'UDCGameplayEffectDataAsset::ArcaneMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ArcaneMagicalReductionMod) == 0x0001B8, "Member 'UDCGameplayEffectDataAsset::ArcaneMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DivineMagicResistance) == 0x0001BC, "Member 'UDCGameplayEffectDataAsset::DivineMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DivineMagicalReduction) == 0x0001C0, "Member 'UDCGameplayEffectDataAsset::DivineMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DivineMagicalReductionMod) == 0x0001C4, "Member 'UDCGameplayEffectDataAsset::DivineMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EvilMagicResistance) == 0x0001C8, "Member 'UDCGameplayEffectDataAsset::EvilMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EvilMagicalReduction) == 0x0001CC, "Member 'UDCGameplayEffectDataAsset::EvilMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, EvilMagicalReductionMod) == 0x0001D0, "Member 'UDCGameplayEffectDataAsset::EvilMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AirMagicResistance) == 0x0001D4, "Member 'UDCGameplayEffectDataAsset::AirMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AirMagicalReduction) == 0x0001D8, "Member 'UDCGameplayEffectDataAsset::AirMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AirMagicalReductionMod) == 0x0001DC, "Member 'UDCGameplayEffectDataAsset::AirMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, SpiritMagicResistance) == 0x0001E0, "Member 'UDCGameplayEffectDataAsset::SpiritMagicResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, SpiritMagicalReduction) == 0x0001E4, "Member 'UDCGameplayEffectDataAsset::SpiritMagicalReduction' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, SpiritMagicalReductionMod) == 0x0001E8, "Member 'UDCGameplayEffectDataAsset::SpiritMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, HeadshotReductionMod) == 0x0001EC, "Member 'UDCGameplayEffectDataAsset::HeadshotReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ProjectileReductionMod) == 0x0001F0, "Member 'UDCGameplayEffectDataAsset::ProjectileReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, UndeadReductionMod) == 0x0001F4, "Member 'UDCGameplayEffectDataAsset::UndeadReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DemonReductionMod) == 0x0001F8, "Member 'UDCGameplayEffectDataAsset::DemonReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ImpactPower) == 0x0001FC, "Member 'UDCGameplayEffectDataAsset::ImpactPower' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecImpactPower) == 0x000200, "Member 'UDCGameplayEffectDataAsset::ExecImpactPower' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecImpactEnduranceRestore) == 0x000204, "Member 'UDCGameplayEffectDataAsset::ExecImpactEnduranceRestore' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ImpactResistance) == 0x000208, "Member 'UDCGameplayEffectDataAsset::ImpactResistance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxImpactEndurance) == 0x00020C, "Member 'UDCGameplayEffectDataAsset::MaxImpactEndurance' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecAddHealthByCurHealthRatio) == 0x000210, "Member 'UDCGameplayEffectDataAsset::ExecAddHealthByCurHealthRatio' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecAddHealthByMaxHealthRatio) == 0x000214, "Member 'UDCGameplayEffectDataAsset::ExecAddHealthByMaxHealthRatio' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecAddRecoverableHealth) == 0x000218, "Member 'UDCGameplayEffectDataAsset::ExecAddRecoverableHealth' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalHealBase) == 0x00021C, "Member 'UDCGameplayEffectDataAsset::PhysicalHealBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecPhysicalHealBase) == 0x000220, "Member 'UDCGameplayEffectDataAsset::ExecPhysicalHealBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalHealMod) == 0x000224, "Member 'UDCGameplayEffectDataAsset::PhysicalHealMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PhysicalHealingReceiveMod) == 0x000228, "Member 'UDCGameplayEffectDataAsset::PhysicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalHealBase) == 0x00022C, "Member 'UDCGameplayEffectDataAsset::MagicalHealBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecMagicalHealBase) == 0x000230, "Member 'UDCGameplayEffectDataAsset::ExecMagicalHealBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalHealMod) == 0x000234, "Member 'UDCGameplayEffectDataAsset::MagicalHealMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalHealingReceiveMod) == 0x000238, "Member 'UDCGameplayEffectDataAsset::MagicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecRecoveryHealBase) == 0x00023C, "Member 'UDCGameplayEffectDataAsset::ExecRecoveryHealBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxHealthMod) == 0x000240, "Member 'UDCGameplayEffectDataAsset::MaxHealthMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxHealthAdd) == 0x000244, "Member 'UDCGameplayEffectDataAsset::MaxHealthAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AddtionalAggroMod) == 0x000248, "Member 'UDCGameplayEffectDataAsset::AddtionalAggroMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxPhysicalShield) == 0x00024C, "Member 'UDCGameplayEffectDataAsset::MaxPhysicalShield' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxMagicalShield) == 0x000250, "Member 'UDCGameplayEffectDataAsset::MaxMagicalShield' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxTotalShield) == 0x000254, "Member 'UDCGameplayEffectDataAsset::MaxTotalShield' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MemoryCapacityMod) == 0x000258, "Member 'UDCGameplayEffectDataAsset::MemoryCapacityMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MemoryCapacityAdd) == 0x00025C, "Member 'UDCGameplayEffectDataAsset::MemoryCapacityAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MaxSpellCountMod) == 0x000260, "Member 'UDCGameplayEffectDataAsset::MaxSpellCountMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MoveSpeedBase) == 0x000264, "Member 'UDCGameplayEffectDataAsset::MoveSpeedBase' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MoveSpeedMod) == 0x000268, "Member 'UDCGameplayEffectDataAsset::MoveSpeedMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MoveSpeedAdd) == 0x00026C, "Member 'UDCGameplayEffectDataAsset::MoveSpeedAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MoveSpeedArmorPenaltyMod) == 0x000270, "Member 'UDCGameplayEffectDataAsset::MoveSpeedArmorPenaltyMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ActionSpeed) == 0x000274, "Member 'UDCGameplayEffectDataAsset::ActionSpeed' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, SpellCastingSpeed) == 0x000278, "Member 'UDCGameplayEffectDataAsset::SpellCastingSpeed' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ItemEquipSpeed) == 0x00027C, "Member 'UDCGameplayEffectDataAsset::ItemEquipSpeed' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, RegularInteractionSpeed) == 0x000280, "Member 'UDCGameplayEffectDataAsset::RegularInteractionSpeed' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, MagicalInteractionSpeed) == 0x000284, "Member 'UDCGameplayEffectDataAsset::MagicalInteractionSpeed' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, BuffDurationMod) == 0x000288, "Member 'UDCGameplayEffectDataAsset::BuffDurationMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, DebuffDurationMod) == 0x00028C, "Member 'UDCGameplayEffectDataAsset::DebuffDurationMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, CooldownReductionMod) == 0x000290, "Member 'UDCGameplayEffectDataAsset::CooldownReductionMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, UtilityEffectivenessMod) == 0x000294, "Member 'UDCGameplayEffectDataAsset::UtilityEffectivenessMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, UtilityEffectivenessAdd) == 0x000298, "Member 'UDCGameplayEffectDataAsset::UtilityEffectivenessAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, WeightLimitMod) == 0x00029C, "Member 'UDCGameplayEffectDataAsset::WeightLimitMod' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, WeightLimitAdd) == 0x0002A0, "Member 'UDCGameplayEffectDataAsset::WeightLimitAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, Luck) == 0x0002A4, "Member 'UDCGameplayEffectDataAsset::Luck' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ManualDexterity) == 0x0002A8, "Member 'UDCGameplayEffectDataAsset::ManualDexterity' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, Persuasiveness) == 0x0002AC, "Member 'UDCGameplayEffectDataAsset::Persuasiveness' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, PersuasivenessBonusRatio) == 0x0002B0, "Member 'UDCGameplayEffectDataAsset::PersuasivenessBonusRatio' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecAttributeBonusRatio) == 0x0002B4, "Member 'UDCGameplayEffectDataAsset::ExecAttributeBonusRatio' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecHealthCost) == 0x0002B8, "Member 'UDCGameplayEffectDataAsset::ExecHealthCost' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecColdness) == 0x0002BC, "Member 'UDCGameplayEffectDataAsset::ExecColdness' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecPrimitiveCalcAdd) == 0x0002C0, "Member 'UDCGameplayEffectDataAsset::ExecPrimitiveCalcAdd' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, ExecPrimitiveCalcMultiply) == 0x0002C4, "Member 'UDCGameplayEffectDataAsset::ExecPrimitiveCalcMultiply' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, GrantedTags) == 0x0002C8, "Member 'UDCGameplayEffectDataAsset::GrantedTags' has a wrong offset!");
static_assert(offsetof(UDCGameplayEffectDataAsset, AssetTags) == 0x0002D8, "Member 'UDCGameplayEffectDataAsset::AssetTags' has a wrong offset!");

// Class DungeonCrawler.DCCharacterInfoWidget
// 0x0020 (0x0378 - 0x0358)
class UDCCharacterInfoWidget final : public UDCWidgetBase
{
public:
	class UDCCaptureStudioWidget*                 CaptureStudioWidget;                               // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryStatusWidget*                 StatusWidget;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventorySkillListWidgetBase*          SkillsWidget;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryPerkListWidgetBase*           PerksWidget;                                       // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetLevelAndFame(int32 Level, int32 Fame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterInfoWidget">();
	}
	static class UDCCharacterInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterInfoWidget>();
	}
};
static_assert(alignof(UDCCharacterInfoWidget) == 0x000008, "Wrong alignment on UDCCharacterInfoWidget");
static_assert(sizeof(UDCCharacterInfoWidget) == 0x000378, "Wrong size on UDCCharacterInfoWidget");
static_assert(offsetof(UDCCharacterInfoWidget, CaptureStudioWidget) == 0x000358, "Member 'UDCCharacterInfoWidget::CaptureStudioWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInfoWidget, StatusWidget) == 0x000360, "Member 'UDCCharacterInfoWidget::StatusWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInfoWidget, SkillsWidget) == 0x000368, "Member 'UDCCharacterInfoWidget::SkillsWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterInfoWidget, PerksWidget) == 0x000370, "Member 'UDCCharacterInfoWidget::PerksWidget' has a wrong offset!");

// Class DungeonCrawler.DCCharacterV2
// 0x00C0 (0x0740 - 0x0680)
#pragma pack(push, 0x1)
class alignas(0x10) ADCCharacterV2 : public ACharacter
{
public:
	uint8                                         Pad_25A9[0x10];                                    // 0x0678(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 PartHead;                                          // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartGloves;                                        // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCPlayerCharacterKey                  CharacterKey;                                      // 0x0698(0x0002)(Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25AA[0x6];                                     // 0x069A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                CharacterPerks;                                    // 0x06A0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartTongue;                                        // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartHelmet;                                        // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartChest;                                         // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartPants;                                         // 0x06C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartBoots;                                         // 0x06D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartBack;                                          // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PartTail;                                          // 0x06E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterDataComponent*              CharacterDataComponent;                            // 0x06E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterPartsComponent*             CharacterPartsComponent;                           // 0x06F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterSkinComponent*              CharacterSkinComponent;                            // 0x06F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCItemSkinComponent*                   ItemSkinComponent;                                 // 0x0700(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCArmorSkinComponent*                  ArmorSkinComponent;                                // 0x0708(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCActionSkinComponent*                 ActionSkinComponent;                               // 0x0710(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x0718(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCEquipmentComponent*                  EquipmentComponent;                                // 0x0720(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCPerkDataComponent*                   PerkDataComponent;                                 // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterAbilitySystemComponent*     AbilitySystemComponent;                            // 0x0730(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class USkeletalMeshComponent* GetPartHeadComponent() const;
	class UDCPerkDataComponent* GetPerkDataComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterV2">();
	}
	static class ADCCharacterV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCharacterV2>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADCCharacterV2) == 0x000010, "Wrong alignment on ADCCharacterV2");
static_assert(sizeof(ADCCharacterV2) == 0x000740, "Wrong size on ADCCharacterV2");
static_assert(offsetof(ADCCharacterV2, PartHead) == 0x000688, "Member 'ADCCharacterV2::PartHead' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartGloves) == 0x000690, "Member 'ADCCharacterV2::PartGloves' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, CharacterKey) == 0x000698, "Member 'ADCCharacterV2::CharacterKey' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, CharacterPerks) == 0x0006A0, "Member 'ADCCharacterV2::CharacterPerks' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartTongue) == 0x0006B0, "Member 'ADCCharacterV2::PartTongue' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartHelmet) == 0x0006B8, "Member 'ADCCharacterV2::PartHelmet' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartChest) == 0x0006C0, "Member 'ADCCharacterV2::PartChest' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartPants) == 0x0006C8, "Member 'ADCCharacterV2::PartPants' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartBoots) == 0x0006D0, "Member 'ADCCharacterV2::PartBoots' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartBack) == 0x0006D8, "Member 'ADCCharacterV2::PartBack' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PartTail) == 0x0006E0, "Member 'ADCCharacterV2::PartTail' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, CharacterDataComponent) == 0x0006E8, "Member 'ADCCharacterV2::CharacterDataComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, CharacterPartsComponent) == 0x0006F0, "Member 'ADCCharacterV2::CharacterPartsComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, CharacterSkinComponent) == 0x0006F8, "Member 'ADCCharacterV2::CharacterSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, ItemSkinComponent) == 0x000700, "Member 'ADCCharacterV2::ItemSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, ArmorSkinComponent) == 0x000708, "Member 'ADCCharacterV2::ArmorSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, ActionSkinComponent) == 0x000710, "Member 'ADCCharacterV2::ActionSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, InventoryComponent) == 0x000718, "Member 'ADCCharacterV2::InventoryComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, EquipmentComponent) == 0x000720, "Member 'ADCCharacterV2::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, PerkDataComponent) == 0x000728, "Member 'ADCCharacterV2::PerkDataComponent' has a wrong offset!");
static_assert(offsetof(ADCCharacterV2, AbilitySystemComponent) == 0x000730, "Member 'ADCCharacterV2::AbilitySystemComponent' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterV2
// 0x0020 (0x0760 - 0x0740)
class ADCPlayerCharacterV2 : public ADCCharacterV2
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0738(0x0010)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCPartyId                             PartyId;                                           // 0x0748(0x0010)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25AB[0x8];                                     // 0x0758(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AccountId(const struct FDCAccountId& OldAccountId);
	void OnRep_PartyId(const struct FDCPartyId& OldPartyId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterV2">();
	}
	static class ADCPlayerCharacterV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerCharacterV2>();
	}
};
static_assert(alignof(ADCPlayerCharacterV2) == 0x000010, "Wrong alignment on ADCPlayerCharacterV2");
static_assert(sizeof(ADCPlayerCharacterV2) == 0x000760, "Wrong size on ADCPlayerCharacterV2");
static_assert(offsetof(ADCPlayerCharacterV2, AccountId) == 0x000738, "Member 'ADCPlayerCharacterV2::AccountId' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterV2, PartyId) == 0x000748, "Member 'ADCPlayerCharacterV2::PartyId' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTrace
// 0x0010 (0x03F0 - 0x03E0)
#pragma pack(push, 0x1)
class alignas(0x10) ADCGATA_AimTrace : public AGameplayAbilityTargetActor
{
public:
	float                                         MaxRange;                                          // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25AC[0x3];                                     // 0x03E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTrace">();
	}
	static class ADCGATA_AimTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTrace>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADCGATA_AimTrace) == 0x000010, "Wrong alignment on ADCGATA_AimTrace");
static_assert(sizeof(ADCGATA_AimTrace) == 0x0003F0, "Wrong size on ADCGATA_AimTrace");
static_assert(offsetof(ADCGATA_AimTrace, MaxRange) == 0x0003E0, "Member 'ADCGATA_AimTrace::MaxRange' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTrace, TraceChannel) == 0x0003E4, "Member 'ADCGATA_AimTrace::TraceChannel' has a wrong offset!");

// Class DungeonCrawler.DCCharacterLobbyCapture
// 0x01B0 (0x0910 - 0x0760)
#pragma pack(push, 0x1)
class alignas(0x10) ADCCharacterLobbyCapture : public ADCPlayerCharacterV2
{
public:
	uint8                                         Pad_25AD[0x50];                                    // 0x0760(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x07B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAbilitySpecHandle             LobbyPoseAbilitySpecHandle;                        // 0x07B8(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWidgetPartyUserLocate                        PartyUserLocate;                                   // 0x07BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25AE[0x3];                                     // 0x07BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLink*                           AccountLink;                                       // 0x07C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25AF[0xE0];                                    // 0x07C8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int64, class AActor*>                    ContainingActorMap;                                // 0x08A8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FItemData>                      ContainingItemDataArray;                           // 0x08F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	struct FNickname GetNickname();
	void OnLobbyPoseSkinChanged(const class UDCActionSkinDataAsset* ActionSkinData, const bool bIsEquipped);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	EWidgetPartyUserLocate GetPartyLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterLobbyCapture">();
	}
	static class ADCCharacterLobbyCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCharacterLobbyCapture>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADCCharacterLobbyCapture) == 0x000010, "Wrong alignment on ADCCharacterLobbyCapture");
static_assert(sizeof(ADCCharacterLobbyCapture) == 0x000910, "Wrong size on ADCCharacterLobbyCapture");
static_assert(offsetof(ADCCharacterLobbyCapture, BaseObject) == 0x0007B0, "Member 'ADCCharacterLobbyCapture::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCCharacterLobbyCapture, LobbyPoseAbilitySpecHandle) == 0x0007B8, "Member 'ADCCharacterLobbyCapture::LobbyPoseAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(ADCCharacterLobbyCapture, PartyUserLocate) == 0x0007BC, "Member 'ADCCharacterLobbyCapture::PartyUserLocate' has a wrong offset!");
static_assert(offsetof(ADCCharacterLobbyCapture, AccountLink) == 0x0007C0, "Member 'ADCCharacterLobbyCapture::AccountLink' has a wrong offset!");
static_assert(offsetof(ADCCharacterLobbyCapture, ContainingActorMap) == 0x0008A8, "Member 'ADCCharacterLobbyCapture::ContainingActorMap' has a wrong offset!");
static_assert(offsetof(ADCCharacterLobbyCapture, ContainingItemDataArray) == 0x0008F8, "Member 'ADCCharacterLobbyCapture::ContainingItemDataArray' has a wrong offset!");

// Class DungeonCrawler.DCCharacterLobbyCaptureMine
// 0x0010 (0x0920 - 0x0910)
class ADCCharacterLobbyCaptureMine final : public ADCCharacterLobbyCapture
{
public:
	uint8                                         Pad_25B1[0x18];                                    // 0x0908(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterLobbyCaptureMine">();
	}
	static class ADCCharacterLobbyCaptureMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCharacterLobbyCaptureMine>();
	}
};
static_assert(alignof(ADCCharacterLobbyCaptureMine) == 0x000010, "Wrong alignment on ADCCharacterLobbyCaptureMine");
static_assert(sizeof(ADCCharacterLobbyCaptureMine) == 0x000920, "Wrong size on ADCCharacterLobbyCaptureMine");

// Class DungeonCrawler.GA_PlayerShapeShiftCastBase
// 0x0028 (0x05C8 - 0x05A0)
class UGA_PlayerShapeShiftCastBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B2[0x8];                                     // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDCShapeShiftDataAsset>  CurrentShapeShiftDataAsset;                        // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25B3[0x10];                                    // 0x05B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCastTriggerSync();
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnFinish();
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnStartSync();
	void SendActivateShapeShiftCrossHairNotify(bool IsActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerShapeShiftCastBase">();
	}
	static class UGA_PlayerShapeShiftCastBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerShapeShiftCastBase>();
	}
};
static_assert(alignof(UGA_PlayerShapeShiftCastBase) == 0x000008, "Wrong alignment on UGA_PlayerShapeShiftCastBase");
static_assert(sizeof(UGA_PlayerShapeShiftCastBase) == 0x0005C8, "Wrong size on UGA_PlayerShapeShiftCastBase");
static_assert(offsetof(UGA_PlayerShapeShiftCastBase, MontageToPlay) == 0x0005A0, "Member 'UGA_PlayerShapeShiftCastBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftCastBase, CurrentShapeShiftDataAsset) == 0x0005B0, "Member 'UGA_PlayerShapeShiftCastBase::CurrentShapeShiftDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCGameSettings
// 0x0040 (0x0078 - 0x0038)
class UDCGameSettings final : public UDeveloperSettings
{
public:
	TArray<struct FServerInfo>                    ServerList;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bApply_DedicatedServerComponent;                   // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B4[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BlackList_DedicatedServerComponent;                // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         WhiteList_DedicatedServerComponent;                // 0x0060(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bApply_SubmitEngineConfigToIronShield;             // 0x0070(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B5[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSettings">();
	}
	static class UDCGameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameSettings>();
	}
};
static_assert(alignof(UDCGameSettings) == 0x000008, "Wrong alignment on UDCGameSettings");
static_assert(sizeof(UDCGameSettings) == 0x000078, "Wrong size on UDCGameSettings");
static_assert(offsetof(UDCGameSettings, ServerList) == 0x000038, "Member 'UDCGameSettings::ServerList' has a wrong offset!");
static_assert(offsetof(UDCGameSettings, bApply_DedicatedServerComponent) == 0x000048, "Member 'UDCGameSettings::bApply_DedicatedServerComponent' has a wrong offset!");
static_assert(offsetof(UDCGameSettings, BlackList_DedicatedServerComponent) == 0x000050, "Member 'UDCGameSettings::BlackList_DedicatedServerComponent' has a wrong offset!");
static_assert(offsetof(UDCGameSettings, WhiteList_DedicatedServerComponent) == 0x000060, "Member 'UDCGameSettings::WhiteList_DedicatedServerComponent' has a wrong offset!");
static_assert(offsetof(UDCGameSettings, bApply_SubmitEngineConfigToIronShield) == 0x000070, "Member 'UDCGameSettings::bApply_SubmitEngineConfigToIronShield' has a wrong offset!");

// Class DungeonCrawler.DCCharacterMovementComponent
// 0x0080 (0x0FD0 - 0x0F50)
class UDCCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_25B6[0x29];                                    // 0x0F48(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceUpdateClientSmooth;                          // 0x0F71(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B7[0xE];                                     // 0x0F72(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UCannotMoveGameplayTagData*             CannotMoveGameplayTagData;                         // 0x0F80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnockBackImmuneGameplayTagData*        KnockBackImmuneGameplayTagData;                    // 0x0F88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25B8[0x40];                                    // 0x0F90(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMovementModifier(const struct FDesignDataMovementModifier& MovementModifier);
	void AddMovementModifiers(const TArray<struct FDesignDataMovementModifier>& MovementModifiers);
	bool IsInputProcessing();
	void RemoveMovementModifier(const struct FDesignDataMovementModifier& MovementModifier);
	void RemoveMovementModifiers(const TArray<struct FDesignDataMovementModifier>& MovementModifiers);
	void SetInputProcessing(bool bSet);
	void SetIsTrapped(bool InbIsTrapped, const struct FVector& InTrapPinnedLocation, float InTrapRange);
	void SetWindForce(const struct FVector& WindVector);

	bool IsAffectedByWindForce() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterMovementComponent">();
	}
	static class UDCCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterMovementComponent>();
	}
};
static_assert(alignof(UDCCharacterMovementComponent) == 0x000010, "Wrong alignment on UDCCharacterMovementComponent");
static_assert(sizeof(UDCCharacterMovementComponent) == 0x000FD0, "Wrong size on UDCCharacterMovementComponent");
static_assert(offsetof(UDCCharacterMovementComponent, bForceUpdateClientSmooth) == 0x000F71, "Member 'UDCCharacterMovementComponent::bForceUpdateClientSmooth' has a wrong offset!");
static_assert(offsetof(UDCCharacterMovementComponent, CannotMoveGameplayTagData) == 0x000F80, "Member 'UDCCharacterMovementComponent::CannotMoveGameplayTagData' has a wrong offset!");
static_assert(offsetof(UDCCharacterMovementComponent, KnockBackImmuneGameplayTagData) == 0x000F88, "Member 'UDCCharacterMovementComponent::KnockBackImmuneGameplayTagData' has a wrong offset!");

// Class DungeonCrawler.DCGameplayEffectUIData
// 0x0008 (0x0030 - 0x0028)
class UDCGameplayEffectUIData final : public UGameplayEffectUIData
{
public:
	class UActorStatusUIData*                     UIDataAsset;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayEffectUIData">();
	}
	static class UDCGameplayEffectUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayEffectUIData>();
	}
};
static_assert(alignof(UDCGameplayEffectUIData) == 0x000008, "Wrong alignment on UDCGameplayEffectUIData");
static_assert(sizeof(UDCGameplayEffectUIData) == 0x000030, "Wrong size on UDCGameplayEffectUIData");
static_assert(offsetof(UDCGameplayEffectUIData, UIDataAsset) == 0x000028, "Member 'UDCGameplayEffectUIData::UIDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCCharacterProduction
// 0x0050 (0x06D0 - 0x0680)
class ADCCharacterProduction final : public ACharacter
{
public:
	uint8                                         Pad_25BB[0x8];                                     // 0x0678(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 PartHead;                                          // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, EditConst, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartHelmet;                                        // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartGloves;                                        // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartChest;                                         // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartPants;                                         // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBoots;                                         // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBack;                                          // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         ItemAssetIDList;                                   // 0x06B8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SkelMesh;                                          // 0x06C8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnItemEquip();
	void OnRep_ChangeHeadMesh();
	void OnRep_ItemDataList(const TArray<class FString>& OldItemAssetIDList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterProduction">();
	}
	static class ADCCharacterProduction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCharacterProduction>();
	}
};
static_assert(alignof(ADCCharacterProduction) == 0x000010, "Wrong alignment on ADCCharacterProduction");
static_assert(sizeof(ADCCharacterProduction) == 0x0006D0, "Wrong size on ADCCharacterProduction");
static_assert(offsetof(ADCCharacterProduction, PartHead) == 0x000680, "Member 'ADCCharacterProduction::PartHead' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, PartHelmet) == 0x000688, "Member 'ADCCharacterProduction::PartHelmet' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, PartGloves) == 0x000690, "Member 'ADCCharacterProduction::PartGloves' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, PartChest) == 0x000698, "Member 'ADCCharacterProduction::PartChest' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, PartPants) == 0x0006A0, "Member 'ADCCharacterProduction::PartPants' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, PartBoots) == 0x0006A8, "Member 'ADCCharacterProduction::PartBoots' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, PartBack) == 0x0006B0, "Member 'ADCCharacterProduction::PartBack' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, ItemAssetIDList) == 0x0006B8, "Member 'ADCCharacterProduction::ItemAssetIDList' has a wrong offset!");
static_assert(offsetof(ADCCharacterProduction, SkelMesh) == 0x0006C8, "Member 'ADCCharacterProduction::SkelMesh' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSelectCapture
// 0x0000 (0x0910 - 0x0910)
class ADCCharacterSelectCapture : public ADCCharacterLobbyCapture
{
public:
	bool                                          bIsEmpty;                                          // 0x0908(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25BC[0x7];                                     // 0x0909(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSelectCapture">();
	}
	static class ADCCharacterSelectCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCCharacterSelectCapture>();
	}
};
static_assert(alignof(ADCCharacterSelectCapture) == 0x000010, "Wrong alignment on ADCCharacterSelectCapture");
static_assert(sizeof(ADCCharacterSelectCapture) == 0x000910, "Wrong size on ADCCharacterSelectCapture");
static_assert(offsetof(ADCCharacterSelectCapture, bIsEmpty) == 0x000908, "Member 'ADCCharacterSelectCapture::bIsEmpty' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillBase
// 0x0130 (0x06D0 - 0x05A0)
class UGA_PlayerSkillBase : public UDCGameplayAbilityBase
{
public:
	bool                                          bShouldHideEquipmentUntilAbilityEnds;              // 0x05A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldHideEquipmentUntilAnimationEnds;            // 0x05A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BD[0x6];                                     // 0x05A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreTypes;                                       // 0x05A8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentSkillActor;                                 // 0x05C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAsyncTaskEffectStackChanged*           EffectStackAsyncTask;                              // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BE[0xF0];                                    // 0x05D8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillMessageDuration;                              // 0x06C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BF[0x4];                                     // 0x06CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ClientOnSkillActivate(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCooldownStarted(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag, float CooldownDuration);
	void OnCooldownTagApplied(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount);
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnSkillActivateNotify(const struct FGameplayEventData& EventData);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ServerOnSkillActivate(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag);
	void SetEquippedItemsHidden(bool bShouldHide);

	const struct FDesignDataSkill GetCurrentDesignDataSkill() const;
	float GetRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillBase">();
	}
	static class UGA_PlayerSkillBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillBase");
static_assert(sizeof(UGA_PlayerSkillBase) == 0x0006D0, "Wrong size on UGA_PlayerSkillBase");
static_assert(offsetof(UGA_PlayerSkillBase, bShouldHideEquipmentUntilAbilityEnds) == 0x0005A0, "Member 'UGA_PlayerSkillBase::bShouldHideEquipmentUntilAbilityEnds' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillBase, bShouldHideEquipmentUntilAnimationEnds) == 0x0005A1, "Member 'UGA_PlayerSkillBase::bShouldHideEquipmentUntilAnimationEnds' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillBase, IgnoreTypes) == 0x0005A8, "Member 'UGA_PlayerSkillBase::IgnoreTypes' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillBase, CurrentSkillActor) == 0x0005C8, "Member 'UGA_PlayerSkillBase::CurrentSkillActor' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillBase, EffectStackAsyncTask) == 0x0005D0, "Member 'UGA_PlayerSkillBase::EffectStackAsyncTask' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillBase, SkillMessageDuration) == 0x0006C8, "Member 'UGA_PlayerSkillBase::SkillMessageDuration' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillCastBase
// 0x00E8 (0x07B8 - 0x06D0)
class UGA_PlayerSkillCastBase : public UGA_PlayerSkillBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C0[0xE0];                                    // 0x06D8(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCastingFinish();
	void OnCastingFinishSync();
	void OnCastingStartSync();
	void OnCastingStartTrigger();
	void OnVelocityChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillCastBase">();
	}
	static class UGA_PlayerSkillCastBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillCastBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillCastBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillCastBase");
static_assert(sizeof(UGA_PlayerSkillCastBase) == 0x0007B8, "Wrong size on UGA_PlayerSkillCastBase");
static_assert(offsetof(UGA_PlayerSkillCastBase, MontageToPlay) == 0x0006D0, "Member 'UGA_PlayerSkillCastBase::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillCastShapeShiftBase
// 0x0008 (0x07C0 - 0x07B8)
class UGA_PlayerSkillCastShapeShiftBase final : public UGA_PlayerSkillCastBase
{
public:
	struct FGameplayTag                           ShapeShiftTag;                                     // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillCastShapeShiftBase">();
	}
	static class UGA_PlayerSkillCastShapeShiftBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillCastShapeShiftBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillCastShapeShiftBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillCastShapeShiftBase");
static_assert(sizeof(UGA_PlayerSkillCastShapeShiftBase) == 0x0007C0, "Wrong size on UGA_PlayerSkillCastShapeShiftBase");
static_assert(offsetof(UGA_PlayerSkillCastShapeShiftBase, ShapeShiftTag) == 0x0007B8, "Member 'UGA_PlayerSkillCastShapeShiftBase::ShapeShiftTag' has a wrong offset!");

// Class DungeonCrawler.DCGameTooltipWithFlavorTextWidget
// 0x0048 (0x0308 - 0x02C0)
class UDCGameTooltipWithFlavorTextWidget : public UUserWidget
{
public:
	class FText                                   TitleText;                                         // 0x02C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   DescriptionText;                                   // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   FlavorText;                                        // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	ESlateVisibility GetDescriptionVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameTooltipWithFlavorTextWidget">();
	}
	static class UDCGameTooltipWithFlavorTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameTooltipWithFlavorTextWidget>();
	}
};
static_assert(alignof(UDCGameTooltipWithFlavorTextWidget) == 0x000008, "Wrong alignment on UDCGameTooltipWithFlavorTextWidget");
static_assert(sizeof(UDCGameTooltipWithFlavorTextWidget) == 0x000308, "Wrong size on UDCGameTooltipWithFlavorTextWidget");
static_assert(offsetof(UDCGameTooltipWithFlavorTextWidget, TitleText) == 0x0002C0, "Member 'UDCGameTooltipWithFlavorTextWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UDCGameTooltipWithFlavorTextWidget, DescriptionText) == 0x0002D8, "Member 'UDCGameTooltipWithFlavorTextWidget::DescriptionText' has a wrong offset!");
static_assert(offsetof(UDCGameTooltipWithFlavorTextWidget, FlavorText) == 0x0002F0, "Member 'UDCGameTooltipWithFlavorTextWidget::FlavorText' has a wrong offset!");

// Class DungeonCrawler.DCCharacterShapeShiftArtData
// 0x0098 (0x0220 - 0x0188)
class UDCCharacterShapeShiftArtData final : public UDCCharacterPartsArtData
{
public:
	class UTexture2D*                             ShapeShiftIconTexture;                             // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ShapeShiftSkeletalMesh;                            // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              ShapeShiftAnimInstanceClass;                       // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ShapeShiftedNiagaraAsset;                          // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AkComponentLocalLocation;                          // 0x01A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             PortraitCaptureTransform;                          // 0x01C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterShapeShiftArtData">();
	}
	static class UDCCharacterShapeShiftArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterShapeShiftArtData>();
	}
};
static_assert(alignof(UDCCharacterShapeShiftArtData) == 0x000010, "Wrong alignment on UDCCharacterShapeShiftArtData");
static_assert(sizeof(UDCCharacterShapeShiftArtData) == 0x000220, "Wrong size on UDCCharacterShapeShiftArtData");
static_assert(offsetof(UDCCharacterShapeShiftArtData, ShapeShiftIconTexture) == 0x000188, "Member 'UDCCharacterShapeShiftArtData::ShapeShiftIconTexture' has a wrong offset!");
static_assert(offsetof(UDCCharacterShapeShiftArtData, ShapeShiftSkeletalMesh) == 0x000190, "Member 'UDCCharacterShapeShiftArtData::ShapeShiftSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UDCCharacterShapeShiftArtData, ShapeShiftAnimInstanceClass) == 0x000198, "Member 'UDCCharacterShapeShiftArtData::ShapeShiftAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UDCCharacterShapeShiftArtData, ShapeShiftedNiagaraAsset) == 0x0001A0, "Member 'UDCCharacterShapeShiftArtData::ShapeShiftedNiagaraAsset' has a wrong offset!");
static_assert(offsetof(UDCCharacterShapeShiftArtData, AkComponentLocalLocation) == 0x0001A8, "Member 'UDCCharacterShapeShiftArtData::AkComponentLocalLocation' has a wrong offset!");
static_assert(offsetof(UDCCharacterShapeShiftArtData, PortraitCaptureTransform) == 0x0001C0, "Member 'UDCCharacterShapeShiftArtData::PortraitCaptureTransform' has a wrong offset!");

// Class DungeonCrawler.DCGATA_GroundTraceWithMaxHeight
// 0x0000 (0x0420 - 0x0420)
class ADCGATA_GroundTraceWithMaxHeight : public AGameplayAbilityTargetActor_GroundTrace
{
public:
	float                                         MaxHeight;                                         // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C1[0x4];                                     // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_GroundTraceWithMaxHeight">();
	}
	static class ADCGATA_GroundTraceWithMaxHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_GroundTraceWithMaxHeight>();
	}
};
static_assert(alignof(ADCGATA_GroundTraceWithMaxHeight) == 0x000010, "Wrong alignment on ADCGATA_GroundTraceWithMaxHeight");
static_assert(sizeof(ADCGATA_GroundTraceWithMaxHeight) == 0x000420, "Wrong size on ADCGATA_GroundTraceWithMaxHeight");
static_assert(offsetof(ADCGATA_GroundTraceWithMaxHeight, MaxHeight) == 0x000418, "Member 'ADCGATA_GroundTraceWithMaxHeight::MaxHeight' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSkinComponent
// 0x0040 (0x00E0 - 0x00A0)
class UDCCharacterSkinComponent final : public UDCActorComponent
{
public:
	class UDCCharacterSkinDataAsset*              Data;                                              // 0x00A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C2[0x18];                                    // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     OwnerGameplayAbilitySpecHandles;                   // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    OwnerGameplayEffectHandles;                        // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_Data(const class UDCCharacterSkinDataAsset* OldData);
	void SetDataForDebug_Server(const class UDCCharacterSkinDataAsset* InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinComponent">();
	}
	static class UDCCharacterSkinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinComponent>();
	}
};
static_assert(alignof(UDCCharacterSkinComponent) == 0x000008, "Wrong alignment on UDCCharacterSkinComponent");
static_assert(sizeof(UDCCharacterSkinComponent) == 0x0000E0, "Wrong size on UDCCharacterSkinComponent");
static_assert(offsetof(UDCCharacterSkinComponent, Data) == 0x0000A0, "Member 'UDCCharacterSkinComponent::Data' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinComponent, OwnerGameplayAbilitySpecHandles) == 0x0000C0, "Member 'UDCCharacterSkinComponent::OwnerGameplayAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinComponent, OwnerGameplayEffectHandles) == 0x0000D0, "Member 'UDCCharacterSkinComponent::OwnerGameplayEffectHandles' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillRouterBase
// 0x0010 (0x06E0 - 0x06D0)
class UGA_PlayerSkillRouterBase : public UGA_PlayerSkillBase
{
public:
	struct FGameplayTag                           RouteTriggerTag;                                   // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CheckItemWeaponTypeTag;                            // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRoutedAbilityEnded(const struct FAbilityEndedData& AbilityEndedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillRouterBase">();
	}
	static class UGA_PlayerSkillRouterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillRouterBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillRouterBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillRouterBase");
static_assert(sizeof(UGA_PlayerSkillRouterBase) == 0x0006E0, "Wrong size on UGA_PlayerSkillRouterBase");
static_assert(offsetof(UGA_PlayerSkillRouterBase, RouteTriggerTag) == 0x0006D0, "Member 'UGA_PlayerSkillRouterBase::RouteTriggerTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillRouterBase, CheckItemWeaponTypeTag) == 0x0006D8, "Member 'UGA_PlayerSkillRouterBase::CheckItemWeaponTypeTag' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSkinDataAsset
// 0x00B0 (0x00F8 - 0x0048)
class UDCCharacterSkinDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCCharacterSkinDataAsset;                     // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               Desc;                                              // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0088(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCCharacterSkinArtData> Art;                                               // 0x00A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDCCharacterClass>                     TargetCharacterClasses;                            // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinDataAsset">();
	}
	static class UDCCharacterSkinDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinDataAsset>();
	}
};
static_assert(alignof(UDCCharacterSkinDataAsset) == 0x000008, "Wrong alignment on UDCCharacterSkinDataAsset");
static_assert(sizeof(UDCCharacterSkinDataAsset) == 0x0000F8, "Wrong size on UDCCharacterSkinDataAsset");
static_assert(offsetof(UDCCharacterSkinDataAsset, Name_DCCharacterSkinDataAsset) == 0x000048, "Member 'UDCCharacterSkinDataAsset::Name_DCCharacterSkinDataAsset' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinDataAsset, Desc) == 0x000060, "Member 'UDCCharacterSkinDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinDataAsset, FlavorText) == 0x000088, "Member 'UDCCharacterSkinDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinDataAsset, Art) == 0x0000A0, "Member 'UDCCharacterSkinDataAsset::Art' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinDataAsset, TargetCharacterClasses) == 0x0000C8, "Member 'UDCCharacterSkinDataAsset::TargetCharacterClasses' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinDataAsset, Abilities) == 0x0000D8, "Member 'UDCCharacterSkinDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinDataAsset, Effects) == 0x0000E8, "Member 'UDCCharacterSkinDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTraceFromSocket
// 0x0010 (0x0400 - 0x03F0)
class ADCGATA_AimTraceFromSocket : public ADCGATA_AimTrace
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C3[0x8];                                     // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTraceFromSocket">();
	}
	static class ADCGATA_AimTraceFromSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTraceFromSocket>();
	}
};
static_assert(alignof(ADCGATA_AimTraceFromSocket) == 0x000010, "Wrong alignment on ADCGATA_AimTraceFromSocket");
static_assert(sizeof(ADCGATA_AimTraceFromSocket) == 0x000400, "Wrong size on ADCGATA_AimTraceFromSocket");
static_assert(offsetof(ADCGATA_AimTraceFromSocket, SkeletalMeshComponent) == 0x0003E8, "Member 'ADCGATA_AimTraceFromSocket::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceFromSocket, SocketName) == 0x0003F0, "Member 'ADCGATA_AimTraceFromSocket::SocketName' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTraceFromSocketOnServer
// 0x0000 (0x0400 - 0x0400)
class ADCGATA_AimTraceFromSocketOnServer final : public ADCGATA_AimTraceFromSocket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTraceFromSocketOnServer">();
	}
	static class ADCGATA_AimTraceFromSocketOnServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTraceFromSocketOnServer>();
	}
};
static_assert(alignof(ADCGATA_AimTraceFromSocketOnServer) == 0x000010, "Wrong alignment on ADCGATA_AimTraceFromSocketOnServer");
static_assert(sizeof(ADCGATA_AimTraceFromSocketOnServer) == 0x000400, "Wrong size on ADCGATA_AimTraceFromSocketOnServer");

// Class DungeonCrawler.DCCharacterSkinListEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCCharacterSkinListEntryWidgetData final : public UObject
{
public:
	struct FDCCharacterSkinInfo                   CharacterSkinInfo;                                 // 0x0028(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinListEntryWidgetData">();
	}
	static class UDCCharacterSkinListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinListEntryWidgetData>();
	}
};
static_assert(alignof(UDCCharacterSkinListEntryWidgetData) == 0x000008, "Wrong alignment on UDCCharacterSkinListEntryWidgetData");
static_assert(sizeof(UDCCharacterSkinListEntryWidgetData) == 0x000038, "Wrong size on UDCCharacterSkinListEntryWidgetData");
static_assert(offsetof(UDCCharacterSkinListEntryWidgetData, CharacterSkinInfo) == 0x000028, "Member 'UDCCharacterSkinListEntryWidgetData::CharacterSkinInfo' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSkinWidget
// 0x0090 (0x0520 - 0x0490)
class UDCCharacterSkinWidget : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_25C4[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CharacterSkinName;                                 // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           CharacterSkinDescTextArray;                        // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   CharacterSkinFlavorText;                           // 0x04D0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             CharacterSkinIconTexture;                          // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        CharacterSkinId;                                   // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C5[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameTooltipWithFlavorTextWidget*     SkinTooltipWidget;                                 // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterSkinDataAsset*              CharacterSkinDataAsset;                            // 0x0518(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UUserWidget* GetTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinWidget">();
	}
	static class UDCCharacterSkinWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinWidget>();
	}
};
static_assert(alignof(UDCCharacterSkinWidget) == 0x000008, "Wrong alignment on UDCCharacterSkinWidget");
static_assert(sizeof(UDCCharacterSkinWidget) == 0x000520, "Wrong size on UDCCharacterSkinWidget");
static_assert(offsetof(UDCCharacterSkinWidget, CharacterSkinName) == 0x0004A8, "Member 'UDCCharacterSkinWidget::CharacterSkinName' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, CharacterSkinDescTextArray) == 0x0004C0, "Member 'UDCCharacterSkinWidget::CharacterSkinDescTextArray' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, CharacterSkinFlavorText) == 0x0004D0, "Member 'UDCCharacterSkinWidget::CharacterSkinFlavorText' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, CharacterSkinIconTexture) == 0x0004E8, "Member 'UDCCharacterSkinWidget::CharacterSkinIconTexture' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, CharacterSkinId) == 0x0004F0, "Member 'UDCCharacterSkinWidget::CharacterSkinId' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, bIsEquipped) == 0x000500, "Member 'UDCCharacterSkinWidget::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, TooltipWidgetClass) == 0x000508, "Member 'UDCCharacterSkinWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, SkinTooltipWidget) == 0x000510, "Member 'UDCCharacterSkinWidget::SkinTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCCharacterSkinWidget, CharacterSkinDataAsset) == 0x000518, "Member 'UDCCharacterSkinWidget::CharacterSkinDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCGameSpawner
// 0x00C0 (0x03B8 - 0x02F8)
class ADCGameSpawner : public ADCActorBase
{
public:
	class UDesignDataAssetSpawner*                DesignDataAssetSpawner;                            // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomScaleMin;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomScaleMax;                                    // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCastShadow;                                       // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C6[0x7];                                     // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FObjectLinkEventContext>        SpawnObjectEventContextArray;                      // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ATargetPoint*>                   TargetPoints;                                      // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpawnerItem                 DesignDataSpawnerItem;                             // 0x0330(0x0050)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PreviewIdx;                                        // 0x0380(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpawnedObject;                                  // 0x0384(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C7[0xB];                                     // 0x0385(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        PreviewAssetId;                                    // 0x0390(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PreviewActor;                                      // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          SpawnedActors;                                     // 0x03A8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnSetMonsterPeaceAction(class ADCMonsterBase* Monster);
	void SetNextPreview();
	class AItemHolderActorBase* SpawnItemHolder(const struct FPrimaryAssetId& InLootDropId, const struct FPrimaryAssetId& InLootDropRateId, bool bInPreview);
	class ADCMonsterBase* SpawnMonster(const struct FPrimaryAssetId& InMonsterId, class ADCCharacterBase* Summoner, bool bInPreview);
	void SpawnObjectBlueprint();
	class APropsActorBase* SpawnProps(const struct FPrimaryAssetId& InPropsId, bool bInPreview);
	void UpdateGameState(const struct FGameStateData& InGameStateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSpawner">();
	}
	static class ADCGameSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameSpawner>();
	}
};
static_assert(alignof(ADCGameSpawner) == 0x000008, "Wrong alignment on ADCGameSpawner");
static_assert(sizeof(ADCGameSpawner) == 0x0003B8, "Wrong size on ADCGameSpawner");
static_assert(offsetof(ADCGameSpawner, DesignDataAssetSpawner) == 0x0002F8, "Member 'ADCGameSpawner::DesignDataAssetSpawner' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, RandomScaleMin) == 0x000300, "Member 'ADCGameSpawner::RandomScaleMin' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, RandomScaleMax) == 0x000304, "Member 'ADCGameSpawner::RandomScaleMax' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, bCastShadow) == 0x000308, "Member 'ADCGameSpawner::bCastShadow' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, SpawnObjectEventContextArray) == 0x000310, "Member 'ADCGameSpawner::SpawnObjectEventContextArray' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, TargetPoints) == 0x000320, "Member 'ADCGameSpawner::TargetPoints' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, DesignDataSpawnerItem) == 0x000330, "Member 'ADCGameSpawner::DesignDataSpawnerItem' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, PreviewIdx) == 0x000380, "Member 'ADCGameSpawner::PreviewIdx' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, bIsSpawnedObject) == 0x000384, "Member 'ADCGameSpawner::bIsSpawnedObject' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, PreviewAssetId) == 0x000390, "Member 'ADCGameSpawner::PreviewAssetId' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, PreviewActor) == 0x0003A0, "Member 'ADCGameSpawner::PreviewActor' has a wrong offset!");
static_assert(offsetof(ADCGameSpawner, SpawnedActors) == 0x0003A8, "Member 'ADCGameSpawner::SpawnedActors' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSkinListEntryWidget
// 0x0010 (0x0530 - 0x0520)
class UDCCharacterSkinListEntryWidget final : public UDCCharacterSkinWidget
{
public:
	uint8                                         Pad_25CB[0x10];                                    // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinListEntryWidget">();
	}
	static class UDCCharacterSkinListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinListEntryWidget>();
	}
};
static_assert(alignof(UDCCharacterSkinListEntryWidget) == 0x000008, "Wrong alignment on UDCCharacterSkinListEntryWidget");
static_assert(sizeof(UDCCharacterSkinListEntryWidget) == 0x000530, "Wrong size on UDCCharacterSkinListEntryWidget");

// Class DungeonCrawler.DCChatRoomDataAsset
// 0x0068 (0x00B0 - 0x0048)
class UDCChatRoomDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCChatRoomDataAsset;                          // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatRoomCategoryType                         ChatRoomCategoryType;                              // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CC[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   AllowedItemLinkTypes;                              // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                AllowedItemLinkClassIds;                           // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                AdditionalAllowedItemLinkIdTagGroups;              // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AllowedAllowedItemLinkDesc;                        // 0x0098(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCChatRoomDataAsset">();
	}
	static class UDCChatRoomDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCChatRoomDataAsset>();
	}
};
static_assert(alignof(UDCChatRoomDataAsset) == 0x000008, "Wrong alignment on UDCChatRoomDataAsset");
static_assert(sizeof(UDCChatRoomDataAsset) == 0x0000B0, "Wrong size on UDCChatRoomDataAsset");
static_assert(offsetof(UDCChatRoomDataAsset, Name_DCChatRoomDataAsset) == 0x000048, "Member 'UDCChatRoomDataAsset::Name_DCChatRoomDataAsset' has a wrong offset!");
static_assert(offsetof(UDCChatRoomDataAsset, Order) == 0x000060, "Member 'UDCChatRoomDataAsset::Order' has a wrong offset!");
static_assert(offsetof(UDCChatRoomDataAsset, ChatRoomCategoryType) == 0x000064, "Member 'UDCChatRoomDataAsset::ChatRoomCategoryType' has a wrong offset!");
static_assert(offsetof(UDCChatRoomDataAsset, AllowedItemLinkTypes) == 0x000068, "Member 'UDCChatRoomDataAsset::AllowedItemLinkTypes' has a wrong offset!");
static_assert(offsetof(UDCChatRoomDataAsset, AllowedItemLinkClassIds) == 0x000078, "Member 'UDCChatRoomDataAsset::AllowedItemLinkClassIds' has a wrong offset!");
static_assert(offsetof(UDCChatRoomDataAsset, AdditionalAllowedItemLinkIdTagGroups) == 0x000088, "Member 'UDCChatRoomDataAsset::AdditionalAllowedItemLinkIdTagGroups' has a wrong offset!");
static_assert(offsetof(UDCChatRoomDataAsset, AllowedAllowedItemLinkDesc) == 0x000098, "Member 'UDCChatRoomDataAsset::AllowedAllowedItemLinkDesc' has a wrong offset!");

// Class DungeonCrawler.GameSpellCurrentSlotWidget
// 0x0130 (0x0488 - 0x0358)
class UGameSpellCurrentSlotWidget final : public UDCWidgetBase
{
public:
	struct FSpellData                             SpellData;                                         // 0x0358(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       DesignDataSpell;                                   // 0x0398(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CD[0x10];                                    // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSetSpellArtData(const class UArtDataSpell* InArtSpellData);
	void OnSpellDataChanged(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell);
	void SetSpellData(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSpellCurrentSlotWidget">();
	}
	static class UGameSpellCurrentSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSpellCurrentSlotWidget>();
	}
};
static_assert(alignof(UGameSpellCurrentSlotWidget) == 0x000008, "Wrong alignment on UGameSpellCurrentSlotWidget");
static_assert(sizeof(UGameSpellCurrentSlotWidget) == 0x000488, "Wrong size on UGameSpellCurrentSlotWidget");
static_assert(offsetof(UGameSpellCurrentSlotWidget, SpellData) == 0x000358, "Member 'UGameSpellCurrentSlotWidget::SpellData' has a wrong offset!");
static_assert(offsetof(UGameSpellCurrentSlotWidget, DesignDataSpell) == 0x000398, "Member 'UGameSpellCurrentSlotWidget::DesignDataSpell' has a wrong offset!");
static_assert(offsetof(UGameSpellCurrentSlotWidget, PlayerCharacter) == 0x000480, "Member 'UGameSpellCurrentSlotWidget::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.MetaLeaderboardInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaLeaderboardInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaLeaderboardInterface">();
	}
	static class IMetaLeaderboardInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaLeaderboardInterface>();
	}
};
static_assert(alignof(IMetaLeaderboardInterface) == 0x000008, "Wrong alignment on IMetaLeaderboardInterface");
static_assert(sizeof(IMetaLeaderboardInterface) == 0x000028, "Wrong size on IMetaLeaderboardInterface");

// Class DungeonCrawler.DCChildActorComponent
// 0x0030 (0x02D0 - 0x02A0)
class UDCChildActorComponent final : public USceneComponent
{
public:
	class APropsActorBase*                        PreviewChildProps;                                 // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25CE[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APropsActorBase>            ChildClass;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25CF[0x10];                                    // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APropsActorBase* SpawnChildActor(bool bIsPreview);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCChildActorComponent">();
	}
	static class UDCChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCChildActorComponent>();
	}
};
static_assert(alignof(UDCChildActorComponent) == 0x000010, "Wrong alignment on UDCChildActorComponent");
static_assert(sizeof(UDCChildActorComponent) == 0x0002D0, "Wrong size on UDCChildActorComponent");
static_assert(offsetof(UDCChildActorComponent, PreviewChildProps) == 0x0002A0, "Member 'UDCChildActorComponent::PreviewChildProps' has a wrong offset!");
static_assert(offsetof(UDCChildActorComponent, ChildClass) == 0x0002B0, "Member 'UDCChildActorComponent::ChildClass' has a wrong offset!");
static_assert(offsetof(UDCChildActorComponent, SocketName) == 0x0002B8, "Member 'UDCChildActorComponent::SocketName' has a wrong offset!");

// Class DungeonCrawler.DCClassPerkSkillPageWidget
// 0x0008 (0x04B0 - 0x04A8)
class UDCClassPerkSkillPageWidget final : public UClassGroupWidgetBase
{
public:
	class UDCCaptureStudioWidget*                 CaptureStudioWidget;                               // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCClassPerkSkillPageWidget">();
	}
	static class UDCClassPerkSkillPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCClassPerkSkillPageWidget>();
	}
};
static_assert(alignof(UDCClassPerkSkillPageWidget) == 0x000008, "Wrong alignment on UDCClassPerkSkillPageWidget");
static_assert(sizeof(UDCClassPerkSkillPageWidget) == 0x0004B0, "Wrong size on UDCClassPerkSkillPageWidget");
static_assert(offsetof(UDCClassPerkSkillPageWidget, CaptureStudioWidget) == 0x0004A8, "Member 'UDCClassPerkSkillPageWidget::CaptureStudioWidget' has a wrong offset!");

// Class DungeonCrawler.GameTestComponent
// 0x0328 (0x03C8 - 0x00A0)
class UGameTestComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_25D1[0x150];                                   // 0x00A0(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLink*                           AccountLink;                                       // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                PerkIdArray;                                       // 0x01F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                SkillIdArray;                                      // 0x0208(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                SpellIdArray;                                      // 0x0218(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataSpell>              AccountDataSpellArray;                             // 0x0228(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                MusicIdArray;                                      // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataMusic>              AccountDataMusicArray;                             // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                ShapeShiftIdArray;                                 // 0x0258(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataShapeShift>         AccountDataShapeShiftArray;                        // 0x0268(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCTrainingClassAbilityIdArray> MasterClassAbilitiesMap;                           // 0x0278(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FDCClassTrainingInfo                   TrainingInfo;                                      // 0x02C8(0x0088)(Transient, NativeAccessSpecifierPrivate)
	TArray<EDCSkillClassAbility>                  CharacterSkillClassAbilities;                      // 0x0350(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCTrainingClassAbilityId>      GainedClassAbilities;                              // 0x0360(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25D2[0x48];                                    // 0x0370(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TestLearningPoint;                                 // 0x03B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TestRewardPoint;                                   // 0x03BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          TokenRedeemSound;                                  // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ClientMsgClassItemMoveRequest(const struct FMsgGameTestClassItemMoveRequest& InMsg);
	void ClientMsgClassItemMoveResponse(const struct FMsgGameTestClassItemMoveResponse& InMsg);
	void ClientMsgClassLevelInfoRequest(const struct FMsgGameTestClassLevelInfoRequest& InMsg);
	void ClientMsgClassLevelInfoResponse(const struct FMsgGameTestClassLevelInfoResponse& InMsg);
	void ClientMsgClassMusicListRequest(const struct FMsgGameTestClassMusicListRequest& InMsg);
	void ClientMsgClassMusicListResponse(const struct FMsgGameTestClassMusicListResponse& InMsg);
	void ClientMsgClassMusicSlotMoveRequest(const struct FMsgGameTestClassMusicSlotMoveRequest& InMsg);
	void ClientMsgClassMusicSlotMoveResponse(const struct FMsgGameTestClassMusicSlotMoveResponse& InMsg);
	void ClientMsgClassPerkListRequest(const struct FMsgGameTestClassPerkListRequest& InMsg);
	void ClientMsgClassPerkListResponse(const struct FMsgGameTestClassPerkListResponse& InMsg);
	void ClientMsgClassShapeShiftListRequest(const struct FMsgGameTestClassShapeShiftListRequest& InMsg);
	void ClientMsgClassShapeShiftListResponse(const struct FMsgGameTestClassShapeShiftListResponse& InMsg);
	void ClientMsgClassShapeShiftSlotMoveRequest(const struct FMsgGameTestClassShapeShiftSlotMoveRequest& InMsg);
	void ClientMsgClassShapeShiftSlotMoveResponse(const struct FMsgGameTestClassShapeShiftSlotMoveResponse& InMsg);
	void ClientMsgClassSkillListRequest(const struct FMsgGameTestClassSkillListRequest& InMsg);
	void ClientMsgClassSkillListResponse(const struct FMsgGameTestClassSkillListResponse& InMsg);
	void ClientMsgClassSpellListRequest(const struct FMsgGameTestClassSpellListRequest& InMsg);
	void ClientMsgClassSpellListResponse(const struct FMsgGameTestClassSpellListResponse& InMsg);
	void ClientMsgClassSpellSequenceChangeRequest(const struct FMsgGameTestClassSpellSequenceChangeRequest& InMsg);
	void ClientMsgClassSpellSequenceChangeResponse(const struct FMsgGameTestClassSpellSequenceChangeResponse& InMsg);
	void ClientMsgClassSpellSlotMoveRequest(const struct FMsgGameTestClassSpellSlotMoveRequest& InMsg);
	void ClientMsgClassSpellSlotMoveResponse(const struct FMsgGameTestClassSpellSlotMoveResponse& InMsg);
	void ClientOnUpdateSkillList(const TArray<struct FPrimaryAssetId>& InSkillIdArray);
	void ClientResReceiveTrainingClassAbility();
	void ClientResReceiveTraningReward();
	void ClientResRedeemLearningToken(const struct FPrimaryAssetId& MasterClassId, const TArray<struct FPrimaryAssetId>& InClassAbilityOptions);
	void ClientResRedeemRewardToken(const TArray<struct FPrimaryAssetId>& InRewardOptions);
	void ClientResTrainingInfo(const struct FDCGameTestClassTrainingInfo& InTrainingInfo);
	void MsgGameTestChangePlayerCharacterClassRequest(const struct FMsgGameTestChangePlayerCharacterClassRequest& InMsg);
	void MsgGameTestChangePlayerCharacterClassResponse(const struct FMsgGameTestChangePlayerCharacterClassResponse& InMsg);
	void ServerReqReceiveTrainingClassAbility(const struct FPrimaryAssetId& InClassAbilityId);
	void ServerReqReceiveTraningReward();
	void ServerReqRedeemLearningToken(const struct FDCTrainingCharacterInfo& InMasterCharacter);
	void ServerReqRedeemRewardToken();
	void ServerReqTrainingInfo();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTestComponent">();
	}
	static class UGameTestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTestComponent>();
	}
};
static_assert(alignof(UGameTestComponent) == 0x000008, "Wrong alignment on UGameTestComponent");
static_assert(sizeof(UGameTestComponent) == 0x0003C8, "Wrong size on UGameTestComponent");
static_assert(offsetof(UGameTestComponent, AccountLink) == 0x0001F0, "Member 'UGameTestComponent::AccountLink' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, PerkIdArray) == 0x0001F8, "Member 'UGameTestComponent::PerkIdArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, SkillIdArray) == 0x000208, "Member 'UGameTestComponent::SkillIdArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, SpellIdArray) == 0x000218, "Member 'UGameTestComponent::SpellIdArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, AccountDataSpellArray) == 0x000228, "Member 'UGameTestComponent::AccountDataSpellArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, MusicIdArray) == 0x000238, "Member 'UGameTestComponent::MusicIdArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, AccountDataMusicArray) == 0x000248, "Member 'UGameTestComponent::AccountDataMusicArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, ShapeShiftIdArray) == 0x000258, "Member 'UGameTestComponent::ShapeShiftIdArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, AccountDataShapeShiftArray) == 0x000268, "Member 'UGameTestComponent::AccountDataShapeShiftArray' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, MasterClassAbilitiesMap) == 0x000278, "Member 'UGameTestComponent::MasterClassAbilitiesMap' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, TrainingInfo) == 0x0002C8, "Member 'UGameTestComponent::TrainingInfo' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, CharacterSkillClassAbilities) == 0x000350, "Member 'UGameTestComponent::CharacterSkillClassAbilities' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, GainedClassAbilities) == 0x000360, "Member 'UGameTestComponent::GainedClassAbilities' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, TestLearningPoint) == 0x0003B8, "Member 'UGameTestComponent::TestLearningPoint' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, TestRewardPoint) == 0x0003BC, "Member 'UGameTestComponent::TestRewardPoint' has a wrong offset!");
static_assert(offsetof(UGameTestComponent, TokenRedeemSound) == 0x0003C0, "Member 'UGameTestComponent::TokenRedeemSound' has a wrong offset!");

// Class DungeonCrawler.DCClientReportPlayerManager
// 0x00D8 (0x0108 - 0x0030)
class UDCClientReportPlayerManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_25D3[0x30];                                    // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCReportPlayerInfo                    ReportInfo;                                        // 0x0060(0x0088)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCReportedInfo>                ReportedInfoArray;                                 // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCReportPlayerResultInfo>      ReportResultInfoArray;                             // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCClientReportPlayerManager">();
	}
	static class UDCClientReportPlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCClientReportPlayerManager>();
	}
};
static_assert(alignof(UDCClientReportPlayerManager) == 0x000008, "Wrong alignment on UDCClientReportPlayerManager");
static_assert(sizeof(UDCClientReportPlayerManager) == 0x000108, "Wrong size on UDCClientReportPlayerManager");
static_assert(offsetof(UDCClientReportPlayerManager, ReportInfo) == 0x000060, "Member 'UDCClientReportPlayerManager::ReportInfo' has a wrong offset!");
static_assert(offsetof(UDCClientReportPlayerManager, ReportedInfoArray) == 0x0000E8, "Member 'UDCClientReportPlayerManager::ReportedInfoArray' has a wrong offset!");
static_assert(offsetof(UDCClientReportPlayerManager, ReportResultInfoArray) == 0x0000F8, "Member 'UDCClientReportPlayerManager::ReportResultInfoArray' has a wrong offset!");

// Class DungeonCrawler.DCClientShopManager
// 0x03B0 (0x03E0 - 0x0030)
class UDCClientShopManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_25D4[0x90];                                    // 0x0030(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCClientShopInfo                      ShopInfo;                                          // 0x00C0(0x02D0)(Transient, NativeAccessSpecifierPrivate)
	struct FDCAccountStatusUpgradeShopInfo        AccountStatusUpgradeShopInfo;                      // 0x0390(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FDCAccountNameChangeShopInfo           AccountNameChangeShopInfo;                         // 0x03A8(0x0018)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCRewardInfo>                  GiftCodeRewards;                                   // 0x03C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCRewardInfo>                  RewardInfos;                                       // 0x03D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCClientShopManager">();
	}
	static class UDCClientShopManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCClientShopManager>();
	}
};
static_assert(alignof(UDCClientShopManager) == 0x000008, "Wrong alignment on UDCClientShopManager");
static_assert(sizeof(UDCClientShopManager) == 0x0003E0, "Wrong size on UDCClientShopManager");
static_assert(offsetof(UDCClientShopManager, ShopInfo) == 0x0000C0, "Member 'UDCClientShopManager::ShopInfo' has a wrong offset!");
static_assert(offsetof(UDCClientShopManager, AccountStatusUpgradeShopInfo) == 0x000390, "Member 'UDCClientShopManager::AccountStatusUpgradeShopInfo' has a wrong offset!");
static_assert(offsetof(UDCClientShopManager, AccountNameChangeShopInfo) == 0x0003A8, "Member 'UDCClientShopManager::AccountNameChangeShopInfo' has a wrong offset!");
static_assert(offsetof(UDCClientShopManager, GiftCodeRewards) == 0x0003C0, "Member 'UDCClientShopManager::GiftCodeRewards' has a wrong offset!");
static_assert(offsetof(UDCClientShopManager, RewardInfos) == 0x0003D0, "Member 'UDCClientShopManager::RewardInfos' has a wrong offset!");

// Class DungeonCrawler.DCCommonButtonOptionLinkWidget
// 0x0010 (0x1670 - 0x1660)
class UDCCommonButtonOptionLinkWidget : public UDCCommonButtonBase
{
public:
	class UTextBlock*                             OptionLinkText;                                    // 0x1658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOptionLinkType                               LinkType;                                          // 0x1660(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D5[0xF];                                     // 0x1661(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickEOptionLinkButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommonButtonOptionLinkWidget">();
	}
	static class UDCCommonButtonOptionLinkWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommonButtonOptionLinkWidget>();
	}
};
static_assert(alignof(UDCCommonButtonOptionLinkWidget) == 0x000010, "Wrong alignment on UDCCommonButtonOptionLinkWidget");
static_assert(sizeof(UDCCommonButtonOptionLinkWidget) == 0x001670, "Wrong size on UDCCommonButtonOptionLinkWidget");
static_assert(offsetof(UDCCommonButtonOptionLinkWidget, OptionLinkText) == 0x001658, "Member 'UDCCommonButtonOptionLinkWidget::OptionLinkText' has a wrong offset!");
static_assert(offsetof(UDCCommonButtonOptionLinkWidget, LinkType) == 0x001660, "Member 'UDCCommonButtonOptionLinkWidget::LinkType' has a wrong offset!");

// Class DungeonCrawler.GA_ActivateItemSpecialBase
// 0x0008 (0x05A8 - 0x05A0)
class UGA_ActivateItemSpecialBase : public UDCGameplayAbilityBase
{
public:
	struct FGameplayTag                           ItemSpeicalTriggerTag;                             // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void OnItemSpecialEnded(const struct FAbilityEndedData& AbilityEndedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ActivateItemSpecialBase">();
	}
	static class UGA_ActivateItemSpecialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ActivateItemSpecialBase>();
	}
};
static_assert(alignof(UGA_ActivateItemSpecialBase) == 0x000008, "Wrong alignment on UGA_ActivateItemSpecialBase");
static_assert(sizeof(UGA_ActivateItemSpecialBase) == 0x0005A8, "Wrong size on UGA_ActivateItemSpecialBase");
static_assert(offsetof(UGA_ActivateItemSpecialBase, ItemSpeicalTriggerTag) == 0x0005A0, "Member 'UGA_ActivateItemSpecialBase::ItemSpeicalTriggerTag' has a wrong offset!");

// Class DungeonCrawler.TopTitleWidgetBase
// 0x0018 (0x0370 - 0x0358)
class UTopTitleWidgetBase final : public UDCWidgetBase
{
public:
	class UTextBlock*                             Text_Title;                                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Left;                                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Right;                                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetLeftButtonText(const class FText& ButtonText);
	void SetRightButtonText(const class FText& ButtonText);
	void SetTitleText(const class FText& TitleText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TopTitleWidgetBase">();
	}
	static class UTopTitleWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTopTitleWidgetBase>();
	}
};
static_assert(alignof(UTopTitleWidgetBase) == 0x000008, "Wrong alignment on UTopTitleWidgetBase");
static_assert(sizeof(UTopTitleWidgetBase) == 0x000370, "Wrong size on UTopTitleWidgetBase");
static_assert(offsetof(UTopTitleWidgetBase, Text_Title) == 0x000358, "Member 'UTopTitleWidgetBase::Text_Title' has a wrong offset!");
static_assert(offsetof(UTopTitleWidgetBase, Btn_Left) == 0x000360, "Member 'UTopTitleWidgetBase::Btn_Left' has a wrong offset!");
static_assert(offsetof(UTopTitleWidgetBase, Btn_Right) == 0x000368, "Member 'UTopTitleWidgetBase::Btn_Right' has a wrong offset!");

// Class DungeonCrawler.DCGhostTrailActor
// 0x00F8 (0x03F0 - 0x02F8)
class ADCGhostTrailActor : public ADCActorBase
{
public:
	class UMaterialInterface*                     GhostTrailMaterial;                                // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScalarParameterName;                               // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OpacityCurve;                                      // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             CharacterRef;                                      // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0318(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActive;                                       // 0x0328(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D6[0x7];                                     // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoseableMeshComponent*                 PoseableMeshComp;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 AttachedMeshComp;                                  // 0x0338(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        SceneRootComp;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              OpacityTimeline;                                   // 0x0350(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicMatInstance;                                // 0x03E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BeginGhostTrailEffect();
	void HandleTimelineFinished();
	void HandleTimelineUpdate(float Value);
	void SetGhostMaterial(const TArray<class UMeshComponent*>& Components);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGhostTrailActor">();
	}
	static class ADCGhostTrailActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGhostTrailActor>();
	}
};
static_assert(alignof(ADCGhostTrailActor) == 0x000008, "Wrong alignment on ADCGhostTrailActor");
static_assert(sizeof(ADCGhostTrailActor) == 0x0003F0, "Wrong size on ADCGhostTrailActor");
static_assert(offsetof(ADCGhostTrailActor, GhostTrailMaterial) == 0x0002F8, "Member 'ADCGhostTrailActor::GhostTrailMaterial' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, ScalarParameterName) == 0x000300, "Member 'ADCGhostTrailActor::ScalarParameterName' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, OpacityCurve) == 0x000308, "Member 'ADCGhostTrailActor::OpacityCurve' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, CharacterRef) == 0x000310, "Member 'ADCGhostTrailActor::CharacterRef' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, Color) == 0x000318, "Member 'ADCGhostTrailActor::Color' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, bAutoActive) == 0x000328, "Member 'ADCGhostTrailActor::bAutoActive' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, PoseableMeshComp) == 0x000330, "Member 'ADCGhostTrailActor::PoseableMeshComp' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, AttachedMeshComp) == 0x000338, "Member 'ADCGhostTrailActor::AttachedMeshComp' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, SceneRootComp) == 0x000348, "Member 'ADCGhostTrailActor::SceneRootComp' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, OpacityTimeline) == 0x000350, "Member 'ADCGhostTrailActor::OpacityTimeline' has a wrong offset!");
static_assert(offsetof(ADCGhostTrailActor, DynamicMatInstance) == 0x0003E8, "Member 'ADCGhostTrailActor::DynamicMatInstance' has a wrong offset!");

// Class DungeonCrawler.MiniMapData
// 0x0050 (0x0098 - 0x0048)
class UMiniMapData final : public UDCDataAssetBase
{
public:
	TMap<class FString, struct FDCMiniMapDataContainer> MiniMapData;                                       // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapData">();
	}
	static class UMiniMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapData>();
	}
};
static_assert(alignof(UMiniMapData) == 0x000008, "Wrong alignment on UMiniMapData");
static_assert(sizeof(UMiniMapData) == 0x000098, "Wrong size on UMiniMapData");
static_assert(offsetof(UMiniMapData, MiniMapData) == 0x000048, "Member 'UMiniMapData::MiniMapData' has a wrong offset!");

// Class DungeonCrawler.DCCommunityBlockEntryWidgetData
// 0x0078 (0x00A0 - 0x0028)
class UDCCommunityBlockEntryWidgetData final : public UObject
{
public:
	struct FDCCommunityCharacterInfo              Info;                                              // 0x0028(0x0078)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommunityBlockEntryWidgetData">();
	}
	static class UDCCommunityBlockEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommunityBlockEntryWidgetData>();
	}
};
static_assert(alignof(UDCCommunityBlockEntryWidgetData) == 0x000008, "Wrong alignment on UDCCommunityBlockEntryWidgetData");
static_assert(sizeof(UDCCommunityBlockEntryWidgetData) == 0x0000A0, "Wrong size on UDCCommunityBlockEntryWidgetData");
static_assert(offsetof(UDCCommunityBlockEntryWidgetData, Info) == 0x000028, "Member 'UDCCommunityBlockEntryWidgetData::Info' has a wrong offset!");

// Class DungeonCrawler.DCCommunityBlockEntryWidget
// 0x0088 (0x0348 - 0x02C0)
class UDCCommunityBlockEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_25D7[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClassRankIconBase*                     ClassRankIcon;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNickname                              Nickname;                                          // 0x02D0(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   CharacterClassName;                                // 0x0310(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EDCGender                                     Gender;                                            // 0x0328(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D8[0x7];                                     // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Portrait;                                          // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelect;                                           // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D9[0x7];                                     // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCContextMenuWidget*                   ContextMenuWidget;                                 // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CleanupContextMenuWidget();
	void ExecuteContextMenu(EContextOptionType Option);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommunityBlockEntryWidget">();
	}
	static class UDCCommunityBlockEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommunityBlockEntryWidget>();
	}
};
static_assert(alignof(UDCCommunityBlockEntryWidget) == 0x000008, "Wrong alignment on UDCCommunityBlockEntryWidget");
static_assert(sizeof(UDCCommunityBlockEntryWidget) == 0x000348, "Wrong size on UDCCommunityBlockEntryWidget");
static_assert(offsetof(UDCCommunityBlockEntryWidget, ClassRankIcon) == 0x0002C8, "Member 'UDCCommunityBlockEntryWidget::ClassRankIcon' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockEntryWidget, Nickname) == 0x0002D0, "Member 'UDCCommunityBlockEntryWidget::Nickname' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockEntryWidget, CharacterClassName) == 0x000310, "Member 'UDCCommunityBlockEntryWidget::CharacterClassName' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockEntryWidget, Gender) == 0x000328, "Member 'UDCCommunityBlockEntryWidget::Gender' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockEntryWidget, Portrait) == 0x000330, "Member 'UDCCommunityBlockEntryWidget::Portrait' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockEntryWidget, bSelect) == 0x000338, "Member 'UDCCommunityBlockEntryWidget::bSelect' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockEntryWidget, ContextMenuWidget) == 0x000340, "Member 'UDCCommunityBlockEntryWidget::ContextMenuWidget' has a wrong offset!");

// Class DungeonCrawler.DCCommunityBlockWidget
// 0x0028 (0x04E0 - 0x04B8)
class UDCCommunityBlockWidget final : public ULobbyGroupWidgetBase
{
public:
	int32                                         PageIndex;                                         // 0x04B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DA[0x4];                                     // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTileView*                              TileView;                                          // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ButtonBack;                                        // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonPageLeft;                                    // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonPageRight;                                   // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FindId(const class FText& FindText);
	void OnBlockUpdated();
	void OnButtonBack();
	void OnButtonPageLeft();
	void OnButtonPageRight();

	int32 GetMaxPage() const;
	int32 NumItemsPerPage() const;
	void OnEntryHovered(class UObject* WidgetData, bool bIsHovered) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCommunityBlockWidget">();
	}
	static class UDCCommunityBlockWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCommunityBlockWidget>();
	}
};
static_assert(alignof(UDCCommunityBlockWidget) == 0x000008, "Wrong alignment on UDCCommunityBlockWidget");
static_assert(sizeof(UDCCommunityBlockWidget) == 0x0004E0, "Wrong size on UDCCommunityBlockWidget");
static_assert(offsetof(UDCCommunityBlockWidget, PageIndex) == 0x0004B8, "Member 'UDCCommunityBlockWidget::PageIndex' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockWidget, TileView) == 0x0004C0, "Member 'UDCCommunityBlockWidget::TileView' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockWidget, ButtonBack) == 0x0004C8, "Member 'UDCCommunityBlockWidget::ButtonBack' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockWidget, ButtonPageLeft) == 0x0004D0, "Member 'UDCCommunityBlockWidget::ButtonPageLeft' has a wrong offset!");
static_assert(offsetof(UDCCommunityBlockWidget, ButtonPageRight) == 0x0004D8, "Member 'UDCCommunityBlockWidget::ButtonPageRight' has a wrong offset!");

// Class DungeonCrawler.GA_ChargedRangedAttackBase
// 0x0008 (0x0660 - 0x0658)
class UGA_ChargedRangedAttackBase : public UGA_RangedAttackBase
{
public:
	uint8                                         Pad_25DC[0x8];                                     // 0x0658(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputActionCompleted();
	void InputActionStarted();
	void SendPlayShootCrossHairNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ChargedRangedAttackBase">();
	}
	static class UGA_ChargedRangedAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ChargedRangedAttackBase>();
	}
};
static_assert(alignof(UGA_ChargedRangedAttackBase) == 0x000008, "Wrong alignment on UGA_ChargedRangedAttackBase");
static_assert(sizeof(UGA_ChargedRangedAttackBase) == 0x000660, "Wrong size on UGA_ChargedRangedAttackBase");

// Class DungeonCrawler.DCConstantDataAsset
// 0x0008 (0x0050 - 0x0048)
class UDCConstantDataAsset final : public UDCTableDataAsset
{
public:
	float                                         FloatValue;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int32Value;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCConstantDataAsset">();
	}
	static class UDCConstantDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCConstantDataAsset>();
	}
};
static_assert(alignof(UDCConstantDataAsset) == 0x000008, "Wrong alignment on UDCConstantDataAsset");
static_assert(sizeof(UDCConstantDataAsset) == 0x000050, "Wrong size on UDCConstantDataAsset");
static_assert(offsetof(UDCConstantDataAsset, FloatValue) == 0x000048, "Member 'UDCConstantDataAsset::FloatValue' has a wrong offset!");
static_assert(offsetof(UDCConstantDataAsset, Int32Value) == 0x00004C, "Member 'UDCConstantDataAsset::Int32Value' has a wrong offset!");

// Class DungeonCrawler.DCGATA_LineTraceInteractable
// 0x00E0 (0x04C0 - 0x03E0)
class ADCGATA_LineTraceInteractable final : public AGameplayAbilityTargetActor
{
public:
	FMulticastInlineDelegateProperty_             FoundNewInteractableTarget;                        // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LostInteractableTarget;                            // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DD[0xB8];                                    // 0x0408(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_LineTraceInteractable">();
	}
	static class ADCGATA_LineTraceInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_LineTraceInteractable>();
	}
};
static_assert(alignof(ADCGATA_LineTraceInteractable) == 0x000010, "Wrong alignment on ADCGATA_LineTraceInteractable");
static_assert(sizeof(ADCGATA_LineTraceInteractable) == 0x0004C0, "Wrong size on ADCGATA_LineTraceInteractable");
static_assert(offsetof(ADCGATA_LineTraceInteractable, FoundNewInteractableTarget) == 0x0003E0, "Member 'ADCGATA_LineTraceInteractable::FoundNewInteractableTarget' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineTraceInteractable, LostInteractableTarget) == 0x0003F0, "Member 'ADCGATA_LineTraceInteractable::LostInteractableTarget' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineTraceInteractable, MaxRange) == 0x000400, "Member 'ADCGATA_LineTraceInteractable::MaxRange' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineTraceInteractable, Radius) == 0x000404, "Member 'ADCGATA_LineTraceInteractable::Radius' has a wrong offset!");

// Class DungeonCrawler.DCContextComponent
// 0x0070 (0x0110 - 0x00A0)
class UDCContextComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_25DE[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UContextMenuWidgetBase>     ContextMenuWidgetClass;                            // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DF[0x10];                                    // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnContextMenuHolderVisibilityChaned(ESlateVisibility Visibility);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCContextComponent">();
	}
	static class UDCContextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCContextComponent>();
	}
};
static_assert(alignof(UDCContextComponent) == 0x000008, "Wrong alignment on UDCContextComponent");
static_assert(sizeof(UDCContextComponent) == 0x000110, "Wrong size on UDCContextComponent");
static_assert(offsetof(UDCContextComponent, ContextMenuWidgetClass) == 0x0000F8, "Member 'UDCContextComponent::ContextMenuWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCContextMenuEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCContextMenuEntryWidgetData final : public UObject
{
public:
	EContextOptionType                            ContextOption;                                     // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E0[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCContextMenuWidget*                   ContextMenuWidget;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCContextMenuEntryWidgetData">();
	}
	static class UDCContextMenuEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCContextMenuEntryWidgetData>();
	}
};
static_assert(alignof(UDCContextMenuEntryWidgetData) == 0x000008, "Wrong alignment on UDCContextMenuEntryWidgetData");
static_assert(sizeof(UDCContextMenuEntryWidgetData) == 0x000038, "Wrong size on UDCContextMenuEntryWidgetData");
static_assert(offsetof(UDCContextMenuEntryWidgetData, ContextOption) == 0x000028, "Member 'UDCContextMenuEntryWidgetData::ContextOption' has a wrong offset!");
static_assert(offsetof(UDCContextMenuEntryWidgetData, ContextMenuWidget) == 0x000030, "Member 'UDCContextMenuEntryWidgetData::ContextMenuWidget' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionComboBoxWidget
// 0x0020 (0x0378 - 0x0358)
class UGameMenuOptionComboBoxWidget : public UDCWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnSelectionChanged;                                // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UComboBoxString*                        ComboBox;                                          // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Title;                                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddComboBox(const class FString& InComboBoxData);
	void ClearComboBox();
	class UWidget* GetPrimaryGamepadFocusWidget();
	int32 GetSelectedComboBoxIndex();
	class FString GetSelectedComboBoxText();
	void SetComboBoxIndex(int32 InIndex);
	void SetComboBoxList(const TArray<class FString>& InComboBoxDataList);
	void SetSelectedOption(const class FString& Option);
	void SetTitle(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionComboBoxWidget">();
	}
	static class UGameMenuOptionComboBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionComboBoxWidget>();
	}
};
static_assert(alignof(UGameMenuOptionComboBoxWidget) == 0x000008, "Wrong alignment on UGameMenuOptionComboBoxWidget");
static_assert(sizeof(UGameMenuOptionComboBoxWidget) == 0x000378, "Wrong size on UGameMenuOptionComboBoxWidget");
static_assert(offsetof(UGameMenuOptionComboBoxWidget, OnSelectionChanged) == 0x000358, "Member 'UGameMenuOptionComboBoxWidget::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionComboBoxWidget, ComboBox) == 0x000368, "Member 'UGameMenuOptionComboBoxWidget::ComboBox' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionComboBoxWidget, Title) == 0x000370, "Member 'UGameMenuOptionComboBoxWidget::Title' has a wrong offset!");

// Class DungeonCrawler.DCHudWidgetBase
// 0x0000 (0x0358 - 0x0358)
class UDCHudWidgetBase final : public UDCWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCHudWidgetBase">();
	}
	static class UDCHudWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCHudWidgetBase>();
	}
};
static_assert(alignof(UDCHudWidgetBase) == 0x000008, "Wrong alignment on UDCHudWidgetBase");
static_assert(sizeof(UDCHudWidgetBase) == 0x000358, "Wrong size on UDCHudWidgetBase");

// Class DungeonCrawler.DCContextMenuEntryWidget
// 0x0010 (0x02D0 - 0x02C0)
class UDCContextMenuEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_25E1[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EContextOptionType                            ContextOption;                                     // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E2[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCContextMenuEntryWidget">();
	}
	static class UDCContextMenuEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCContextMenuEntryWidget>();
	}
};
static_assert(alignof(UDCContextMenuEntryWidget) == 0x000008, "Wrong alignment on UDCContextMenuEntryWidget");
static_assert(sizeof(UDCContextMenuEntryWidget) == 0x0002D0, "Wrong size on UDCContextMenuEntryWidget");
static_assert(offsetof(UDCContextMenuEntryWidget, ContextOption) == 0x0002C8, "Member 'UDCContextMenuEntryWidget::ContextOption' has a wrong offset!");

// Class DungeonCrawler.DCContextMenuWidget
// 0x0030 (0x02F0 - 0x02C0)
class UDCContextMenuWidget : public UUserWidget
{
public:
	uint8                                         Pad_25E3[0x20];                                    // 0x02C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               RootOverlay;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UListView*                              ListView;                                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCContextMenuWidget">();
	}
	static class UDCContextMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCContextMenuWidget>();
	}
};
static_assert(alignof(UDCContextMenuWidget) == 0x000008, "Wrong alignment on UDCContextMenuWidget");
static_assert(sizeof(UDCContextMenuWidget) == 0x0002F0, "Wrong size on UDCContextMenuWidget");
static_assert(offsetof(UDCContextMenuWidget, RootOverlay) == 0x0002E0, "Member 'UDCContextMenuWidget::RootOverlay' has a wrong offset!");
static_assert(offsetof(UDCContextMenuWidget, ListView) == 0x0002E8, "Member 'UDCContextMenuWidget::ListView' has a wrong offset!");

// Class DungeonCrawler.DCInputComponent
// 0x0000 (0x0160 - 0x0160)
class UDCInputComponent final : public UEnhancedInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInputComponent">();
	}
	static class UDCInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInputComponent>();
	}
};
static_assert(alignof(UDCInputComponent) == 0x000008, "Wrong alignment on UDCInputComponent");
static_assert(sizeof(UDCInputComponent) == 0x000160, "Wrong size on UDCInputComponent");

// Class DungeonCrawler.DCCountButtonWidget
// 0x0000 (0x1660 - 0x1660)
class UDCCountButtonWidget final : public UDCCommonButtonBase
{
public:
	int32                                         Count;                                             // 0x1658(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E4[0x4];                                     // 0x165C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCount(int32 InCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCountButtonWidget">();
	}
	static class UDCCountButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCountButtonWidget>();
	}
};
static_assert(alignof(UDCCountButtonWidget) == 0x000010, "Wrong alignment on UDCCountButtonWidget");
static_assert(sizeof(UDCCountButtonWidget) == 0x001660, "Wrong size on UDCCountButtonWidget");
static_assert(offsetof(UDCCountButtonWidget, Count) == 0x001658, "Member 'UDCCountButtonWidget::Count' has a wrong offset!");

// Class DungeonCrawler.DCCrossPlatformLinkManager
// 0x00B8 (0x00E8 - 0x0030)
class UDCCrossPlatformLinkManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_25E5[0x48];                                    // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDCPlatform, class FString>              PlatformAccountMap;                                // 0x0078(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class FString                                 FAQUrl;                                            // 0x00C8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LinkCode;                                          // 0x00D8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCrossPlatformLinkManager">();
	}
	static class UDCCrossPlatformLinkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCrossPlatformLinkManager>();
	}
};
static_assert(alignof(UDCCrossPlatformLinkManager) == 0x000008, "Wrong alignment on UDCCrossPlatformLinkManager");
static_assert(sizeof(UDCCrossPlatformLinkManager) == 0x0000E8, "Wrong size on UDCCrossPlatformLinkManager");
static_assert(offsetof(UDCCrossPlatformLinkManager, PlatformAccountMap) == 0x000078, "Member 'UDCCrossPlatformLinkManager::PlatformAccountMap' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkManager, FAQUrl) == 0x0000C8, "Member 'UDCCrossPlatformLinkManager::FAQUrl' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkManager, LinkCode) == 0x0000D8, "Member 'UDCCrossPlatformLinkManager::LinkCode' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsInputBindPopupWidget
// 0x0010 (0x0498 - 0x0488)
class UGameMenuOptionsInputBindPopupWidget : public UDCCommonActivatableWidgetBase
{
public:
	uint8                                         Pad_25E6[0x10];                                    // 0x0488(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsInputBindPopupWidget">();
	}
	static class UGameMenuOptionsInputBindPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsInputBindPopupWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsInputBindPopupWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsInputBindPopupWidget");
static_assert(sizeof(UGameMenuOptionsInputBindPopupWidget) == 0x000498, "Wrong size on UGameMenuOptionsInputBindPopupWidget");

// Class DungeonCrawler.DCCrossPlatformLinkPopup
// 0x0070 (0x0500 - 0x0490)
class UDCCrossPlatformLinkPopup : public UCommonPopupBase
{
public:
	class UDCCrossPlatformLinkPopupData*          CrossPlatformLinkPopupData;                        // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          EnterCodeEditableText;                             // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonLinkAccount;                                 // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonClearCode;                                   // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonOk;                                          // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonCancel;                                      // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              CheckBoxTextOnOff;                                 // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LinkFailedReason;                                  // 0x04C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E7[0x20];                                    // 0x04E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelButtonClicked();
	void OnCheckBoxStateChanged(bool bIsChecked);
	void OnClearCodeButtonClicked();
	void OnClearLinkCode();
	void OnLinkAccountButtonClicked();
	void OnOkButtonClicked();
	void OnStateChanged(EDCCrossPlatfromLinkPopupState InState);
	void OnTextChangedLickCode(const class FText& InLinkCode);
	void OnTryLink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCrossPlatformLinkPopup">();
	}
	static class UDCCrossPlatformLinkPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCrossPlatformLinkPopup>();
	}
};
static_assert(alignof(UDCCrossPlatformLinkPopup) == 0x000008, "Wrong alignment on UDCCrossPlatformLinkPopup");
static_assert(sizeof(UDCCrossPlatformLinkPopup) == 0x000500, "Wrong size on UDCCrossPlatformLinkPopup");
static_assert(offsetof(UDCCrossPlatformLinkPopup, CrossPlatformLinkPopupData) == 0x000490, "Member 'UDCCrossPlatformLinkPopup::CrossPlatformLinkPopupData' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, EnterCodeEditableText) == 0x000498, "Member 'UDCCrossPlatformLinkPopup::EnterCodeEditableText' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, ButtonLinkAccount) == 0x0004A0, "Member 'UDCCrossPlatformLinkPopup::ButtonLinkAccount' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, ButtonClearCode) == 0x0004A8, "Member 'UDCCrossPlatformLinkPopup::ButtonClearCode' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, ButtonOk) == 0x0004B0, "Member 'UDCCrossPlatformLinkPopup::ButtonOk' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, ButtonCancel) == 0x0004B8, "Member 'UDCCrossPlatformLinkPopup::ButtonCancel' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, CheckBoxTextOnOff) == 0x0004C0, "Member 'UDCCrossPlatformLinkPopup::CheckBoxTextOnOff' has a wrong offset!");
static_assert(offsetof(UDCCrossPlatformLinkPopup, LinkFailedReason) == 0x0004C8, "Member 'UDCCrossPlatformLinkPopup::LinkFailedReason' has a wrong offset!");

// Class DungeonCrawler.DCHitBoxComponent
// 0x0020 (0x05D0 - 0x05B0)
class UDCHitBoxComponent : public UBoxComponent
{
public:
	EHitBoxType                                   HitBoxType;                                        // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E8[0x3];                                     // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplier;                                  // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E9[0x18];                                    // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetClosestLocationOnMesh(const struct FHitResult& InHitResult, const class AActor* Instigator) const;
	EHitDirection GetHitDirection(const struct FVector& AttackerLocation) const;
	struct FHitResult GetHitResultFromClosestLocationTraceOnMesh(const struct FHitResult& InHitResult, const class AActor* Instigator) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCHitBoxComponent">();
	}
	static class UDCHitBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCHitBoxComponent>();
	}
};
static_assert(alignof(UDCHitBoxComponent) == 0x000010, "Wrong alignment on UDCHitBoxComponent");
static_assert(sizeof(UDCHitBoxComponent) == 0x0005D0, "Wrong size on UDCHitBoxComponent");
static_assert(offsetof(UDCHitBoxComponent, HitBoxType) == 0x0005B0, "Member 'UDCHitBoxComponent::HitBoxType' has a wrong offset!");
static_assert(offsetof(UDCHitBoxComponent, DamageMultiplier) == 0x0005B4, "Member 'UDCHitBoxComponent::DamageMultiplier' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeListWidget
// 0x0018 (0x0370 - 0x0358)
class UDCCustomizeListWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_25EB[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTileView*                              TileView;                                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      GridPanel;                                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeListWidget">();
	}
	static class UDCCustomizeListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeListWidget>();
	}
};
static_assert(alignof(UDCCustomizeListWidget) == 0x000008, "Wrong alignment on UDCCustomizeListWidget");
static_assert(sizeof(UDCCustomizeListWidget) == 0x000370, "Wrong size on UDCCustomizeListWidget");
static_assert(offsetof(UDCCustomizeListWidget, TileView) == 0x000360, "Member 'UDCCustomizeListWidget::TileView' has a wrong offset!");
static_assert(offsetof(UDCCustomizeListWidget, GridPanel) == 0x000368, "Member 'UDCCustomizeListWidget::GridPanel' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeActionSkinListWidget
// 0x0030 (0x03A0 - 0x0370)
class UDCCustomizeActionSkinListWidget final : public UDCCustomizeListWidget
{
public:
	uint8                                         Pad_25EC[0x18];                                    // 0x0370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EDCActionSkinType                             ActionSkinType;                                    // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25ED[0x17];                                    // 0x0389(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetActionSkinInfoArray(const TArray<struct FDCActionSkinInfo>& ActionSkinInfoArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeActionSkinListWidget">();
	}
	static class UDCCustomizeActionSkinListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeActionSkinListWidget>();
	}
};
static_assert(alignof(UDCCustomizeActionSkinListWidget) == 0x000008, "Wrong alignment on UDCCustomizeActionSkinListWidget");
static_assert(sizeof(UDCCustomizeActionSkinListWidget) == 0x0003A0, "Wrong size on UDCCustomizeActionSkinListWidget");
static_assert(offsetof(UDCCustomizeActionSkinListWidget, ActionSkinType) == 0x000388, "Member 'UDCCustomizeActionSkinListWidget::ActionSkinType' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionInputSlotItemData
// 0x0010 (0x0038 - 0x0028)
class UGameMenuOptionInputSlotItemData final : public UObject
{
public:
	struct FLoadedMappableConfigPair              LoadedMappableConfigPair;                          // 0x0028(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionInputSlotItemData">();
	}
	static class UGameMenuOptionInputSlotItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionInputSlotItemData>();
	}
};
static_assert(alignof(UGameMenuOptionInputSlotItemData) == 0x000008, "Wrong alignment on UGameMenuOptionInputSlotItemData");
static_assert(sizeof(UGameMenuOptionInputSlotItemData) == 0x000038, "Wrong size on UGameMenuOptionInputSlotItemData");
static_assert(offsetof(UGameMenuOptionInputSlotItemData, LoadedMappableConfigPair) == 0x000028, "Member 'UGameMenuOptionInputSlotItemData::LoadedMappableConfigPair' has a wrong offset!");

// Class DungeonCrawler.DCInGameQuestLogDealTableWidget
// 0x0108 (0x0460 - 0x0358)
class UDCInGameQuestLogDealTableWidget final : public UDCWidgetBase
{
public:
	class FText                                   RequiredLevelText;                                 // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequiredQuestText;                                 // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequiredAffinityText;                              // 0x0388(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRewardItemWidget>        RewardItemWidgetClass;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              RequirementListView;                               // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         RewardItemHorizontalBox;                           // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCQuestRequirementFetchWidget*         FetchRequiredWidget;                               // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCQuestInfo                           QuestInfo;                                         // 0x03C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class FString                                 MerchantId;                                        // 0x0418(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ChapterId;                                         // 0x0428(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCQuestCompleteInfo                   QuestCompleteInfo;                                 // 0x0438(0x0028)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnQuestInfoUpdated();

	EDCQuestState GetQuestState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInGameQuestLogDealTableWidget">();
	}
	static class UDCInGameQuestLogDealTableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInGameQuestLogDealTableWidget>();
	}
};
static_assert(alignof(UDCInGameQuestLogDealTableWidget) == 0x000008, "Wrong alignment on UDCInGameQuestLogDealTableWidget");
static_assert(sizeof(UDCInGameQuestLogDealTableWidget) == 0x000460, "Wrong size on UDCInGameQuestLogDealTableWidget");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, RequiredLevelText) == 0x000358, "Member 'UDCInGameQuestLogDealTableWidget::RequiredLevelText' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, RequiredQuestText) == 0x000370, "Member 'UDCInGameQuestLogDealTableWidget::RequiredQuestText' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, RequiredAffinityText) == 0x000388, "Member 'UDCInGameQuestLogDealTableWidget::RequiredAffinityText' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, RewardItemWidgetClass) == 0x0003A0, "Member 'UDCInGameQuestLogDealTableWidget::RewardItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, MerchantInfoWidget) == 0x0003A8, "Member 'UDCInGameQuestLogDealTableWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, RequirementListView) == 0x0003B0, "Member 'UDCInGameQuestLogDealTableWidget::RequirementListView' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, RewardItemHorizontalBox) == 0x0003B8, "Member 'UDCInGameQuestLogDealTableWidget::RewardItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, FetchRequiredWidget) == 0x0003C0, "Member 'UDCInGameQuestLogDealTableWidget::FetchRequiredWidget' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, QuestInfo) == 0x0003C8, "Member 'UDCInGameQuestLogDealTableWidget::QuestInfo' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, MerchantId) == 0x000418, "Member 'UDCInGameQuestLogDealTableWidget::MerchantId' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, ChapterId) == 0x000428, "Member 'UDCInGameQuestLogDealTableWidget::ChapterId' has a wrong offset!");
static_assert(offsetof(UDCInGameQuestLogDealTableWidget, QuestCompleteInfo) == 0x000438, "Member 'UDCInGameQuestLogDealTableWidget::QuestCompleteInfo' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeCharacterSkinListWidget
// 0x0028 (0x0398 - 0x0370)
class UDCCustomizeCharacterSkinListWidget final : public UDCCustomizeListWidget
{
public:
	uint8                                         Pad_25EE[0x28];                                    // 0x0370(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetCharacterSkinInfoArray(const TArray<struct FDCCharacterSkinInfo>& CharacterSkinInfoArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeCharacterSkinListWidget">();
	}
	static class UDCCustomizeCharacterSkinListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeCharacterSkinListWidget>();
	}
};
static_assert(alignof(UDCCustomizeCharacterSkinListWidget) == 0x000008, "Wrong alignment on UDCCustomizeCharacterSkinListWidget");
static_assert(sizeof(UDCCustomizeCharacterSkinListWidget) == 0x000398, "Wrong size on UDCCustomizeCharacterSkinListWidget");

// Class DungeonCrawler.DCCustomizeComponent
// 0x0110 (0x01B0 - 0x00A0)
class UDCCustomizeComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_25EF[0x110];                                   // 0x00A0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeComponent">();
	}
	static class UDCCustomizeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeComponent>();
	}
};
static_assert(alignof(UDCCustomizeComponent) == 0x000008, "Wrong alignment on UDCCustomizeComponent");
static_assert(sizeof(UDCCustomizeComponent) == 0x0001B0, "Wrong size on UDCCustomizeComponent");

// Class DungeonCrawler.DCInventoryCurrencyWidget
// 0x0010 (0x02D0 - 0x02C0)
class UDCInventoryCurrencyWidget final : public UUserWidget
{
public:
	int32                                         Currency;                                          // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F0[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCInventoryComponent*                  Source;                                            // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryCurrencyWidget">();
	}
	static class UDCInventoryCurrencyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryCurrencyWidget>();
	}
};
static_assert(alignof(UDCInventoryCurrencyWidget) == 0x000008, "Wrong alignment on UDCInventoryCurrencyWidget");
static_assert(sizeof(UDCInventoryCurrencyWidget) == 0x0002D0, "Wrong size on UDCInventoryCurrencyWidget");
static_assert(offsetof(UDCInventoryCurrencyWidget, Currency) == 0x0002C0, "Member 'UDCInventoryCurrencyWidget::Currency' has a wrong offset!");
static_assert(offsetof(UDCInventoryCurrencyWidget, Source) == 0x0002C8, "Member 'UDCInventoryCurrencyWidget::Source' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeDragVisualWidget
// 0x0008 (0x0360 - 0x0358)
class UDCCustomizeDragVisualWidget final : public UDCWidgetBase
{
public:
	class UTexture2D*                             CustomizeItemTexture;                              // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeDragVisualWidget">();
	}
	static class UDCCustomizeDragVisualWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeDragVisualWidget>();
	}
};
static_assert(alignof(UDCCustomizeDragVisualWidget) == 0x000008, "Wrong alignment on UDCCustomizeDragVisualWidget");
static_assert(sizeof(UDCCustomizeDragVisualWidget) == 0x000360, "Wrong size on UDCCustomizeDragVisualWidget");
static_assert(offsetof(UDCCustomizeDragVisualWidget, CustomizeItemTexture) == 0x000358, "Member 'UDCCustomizeDragVisualWidget::CustomizeItemTexture' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeEmoteListWidget
// 0x0028 (0x0398 - 0x0370)
class UDCCustomizeEmoteListWidget final : public UDCCustomizeListWidget
{
public:
	uint8                                         Pad_25F1[0x28];                                    // 0x0370(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetEmoteIdArray(const TArray<struct FDCEmoteInfo>& EmoteIdArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeEmoteListWidget">();
	}
	static class UDCCustomizeEmoteListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeEmoteListWidget>();
	}
};
static_assert(alignof(UDCCustomizeEmoteListWidget) == 0x000008, "Wrong alignment on UDCCustomizeEmoteListWidget");
static_assert(sizeof(UDCCustomizeEmoteListWidget) == 0x000398, "Wrong size on UDCCustomizeEmoteListWidget");

// Class DungeonCrawler.GameMenuOptionSlotTextBoxTwoButtonWidget
// 0x0030 (0x03D0 - 0x03A0)
class UGameMenuOptionSlotTextBoxTwoButtonWidget : public UGameMenuOptionBaseWidget
{
public:
	class UDCCommonButtonBase*                    ButtonLeft;                                        // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCCommonButtonBase*                    ButtonRight;                                       // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              CheckBoxTextOnOff;                                 // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ContentText;                                       // 0x03B8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionSlotTextBoxTwoButtonWidget">();
	}
	static class UGameMenuOptionSlotTextBoxTwoButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionSlotTextBoxTwoButtonWidget>();
	}
};
static_assert(alignof(UGameMenuOptionSlotTextBoxTwoButtonWidget) == 0x000008, "Wrong alignment on UGameMenuOptionSlotTextBoxTwoButtonWidget");
static_assert(sizeof(UGameMenuOptionSlotTextBoxTwoButtonWidget) == 0x0003D0, "Wrong size on UGameMenuOptionSlotTextBoxTwoButtonWidget");
static_assert(offsetof(UGameMenuOptionSlotTextBoxTwoButtonWidget, ButtonLeft) == 0x0003A0, "Member 'UGameMenuOptionSlotTextBoxTwoButtonWidget::ButtonLeft' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSlotTextBoxTwoButtonWidget, ButtonRight) == 0x0003A8, "Member 'UGameMenuOptionSlotTextBoxTwoButtonWidget::ButtonRight' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSlotTextBoxTwoButtonWidget, CheckBoxTextOnOff) == 0x0003B0, "Member 'UGameMenuOptionSlotTextBoxTwoButtonWidget::CheckBoxTextOnOff' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSlotTextBoxTwoButtonWidget, ContentText) == 0x0003B8, "Member 'UGameMenuOptionSlotTextBoxTwoButtonWidget::ContentText' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeItemSkinListWidget
// 0x0030 (0x03A0 - 0x0370)
class UDCCustomizeItemSkinListWidget final : public UDCCustomizeListWidget
{
public:
	uint8                                         Pad_25F2[0x18];                                    // 0x0370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCItemSkinViewerWidgetBase*            ItemSkinViewerWidget;                              // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F3[0x10];                                    // 0x0390(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangedVisibility(ESlateVisibility InNewVisibility);
	void OnSetItemSkinInfoArray(const TArray<struct FDCItemSkinInfo>& ItemSkinInfoArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeItemSkinListWidget">();
	}
	static class UDCCustomizeItemSkinListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeItemSkinListWidget>();
	}
};
static_assert(alignof(UDCCustomizeItemSkinListWidget) == 0x000008, "Wrong alignment on UDCCustomizeItemSkinListWidget");
static_assert(sizeof(UDCCustomizeItemSkinListWidget) == 0x0003A0, "Wrong size on UDCCustomizeItemSkinListWidget");
static_assert(offsetof(UDCCustomizeItemSkinListWidget, ItemSkinViewerWidget) == 0x000388, "Member 'UDCCustomizeItemSkinListWidget::ItemSkinViewerWidget' has a wrong offset!");

// Class DungeonCrawler.DCIngameInventoryPageWidget
// 0x0048 (0x04F0 - 0x04A8)
class UDCIngameInventoryPageWidget final : public UGameGroupWidgetBase
{
public:
	class UDCCharacterInfoWidget*                 CharacterInfoWidget;                               // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterInventoryWidget*            TargetCharacterWidget;                             // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterInventoryWidget*            LootingCharacterWidget;                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCStorageWidget*                       LootingStorageWidget;                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCExpressmanStorageWidget*             ExpressmanWidget;                                  // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADCCharacterBase*                       TargetCharacter;                                   // 0x04D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCInputNumberWidget>       SplitWidgetClass;                                  // 0x04D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           SplitInputAction;                                  // 0x04E0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInputNumberWidget*                   SplitWidget;                                       // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsUnderDropArea(const struct FVector2D& ScreenSpacePosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIngameInventoryPageWidget">();
	}
	static class UDCIngameInventoryPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCIngameInventoryPageWidget>();
	}
};
static_assert(alignof(UDCIngameInventoryPageWidget) == 0x000008, "Wrong alignment on UDCIngameInventoryPageWidget");
static_assert(sizeof(UDCIngameInventoryPageWidget) == 0x0004F0, "Wrong size on UDCIngameInventoryPageWidget");
static_assert(offsetof(UDCIngameInventoryPageWidget, CharacterInfoWidget) == 0x0004A8, "Member 'UDCIngameInventoryPageWidget::CharacterInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, TargetCharacterWidget) == 0x0004B0, "Member 'UDCIngameInventoryPageWidget::TargetCharacterWidget' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, LootingCharacterWidget) == 0x0004B8, "Member 'UDCIngameInventoryPageWidget::LootingCharacterWidget' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, LootingStorageWidget) == 0x0004C0, "Member 'UDCIngameInventoryPageWidget::LootingStorageWidget' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, ExpressmanWidget) == 0x0004C8, "Member 'UDCIngameInventoryPageWidget::ExpressmanWidget' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, TargetCharacter) == 0x0004D0, "Member 'UDCIngameInventoryPageWidget::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, SplitWidgetClass) == 0x0004D8, "Member 'UDCIngameInventoryPageWidget::SplitWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, SplitInputAction) == 0x0004E0, "Member 'UDCIngameInventoryPageWidget::SplitInputAction' has a wrong offset!");
static_assert(offsetof(UDCIngameInventoryPageWidget, SplitWidget) == 0x0004E8, "Member 'UDCIngameInventoryPageWidget::SplitWidget' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeLobbyEmoteListWidget
// 0x0028 (0x0398 - 0x0370)
class UDCCustomizeLobbyEmoteListWidget final : public UDCCustomizeListWidget
{
public:
	uint8                                         Pad_25F5[0x28];                                    // 0x0370(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetLobbyEmoteIdArray(const TArray<struct FDCLobbyEmoteInfo>& LobbyEmoteIdArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeLobbyEmoteListWidget">();
	}
	static class UDCCustomizeLobbyEmoteListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeLobbyEmoteListWidget>();
	}
};
static_assert(alignof(UDCCustomizeLobbyEmoteListWidget) == 0x000008, "Wrong alignment on UDCCustomizeLobbyEmoteListWidget");
static_assert(sizeof(UDCCustomizeLobbyEmoteListWidget) == 0x000398, "Wrong size on UDCCustomizeLobbyEmoteListWidget");

// Class DungeonCrawler.DCCustomizeRadialSlotWidget
// 0x0098 (0x0528 - 0x0490)
class UDCCustomizeRadialSlotWidget final : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_25F6[0x30];                                    // 0x0490(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                IconOverlay;                                       // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             IconTexture;                                       // 0x04C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             PreviewIconTexture;                                // 0x04D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconAngle;                                         // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F7[0x4];                                     // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_DCCustomizeRadialSlotWidget;                  // 0x04E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   FlavorText;                                        // 0x04F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameTooltipWithFlavorTextWidget*     RadialTooltipWidget;                               // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDragEnter;                                      // 0x0520(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F8[0x7];                                     // 0x0521(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESlateVisibility GetArrowVisibility();
	ESlateVisibility GetHighlightVisibility();
	class UUserWidget* GetTooltipWidget();
	void OnPlayItemDropSound();
	void SetIconImageAngle(float NewAngle);

	bool IsIconVisible() const;
	bool IsPrewiewVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeRadialSlotWidget">();
	}
	static class UDCCustomizeRadialSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeRadialSlotWidget>();
	}
};
static_assert(alignof(UDCCustomizeRadialSlotWidget) == 0x000008, "Wrong alignment on UDCCustomizeRadialSlotWidget");
static_assert(sizeof(UDCCustomizeRadialSlotWidget) == 0x000528, "Wrong size on UDCCustomizeRadialSlotWidget");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, IconOverlay) == 0x0004C0, "Member 'UDCCustomizeRadialSlotWidget::IconOverlay' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, IconTexture) == 0x0004C8, "Member 'UDCCustomizeRadialSlotWidget::IconTexture' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, PreviewIconTexture) == 0x0004D0, "Member 'UDCCustomizeRadialSlotWidget::PreviewIconTexture' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, IconAngle) == 0x0004D8, "Member 'UDCCustomizeRadialSlotWidget::IconAngle' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, Name_DCCustomizeRadialSlotWidget) == 0x0004E0, "Member 'UDCCustomizeRadialSlotWidget::Name_DCCustomizeRadialSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, FlavorText) == 0x0004F8, "Member 'UDCCustomizeRadialSlotWidget::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, TooltipWidgetClass) == 0x000510, "Member 'UDCCustomizeRadialSlotWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, RadialTooltipWidget) == 0x000518, "Member 'UDCCustomizeRadialSlotWidget::RadialTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCCustomizeRadialSlotWidget, bIsDragEnter) == 0x000520, "Member 'UDCCustomizeRadialSlotWidget::bIsDragEnter' has a wrong offset!");

// Class DungeonCrawler.DCCustomizeWidgetBase
// 0x0030 (0x0388 - 0x0358)
class UDCCustomizeWidgetBase final : public UDCWidgetBase
{
public:
	int32                                         CustomizeCurrentPageIndex;                         // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CustomizeMaxPageIndex;                             // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTabListWidgetBase*                   CustomizeTabList;                                  // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CustomizeButtonArrowL;                             // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CustomizeButtonArrowR;                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F9[0x10];                                    // 0x0378(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnyTabButtonSelected(class FName InTabButtonId);
	bool IsCustomizeFirstPage();
	bool IsCustomizeLastPage();
	void OnCustomizeNextPage();
	void OnCustomizePrevPage();
	void OnCustomizeWidgetClose();
	void OnCustomizeWidgetOpen();
	void UpdateCustomizeMaxPageIndex(class FName InTabButtonId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCustomizeWidgetBase">();
	}
	static class UDCCustomizeWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCustomizeWidgetBase>();
	}
};
static_assert(alignof(UDCCustomizeWidgetBase) == 0x000008, "Wrong alignment on UDCCustomizeWidgetBase");
static_assert(sizeof(UDCCustomizeWidgetBase) == 0x000388, "Wrong size on UDCCustomizeWidgetBase");
static_assert(offsetof(UDCCustomizeWidgetBase, CustomizeCurrentPageIndex) == 0x000358, "Member 'UDCCustomizeWidgetBase::CustomizeCurrentPageIndex' has a wrong offset!");
static_assert(offsetof(UDCCustomizeWidgetBase, CustomizeMaxPageIndex) == 0x00035C, "Member 'UDCCustomizeWidgetBase::CustomizeMaxPageIndex' has a wrong offset!");
static_assert(offsetof(UDCCustomizeWidgetBase, CustomizeTabList) == 0x000360, "Member 'UDCCustomizeWidgetBase::CustomizeTabList' has a wrong offset!");
static_assert(offsetof(UDCCustomizeWidgetBase, CustomizeButtonArrowL) == 0x000368, "Member 'UDCCustomizeWidgetBase::CustomizeButtonArrowL' has a wrong offset!");
static_assert(offsetof(UDCCustomizeWidgetBase, CustomizeButtonArrowR) == 0x000370, "Member 'UDCCustomizeWidgetBase::CustomizeButtonArrowR' has a wrong offset!");

// Class DungeonCrawler.DCItemActorAttributeSet
// 0x0000 (0x0AC0 - 0x0AC0)
class UDCItemActorAttributeSet final : public UDCAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemActorAttributeSet">();
	}
	static class UDCItemActorAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemActorAttributeSet>();
	}
};
static_assert(alignof(UDCItemActorAttributeSet) == 0x000008, "Wrong alignment on UDCItemActorAttributeSet");
static_assert(sizeof(UDCItemActorAttributeSet) == 0x000AC0, "Wrong size on UDCItemActorAttributeSet");

// Class DungeonCrawler.DCDamageExecCalculation
// 0x0000 (0x0040 - 0x0040)
class UDCDamageExecCalculation final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDamageExecCalculation">();
	}
	static class UDCDamageExecCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDamageExecCalculation>();
	}
};
static_assert(alignof(UDCDamageExecCalculation) == 0x000008, "Wrong alignment on UDCDamageExecCalculation");
static_assert(sizeof(UDCDamageExecCalculation) == 0x000040, "Wrong size on UDCDamageExecCalculation");

// Class DungeonCrawler.DCDataBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCDataBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString AccountIdToString(const struct FDCAccountId& Value);
	static bool CanAddStack(const struct FDCItemInfo& ItemInfo, int32 Stack);
	static bool FindActorFromActorClassList(const class AActor* InActor, const TArray<TSubclassOf<class AActor>>& InActorClassList);
	static void GetActionSkinIdArray(TArray<struct FPrimaryAssetId>* OutActionSkinIdArray);
	static void GetArmorSkinIdArray(TArray<struct FPrimaryAssetId>* OutArmorSkinIdArray);
	static class FText GetAttackTypeText(const struct FGameplayTag& InAttackTypeTag);
	static TMap<struct FGameplayTag, class FText> GetAttackTypeTextMap();
	static class FText GetAttributeText(const struct FGameplayAttribute& Attribute);
	static const TMap<struct FGameplayAttribute, class FText> GetAttributeTextMap();
	static class FText GetCharacterClassText(EDCCharacterClass InClass);
	static void GetCharacterSkinIdArray(TArray<struct FPrimaryAssetId>* OutCharacterSkinIdArray);
	static float GetConstantFloat(const struct FPrimaryAssetId& InConstantId);
	static int32 GetConstantInt32(const struct FPrimaryAssetId& InConstantId);
	static const class UDescData* GetDescData(const struct FPrimaryAssetId& InId);
	static class UDesignDataAssetItemRequirement* GetDesignDataAssetItemRequirement(const struct FPrimaryAssetId& InId);
	static struct FDesignDataBaseItem GetDesignDataBaseItem(const struct FPrimaryAssetId& InId);
	static struct FDesignDataEmote GetDesignDataEmote(const struct FPrimaryAssetId& InId);
	static struct FDesignDataGameplayAbility GetDesignDataGameplayAbility(const struct FPrimaryAssetId& InId);
	static struct FDesignDataGameplayEffect GetDesignDataGameplayEffect(const struct FPrimaryAssetId& InId);
	static struct FDesignDataGEModifier GetDesignDataGEModifier(const struct FPrimaryAssetId& InId);
	static struct FDesignDataItem GetDesignDataItem(const struct FPrimaryAssetId& InId);
	static struct FDesignDataItemConsume GetDesignDataItemConsume(const struct FPrimaryAssetId& InId);
	static struct FDesignDataItemContainer GetDesignDataItemContainer(const struct FPrimaryAssetId& InId);
	static const TArray<struct FPrimaryAssetId> GetDesignDataItemIdsByGameplayTag(const struct FGameplayTag& ItemGameplayTag);
	static struct FDesignDataItemProperty GetDesignDataItemProperty(const struct FPrimaryAssetId& InId);
	static struct FDesignDataItemPropertyType GetDesignDataItemPropertyType(const struct FPrimaryAssetId& InId);
	static struct FDesignDataItemRequirement GetDesignDataItemRequirement(const struct FPrimaryAssetId& InId);
	static struct FDesignDataMeleeAttack GetDesignDataMeleeAttack(const struct FPrimaryAssetId& InId);
	static struct FDesignDataMonster GetDesignDataMonster(const struct FPrimaryAssetId& InId);
	static struct FDesignDataMovementModifier GetDesignDataMovementModifier(const struct FPrimaryAssetId& InId);
	static struct FDesignDataMusic GetDesignDataMusic(const struct FPrimaryAssetId& InId);
	static void GetDesignDataMusicMap(TMap<struct FPrimaryAssetId, struct FDesignDataMusic>* OutDesignDataMusicMap);
	static struct FDesignDataPerk GetDesignDataPerk(const struct FPrimaryAssetId& InId);
	static void GetDesignDataPerkMap(TMap<struct FPrimaryAssetId, struct FDesignDataPerk>* OutDesignDataPerkMap);
	static struct FDesignDataPlayerCharacter GetDesignDataPlayerCharacter(const struct FPrimaryAssetId& InId);
	static void GetDesignDataPlayerCharacterMap(TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter>* OutDesignDataPlayerCharacterMap);
	static struct FDesignDataProps GetDesignDataProps(const struct FPrimaryAssetId& InId);
	static struct FDesignDataPropsInteract GetDesignDataPropsInteract(const struct FPrimaryAssetId& InId);
	static struct FDesignDataPropsSkillCheck GetDesignDataPropsSkillCheck(const struct FPrimaryAssetId& InId);
	static void GetDesignDataShapeShiftMap(TMap<struct FPrimaryAssetId, struct FDesignDataShapeShift>* OutDesignDataShapeShiftMap);
	static struct FDesignDataSkill GetDesignDataSkill(const struct FPrimaryAssetId& InId);
	static void GetDesignDataSkillMap(TMap<struct FPrimaryAssetId, struct FDesignDataSkill>* OutDesignDataSkillMap);
	static struct FDesignDataSpell GetDesignDataSpell(const struct FPrimaryAssetId& InId);
	static void GetDesignDataSpellMap(TMap<struct FPrimaryAssetId, struct FDesignDataSpell>* OutDesignDataSpellMap);
	static class FText GetDungeonTextByIdTag(const struct FGameplayTag& InIdTag);
	static class FText GetDungeonTypeChapterText(const struct FGameplayTag& InIdTag);
	static class FText GetDungeonTypeDescText(const struct FGameplayTag& InIdTag);
	static class FText GetDungeonTypeGroupText(const struct FGameplayTag& InIdTag);
	static class FText GetDungeonTypeText(const struct FGameplayTag& InIdTag);
	static void GetEmoteIdArray(TArray<struct FPrimaryAssetId>* OutEmoteIdArray);
	static class FText GetFriendErrorMsgText(int32 InResult);
	static struct FGameplayTag GetGameplayTagByItemRarity(const EDCItemRarity ItemRarity);
	static class FText GetGameTypeGroupText(EGameType InGameType);
	static class FText GetGameTypeText(EGameType InGameType);
	static EGameType GetHighRollerGameType(EGameType InGameType);
	static struct FGameplayTagContainer GetIdTagGroupContainer(const struct FPrimaryAssetId& InId);
	static class FText GetIdTagText(const struct FGameplayTag& InIdTag);
	static const TMap<struct FGameplayTag, class FText> GetItemAccessoryTypeTextMap();
	static TSubclassOf<class AItemActor> GetItemActorClass(class AActor* OwnerActor, const struct FItemData& ItemData);
	static const TMap<struct FGameplayTag, class FText> GetItemArmorTypeTextMap();
	static class UArtDataItem* GetItemArtData(const struct FItemData& ItemData);
	static int32 GetItemAvailableCount(const struct FDCItemInfo& ItemInfo);
	static struct FItemData GetItemData(const struct FDCItemInfo& ItemInfo);
	static struct FItemData GetItemDataEx(const struct FDCItemInfo& ItemInfo, const EDCInventoryId Inventory, const int32 Slot);
	static struct FGameplayTagContainer GetItemEffectDefaultFormatTagContainer();
	static struct FGameplayTagContainer GetItemEffectPercentFormatTagContainer();
	static struct FGameplayTagContainer GetItemEffectTimeFormatTagContainer();
	static class FText GetItemEffectValueText(const struct FGameplayTag& InItemEffectTypeTag, const int32 InValue);
	static const TMap<struct FGameplayTag, class FText> GetItemHandTypeTextMap();
	static class FText GetItemIdTagText(const struct FGameplayTag& InIdTag);
	static class FText GetItemLootStateText(EDCItemLootState InLootState);
	static const TMap<struct FGameplayTag, class FText> GetItemMiscTypeTextMap();
	static class FText GetItemPropertyItemTooltipText(const struct FGameplayTag& InItemPropertyTypeTag, const class FString& InValueString, const bool bIsPriamary);
	static struct FPrimaryAssetId GetItemPropertyTypeId_Unidentified();
	static class FText GetItemPropertyTypeText(const struct FGameplayTag& InItemPropertyTypeTag);
	static class FText GetItemPropertyTypeTextFromAsset(const struct FPrimaryAssetId& InItemPropertyTypeId);
	static const TMap<struct FGameplayTag, class FText> GetItemPropertyTypeTextMap();
	static EDCItemRarity GetItemRarityByGameplayTag(const struct FGameplayTag& InItemRarityTag);
	static struct FGameplayTag GetItemRarityLimit(const class UObject* InWorldContextObject, EGameType InGameType);
	static class FText GetItemRarityText(const struct FGameplayTag& InItemRarityTag);
	static const TMap<struct FGameplayTag, class FText> GetItemRarityTypeTextMap();
	static void GetItemSkinIdArray(TArray<struct FPrimaryAssetId>* OutItemSkinIdArray);
	static class FText GetItemSlotText(const struct FGameplayTag& InItemSlotTag);
	static const TMap<struct FGameplayTag, class FText> GetItemSlotTypeTextMap();
	static class FText GetItemTypeCategoryText(const EItemType& ItemType);
	static void GetItemTypeChatFilterTagContainerMaps(const class UDCChatRoomDataAsset* InChatRoomData, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutTypeIdTagChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutTypeRarityChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutTypeSlotChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutPropertyChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutPlayerCharacterChatFilterTagContainerMap);
	static class FText GetItemTypeText(const struct FGameplayTag& InTypeTag);
	static class FText GetItemTypeTextByCategory(const class UDCItemDataAsset* ItemDataAsset, const class FString& FormatString);
	static const TMap<struct FGameplayTag, class FText> GetItemUtilityTypeTextMap();
	static const TMap<struct FGameplayTag, class FText> GetItemWeaponTypeTextMap();
	static void GetLobbyEmoteIdArray(TArray<struct FPrimaryAssetId>* OutLobbyEmoteIdArray);
	static class FText GetLogEventTypeText(const EDCLogEventType& InLogEventType);
	static class FText GetMatchModeText(EMatchMode InMatchMode);
	static class FText GetMonsterIdTagText(const struct FGameplayTag& InIdTag);
	static EGameType GetNormalGameType(EGameType InGameType);
	static class FText GetPlatformName(EDCPlatform InPlatform);
	static class UPrimaryDataAsset* GetPrimaryAssetSync(const struct FPrimaryAssetId& PrimaryAssetId);
	static class FText GetPropsIdTagText(const struct FGameplayTag& InIdTag);
	static const struct FPrimaryAssetId GetRandomDesignDataItemId();
	static class FText GetSetByCallerTagText(const struct FGameplayTag& InSetByCallerTag);
	static const TMap<struct FGameplayTag, class FText> GetSetByCallerTagTextMap();
	static const class UDCShapeShiftDataAsset* GetShapeShiftData(const struct FPrimaryAssetId& InId);
	static class UDCShapeShiftDataAsset* GetShapeShiftDataByTag(const struct FGameplayTag& InTag);
	static TArray<class UDCShapeShiftDataAsset*> GetShapeShiftDatas();
	static class FText GetStatisticsTypeText(EStatisticsType InStatisticsType);
	static class FText GetTypeTagText(const struct FGameplayTag& InTypeTag);
	static const TMap<struct FGameplayTag, class FText> GetTypeTextMap();
	static class FString GetViewNickname(const struct FNickname& Nickname);
	static struct FLinearColor GetViewNicknameColor(const struct FNickname& Nickname);
	static bool IsArenaGameType(EGameType InGameType);
	static bool IsArenaSelected();
	static bool IsAvailableInteraction(class ADCPlayerCharacterBase* Interacter, class AActor* DstActor, const struct FHitResult& InHitResult, float* OutDistance);
	static bool IsAvailableInteractionWithPhysicalTarget(class ADCPlayerCharacterBase* Interacter, class AActor* DstActor, float* OutXYDistance);
	static bool IsDungeonGameType(EGameType InGameType);
	static bool IsDuoGameType(EGameType InGameType);
	static bool IsHighRoller(EGameType InGameType);
	static bool IsItemWearableByClass(class AActor* InOwnerActor, const class AItemActor* InItemActor);
	static bool IsLowViolenceMode();
	static bool IsSoloGameType(EGameType InGameType);
	static bool IsStreamingMode();
	static bool IsTrioGameType(EGameType InGameType);
	static bool IsUtilityItem(const struct FDCItemInfo& ItemInfo, const struct FGameplayTag& Tag);
	static int64 ItemIdToInteger(const struct FDCItemId& Value);
	static TArray<class UObject*> LoadObjectLibrary(const class FString& Path, TSubclassOf<class UObject> ObjectClass);
	static void LoadPrimaryAsset(const struct FPrimaryAssetId& InPrimaryAssetId, const TDelegate<void(class UObject* InObjectLoaded)>& InOnComplete);
	static struct FPrimaryAssetId MakePrimaryAssetId(const class FString& PrimaryAssetIdStr);
	static class FString MakePrimaryAssetIdStr(const struct FPrimaryAssetId& PrimaryAssetId);
	static int64 MakeUniqueId();
	static class FString PartyIdToString(const struct FDCPartyId& Value);
	static class AItemActor* SpawnItemActor(class AActor* OwnerActor, const struct FItemData& ItemData, const struct FTransform& Transform);
	static class AItemHolderActorBase* SpawnItemHolderActor(class AActor* Spawner, const struct FItemData& ItemData);
	static class AItemHolderActorBase* SpawnItemHolderActorWithItemHolderActorClass(class AActor* Spawner, const struct FItemData& ItemData, const TSubclassOf<class AItemHolderActorBase> ItemHolderActorClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDataBlueprintLibrary">();
	}
	static class UDCDataBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDataBlueprintLibrary>();
	}
};
static_assert(alignof(UDCDataBlueprintLibrary) == 0x000008, "Wrong alignment on UDCDataBlueprintLibrary");
static_assert(sizeof(UDCDataBlueprintLibrary) == 0x000028, "Wrong size on UDCDataBlueprintLibrary");

// Class DungeonCrawler.DCDeathCamWidget
// 0x0000 (0x04A8 - 0x04A8)
class UDCDeathCamWidget final : public UGameGroupWidgetBase
{
public:
	float GetProgress();
	bool IsEnded();
	bool IsPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDeathCamWidget">();
	}
	static class UDCDeathCamWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDeathCamWidget>();
	}
};
static_assert(alignof(UDCDeathCamWidget) == 0x000008, "Wrong alignment on UDCDeathCamWidget");
static_assert(sizeof(UDCDeathCamWidget) == 0x0004A8, "Wrong size on UDCDeathCamWidget");

// Class DungeonCrawler.DCInventoryWidget
// 0x0010 (0x03F0 - 0x03E0)
class UDCInventoryWidget final : public UDCInventoryWidgetBase
{
public:
	class UDCEquipmentWidget*                     EquipWidget;                                       // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           BagWidget;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryWidget">();
	}
	static class UDCInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryWidget>();
	}
};
static_assert(alignof(UDCInventoryWidget) == 0x000008, "Wrong alignment on UDCInventoryWidget");
static_assert(sizeof(UDCInventoryWidget) == 0x0003F0, "Wrong size on UDCInventoryWidget");
static_assert(offsetof(UDCInventoryWidget, EquipWidget) == 0x0003E0, "Member 'UDCInventoryWidget::EquipWidget' has a wrong offset!");
static_assert(offsetof(UDCInventoryWidget, BagWidget) == 0x0003E8, "Member 'UDCInventoryWidget::BagWidget' has a wrong offset!");

// Class DungeonCrawler.DCDrawbridgeWheel
// 0x0068 (0x0448 - 0x03E0)
class ADCDrawbridgeWheel : public APropsActorBase
{
public:
	struct FDCWheelInteractData                   WheelInteractData;                                 // 0x03E0(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2614[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAkComponent*                         AkComponent;                                       // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSkeletalMeshComponent*               WheelMeshComponent;                                // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2615[0x30];                                    // 0x0418(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WheelInteractData(const struct FDCWheelInteractData& InOldWheelInteractData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDrawbridgeWheel">();
	}
	static class ADCDrawbridgeWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCDrawbridgeWheel>();
	}
};
static_assert(alignof(ADCDrawbridgeWheel) == 0x000008, "Wrong alignment on ADCDrawbridgeWheel");
static_assert(sizeof(ADCDrawbridgeWheel) == 0x000448, "Wrong size on ADCDrawbridgeWheel");
static_assert(offsetof(ADCDrawbridgeWheel, WheelInteractData) == 0x0003E0, "Member 'ADCDrawbridgeWheel::WheelInteractData' has a wrong offset!");
static_assert(offsetof(ADCDrawbridgeWheel, RootSceneComponent) == 0x000400, "Member 'ADCDrawbridgeWheel::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ADCDrawbridgeWheel, AkComponent) == 0x000408, "Member 'ADCDrawbridgeWheel::AkComponent' has a wrong offset!");
static_assert(offsetof(ADCDrawbridgeWheel, WheelMeshComponent) == 0x000410, "Member 'ADCDrawbridgeWheel::WheelMeshComponent' has a wrong offset!");

// Class DungeonCrawler.DCDungeonDataAsset
// 0x0090 (0x00D8 - 0x0048)
class UDCDungeonDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_DCDungeonDataAsset;                           // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EGameType>                             GameTypes;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Floor;                                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2616[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCFloorRuleDataAsset>   FloorRule;                                         // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LevelAsset;                                        // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriumphExp;                                        // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2617[0x4];                                     // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonDataAsset">();
	}
	static class UDCDungeonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDungeonDataAsset>();
	}
};
static_assert(alignof(UDCDungeonDataAsset) == 0x000008, "Wrong alignment on UDCDungeonDataAsset");
static_assert(sizeof(UDCDungeonDataAsset) == 0x0000D8, "Wrong size on UDCDungeonDataAsset");
static_assert(offsetof(UDCDungeonDataAsset, IdTag) == 0x000048, "Member 'UDCDungeonDataAsset::IdTag' has a wrong offset!");
static_assert(offsetof(UDCDungeonDataAsset, Name_DCDungeonDataAsset) == 0x000050, "Member 'UDCDungeonDataAsset::Name_DCDungeonDataAsset' has a wrong offset!");
static_assert(offsetof(UDCDungeonDataAsset, GameTypes) == 0x000068, "Member 'UDCDungeonDataAsset::GameTypes' has a wrong offset!");
static_assert(offsetof(UDCDungeonDataAsset, Floor) == 0x000078, "Member 'UDCDungeonDataAsset::Floor' has a wrong offset!");
static_assert(offsetof(UDCDungeonDataAsset, FloorRule) == 0x000080, "Member 'UDCDungeonDataAsset::FloorRule' has a wrong offset!");
static_assert(offsetof(UDCDungeonDataAsset, LevelAsset) == 0x0000A8, "Member 'UDCDungeonDataAsset::LevelAsset' has a wrong offset!");
static_assert(offsetof(UDCDungeonDataAsset, TriumphExp) == 0x0000D0, "Member 'UDCDungeonDataAsset::TriumphExp' has a wrong offset!");

// Class DungeonCrawler.DCItemDataAsset
// 0x0220 (0x0268 - 0x0048)
class UDCItemDataAsset final : public UDCTableDataAsset
{
public:
	uint8                                         Pad_2618[0x8];                                     // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           IdTag;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        OriginId;                                          // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_DCItemDataAsset;                              // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2619[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SlotType;                                          // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HandType;                                          // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261A[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   WeaponTypes;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ArmorType;                                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UtilityType;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AccessoryType;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MiscType;                                          // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmmoCount;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDrop;                                           // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSaveIntoDatabase;                               // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForceTradeable;                                  // 0x010A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261B[0x5];                                     // 0x010B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UArtDataItem>            ArtData;                                           // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemConsumeDataAsset> ConsumeData;                                       // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemActor>                 ActorClass;                                        // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActorClass;                              // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryWidth;                                    // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryHeight;                                   // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WearingDelayTime;                                  // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261C[0x4];                                     // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> SelfAbilities;                                     // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> SelfEffects;                                       // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x01D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemPropertyDataAsset> PrimaryProperty;                                   // 0x01E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCItemPropertyDataAsset>> SecondaryProperties;                               // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDCItemRequirementDataAsset*            Requirement;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemBundleInfoDataAsset> BundleInfo;                                        // 0x0228(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemContainerDataAsset*              ContainerData;                                     // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdvPoint;                                          // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpPoint;                                          // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GearScore;                                         // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261D[0x4];                                     // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EDCItemEquipType GetEquipType() const;
	bool IsSoulHeart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemDataAsset">();
	}
	static class UDCItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemDataAsset>();
	}
};
static_assert(alignof(UDCItemDataAsset) == 0x000008, "Wrong alignment on UDCItemDataAsset");
static_assert(sizeof(UDCItemDataAsset) == 0x000268, "Wrong size on UDCItemDataAsset");
static_assert(offsetof(UDCItemDataAsset, IdTag) == 0x000050, "Member 'UDCItemDataAsset::IdTag' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, OriginId) == 0x000058, "Member 'UDCItemDataAsset::OriginId' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, Name_DCItemDataAsset) == 0x000080, "Member 'UDCItemDataAsset::Name_DCItemDataAsset' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, FlavorText) == 0x000098, "Member 'UDCItemDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ItemType) == 0x0000B0, "Member 'UDCItemDataAsset::ItemType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, SlotType) == 0x0000B4, "Member 'UDCItemDataAsset::SlotType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, HandType) == 0x0000BC, "Member 'UDCItemDataAsset::HandType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, WeaponTypes) == 0x0000C8, "Member 'UDCItemDataAsset::WeaponTypes' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ArmorType) == 0x0000D8, "Member 'UDCItemDataAsset::ArmorType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, UtilityType) == 0x0000E0, "Member 'UDCItemDataAsset::UtilityType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, AccessoryType) == 0x0000E8, "Member 'UDCItemDataAsset::AccessoryType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, MiscType) == 0x0000F0, "Member 'UDCItemDataAsset::MiscType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, RarityType) == 0x0000F8, "Member 'UDCItemDataAsset::RarityType' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, MaxCount) == 0x000100, "Member 'UDCItemDataAsset::MaxCount' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, MaxAmmoCount) == 0x000104, "Member 'UDCItemDataAsset::MaxAmmoCount' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, CanDrop) == 0x000108, "Member 'UDCItemDataAsset::CanDrop' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, CanSaveIntoDatabase) == 0x000109, "Member 'UDCItemDataAsset::CanSaveIntoDatabase' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, IsForceTradeable) == 0x00010A, "Member 'UDCItemDataAsset::IsForceTradeable' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ArtData) == 0x000110, "Member 'UDCItemDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, SoundData) == 0x000138, "Member 'UDCItemDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ConsumeData) == 0x000160, "Member 'UDCItemDataAsset::ConsumeData' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ActorClass) == 0x000188, "Member 'UDCItemDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ItemHolderActorClass) == 0x000190, "Member 'UDCItemDataAsset::ItemHolderActorClass' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, InventoryWidth) == 0x000198, "Member 'UDCItemDataAsset::InventoryWidth' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, InventoryHeight) == 0x00019C, "Member 'UDCItemDataAsset::InventoryHeight' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, WearingDelayTime) == 0x0001A0, "Member 'UDCItemDataAsset::WearingDelayTime' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, SelfAbilities) == 0x0001A8, "Member 'UDCItemDataAsset::SelfAbilities' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, SelfEffects) == 0x0001B8, "Member 'UDCItemDataAsset::SelfEffects' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, Abilities) == 0x0001C8, "Member 'UDCItemDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, Effects) == 0x0001D8, "Member 'UDCItemDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, PrimaryProperty) == 0x0001E8, "Member 'UDCItemDataAsset::PrimaryProperty' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, SecondaryProperties) == 0x000210, "Member 'UDCItemDataAsset::SecondaryProperties' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, Requirement) == 0x000220, "Member 'UDCItemDataAsset::Requirement' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, BundleInfo) == 0x000228, "Member 'UDCItemDataAsset::BundleInfo' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ContainerData) == 0x000250, "Member 'UDCItemDataAsset::ContainerData' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, AdvPoint) == 0x000258, "Member 'UDCItemDataAsset::AdvPoint' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, ExpPoint) == 0x00025C, "Member 'UDCItemDataAsset::ExpPoint' has a wrong offset!");
static_assert(offsetof(UDCItemDataAsset, GearScore) == 0x000260, "Member 'UDCItemDataAsset::GearScore' has a wrong offset!");

// Class DungeonCrawler.DCDungeonTypeDataAsset
// 0x0070 (0x00B8 - 0x0048)
class UDCDungeonTypeDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_DCDungeonTypeDataAsset;                       // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   GroupName;                                         // 0x0068(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ChapterName;                                       // 0x0080(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Desc;                                              // 0x0098(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261E[0x4];                                     // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonTypeDataAsset">();
	}
	static class UDCDungeonTypeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDungeonTypeDataAsset>();
	}
};
static_assert(alignof(UDCDungeonTypeDataAsset) == 0x000008, "Wrong alignment on UDCDungeonTypeDataAsset");
static_assert(sizeof(UDCDungeonTypeDataAsset) == 0x0000B8, "Wrong size on UDCDungeonTypeDataAsset");
static_assert(offsetof(UDCDungeonTypeDataAsset, IdTag) == 0x000048, "Member 'UDCDungeonTypeDataAsset::IdTag' has a wrong offset!");
static_assert(offsetof(UDCDungeonTypeDataAsset, Name_DCDungeonTypeDataAsset) == 0x000050, "Member 'UDCDungeonTypeDataAsset::Name_DCDungeonTypeDataAsset' has a wrong offset!");
static_assert(offsetof(UDCDungeonTypeDataAsset, GroupName) == 0x000068, "Member 'UDCDungeonTypeDataAsset::GroupName' has a wrong offset!");
static_assert(offsetof(UDCDungeonTypeDataAsset, ChapterName) == 0x000080, "Member 'UDCDungeonTypeDataAsset::ChapterName' has a wrong offset!");
static_assert(offsetof(UDCDungeonTypeDataAsset, Desc) == 0x000098, "Member 'UDCDungeonTypeDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCDungeonTypeDataAsset, Order) == 0x0000B0, "Member 'UDCDungeonTypeDataAsset::Order' has a wrong offset!");

// Class DungeonCrawler.DCDungeonModuleDataAsset
// 0x0018 (0x0060 - 0x0048)
class UDCDungeonModuleDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCDungeonModuleDataAsset;                     // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonModuleDataAsset">();
	}
	static class UDCDungeonModuleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDungeonModuleDataAsset>();
	}
};
static_assert(alignof(UDCDungeonModuleDataAsset) == 0x000008, "Wrong alignment on UDCDungeonModuleDataAsset");
static_assert(sizeof(UDCDungeonModuleDataAsset) == 0x000060, "Wrong size on UDCDungeonModuleDataAsset");
static_assert(offsetof(UDCDungeonModuleDataAsset, Name_DCDungeonModuleDataAsset) == 0x000048, "Member 'UDCDungeonModuleDataAsset::Name_DCDungeonModuleDataAsset' has a wrong offset!");

// Class DungeonCrawler.GA_MusicGrantingAbilityBase
// 0x0040 (0x0840 - 0x0800)
class UGA_MusicGrantingAbilityBase : public UGA_MusicBase
{
public:
	struct FPrimaryAssetId                        GrantingAbilityId;                                 // 0x0800(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GrantedAbilityTag;                                 // 0x0810(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCGameplayAbilityData                 GrantingAbilityData;                               // 0x0818(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnTargetActorOverlap(const TArray<class AActor*>& TargetActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MusicGrantingAbilityBase">();
	}
	static class UGA_MusicGrantingAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MusicGrantingAbilityBase>();
	}
};
static_assert(alignof(UGA_MusicGrantingAbilityBase) == 0x000008, "Wrong alignment on UGA_MusicGrantingAbilityBase");
static_assert(sizeof(UGA_MusicGrantingAbilityBase) == 0x000840, "Wrong size on UGA_MusicGrantingAbilityBase");
static_assert(offsetof(UGA_MusicGrantingAbilityBase, GrantingAbilityId) == 0x000800, "Member 'UGA_MusicGrantingAbilityBase::GrantingAbilityId' has a wrong offset!");
static_assert(offsetof(UGA_MusicGrantingAbilityBase, GrantedAbilityTag) == 0x000810, "Member 'UGA_MusicGrantingAbilityBase::GrantedAbilityTag' has a wrong offset!");
static_assert(offsetof(UGA_MusicGrantingAbilityBase, GrantingAbilityData) == 0x000818, "Member 'UGA_MusicGrantingAbilityBase::GrantingAbilityData' has a wrong offset!");

// Class DungeonCrawler.DCItemContainerDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCItemContainerDataAsset final : public UDCTableDataAsset
{
public:
	class UDCItemDataAsset*                       ContentsItem;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxContentsCount;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261F[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemContainerDataAsset">();
	}
	static class UDCItemContainerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemContainerDataAsset>();
	}
};
static_assert(alignof(UDCItemContainerDataAsset) == 0x000008, "Wrong alignment on UDCItemContainerDataAsset");
static_assert(sizeof(UDCItemContainerDataAsset) == 0x000058, "Wrong size on UDCItemContainerDataAsset");
static_assert(offsetof(UDCItemContainerDataAsset, ContentsItem) == 0x000048, "Member 'UDCItemContainerDataAsset::ContentsItem' has a wrong offset!");
static_assert(offsetof(UDCItemContainerDataAsset, MaxContentsCount) == 0x000050, "Member 'UDCItemContainerDataAsset::MaxContentsCount' has a wrong offset!");

// Class DungeonCrawler.DCDungeonGameState
// 0x0138 (0x08E8 - 0x07B0)
class ADCDungeonGameState final : public ADCGameStateBase
{
public:
	struct FGameAnnounceData                      AnnounceForDown;                                   // 0x07B0(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         DungeonNextFloorAnnounceDelaySeconds;              // 0x0840(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DungeonNextFloorLoadingDelaySeconds;               // 0x0844(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameAnnounceData                      AnnounceForResult;                                 // 0x0848(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         DungeonResultAnnounceDelaySeconds;                 // 0x08D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DungeonResultLoadingDelaySeconds;                  // 0x08DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPlayers;                                        // 0x08E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPauseServerUpdate;                                // 0x08E4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2620[0x3];                                     // 0x08E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bPauseServerUpdate(bool bOldPauseServerUpdate);
	void OnRep_NumPlayers(const int32 OldNumPlayers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonGameState">();
	}
	static class ADCDungeonGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCDungeonGameState>();
	}
};
static_assert(alignof(ADCDungeonGameState) == 0x000008, "Wrong alignment on ADCDungeonGameState");
static_assert(sizeof(ADCDungeonGameState) == 0x0008E8, "Wrong size on ADCDungeonGameState");
static_assert(offsetof(ADCDungeonGameState, AnnounceForDown) == 0x0007B0, "Member 'ADCDungeonGameState::AnnounceForDown' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, DungeonNextFloorAnnounceDelaySeconds) == 0x000840, "Member 'ADCDungeonGameState::DungeonNextFloorAnnounceDelaySeconds' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, DungeonNextFloorLoadingDelaySeconds) == 0x000844, "Member 'ADCDungeonGameState::DungeonNextFloorLoadingDelaySeconds' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, AnnounceForResult) == 0x000848, "Member 'ADCDungeonGameState::AnnounceForResult' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, DungeonResultAnnounceDelaySeconds) == 0x0008D8, "Member 'ADCDungeonGameState::DungeonResultAnnounceDelaySeconds' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, DungeonResultLoadingDelaySeconds) == 0x0008DC, "Member 'ADCDungeonGameState::DungeonResultLoadingDelaySeconds' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, NumPlayers) == 0x0008E0, "Member 'ADCDungeonGameState::NumPlayers' has a wrong offset!");
static_assert(offsetof(ADCDungeonGameState, bPauseServerUpdate) == 0x0008E4, "Member 'ADCDungeonGameState::bPauseServerUpdate' has a wrong offset!");

// Class DungeonCrawler.DCStateButtonWidgetBase
// 0x0010 (0x1670 - 0x1660)
class UDCStateButtonWidgetBase : public UDCCommonButtonBase
{
public:
	uint8                                         Pad_2621[0x18];                                    // 0x1658(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommonButtonClickedInternal();
	void SetActive(bool bState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStateButtonWidgetBase">();
	}
	static class UDCStateButtonWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStateButtonWidgetBase>();
	}
};
static_assert(alignof(UDCStateButtonWidgetBase) == 0x000010, "Wrong alignment on UDCStateButtonWidgetBase");
static_assert(sizeof(UDCStateButtonWidgetBase) == 0x001670, "Wrong size on UDCStateButtonWidgetBase");

// Class DungeonCrawler.DCDungeonResultItemWidgetData
// 0x0038 (0x0060 - 0x0028)
class UDCDungeonResultItemWidgetData final : public UObject
{
public:
	EDCLogEventType                               ResultType;                                        // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2622[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResultCountText;                                   // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ResultAdvPointText;                                // 0x0048(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCDungeonResultItemWidgetData">();
	}
	static class UDCDungeonResultItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCDungeonResultItemWidgetData>();
	}
};
static_assert(alignof(UDCDungeonResultItemWidgetData) == 0x000008, "Wrong alignment on UDCDungeonResultItemWidgetData");
static_assert(sizeof(UDCDungeonResultItemWidgetData) == 0x000060, "Wrong size on UDCDungeonResultItemWidgetData");
static_assert(offsetof(UDCDungeonResultItemWidgetData, ResultType) == 0x000028, "Member 'UDCDungeonResultItemWidgetData::ResultType' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultItemWidgetData, ResultCountText) == 0x000030, "Member 'UDCDungeonResultItemWidgetData::ResultCountText' has a wrong offset!");
static_assert(offsetof(UDCDungeonResultItemWidgetData, ResultAdvPointText) == 0x000048, "Member 'UDCDungeonResultItemWidgetData::ResultAdvPointText' has a wrong offset!");

// Class DungeonCrawler.DCItemPropertyDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCItemPropertyDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDDCItemPropertyItem>           ItemPropertyItemArray;                             // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemPropertyDataAsset">();
	}
	static class UDCItemPropertyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemPropertyDataAsset>();
	}
};
static_assert(alignof(UDCItemPropertyDataAsset) == 0x000008, "Wrong alignment on UDCItemPropertyDataAsset");
static_assert(sizeof(UDCItemPropertyDataAsset) == 0x000058, "Wrong size on UDCItemPropertyDataAsset");
static_assert(offsetof(UDCItemPropertyDataAsset, ItemPropertyItemArray) == 0x000048, "Member 'UDCItemPropertyDataAsset::ItemPropertyItemArray' has a wrong offset!");

// Class DungeonCrawler.DCEditableText
// 0x0040 (0x0550 - 0x0510)
class UDCEditableText final : public UEditableText
{
public:
	uint8                                         Pad_2623[0x40];                                    // 0x0510(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEditableText">();
	}
	static class UDCEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEditableText>();
	}
};
static_assert(alignof(UDCEditableText) == 0x000010, "Wrong alignment on UDCEditableText");
static_assert(sizeof(UDCEditableText) == 0x000550, "Wrong size on UDCEditableText");

// Class DungeonCrawler.DCItemSkinWidget
// 0x0080 (0x0510 - 0x0490)
class UDCItemSkinWidget : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_2624[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemSkinName;                                      // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemSkinFlavorText;                                // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ItemSkinIconTexture;                               // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        ItemSkinId;                                        // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2625[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameTooltipWithFlavorTextWidget*     SkinTooltipWidget;                                 // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtDataItem*                           ItemSkinArtData;                                   // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinWidget">();
	}
	static class UDCItemSkinWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinWidget>();
	}
};
static_assert(alignof(UDCItemSkinWidget) == 0x000008, "Wrong alignment on UDCItemSkinWidget");
static_assert(sizeof(UDCItemSkinWidget) == 0x000510, "Wrong size on UDCItemSkinWidget");
static_assert(offsetof(UDCItemSkinWidget, ItemSkinName) == 0x0004A8, "Member 'UDCItemSkinWidget::ItemSkinName' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, ItemSkinFlavorText) == 0x0004C0, "Member 'UDCItemSkinWidget::ItemSkinFlavorText' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, ItemSkinIconTexture) == 0x0004D8, "Member 'UDCItemSkinWidget::ItemSkinIconTexture' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, ItemSkinId) == 0x0004E0, "Member 'UDCItemSkinWidget::ItemSkinId' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, bIsEquipped) == 0x0004F0, "Member 'UDCItemSkinWidget::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, TooltipWidgetClass) == 0x0004F8, "Member 'UDCItemSkinWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, SkinTooltipWidget) == 0x000500, "Member 'UDCItemSkinWidget::SkinTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCItemSkinWidget, ItemSkinArtData) == 0x000508, "Member 'UDCItemSkinWidget::ItemSkinArtData' has a wrong offset!");

// Class DungeonCrawler.DCItemSkinListEntryWidget
// 0x0010 (0x0520 - 0x0510)
class UDCItemSkinListEntryWidget final : public UDCItemSkinWidget
{
public:
	uint8                                         Pad_2626[0x10];                                    // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinListEntryWidget">();
	}
	static class UDCItemSkinListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinListEntryWidget>();
	}
};
static_assert(alignof(UDCItemSkinListEntryWidget) == 0x000008, "Wrong alignment on UDCItemSkinListEntryWidget");
static_assert(sizeof(UDCItemSkinListEntryWidget) == 0x000520, "Wrong size on UDCItemSkinListEntryWidget");

// Class DungeonCrawler.DCQuestLogContentsListEntryData
// 0x0058 (0x0080 - 0x0028)
class UDCQuestLogContentsListEntryData final : public UObject
{
public:
	struct FDCQuestInfo                           QuestInfo;                                         // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2627[0x7];                                     // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogContentsListEntryData">();
	}
	static class UDCQuestLogContentsListEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogContentsListEntryData>();
	}
};
static_assert(alignof(UDCQuestLogContentsListEntryData) == 0x000008, "Wrong alignment on UDCQuestLogContentsListEntryData");
static_assert(sizeof(UDCQuestLogContentsListEntryData) == 0x000080, "Wrong size on UDCQuestLogContentsListEntryData");
static_assert(offsetof(UDCQuestLogContentsListEntryData, QuestInfo) == 0x000028, "Member 'UDCQuestLogContentsListEntryData::QuestInfo' has a wrong offset!");
static_assert(offsetof(UDCQuestLogContentsListEntryData, bIsSelected) == 0x000078, "Member 'UDCQuestLogContentsListEntryData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.DCEmoteListEntryWidgetData
// 0x0018 (0x0040 - 0x0028)
class UDCEmoteListEntryWidgetData final : public UObject
{
public:
	struct FDCEmoteInfo                           EmoteInfo;                                         // 0x0028(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2628[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEmoteListEntryWidgetData">();
	}
	static class UDCEmoteListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEmoteListEntryWidgetData>();
	}
};
static_assert(alignof(UDCEmoteListEntryWidgetData) == 0x000008, "Wrong alignment on UDCEmoteListEntryWidgetData");
static_assert(sizeof(UDCEmoteListEntryWidgetData) == 0x000040, "Wrong size on UDCEmoteListEntryWidgetData");
static_assert(offsetof(UDCEmoteListEntryWidgetData, EmoteInfo) == 0x000028, "Member 'UDCEmoteListEntryWidgetData::EmoteInfo' has a wrong offset!");
static_assert(offsetof(UDCEmoteListEntryWidgetData, bIsSelected) == 0x000038, "Member 'UDCEmoteListEntryWidgetData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.ItemTooltipWidget
// 0x0100 (0x0458 - 0x0358)
class UItemTooltipWidget : public UDCWidgetBase
{
public:
	struct FItemTooltipWidgetData                 WidgetData;                                        // 0x0358(0x0100)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnItemData(const struct FItemData& NewItemData, const struct FItemData& OldItemData);
	void OnRefreshItemName();
	void SetItemData(const struct FItemData& NewItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipWidget">();
	}
	static class UItemTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipWidget>();
	}
};
static_assert(alignof(UItemTooltipWidget) == 0x000008, "Wrong alignment on UItemTooltipWidget");
static_assert(sizeof(UItemTooltipWidget) == 0x000458, "Wrong size on UItemTooltipWidget");
static_assert(offsetof(UItemTooltipWidget, WidgetData) == 0x000358, "Member 'UItemTooltipWidget::WidgetData' has a wrong offset!");

// Class DungeonCrawler.DCEmoteWidget
// 0x0080 (0x0510 - 0x0490)
class UDCEmoteWidget : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_2629[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EmoteName;                                         // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   EmoteFlavorText;                                   // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmoteIconTexture;                                  // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        EmoteId;                                           // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262A[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameTooltipWithFlavorTextWidget*     EmoteTooltipWidget;                                // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCCustomizeDragVisualWidget> EmoteDragVisualWidgetClass;                        // 0x0508(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UUserWidget* GetTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEmoteWidget">();
	}
	static class UDCEmoteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEmoteWidget>();
	}
};
static_assert(alignof(UDCEmoteWidget) == 0x000008, "Wrong alignment on UDCEmoteWidget");
static_assert(sizeof(UDCEmoteWidget) == 0x000510, "Wrong size on UDCEmoteWidget");
static_assert(offsetof(UDCEmoteWidget, EmoteName) == 0x0004A8, "Member 'UDCEmoteWidget::EmoteName' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, EmoteFlavorText) == 0x0004C0, "Member 'UDCEmoteWidget::EmoteFlavorText' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, EmoteIconTexture) == 0x0004D8, "Member 'UDCEmoteWidget::EmoteIconTexture' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, EmoteId) == 0x0004E0, "Member 'UDCEmoteWidget::EmoteId' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, bIsEquipped) == 0x0004F0, "Member 'UDCEmoteWidget::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, TooltipWidgetClass) == 0x0004F8, "Member 'UDCEmoteWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, EmoteTooltipWidget) == 0x000500, "Member 'UDCEmoteWidget::EmoteTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCEmoteWidget, EmoteDragVisualWidgetClass) == 0x000508, "Member 'UDCEmoteWidget::EmoteDragVisualWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCItemDragVisualWidget
// 0x0008 (0x06C0 - 0x06B8)
class UDCItemDragVisualWidget final : public UDCItemCommonWidget
{
public:
	class USizeBox*                               ItemSizeBox;                                       // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemDragVisualWidget">();
	}
	static class UDCItemDragVisualWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemDragVisualWidget>();
	}
};
static_assert(alignof(UDCItemDragVisualWidget) == 0x000008, "Wrong alignment on UDCItemDragVisualWidget");
static_assert(sizeof(UDCItemDragVisualWidget) == 0x0006C0, "Wrong size on UDCItemDragVisualWidget");
static_assert(offsetof(UDCItemDragVisualWidget, ItemSizeBox) == 0x0006B8, "Member 'UDCItemDragVisualWidget::ItemSizeBox' has a wrong offset!");

// Class DungeonCrawler.DCEmoteListEntryWidget
// 0x0010 (0x0520 - 0x0510)
class UDCEmoteListEntryWidget final : public UDCEmoteWidget
{
public:
	uint8                                         Pad_262B[0x10];                                    // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESlateVisibility GetSelectedVisibility();
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEmoteListEntryWidget">();
	}
	static class UDCEmoteListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEmoteListEntryWidget>();
	}
};
static_assert(alignof(UDCEmoteListEntryWidget) == 0x000008, "Wrong alignment on UDCEmoteListEntryWidget");
static_assert(sizeof(UDCEmoteListEntryWidget) == 0x000520, "Wrong size on UDCEmoteListEntryWidget");

// Class DungeonCrawler.DCItemRequirementDataAsset
// 0x0068 (0x00B0 - 0x0048)
class UDCItemRequirementDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FPrimaryAssetId>                ClassRequirements;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         StrengthRequirement;                               // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgilityRequirement;                                // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WillRequirement;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeRequirement;                              // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcefulRequirement;                            // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262C[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                PerkRequirements;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PairWeaponRequirements;                            // 0x0080(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UDCCharacterSkinDataAsset*>      ExclusiveSkins;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemRequirementDataAsset">();
	}
	static class UDCItemRequirementDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemRequirementDataAsset>();
	}
};
static_assert(alignof(UDCItemRequirementDataAsset) == 0x000008, "Wrong alignment on UDCItemRequirementDataAsset");
static_assert(sizeof(UDCItemRequirementDataAsset) == 0x0000B0, "Wrong size on UDCItemRequirementDataAsset");
static_assert(offsetof(UDCItemRequirementDataAsset, ClassRequirements) == 0x000048, "Member 'UDCItemRequirementDataAsset::ClassRequirements' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, StrengthRequirement) == 0x000058, "Member 'UDCItemRequirementDataAsset::StrengthRequirement' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, AgilityRequirement) == 0x00005C, "Member 'UDCItemRequirementDataAsset::AgilityRequirement' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, WillRequirement) == 0x000060, "Member 'UDCItemRequirementDataAsset::WillRequirement' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, KnowledgeRequirement) == 0x000064, "Member 'UDCItemRequirementDataAsset::KnowledgeRequirement' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, ResourcefulRequirement) == 0x000068, "Member 'UDCItemRequirementDataAsset::ResourcefulRequirement' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, PerkRequirements) == 0x000070, "Member 'UDCItemRequirementDataAsset::PerkRequirements' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, PairWeaponRequirements) == 0x000080, "Member 'UDCItemRequirementDataAsset::PairWeaponRequirements' has a wrong offset!");
static_assert(offsetof(UDCItemRequirementDataAsset, ExclusiveSkins) == 0x0000A0, "Member 'UDCItemRequirementDataAsset::ExclusiveSkins' has a wrong offset!");

// Class DungeonCrawler.DCEnhancedInputLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCEnhancedInputLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddPlayerMappableConfigByTagContainer(const class UObject* WorldContextObject, const struct FGameplayTagContainer& InputConfigTags);
	static bool GetActionBoolByTags(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag);
	static bool GetActionBoolWithController(const class UObject* WorldContextObject, const class UInputAction* Action);
	static struct FInputActionValue GetActionValueByTags(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag);
	static struct FInputActionValue GetActionValueWithController(const class UObject* WorldContextObject, const class UInputAction* Action);
	static class UDCEnhancedInputLocalPlayerSubsystem* GetDCEnhancedInputLocalPlayerSubSystem(const class UObject* WorldContextObject);
	static class UEnhancedPlayerInput* GetEnhancedPlayerInput(const class UObject* WorldContextObject);
	static struct FKey GetFirstMappedKeyFromRegisteredInputToAction(const class UObject* WorldContextObject, const class UInputAction* Action);
	static const class UInputAction* GetInputAction(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag);
	static const class UDCInputConfig* GetInputConfigByTag(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag);
	static TArray<struct FKey> GetKeysMappedToAction(const class UObject* WorldContextObject, const class UInputAction* Action);
	static void InjectInputForAction(const class UObject* WorldContextObject, const class UInputAction* Action, const struct FInputActionValue& RawValue, const TArray<class UInputModifier*>& Modifiers, const TArray<class UInputTrigger*>& Triggers);
	static void InjectInputVectorForAction(const class UObject* WorldContextObject, const class UInputAction* Action, const struct FVector& Value, const TArray<class UInputModifier*>& Modifiers, const TArray<class UInputTrigger*>& Triggers);
	static void RemovePlayerMappableConfigByTagContainer(const class UObject* WorldContextObject, const struct FGameplayTagContainer& InputConfigTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEnhancedInputLibrary">();
	}
	static class UDCEnhancedInputLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEnhancedInputLibrary>();
	}
};
static_assert(alignof(UDCEnhancedInputLibrary) == 0x000008, "Wrong alignment on UDCEnhancedInputLibrary");
static_assert(sizeof(UDCEnhancedInputLibrary) == 0x000028, "Wrong size on UDCEnhancedInputLibrary");

// Class DungeonCrawler.DCItemSkinListEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UDCItemSkinListEntryWidgetData final : public UObject
{
public:
	struct FDCItemSkinInfo                        ItemSkinInfo;                                      // 0x0028(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinListEntryWidgetData">();
	}
	static class UDCItemSkinListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinListEntryWidgetData>();
	}
};
static_assert(alignof(UDCItemSkinListEntryWidgetData) == 0x000008, "Wrong alignment on UDCItemSkinListEntryWidgetData");
static_assert(sizeof(UDCItemSkinListEntryWidgetData) == 0x000038, "Wrong size on UDCItemSkinListEntryWidgetData");
static_assert(offsetof(UDCItemSkinListEntryWidgetData, ItemSkinInfo) == 0x000028, "Member 'UDCItemSkinListEntryWidgetData::ItemSkinInfo' has a wrong offset!");

// Class DungeonCrawler.DCEntryGameMode
// 0x0000 (0x03A8 - 0x03A8)
class ADCEntryGameMode final : public ADCGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEntryGameMode">();
	}
	static class ADCEntryGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCEntryGameMode>();
	}
};
static_assert(alignof(ADCEntryGameMode) == 0x000008, "Wrong alignment on ADCEntryGameMode");
static_assert(sizeof(ADCEntryGameMode) == 0x0003A8, "Wrong size on ADCEntryGameMode");

// Class DungeonCrawler.DCItemTooltipStatElementWidget
// 0x0018 (0x02D8 - 0x02C0)
class UDCItemTooltipStatElementWidget final : public UUserWidget
{
public:
	class UDCItemPropertyTypeDataAsset*           Data;                                              // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCItemTooltipStatType                        StatType;                                          // 0x02C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262F[0x3];                                     // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x02CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinValue;                                          // 0x02D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxValue;                                          // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipStatElementWidget">();
	}
	static class UDCItemTooltipStatElementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipStatElementWidget>();
	}
};
static_assert(alignof(UDCItemTooltipStatElementWidget) == 0x000008, "Wrong alignment on UDCItemTooltipStatElementWidget");
static_assert(sizeof(UDCItemTooltipStatElementWidget) == 0x0002D8, "Wrong size on UDCItemTooltipStatElementWidget");
static_assert(offsetof(UDCItemTooltipStatElementWidget, Data) == 0x0002C0, "Member 'UDCItemTooltipStatElementWidget::Data' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipStatElementWidget, StatType) == 0x0002C8, "Member 'UDCItemTooltipStatElementWidget::StatType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipStatElementWidget, Value) == 0x0002CC, "Member 'UDCItemTooltipStatElementWidget::Value' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipStatElementWidget, MinValue) == 0x0002D0, "Member 'UDCItemTooltipStatElementWidget::MinValue' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipStatElementWidget, MaxValue) == 0x0002D4, "Member 'UDCItemTooltipStatElementWidget::MaxValue' has a wrong offset!");

// Class DungeonCrawler.DCQuestProgressSlotWidget
// 0x0008 (0x0360 - 0x0358)
class UDCQuestProgressSlotWidget final : public UDCWidgetBase
{
public:
	bool                                          bIsFirst;                                          // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLast;                                           // 0x0359(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCQuestState                                 QuestState;                                        // 0x035A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2630[0x5];                                     // 0x035B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnQuestProgressInfoSet();

	class FText GetQuestIndexText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestProgressSlotWidget">();
	}
	static class UDCQuestProgressSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestProgressSlotWidget>();
	}
};
static_assert(alignof(UDCQuestProgressSlotWidget) == 0x000008, "Wrong alignment on UDCQuestProgressSlotWidget");
static_assert(sizeof(UDCQuestProgressSlotWidget) == 0x000360, "Wrong size on UDCQuestProgressSlotWidget");
static_assert(offsetof(UDCQuestProgressSlotWidget, bIsFirst) == 0x000358, "Member 'UDCQuestProgressSlotWidget::bIsFirst' has a wrong offset!");
static_assert(offsetof(UDCQuestProgressSlotWidget, bIsLast) == 0x000359, "Member 'UDCQuestProgressSlotWidget::bIsLast' has a wrong offset!");
static_assert(offsetof(UDCQuestProgressSlotWidget, QuestState) == 0x00035A, "Member 'UDCQuestProgressSlotWidget::QuestState' has a wrong offset!");

// Class DungeonCrawler.DCEquipAbility
// 0x0010 (0x0760 - 0x0750)
class UDCEquipAbility : public UDCInventoryAbilityBase
{
public:
	class UAnimMontage*                           CharacterMontage;                                  // 0x0750(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2631[0x8];                                     // 0x0758(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEquip();
	void OnEquipApplied();
	void OnInterrupt(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnPrepared();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEquipAbility">();
	}
	static class UDCEquipAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEquipAbility>();
	}
};
static_assert(alignof(UDCEquipAbility) == 0x000008, "Wrong alignment on UDCEquipAbility");
static_assert(sizeof(UDCEquipAbility) == 0x000760, "Wrong size on UDCEquipAbility");
static_assert(offsetof(UDCEquipAbility, CharacterMontage) == 0x000750, "Member 'UDCEquipAbility::CharacterMontage' has a wrong offset!");

// Class DungeonCrawler.LeaderboardDetailDungeonTabItemWidgetData
// 0x0008 (0x0030 - 0x0028)
class ULeaderboardDetailDungeonTabItemWidgetData final : public UObject
{
public:
	struct FGameplayTag                           DungeonIdTag;                                      // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDetailDungeonTabItemWidgetData">();
	}
	static class ULeaderboardDetailDungeonTabItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDetailDungeonTabItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardDetailDungeonTabItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardDetailDungeonTabItemWidgetData");
static_assert(sizeof(ULeaderboardDetailDungeonTabItemWidgetData) == 0x000030, "Wrong size on ULeaderboardDetailDungeonTabItemWidgetData");
static_assert(offsetof(ULeaderboardDetailDungeonTabItemWidgetData, DungeonIdTag) == 0x000028, "Member 'ULeaderboardDetailDungeonTabItemWidgetData::DungeonIdTag' has a wrong offset!");

// Class DungeonCrawler.DCEquipInventory
// 0x0000 (0x02B0 - 0x02B0)
class UDCEquipInventory final : public UDCInventoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEquipInventory">();
	}
	static class UDCEquipInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEquipInventory>();
	}
};
static_assert(alignof(UDCEquipInventory) == 0x000008, "Wrong alignment on UDCEquipInventory");
static_assert(sizeof(UDCEquipInventory) == 0x0002B0, "Wrong size on UDCEquipInventory");

// Class DungeonCrawler.DCItemSkinViewerWidgetBase
// 0x0008 (0x02C8 - 0x02C0)
class UDCItemSkinViewerWidgetBase final : public UUserWidget
{
public:
	class ADCItemSkinViewerActor*                 ItemSkinViewerActor;                               // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinViewerWidgetBase">();
	}
	static class UDCItemSkinViewerWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinViewerWidgetBase>();
	}
};
static_assert(alignof(UDCItemSkinViewerWidgetBase) == 0x000008, "Wrong alignment on UDCItemSkinViewerWidgetBase");
static_assert(sizeof(UDCItemSkinViewerWidgetBase) == 0x0002C8, "Wrong size on UDCItemSkinViewerWidgetBase");
static_assert(offsetof(UDCItemSkinViewerWidgetBase, ItemSkinViewerActor) == 0x0002C0, "Member 'UDCItemSkinViewerWidgetBase::ItemSkinViewerActor' has a wrong offset!");

// Class DungeonCrawler.DCEquipmentComponent
// 0x06C8 (0x0768 - 0x00A0)
class UDCEquipmentComponent final : public UDCActorComponent
{
public:
	FMulticastInlineDelegateProperty_             HoldingItemActorsEvent;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2632[0x78];                                    // 0x00B0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCEquipInventory*                      Inventory;                                         // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCEquipArmorInfo                      EquipArmorInfo;                                    // 0x0130(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FDCEquipHoldableInfo>           EquipHoldableInfos;                                // 0x0150(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	struct FDCEquipHoldInfo                       EquipHoldInfo;                                     // 0x0160(0x0028)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FDCEquipAnimData                       EquipAnimData;                                     // 0x0188(0x02D0)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FDCItemInfo                            BareHandsItemInfo;                                 // 0x0458(0x0168)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCItemInfo                            BareHandRightItemInfo;                             // 0x05C0(0x0168)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBareHandsApplied;                                 // 0x0728(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBareHandRightApplied;                             // 0x0729(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideItemActorsOnBack;                             // 0x072A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2633[0x5];                                     // 0x072B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCHideItemActorsWhileAction           HideInfoWhileAction;                               // 0x0730(0x0028)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2634[0x10];                                    // 0x0758(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EquipAnimData(const struct FDCEquipAnimData& OldEquipAnimData);
	void OnRep_EquipArmorInfo(const struct FDCEquipArmorInfo& OldEquipArmorInfo);
	void OnRep_EquipHoldableInfos(const TArray<struct FDCEquipHoldableInfo>& OldEquipHoldableInfo);
	void OnRep_EquipHoldInfo(const struct FDCEquipHoldInfo& OldEquipHoldInfo);

	const struct FDCEquipHoldInfo GetEquipHoldInfo() const;
	void GetEquippedItemActors(TArray<class AItemActor*>* OutItemActors) const;
	TArray<struct FDCItemInfo> GetEquippedItemInfos() const;
	void GetHoldingItemActors(TArray<class AItemActor*>* OutItemActors) const;
	class AItemActor* GetItemActorById(const struct FDCItemId& ItemId) const;
	class AItemActor* GetItemActorBySlot(EDCEquipmentSlotIndex Slot) const;
	bool GetItemInfoBySlot(EDCEquipmentSlotIndex Slot, struct FDCItemInfo* OutItemInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEquipmentComponent">();
	}
	static class UDCEquipmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEquipmentComponent>();
	}
};
static_assert(alignof(UDCEquipmentComponent) == 0x000008, "Wrong alignment on UDCEquipmentComponent");
static_assert(sizeof(UDCEquipmentComponent) == 0x000768, "Wrong size on UDCEquipmentComponent");
static_assert(offsetof(UDCEquipmentComponent, HoldingItemActorsEvent) == 0x0000A0, "Member 'UDCEquipmentComponent::HoldingItemActorsEvent' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, Inventory) == 0x000128, "Member 'UDCEquipmentComponent::Inventory' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, EquipArmorInfo) == 0x000130, "Member 'UDCEquipmentComponent::EquipArmorInfo' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, EquipHoldableInfos) == 0x000150, "Member 'UDCEquipmentComponent::EquipHoldableInfos' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, EquipHoldInfo) == 0x000160, "Member 'UDCEquipmentComponent::EquipHoldInfo' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, EquipAnimData) == 0x000188, "Member 'UDCEquipmentComponent::EquipAnimData' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, BareHandsItemInfo) == 0x000458, "Member 'UDCEquipmentComponent::BareHandsItemInfo' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, BareHandRightItemInfo) == 0x0005C0, "Member 'UDCEquipmentComponent::BareHandRightItemInfo' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, bBareHandsApplied) == 0x000728, "Member 'UDCEquipmentComponent::bBareHandsApplied' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, bBareHandRightApplied) == 0x000729, "Member 'UDCEquipmentComponent::bBareHandRightApplied' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, bHideItemActorsOnBack) == 0x00072A, "Member 'UDCEquipmentComponent::bHideItemActorsOnBack' has a wrong offset!");
static_assert(offsetof(UDCEquipmentComponent, HideInfoWhileAction) == 0x000730, "Member 'UDCEquipmentComponent::HideInfoWhileAction' has a wrong offset!");

// Class DungeonCrawler.DCEquipmentSlot
// 0x0010 (0x0038 - 0x0028)
class UDCEquipmentSlot : public UObject
{
public:
	EDCEquipmentSlotIndex                         SlotIndex;                                         // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2638[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItem*                                  Item;                                              // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEquipmentSlot">();
	}
	static class UDCEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEquipmentSlot>();
	}
};
static_assert(alignof(UDCEquipmentSlot) == 0x000008, "Wrong alignment on UDCEquipmentSlot");
static_assert(sizeof(UDCEquipmentSlot) == 0x000038, "Wrong size on UDCEquipmentSlot");
static_assert(offsetof(UDCEquipmentSlot, SlotIndex) == 0x000028, "Member 'UDCEquipmentSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlot, Item) == 0x000030, "Member 'UDCEquipmentSlot::Item' has a wrong offset!");

// Class DungeonCrawler.DCItemSkinComponent
// 0x0078 (0x0118 - 0x00A0)
class UDCItemSkinComponent final : public UDCActorComponent
{
public:
	TArray<class UDCItemSkinDataAsset*>           Datas;                                             // 0x00A0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2639[0x68];                                    // 0x00B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDataForDebug_Server(const class UDCItemSkinDataAsset* InData);
	void OnRep_Datas(const TArray<class UDCItemSkinDataAsset*>& OldDatas);
	void RemoveDataForDebug_Server(const struct FPrimaryAssetId& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinComponent">();
	}
	static class UDCItemSkinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinComponent>();
	}
};
static_assert(alignof(UDCItemSkinComponent) == 0x000008, "Wrong alignment on UDCItemSkinComponent");
static_assert(sizeof(UDCItemSkinComponent) == 0x000118, "Wrong size on UDCItemSkinComponent");
static_assert(offsetof(UDCItemSkinComponent, Datas) == 0x0000A0, "Member 'UDCItemSkinComponent::Datas' has a wrong offset!");

// Class DungeonCrawler.DCQuestItemGroupTooltipWidget
// 0x0028 (0x0380 - 0x0358)
class UDCQuestItemGroupTooltipWidget final : public UDCWidgetBase
{
public:
	class FText                                   TooltipNameText;                                   // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Rarity;                                            // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCItemLootState                              LootState;                                         // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263A[0x7];                                     // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestItemGroupTooltipWidget">();
	}
	static class UDCQuestItemGroupTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestItemGroupTooltipWidget>();
	}
};
static_assert(alignof(UDCQuestItemGroupTooltipWidget) == 0x000008, "Wrong alignment on UDCQuestItemGroupTooltipWidget");
static_assert(sizeof(UDCQuestItemGroupTooltipWidget) == 0x000380, "Wrong size on UDCQuestItemGroupTooltipWidget");
static_assert(offsetof(UDCQuestItemGroupTooltipWidget, TooltipNameText) == 0x000358, "Member 'UDCQuestItemGroupTooltipWidget::TooltipNameText' has a wrong offset!");
static_assert(offsetof(UDCQuestItemGroupTooltipWidget, Rarity) == 0x000370, "Member 'UDCQuestItemGroupTooltipWidget::Rarity' has a wrong offset!");
static_assert(offsetof(UDCQuestItemGroupTooltipWidget, LootState) == 0x000378, "Member 'UDCQuestItemGroupTooltipWidget::LootState' has a wrong offset!");

// Class DungeonCrawler.DCWeaponEquipmentSlot
// 0x0008 (0x0040 - 0x0038)
class UDCWeaponEquipmentSlot final : public UDCEquipmentSlot
{
public:
	class UDCWeaponEquipmentSlot*                 PairSlot;                                          // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWeaponEquipmentSlot">();
	}
	static class UDCWeaponEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCWeaponEquipmentSlot>();
	}
};
static_assert(alignof(UDCWeaponEquipmentSlot) == 0x000008, "Wrong alignment on UDCWeaponEquipmentSlot");
static_assert(sizeof(UDCWeaponEquipmentSlot) == 0x000040, "Wrong size on UDCWeaponEquipmentSlot");
static_assert(offsetof(UDCWeaponEquipmentSlot, PairSlot) == 0x000038, "Member 'UDCWeaponEquipmentSlot::PairSlot' has a wrong offset!");

// Class DungeonCrawler.GA_PropsMeleeAttackBase
// 0x0008 (0x0668 - 0x0660)
class UGA_PropsMeleeAttackBase : public UGA_MeleeAttackBase
{
public:
	struct FGameplayTag                           CancleGameplayTag;                                 // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PropsMeleeAttackBase">();
	}
	static class UGA_PropsMeleeAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PropsMeleeAttackBase>();
	}
};
static_assert(alignof(UGA_PropsMeleeAttackBase) == 0x000008, "Wrong alignment on UGA_PropsMeleeAttackBase");
static_assert(sizeof(UGA_PropsMeleeAttackBase) == 0x000668, "Wrong size on UGA_PropsMeleeAttackBase");
static_assert(offsetof(UGA_PropsMeleeAttackBase, CancleGameplayTag) == 0x000660, "Member 'UGA_PropsMeleeAttackBase::CancleGameplayTag' has a wrong offset!");

// Class DungeonCrawler.DCEquipmentSlotWidget
// 0x0040 (0x06F8 - 0x06B8)
class UDCEquipmentSlotWidget final : public UDCItemCommonWidget
{
public:
	bool                                          bCanEquip;                                         // 0x06B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEquipPreview;                                  // 0x06B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPairSlot;                                         // 0x06BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDropPreview;                                      // 0x06BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263B[0x4];                                     // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 DropPreviewImage;                                  // 0x06C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 EquipProgressImage;                                // 0x06C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EquipDurationSeconds;                              // 0x06D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EquipStartTimeSeconds;                             // 0x06D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               ItemSizeBox;                                       // 0x06D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               DropPreviewSizeBox;                                // 0x06E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               EquipProgressSizeBox;                              // 0x06E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCEquipmentSlotIndex                         EquipSlot;                                         // 0x06F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEquipProgress;                                    // 0x06F1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_263C[0x6];                                     // 0x06F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEquipElapsedSeconds() const;
	float GetEquipRemainSeconds() const;
	bool IsPairSlot() const;
	bool IsTwoHandedWeapon() const;
	bool IsWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEquipmentSlotWidget">();
	}
	static class UDCEquipmentSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEquipmentSlotWidget>();
	}
};
static_assert(alignof(UDCEquipmentSlotWidget) == 0x000008, "Wrong alignment on UDCEquipmentSlotWidget");
static_assert(sizeof(UDCEquipmentSlotWidget) == 0x0006F8, "Wrong size on UDCEquipmentSlotWidget");
static_assert(offsetof(UDCEquipmentSlotWidget, bCanEquip) == 0x0006B8, "Member 'UDCEquipmentSlotWidget::bCanEquip' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, bCanEquipPreview) == 0x0006B9, "Member 'UDCEquipmentSlotWidget::bCanEquipPreview' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, bPairSlot) == 0x0006BA, "Member 'UDCEquipmentSlotWidget::bPairSlot' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, bDropPreview) == 0x0006BB, "Member 'UDCEquipmentSlotWidget::bDropPreview' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, DropPreviewImage) == 0x0006C0, "Member 'UDCEquipmentSlotWidget::DropPreviewImage' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, EquipProgressImage) == 0x0006C8, "Member 'UDCEquipmentSlotWidget::EquipProgressImage' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, EquipDurationSeconds) == 0x0006D0, "Member 'UDCEquipmentSlotWidget::EquipDurationSeconds' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, EquipStartTimeSeconds) == 0x0006D4, "Member 'UDCEquipmentSlotWidget::EquipStartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, ItemSizeBox) == 0x0006D8, "Member 'UDCEquipmentSlotWidget::ItemSizeBox' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, DropPreviewSizeBox) == 0x0006E0, "Member 'UDCEquipmentSlotWidget::DropPreviewSizeBox' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, EquipProgressSizeBox) == 0x0006E8, "Member 'UDCEquipmentSlotWidget::EquipProgressSizeBox' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, EquipSlot) == 0x0006F0, "Member 'UDCEquipmentSlotWidget::EquipSlot' has a wrong offset!");
static_assert(offsetof(UDCEquipmentSlotWidget, bEquipProgress) == 0x0006F1, "Member 'UDCEquipmentSlotWidget::bEquipProgress' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTraceWithSphere
// 0x0010 (0x03F0 - 0x03E0)
class ADCGATA_AimTraceWithSphere : public AGameplayAbilityTargetActor
{
public:
	float                                         MaxRange;                                          // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263D[0x7];                                     // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTraceWithSphere">();
	}
	static class ADCGATA_AimTraceWithSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTraceWithSphere>();
	}
};
static_assert(alignof(ADCGATA_AimTraceWithSphere) == 0x000010, "Wrong alignment on ADCGATA_AimTraceWithSphere");
static_assert(sizeof(ADCGATA_AimTraceWithSphere) == 0x0003F0, "Wrong size on ADCGATA_AimTraceWithSphere");
static_assert(offsetof(ADCGATA_AimTraceWithSphere, MaxRange) == 0x0003E0, "Member 'ADCGATA_AimTraceWithSphere::MaxRange' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceWithSphere, Radius) == 0x0003E4, "Member 'ADCGATA_AimTraceWithSphere::Radius' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceWithSphere, TraceChannel) == 0x0003E8, "Member 'ADCGATA_AimTraceWithSphere::TraceChannel' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTraceSphereOnServer
// 0x0000 (0x03F0 - 0x03F0)
class ADCGATA_AimTraceSphereOnServer final : public ADCGATA_AimTraceWithSphere
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTraceSphereOnServer">();
	}
	static class ADCGATA_AimTraceSphereOnServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTraceSphereOnServer>();
	}
};
static_assert(alignof(ADCGATA_AimTraceSphereOnServer) == 0x000010, "Wrong alignment on ADCGATA_AimTraceSphereOnServer");
static_assert(sizeof(ADCGATA_AimTraceSphereOnServer) == 0x0003F0, "Wrong size on ADCGATA_AimTraceSphereOnServer");

// Class DungeonCrawler.DCEquipmentWidget
// 0x0108 (0x04E8 - 0x03E0)
class UDCEquipmentWidget final : public UDCInventoryWidgetBase
{
public:
	bool                                          bShowSoulHeart;                                    // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263E[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCEquipInventory*                      Inventory;                                         // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 WeaponL1SlotWidget;                                // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 WeaponL2SlotWidget;                                // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 WeaponR1SlotWidget;                                // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 WeaponR2SlotWidget;                                // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 UtilityL1SlotWidget;                               // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 UtilityL2SlotWidget;                               // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 UtilityL3SlotWidget;                               // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 UtilityR1SlotWidget;                               // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 UtilityR2SlotWidget;                               // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 UtilityR3SlotWidget;                               // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 ArmorHeadSlotWidget;                               // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 ArmorChestSlotWidget;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 ArmorHandsSlotWidget;                              // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 ArmorLegsSlotWidget;                               // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 ArmorFootSlotWidget;                               // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 ArmorBackSlotWidget;                               // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 AccessoryNecklaceSlotWidget;                       // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 AccessoryRing1SlotWidget;                          // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 AccessoryRing2SlotWidget;                          // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentSlotWidget*                 SoulHeartSlotWidget;                               // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDCEquipmentSlotIndex, class UDCEquipmentSlotWidget*> SlotWidgets;                                       // 0x0490(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EDCEquipmentSlotIndex                         PrevDropPreview;                                   // 0x04E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263F[0x7];                                     // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDCEquipmentSlotWidget* GetSlotWidget(EDCEquipmentSlotIndex Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEquipmentWidget">();
	}
	static class UDCEquipmentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEquipmentWidget>();
	}
};
static_assert(alignof(UDCEquipmentWidget) == 0x000008, "Wrong alignment on UDCEquipmentWidget");
static_assert(sizeof(UDCEquipmentWidget) == 0x0004E8, "Wrong size on UDCEquipmentWidget");
static_assert(offsetof(UDCEquipmentWidget, bShowSoulHeart) == 0x0003E0, "Member 'UDCEquipmentWidget::bShowSoulHeart' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, Inventory) == 0x0003E8, "Member 'UDCEquipmentWidget::Inventory' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, WeaponL1SlotWidget) == 0x0003F0, "Member 'UDCEquipmentWidget::WeaponL1SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, WeaponL2SlotWidget) == 0x0003F8, "Member 'UDCEquipmentWidget::WeaponL2SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, WeaponR1SlotWidget) == 0x000400, "Member 'UDCEquipmentWidget::WeaponR1SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, WeaponR2SlotWidget) == 0x000408, "Member 'UDCEquipmentWidget::WeaponR2SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, UtilityL1SlotWidget) == 0x000410, "Member 'UDCEquipmentWidget::UtilityL1SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, UtilityL2SlotWidget) == 0x000418, "Member 'UDCEquipmentWidget::UtilityL2SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, UtilityL3SlotWidget) == 0x000420, "Member 'UDCEquipmentWidget::UtilityL3SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, UtilityR1SlotWidget) == 0x000428, "Member 'UDCEquipmentWidget::UtilityR1SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, UtilityR2SlotWidget) == 0x000430, "Member 'UDCEquipmentWidget::UtilityR2SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, UtilityR3SlotWidget) == 0x000438, "Member 'UDCEquipmentWidget::UtilityR3SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, ArmorHeadSlotWidget) == 0x000440, "Member 'UDCEquipmentWidget::ArmorHeadSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, ArmorChestSlotWidget) == 0x000448, "Member 'UDCEquipmentWidget::ArmorChestSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, ArmorHandsSlotWidget) == 0x000450, "Member 'UDCEquipmentWidget::ArmorHandsSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, ArmorLegsSlotWidget) == 0x000458, "Member 'UDCEquipmentWidget::ArmorLegsSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, ArmorFootSlotWidget) == 0x000460, "Member 'UDCEquipmentWidget::ArmorFootSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, ArmorBackSlotWidget) == 0x000468, "Member 'UDCEquipmentWidget::ArmorBackSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, AccessoryNecklaceSlotWidget) == 0x000470, "Member 'UDCEquipmentWidget::AccessoryNecklaceSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, AccessoryRing1SlotWidget) == 0x000478, "Member 'UDCEquipmentWidget::AccessoryRing1SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, AccessoryRing2SlotWidget) == 0x000480, "Member 'UDCEquipmentWidget::AccessoryRing2SlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, SoulHeartSlotWidget) == 0x000488, "Member 'UDCEquipmentWidget::SoulHeartSlotWidget' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, SlotWidgets) == 0x000490, "Member 'UDCEquipmentWidget::SlotWidgets' has a wrong offset!");
static_assert(offsetof(UDCEquipmentWidget, PrevDropPreview) == 0x0004E0, "Member 'UDCEquipmentWidget::PrevDropPreview' has a wrong offset!");

// Class DungeonCrawler.DCItemInfoWidgetData
// 0x0168 (0x0190 - 0x0028)
class UDCItemInfoWidgetData final : public UObject
{
public:
	uint8                                         Pad_2641[0x168];                                   // 0x0028(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemInfoWidgetData">();
	}
	static class UDCItemInfoWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemInfoWidgetData>();
	}
};
static_assert(alignof(UDCItemInfoWidgetData) == 0x000008, "Wrong alignment on UDCItemInfoWidgetData");
static_assert(sizeof(UDCItemInfoWidgetData) == 0x000190, "Wrong size on UDCItemInfoWidgetData");

// Class DungeonCrawler.DCExpressmanItemsSubsystem
// 0x00A8 (0x00D8 - 0x0030)
class UDCExpressmanItemsSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<struct FDCAccountId, struct FDeliveryItemInfo> DeliveryItemList;                                  // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2642[0x58];                                    // 0x0080(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCExpressmanItemsSubsystem">();
	}
	static class UDCExpressmanItemsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCExpressmanItemsSubsystem>();
	}
};
static_assert(alignof(UDCExpressmanItemsSubsystem) == 0x000008, "Wrong alignment on UDCExpressmanItemsSubsystem");
static_assert(sizeof(UDCExpressmanItemsSubsystem) == 0x0000D8, "Wrong size on UDCExpressmanItemsSubsystem");
static_assert(offsetof(UDCExpressmanItemsSubsystem, DeliveryItemList) == 0x000030, "Member 'UDCExpressmanItemsSubsystem::DeliveryItemList' has a wrong offset!");

// Class DungeonCrawler.GA_ShapeShiftBase
// 0x0008 (0x05A8 - 0x05A0)
class UGA_ShapeShiftBase : public UDCGameplayAbilityBase
{
public:
	struct FGameplayTag                           ShapeShiftBuffTag;                                 // 0x05A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void OnShapeShiftBuffTagRemoved(int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ShapeShiftBase">();
	}
	static class UGA_ShapeShiftBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ShapeShiftBase>();
	}
};
static_assert(alignof(UGA_ShapeShiftBase) == 0x000008, "Wrong alignment on UGA_ShapeShiftBase");
static_assert(sizeof(UGA_ShapeShiftBase) == 0x0005A8, "Wrong size on UGA_ShapeShiftBase");
static_assert(offsetof(UGA_ShapeShiftBase, ShapeShiftBuffTag) == 0x0005A0, "Member 'UGA_ShapeShiftBase::ShapeShiftBuffTag' has a wrong offset!");

// Class DungeonCrawler.DCStorageWidget
// 0x0008 (0x03E8 - 0x03E0)
class UDCStorageWidget : public UDCInventoryWidgetBase
{
public:
	class UDCBagWidget*                           BagWidget;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStorageWidget">();
	}
	static class UDCStorageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStorageWidget>();
	}
};
static_assert(alignof(UDCStorageWidget) == 0x000008, "Wrong alignment on UDCStorageWidget");
static_assert(sizeof(UDCStorageWidget) == 0x0003E8, "Wrong size on UDCStorageWidget");
static_assert(offsetof(UDCStorageWidget, BagWidget) == 0x0003E0, "Member 'UDCStorageWidget::BagWidget' has a wrong offset!");

// Class DungeonCrawler.DCGATA_LineCollision
// 0x0130 (0x0510 - 0x03E0)
class ADCGATA_LineCollision : public AGameplayAbilityTargetActor
{
public:
	struct FCollisionProfileName                  TraceProfile;                                      // 0x03E0(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bIgnoreBlockingHits;                               // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x03E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2643[0x2];                                     // 0x03EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugLineDrawTime;                                 // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2644[0xA0];                                    // 0x03F0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SourceSkeletalMeshComponent;                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerSkeletalMeshComponent;                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2645[0x70];                                    // 0x04A0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_LineCollision">();
	}
	static class ADCGATA_LineCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_LineCollision>();
	}
};
static_assert(alignof(ADCGATA_LineCollision) == 0x000010, "Wrong alignment on ADCGATA_LineCollision");
static_assert(sizeof(ADCGATA_LineCollision) == 0x000510, "Wrong size on ADCGATA_LineCollision");
static_assert(offsetof(ADCGATA_LineCollision, TraceProfile) == 0x0003E0, "Member 'ADCGATA_LineCollision::TraceProfile' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineCollision, bIgnoreBlockingHits) == 0x0003E8, "Member 'ADCGATA_LineCollision::bIgnoreBlockingHits' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineCollision, bShowDebug) == 0x0003E9, "Member 'ADCGATA_LineCollision::bShowDebug' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineCollision, DebugLineDrawTime) == 0x0003EC, "Member 'ADCGATA_LineCollision::DebugLineDrawTime' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineCollision, SourceSkeletalMeshComponent) == 0x000490, "Member 'ADCGATA_LineCollision::SourceSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADCGATA_LineCollision, OwnerSkeletalMeshComponent) == 0x000498, "Member 'ADCGATA_LineCollision::OwnerSkeletalMeshComponent' has a wrong offset!");

// Class DungeonCrawler.DCExpressmanStorageWidget
// 0x0020 (0x0408 - 0x03E8)
class UDCExpressmanStorageWidget final : public UDCStorageWidget
{
public:
	uint8                                         Pad_2646[0x8];                                     // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             ListingChargeText;                                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCExpressmanComponent*                 ExpressmanComponent;                               // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        ExpressmanInventory;                               // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCalculationTotalPrice();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCExpressmanStorageWidget">();
	}
	static class UDCExpressmanStorageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCExpressmanStorageWidget>();
	}
};
static_assert(alignof(UDCExpressmanStorageWidget) == 0x000008, "Wrong alignment on UDCExpressmanStorageWidget");
static_assert(sizeof(UDCExpressmanStorageWidget) == 0x000408, "Wrong size on UDCExpressmanStorageWidget");
static_assert(offsetof(UDCExpressmanStorageWidget, ListingChargeText) == 0x0003F0, "Member 'UDCExpressmanStorageWidget::ListingChargeText' has a wrong offset!");
static_assert(offsetof(UDCExpressmanStorageWidget, ExpressmanComponent) == 0x0003F8, "Member 'UDCExpressmanStorageWidget::ExpressmanComponent' has a wrong offset!");
static_assert(offsetof(UDCExpressmanStorageWidget, ExpressmanInventory) == 0x000400, "Member 'UDCExpressmanStorageWidget::ExpressmanInventory' has a wrong offset!");

// Class DungeonCrawler.DCFeatureUnlockRemainTimeWidget
// 0x0048 (0x0330 - 0x02E8)
class UDCFeatureUnlockRemainTimeWidget final : public UCommonUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnTimerRunsOut;                                    // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   FeatureUnlockRemainTimeText;                       // 0x02F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTimespan                              RemainTime;                                        // 0x0310(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2647[0x18];                                    // 0x0318(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAccountStatusUpdated(const EDCAccountStatus InAccountStatus);
	void SetRemainTime(const struct FTimespan& InRemainTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFeatureUnlockRemainTimeWidget">();
	}
	static class UDCFeatureUnlockRemainTimeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFeatureUnlockRemainTimeWidget>();
	}
};
static_assert(alignof(UDCFeatureUnlockRemainTimeWidget) == 0x000008, "Wrong alignment on UDCFeatureUnlockRemainTimeWidget");
static_assert(sizeof(UDCFeatureUnlockRemainTimeWidget) == 0x000330, "Wrong size on UDCFeatureUnlockRemainTimeWidget");
static_assert(offsetof(UDCFeatureUnlockRemainTimeWidget, OnTimerRunsOut) == 0x0002E8, "Member 'UDCFeatureUnlockRemainTimeWidget::OnTimerRunsOut' has a wrong offset!");
static_assert(offsetof(UDCFeatureUnlockRemainTimeWidget, FeatureUnlockRemainTimeText) == 0x0002F8, "Member 'UDCFeatureUnlockRemainTimeWidget::FeatureUnlockRemainTimeText' has a wrong offset!");
static_assert(offsetof(UDCFeatureUnlockRemainTimeWidget, RemainTime) == 0x000310, "Member 'UDCFeatureUnlockRemainTimeWidget::RemainTime' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTracePerTickOnServer
// 0x0000 (0x03F0 - 0x03F0)
class ADCGATA_AimTracePerTickOnServer final : public ADCGATA_AimTrace
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTracePerTickOnServer">();
	}
	static class ADCGATA_AimTracePerTickOnServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTracePerTickOnServer>();
	}
};
static_assert(alignof(ADCGATA_AimTracePerTickOnServer) == 0x000010, "Wrong alignment on ADCGATA_AimTracePerTickOnServer");
static_assert(sizeof(ADCGATA_AimTracePerTickOnServer) == 0x0003F0, "Wrong size on ADCGATA_AimTracePerTickOnServer");

// Class DungeonCrawler.DCFloorPortalDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCFloorPortalDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           PortalType;                                        // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalScrollNum;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2648[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFloorPortalDataAsset">();
	}
	static class UDCFloorPortalDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFloorPortalDataAsset>();
	}
};
static_assert(alignof(UDCFloorPortalDataAsset) == 0x000008, "Wrong alignment on UDCFloorPortalDataAsset");
static_assert(sizeof(UDCFloorPortalDataAsset) == 0x000058, "Wrong size on UDCFloorPortalDataAsset");
static_assert(offsetof(UDCFloorPortalDataAsset, PortalType) == 0x000048, "Member 'UDCFloorPortalDataAsset::PortalType' has a wrong offset!");
static_assert(offsetof(UDCFloorPortalDataAsset, PortalScrollNum) == 0x000050, "Member 'UDCFloorPortalDataAsset::PortalScrollNum' has a wrong offset!");

// Class DungeonCrawler.GA_SpellBase
// 0x00C0 (0x0660 - 0x05A0)
class UGA_SpellBase : public UDCGameplayAbilityBase
{
public:
	struct FGameplayEventData                     CurrentTriggerData;                                // 0x05A0(0x00B0)(NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectContainerTag;                                // 0x0650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0658(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AbilityActivated_BP(const struct FGameplayEventData& TriggerEventData, bool bIsSocketSightBlocked);
	void CastToSelf(const struct FGameplayTag& OptionalEffectContainerTag);
	bool CastToTarget(const struct FHitResult& HitResult, const struct FGameplayTag& OptionalEffectContainerTag);
	void ExecuteSpellCastFireCue();
	class AProjectileActor* FireProjectile(const struct FHitResult& HitResult, TSubclassOf<class AProjectileActor> ProjectileActorClass);
	void OnCasted(class AActor* InTarget);

	float GetAimRadius() const;
	float GetAreaRadius() const;
	struct FDesignDataSpell GetDesignDataSpell() const;
	float GetRange() const;
	bool IsAreaInstall() const;
	bool IsSightBlocked(const struct FHitResult& HitResult) const;
	bool IsSocketSightBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SpellBase">();
	}
	static class UGA_SpellBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SpellBase>();
	}
};
static_assert(alignof(UGA_SpellBase) == 0x000008, "Wrong alignment on UGA_SpellBase");
static_assert(sizeof(UGA_SpellBase) == 0x000660, "Wrong size on UGA_SpellBase");
static_assert(offsetof(UGA_SpellBase, CurrentTriggerData) == 0x0005A0, "Member 'UGA_SpellBase::CurrentTriggerData' has a wrong offset!");
static_assert(offsetof(UGA_SpellBase, EffectContainerTag) == 0x000650, "Member 'UGA_SpellBase::EffectContainerTag' has a wrong offset!");
static_assert(offsetof(UGA_SpellBase, GameplayCueTag) == 0x000658, "Member 'UGA_SpellBase::GameplayCueTag' has a wrong offset!");

// Class DungeonCrawler.GA_SpellCastingBase
// 0x0008 (0x0668 - 0x0660)
class UGA_SpellCastingBase : public UGA_SpellBase
{
public:
	uint8                                         Pad_264C[0x8];                                     // 0x0660(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SpellCastingBase">();
	}
	static class UGA_SpellCastingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SpellCastingBase>();
	}
};
static_assert(alignof(UGA_SpellCastingBase) == 0x000008, "Wrong alignment on UGA_SpellCastingBase");
static_assert(sizeof(UGA_SpellCastingBase) == 0x000668, "Wrong size on UGA_SpellCastingBase");

// Class DungeonCrawler.GA_SpellCastingAndWaitForEndBase
// 0x0000 (0x0668 - 0x0668)
class UGA_SpellCastingAndWaitForEndBase : public UGA_SpellCastingBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SpellCastingAndWaitForEndBase">();
	}
	static class UGA_SpellCastingAndWaitForEndBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SpellCastingAndWaitForEndBase>();
	}
};
static_assert(alignof(UGA_SpellCastingAndWaitForEndBase) == 0x000008, "Wrong alignment on UGA_SpellCastingAndWaitForEndBase");
static_assert(sizeof(UGA_SpellCastingAndWaitForEndBase) == 0x000668, "Wrong size on UGA_SpellCastingAndWaitForEndBase");

// Class DungeonCrawler.DCItemTooltipRequirementWidget
// 0x0020 (0x0680 - 0x0660)
class UDCItemTooltipRequirementWidget final : public UDCItemWidgetBase
{
public:
	class UListView*                              AttributeListWidget;                               // 0x0660(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPrimaryAssetId>                ClassIds;                                          // 0x0668(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRequired;                                         // 0x0678(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264D[0x7];                                     // 0x0679(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipRequirementWidget">();
	}
	static class UDCItemTooltipRequirementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipRequirementWidget>();
	}
};
static_assert(alignof(UDCItemTooltipRequirementWidget) == 0x000008, "Wrong alignment on UDCItemTooltipRequirementWidget");
static_assert(sizeof(UDCItemTooltipRequirementWidget) == 0x000680, "Wrong size on UDCItemTooltipRequirementWidget");
static_assert(offsetof(UDCItemTooltipRequirementWidget, AttributeListWidget) == 0x000660, "Member 'UDCItemTooltipRequirementWidget::AttributeListWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipRequirementWidget, ClassIds) == 0x000668, "Member 'UDCItemTooltipRequirementWidget::ClassIds' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipRequirementWidget, bRequired) == 0x000678, "Member 'UDCItemTooltipRequirementWidget::bRequired' has a wrong offset!");

// Class DungeonCrawler.DCFloorRuleDeathSwarmDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCFloorRuleDeathSwarmDataAsset final : public UDCFloorRuleDataAsset
{
public:
	TArray<struct FDCFloorRuleDeathSwarmItemData> FloorRuleItemArray;                                // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFloorRuleDeathSwarmDataAsset">();
	}
	static class UDCFloorRuleDeathSwarmDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFloorRuleDeathSwarmDataAsset>();
	}
};
static_assert(alignof(UDCFloorRuleDeathSwarmDataAsset) == 0x000008, "Wrong alignment on UDCFloorRuleDeathSwarmDataAsset");
static_assert(sizeof(UDCFloorRuleDeathSwarmDataAsset) == 0x000058, "Wrong size on UDCFloorRuleDeathSwarmDataAsset");
static_assert(offsetof(UDCFloorRuleDeathSwarmDataAsset, FloorRuleItemArray) == 0x000048, "Member 'UDCFloorRuleDeathSwarmDataAsset::FloorRuleItemArray' has a wrong offset!");

// Class DungeonCrawler.DCFriendInterface
// 0x0000 (0x0028 - 0x0028)
class IDCFriendInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFriendInterface">();
	}
	static class IDCFriendInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCFriendInterface>();
	}
};
static_assert(alignof(IDCFriendInterface) == 0x000008, "Wrong alignment on IDCFriendInterface");
static_assert(sizeof(IDCFriendInterface) == 0x000028, "Wrong size on IDCFriendInterface");

// Class DungeonCrawler.GA_UnShapeShiftBase
// 0x0000 (0x05A0 - 0x05A0)
class UGA_UnShapeShiftBase : public UDCGameplayAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_UnShapeShiftBase">();
	}
	static class UGA_UnShapeShiftBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_UnShapeShiftBase>();
	}
};
static_assert(alignof(UGA_UnShapeShiftBase) == 0x000008, "Wrong alignment on UGA_UnShapeShiftBase");
static_assert(sizeof(UGA_UnShapeShiftBase) == 0x0005A0, "Wrong size on UGA_UnShapeShiftBase");

// Class DungeonCrawler.DCFriendItemRecoveryEntryWidget
// 0x0008 (0x06C0 - 0x06B8)
class UDCFriendItemRecoveryEntryWidget final : public UDCItemCommonWidget
{
public:
	class UTextBlock*                             ItemCount;                                         // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFriendItemRecoveryEntryWidget">();
	}
	static class UDCFriendItemRecoveryEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFriendItemRecoveryEntryWidget>();
	}
};
static_assert(alignof(UDCFriendItemRecoveryEntryWidget) == 0x000008, "Wrong alignment on UDCFriendItemRecoveryEntryWidget");
static_assert(sizeof(UDCFriendItemRecoveryEntryWidget) == 0x0006C0, "Wrong size on UDCFriendItemRecoveryEntryWidget");
static_assert(offsetof(UDCFriendItemRecoveryEntryWidget, ItemCount) == 0x0006B8, "Member 'UDCFriendItemRecoveryEntryWidget::ItemCount' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipWidget
// 0x00B0 (0x0710 - 0x0660)
class UDCItemTooltipWidget final : public UDCItemWidgetBase
{
public:
	class UDCItemTooltipNameWidget*               NameWidget;                                        // 0x0660(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemTooltipStatWidget*               StatWidget;                                        // 0x0668(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemTooltipAbilityWidget*            AbilityWidget;                                     // 0x0670(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemTooltipRequirementWidget*        RequirementWidget;                                 // 0x0678(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemTooltipInfoWidget*               InfoWidget;                                        // 0x0680(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemTooltipControlInfoWidget*        ControlInfoWidget;                                 // 0x0688(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCMerchantPriceType                          PriceType;                                         // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264E[0x7];                                     // 0x0691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UListView*                              PriceListWidget;                                   // 0x0698(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DescTextBlock;                                     // 0x06A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCItemOriginInfo                      ItemOriginInfo;                                    // 0x06A8(0x0048)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemOriginTextBlock;                               // 0x06F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCItemTooltipStatType                        ItemTooltipStatType;                               // 0x06F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264F[0x7];                                     // 0x06F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCItemWidgetBase*>              ChildWidgets;                                      // 0x0700(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipWidget">();
	}
	static class UDCItemTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipWidget>();
	}
};
static_assert(alignof(UDCItemTooltipWidget) == 0x000008, "Wrong alignment on UDCItemTooltipWidget");
static_assert(sizeof(UDCItemTooltipWidget) == 0x000710, "Wrong size on UDCItemTooltipWidget");
static_assert(offsetof(UDCItemTooltipWidget, NameWidget) == 0x000660, "Member 'UDCItemTooltipWidget::NameWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, StatWidget) == 0x000668, "Member 'UDCItemTooltipWidget::StatWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, AbilityWidget) == 0x000670, "Member 'UDCItemTooltipWidget::AbilityWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, RequirementWidget) == 0x000678, "Member 'UDCItemTooltipWidget::RequirementWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, InfoWidget) == 0x000680, "Member 'UDCItemTooltipWidget::InfoWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, ControlInfoWidget) == 0x000688, "Member 'UDCItemTooltipWidget::ControlInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, PriceType) == 0x000690, "Member 'UDCItemTooltipWidget::PriceType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, PriceListWidget) == 0x000698, "Member 'UDCItemTooltipWidget::PriceListWidget' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, DescTextBlock) == 0x0006A0, "Member 'UDCItemTooltipWidget::DescTextBlock' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, ItemOriginInfo) == 0x0006A8, "Member 'UDCItemTooltipWidget::ItemOriginInfo' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, ItemOriginTextBlock) == 0x0006F0, "Member 'UDCItemTooltipWidget::ItemOriginTextBlock' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, ItemTooltipStatType) == 0x0006F8, "Member 'UDCItemTooltipWidget::ItemTooltipStatType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipWidget, ChildWidgets) == 0x000700, "Member 'UDCItemTooltipWidget::ChildWidgets' has a wrong offset!");

// Class DungeonCrawler.DCFriendItemRecoveryPopupData
// 0x0010 (0x0040 - 0x0030)
class UDCFriendItemRecoveryPopupData final : public UPopupDataBase
{
public:
	uint8                                         Pad_2650[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFriendItemRecoveryPopupData">();
	}
	static class UDCFriendItemRecoveryPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFriendItemRecoveryPopupData>();
	}
};
static_assert(alignof(UDCFriendItemRecoveryPopupData) == 0x000008, "Wrong alignment on UDCFriendItemRecoveryPopupData");
static_assert(sizeof(UDCFriendItemRecoveryPopupData) == 0x000040, "Wrong size on UDCFriendItemRecoveryPopupData");

// Class DungeonCrawler.DCFriendItemRecoveryPopup
// 0x0018 (0x04A8 - 0x0490)
class UDCFriendItemRecoveryPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    OkButton;                                          // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         FriendRecoveryItemHorizontalBox;                   // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCFriendItemRecoveryEntryWidget> DCFriendItemRecoveryEntryWidgetClass;              // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOkButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFriendItemRecoveryPopup">();
	}
	static class UDCFriendItemRecoveryPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFriendItemRecoveryPopup>();
	}
};
static_assert(alignof(UDCFriendItemRecoveryPopup) == 0x000008, "Wrong alignment on UDCFriendItemRecoveryPopup");
static_assert(sizeof(UDCFriendItemRecoveryPopup) == 0x0004A8, "Wrong size on UDCFriendItemRecoveryPopup");
static_assert(offsetof(UDCFriendItemRecoveryPopup, OkButton) == 0x000490, "Member 'UDCFriendItemRecoveryPopup::OkButton' has a wrong offset!");
static_assert(offsetof(UDCFriendItemRecoveryPopup, FriendRecoveryItemHorizontalBox) == 0x000498, "Member 'UDCFriendItemRecoveryPopup::FriendRecoveryItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCFriendItemRecoveryPopup, DCFriendItemRecoveryEntryWidgetClass) == 0x0004A0, "Member 'UDCFriendItemRecoveryPopup::DCFriendItemRecoveryEntryWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipRequiredAttributeWidgetData
// 0x0018 (0x0040 - 0x0028)
class UDCItemTooltipRequiredAttributeWidgetData final : public UObject
{
public:
	EItemRequirementType                          RequireType;                                       // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2651[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCItemRequirementDataAsset*            RequiredData;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             OwnerCharacter;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipRequiredAttributeWidgetData">();
	}
	static class UDCItemTooltipRequiredAttributeWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipRequiredAttributeWidgetData>();
	}
};
static_assert(alignof(UDCItemTooltipRequiredAttributeWidgetData) == 0x000008, "Wrong alignment on UDCItemTooltipRequiredAttributeWidgetData");
static_assert(sizeof(UDCItemTooltipRequiredAttributeWidgetData) == 0x000040, "Wrong size on UDCItemTooltipRequiredAttributeWidgetData");
static_assert(offsetof(UDCItemTooltipRequiredAttributeWidgetData, RequireType) == 0x000028, "Member 'UDCItemTooltipRequiredAttributeWidgetData::RequireType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipRequiredAttributeWidgetData, RequiredData) == 0x000030, "Member 'UDCItemTooltipRequiredAttributeWidgetData::RequiredData' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipRequiredAttributeWidgetData, OwnerCharacter) == 0x000038, "Member 'UDCItemTooltipRequiredAttributeWidgetData::OwnerCharacter' has a wrong offset!");

// Class DungeonCrawler.DCPortraitMessagePopupBase
// 0x0038 (0x04C8 - 0x0490)
class UDCPortraitMessagePopupBase : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    OkButton;                                          // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MerchantPortraitImage;                             // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDCMerchantDataAsset>    MerchantDataAsset;                                 // 0x04A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOkButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPortraitMessagePopupBase">();
	}
	static class UDCPortraitMessagePopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPortraitMessagePopupBase>();
	}
};
static_assert(alignof(UDCPortraitMessagePopupBase) == 0x000008, "Wrong alignment on UDCPortraitMessagePopupBase");
static_assert(sizeof(UDCPortraitMessagePopupBase) == 0x0004C8, "Wrong size on UDCPortraitMessagePopupBase");
static_assert(offsetof(UDCPortraitMessagePopupBase, OkButton) == 0x000490, "Member 'UDCPortraitMessagePopupBase::OkButton' has a wrong offset!");
static_assert(offsetof(UDCPortraitMessagePopupBase, MerchantPortraitImage) == 0x000498, "Member 'UDCPortraitMessagePopupBase::MerchantPortraitImage' has a wrong offset!");
static_assert(offsetof(UDCPortraitMessagePopupBase, MerchantDataAsset) == 0x0004A0, "Member 'UDCPortraitMessagePopupBase::MerchantDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCFriendItemRecoveryReceivePopup
// 0x0008 (0x04D0 - 0x04C8)
class UDCFriendItemRecoveryReceivePopup final : public UDCPortraitMessagePopupBase
{
public:
	class UDCCommonButtonBase*                    DungeonRecoveryShortcutButton;                     // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDungeonRecoveryShortcutButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCFriendItemRecoveryReceivePopup">();
	}
	static class UDCFriendItemRecoveryReceivePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCFriendItemRecoveryReceivePopup>();
	}
};
static_assert(alignof(UDCFriendItemRecoveryReceivePopup) == 0x000008, "Wrong alignment on UDCFriendItemRecoveryReceivePopup");
static_assert(sizeof(UDCFriendItemRecoveryReceivePopup) == 0x0004D0, "Wrong size on UDCFriendItemRecoveryReceivePopup");
static_assert(offsetof(UDCFriendItemRecoveryReceivePopup, DungeonRecoveryShortcutButton) == 0x0004C8, "Member 'UDCFriendItemRecoveryReceivePopup::DungeonRecoveryShortcutButton' has a wrong offset!");

// Class DungeonCrawler.GA_ChangeIdle
// 0x0008 (0x05A8 - 0x05A0)
class UGA_ChangeIdle : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ChangeIdle">();
	}
	static class UGA_ChangeIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ChangeIdle>();
	}
};
static_assert(alignof(UGA_ChangeIdle) == 0x000008, "Wrong alignment on UGA_ChangeIdle");
static_assert(sizeof(UGA_ChangeIdle) == 0x0005A8, "Wrong size on UGA_ChangeIdle");
static_assert(offsetof(UGA_ChangeIdle, MontageToPlay) == 0x0005A0, "Member 'UGA_ChangeIdle::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.TimerWidgetBase
// 0x0020 (0x0378 - 0x0358)
class UTimerWidgetBase : public UDCWidgetBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerWidgetData                       WidgetData;                                        // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2652[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint(const struct FMsgAccountLinkAccountDataReplicationNotify& InMsg);
	void OnLeftHour(int32 NewValue, int32 OldValue);
	void OnLeftMinute(int32 NewValue, int32 OldValue);
	void OnLeftSecond(int32 NewValue, int32 OldValue);
	void OnProgress(float NewValue, float OldValue);
	void StartTimer(float InEndServerWorldTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerWidgetBase">();
	}
	static class UTimerWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimerWidgetBase>();
	}
};
static_assert(alignof(UTimerWidgetBase) == 0x000008, "Wrong alignment on UTimerWidgetBase");
static_assert(sizeof(UTimerWidgetBase) == 0x000378, "Wrong size on UTimerWidgetBase");
static_assert(offsetof(UTimerWidgetBase, AccountLink) == 0x000358, "Member 'UTimerWidgetBase::AccountLink' has a wrong offset!");
static_assert(offsetof(UTimerWidgetBase, WidgetData) == 0x000360, "Member 'UTimerWidgetBase::WidgetData' has a wrong offset!");

// Class DungeonCrawler.DCGameDownTimerWidget
// 0x0018 (0x0390 - 0x0378)
class UDCGameDownTimerWidget final : public UTimerWidgetBase
{
public:
	bool                                          bIsDowned;                                         // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpectatorHasTargetCharacter;                      // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2653[0x16];                                    // 0x037A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameDownTimerWidget">();
	}
	static class UDCGameDownTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameDownTimerWidget>();
	}
};
static_assert(alignof(UDCGameDownTimerWidget) == 0x000008, "Wrong alignment on UDCGameDownTimerWidget");
static_assert(sizeof(UDCGameDownTimerWidget) == 0x000390, "Wrong size on UDCGameDownTimerWidget");
static_assert(offsetof(UDCGameDownTimerWidget, bIsDowned) == 0x000378, "Member 'UDCGameDownTimerWidget::bIsDowned' has a wrong offset!");
static_assert(offsetof(UDCGameDownTimerWidget, bSpectatorHasTargetCharacter) == 0x000379, "Member 'UDCGameDownTimerWidget::bSpectatorHasTargetCharacter' has a wrong offset!");

// Class DungeonCrawler.DCGameInstance
// 0x0240 (0x0400 - 0x01C0)
class UDCGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_2654[0x58];                                    // 0x01C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCLoadingScreenWidget>     LoadingScreenClass;                                // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLoadingScreenWidget*                 LoadingScreenWidget;                               // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLoadingScreenWidget*                 BufferLoadingScreenWidget;                         // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           RemoveBufferLoadingScreenTimerHandle;              // 0x0230(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseObject*                            BaseObject;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCGameSettings*                        GameSettings;                                      // 0x0240(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  LoginLevel;                                        // 0x0248(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  CharacterSelectLevel;                              // 0x0270(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  LobbyLevel;                                        // 0x0298(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  TavernLevel;                                       // 0x02C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCResource>                ResourceClass;                                     // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCResource*                            Resource;                                          // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                MasterVolume;                                      // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                EffectVolume;                                      // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                MusicVolume;                                       // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCClientAccountManager*                ClientAccountManager;                              // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCClientShopManager*                   ClientShopManager;                                 // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCrossPlatformLinkManager*            CrossPlatformLinkManager;                          // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCIngameUserManager*                   IngameUserManager;                                 // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCPlayerManager*                       PlayerManager;                                     // 0x0330(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCPartyManager*                        PartyManager;                                      // 0x0338(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCPerfMonitor*                         PerfMonitor;                                       // 0x0340(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCDeathCamManager*                     DeathCamManager;                                   // 0x0348(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCClientReportPlayerManager*           ClientReportPlayerManager;                         // 0x0350(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCLogEventManager*                     LogEventManager;                                   // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCReportSystem*                        ReportSystem;                                      // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCStatisticsManager*                   StatisticsManager;                                 // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2655[0x30];                                    // 0x0370(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class USkeletalMeshComponent*, class FString> ClothMeshLogMap;                                   // 0x03A0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2656[0x10];                                    // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnPostLoadMapWithWorld(class UWorld* LoadedWorld);
	void OnPreLoadMap(const class FString& MapName);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameInstance">();
	}
	static class UDCGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameInstance>();
	}
};
static_assert(alignof(UDCGameInstance) == 0x000008, "Wrong alignment on UDCGameInstance");
static_assert(sizeof(UDCGameInstance) == 0x000400, "Wrong size on UDCGameInstance");
static_assert(offsetof(UDCGameInstance, LoadingScreenClass) == 0x000218, "Member 'UDCGameInstance::LoadingScreenClass' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, LoadingScreenWidget) == 0x000220, "Member 'UDCGameInstance::LoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, BufferLoadingScreenWidget) == 0x000228, "Member 'UDCGameInstance::BufferLoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, RemoveBufferLoadingScreenTimerHandle) == 0x000230, "Member 'UDCGameInstance::RemoveBufferLoadingScreenTimerHandle' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, BaseObject) == 0x000238, "Member 'UDCGameInstance::BaseObject' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, GameSettings) == 0x000240, "Member 'UDCGameInstance::GameSettings' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, LoginLevel) == 0x000248, "Member 'UDCGameInstance::LoginLevel' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, CharacterSelectLevel) == 0x000270, "Member 'UDCGameInstance::CharacterSelectLevel' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, LobbyLevel) == 0x000298, "Member 'UDCGameInstance::LobbyLevel' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, TavernLevel) == 0x0002C0, "Member 'UDCGameInstance::TavernLevel' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, ResourceClass) == 0x0002E8, "Member 'UDCGameInstance::ResourceClass' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, Resource) == 0x0002F0, "Member 'UDCGameInstance::Resource' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, MasterVolume) == 0x0002F8, "Member 'UDCGameInstance::MasterVolume' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, EffectVolume) == 0x000300, "Member 'UDCGameInstance::EffectVolume' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, MusicVolume) == 0x000308, "Member 'UDCGameInstance::MusicVolume' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, ClientAccountManager) == 0x000310, "Member 'UDCGameInstance::ClientAccountManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, ClientShopManager) == 0x000318, "Member 'UDCGameInstance::ClientShopManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, CrossPlatformLinkManager) == 0x000320, "Member 'UDCGameInstance::CrossPlatformLinkManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, IngameUserManager) == 0x000328, "Member 'UDCGameInstance::IngameUserManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, PlayerManager) == 0x000330, "Member 'UDCGameInstance::PlayerManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, PartyManager) == 0x000338, "Member 'UDCGameInstance::PartyManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, PerfMonitor) == 0x000340, "Member 'UDCGameInstance::PerfMonitor' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, DeathCamManager) == 0x000348, "Member 'UDCGameInstance::DeathCamManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, ClientReportPlayerManager) == 0x000350, "Member 'UDCGameInstance::ClientReportPlayerManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, LogEventManager) == 0x000358, "Member 'UDCGameInstance::LogEventManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, ReportSystem) == 0x000360, "Member 'UDCGameInstance::ReportSystem' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, StatisticsManager) == 0x000368, "Member 'UDCGameInstance::StatisticsManager' has a wrong offset!");
static_assert(offsetof(UDCGameInstance, ClothMeshLogMap) == 0x0003A0, "Member 'UDCGameInstance::ClothMeshLogMap' has a wrong offset!");

// Class DungeonCrawler.GA_DrawbridgeWheel
// 0x0010 (0x05B0 - 0x05A0)
class UGA_DrawbridgeWheel : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2657[0x8];                                     // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_DrawbridgeWheel">();
	}
	static class UGA_DrawbridgeWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_DrawbridgeWheel>();
	}
};
static_assert(alignof(UGA_DrawbridgeWheel) == 0x000008, "Wrong alignment on UGA_DrawbridgeWheel");
static_assert(sizeof(UGA_DrawbridgeWheel) == 0x0005B0, "Wrong size on UGA_DrawbridgeWheel");
static_assert(offsetof(UGA_DrawbridgeWheel, MontageToPlay) == 0x0005A0, "Member 'UGA_DrawbridgeWheel::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.DCGameModeAIControllerArenaBase
// 0x0000 (0x0438 - 0x0438)
class ADCGameModeAIControllerArenaBase final : public ADCGameModeAIControllerGameBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerArenaBase">();
	}
	static class ADCGameModeAIControllerArenaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerArenaBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerArenaBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerArenaBase");
static_assert(sizeof(ADCGameModeAIControllerArenaBase) == 0x000438, "Wrong size on ADCGameModeAIControllerArenaBase");

// Class DungeonCrawler.DCInventoryValidatorBase
// 0x0008 (0x0030 - 0x0028)
class UDCInventoryValidatorBase : public UObject
{
public:
	EDCInventoryValidatorType                     ValidatorType;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2658[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryValidatorBase">();
	}
	static class UDCInventoryValidatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryValidatorBase>();
	}
};
static_assert(alignof(UDCInventoryValidatorBase) == 0x000008, "Wrong alignment on UDCInventoryValidatorBase");
static_assert(sizeof(UDCInventoryValidatorBase) == 0x000030, "Wrong size on UDCInventoryValidatorBase");
static_assert(offsetof(UDCInventoryValidatorBase, ValidatorType) == 0x000028, "Member 'UDCInventoryValidatorBase::ValidatorType' has a wrong offset!");

// Class DungeonCrawler.DCGameModeAIControllerDungeonCrawlBase
// 0x0070 (0x04A8 - 0x0438)
class ADCGameModeAIControllerDungeonCrawlBase final : public ADCGameModeAIControllerDungeonBase
{
public:
	struct FPlayerPointData                       DownPlayerPointData;                               // 0x0438(0x0070)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerDungeonCrawlBase">();
	}
	static class ADCGameModeAIControllerDungeonCrawlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerDungeonCrawlBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerDungeonCrawlBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerDungeonCrawlBase");
static_assert(sizeof(ADCGameModeAIControllerDungeonCrawlBase) == 0x0004A8, "Wrong size on ADCGameModeAIControllerDungeonCrawlBase");
static_assert(offsetof(ADCGameModeAIControllerDungeonCrawlBase, DownPlayerPointData) == 0x000438, "Member 'ADCGameModeAIControllerDungeonCrawlBase::DownPlayerPointData' has a wrong offset!");

// Class DungeonCrawler.DCGameModeAIControllerMetaBase
// 0x0000 (0x0430 - 0x0430)
class ADCGameModeAIControllerMetaBase : public ADCGameModeAIControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerMetaBase">();
	}
	static class ADCGameModeAIControllerMetaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerMetaBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerMetaBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerMetaBase");
static_assert(sizeof(ADCGameModeAIControllerMetaBase) == 0x000430, "Wrong size on ADCGameModeAIControllerMetaBase");

// Class DungeonCrawler.DCGameModeAIControllerMetaLobbyBase
// 0x0000 (0x0430 - 0x0430)
class ADCGameModeAIControllerMetaLobbyBase final : public ADCGameModeAIControllerMetaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameModeAIControllerMetaLobbyBase">();
	}
	static class ADCGameModeAIControllerMetaLobbyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameModeAIControllerMetaLobbyBase>();
	}
};
static_assert(alignof(ADCGameModeAIControllerMetaLobbyBase) == 0x000008, "Wrong alignment on ADCGameModeAIControllerMetaLobbyBase");
static_assert(sizeof(ADCGameModeAIControllerMetaLobbyBase) == 0x000430, "Wrong size on ADCGameModeAIControllerMetaLobbyBase");

// Class DungeonCrawler.ObjectLinkMetaDataBlueprint
// 0x0058 (0x0080 - 0x0028)
class UObjectLinkMetaDataBlueprint final : public UObject
{
public:
	struct FObjectLinkMetaData                    MetaData;                                          // 0x0028(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectLinkMetaDataBlueprint">();
	}
	static class UObjectLinkMetaDataBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectLinkMetaDataBlueprint>();
	}
};
static_assert(alignof(UObjectLinkMetaDataBlueprint) == 0x000008, "Wrong alignment on UObjectLinkMetaDataBlueprint");
static_assert(sizeof(UObjectLinkMetaDataBlueprint) == 0x000080, "Wrong size on UObjectLinkMetaDataBlueprint");
static_assert(offsetof(UObjectLinkMetaDataBlueprint, MetaData) == 0x000028, "Member 'UObjectLinkMetaDataBlueprint::MetaData' has a wrong offset!");

// Class DungeonCrawler.DCGameObjectLinkComponent
// 0x0058 (0x00F8 - 0x00A0)
class UDCGameObjectLinkComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2659[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TypeTag;                                           // 0x00A8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FObjectLinkEventContext>        EventContextArray;                                 // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnGameObjectLinkEvent;                             // 0x00C0(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_265A[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGlobalEvent;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FObjectLinkGlobalEvent>         RecvGlobalEventArray;                              // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_265B[0x10];                                    // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastGlobalEvent(const struct FObjectLinkGlobalEvent& InGlobalEvent);
	bool IsLinkerSet();
	TArray<struct FObjectLinkResponeEvent> RequestToLinkers(struct FObjectLinkRequestEvent& ObjectLinkRequestEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameObjectLinkComponent">();
	}
	static class UDCGameObjectLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameObjectLinkComponent>();
	}
};
static_assert(alignof(UDCGameObjectLinkComponent) == 0x000008, "Wrong alignment on UDCGameObjectLinkComponent");
static_assert(sizeof(UDCGameObjectLinkComponent) == 0x0000F8, "Wrong size on UDCGameObjectLinkComponent");
static_assert(offsetof(UDCGameObjectLinkComponent, TypeTag) == 0x0000A8, "Member 'UDCGameObjectLinkComponent::TypeTag' has a wrong offset!");
static_assert(offsetof(UDCGameObjectLinkComponent, EventContextArray) == 0x0000B0, "Member 'UDCGameObjectLinkComponent::EventContextArray' has a wrong offset!");
static_assert(offsetof(UDCGameObjectLinkComponent, OnGameObjectLinkEvent) == 0x0000C0, "Member 'UDCGameObjectLinkComponent::OnGameObjectLinkEvent' has a wrong offset!");
static_assert(offsetof(UDCGameObjectLinkComponent, OnGlobalEvent) == 0x0000C8, "Member 'UDCGameObjectLinkComponent::OnGlobalEvent' has a wrong offset!");
static_assert(offsetof(UDCGameObjectLinkComponent, RecvGlobalEventArray) == 0x0000D8, "Member 'UDCGameObjectLinkComponent::RecvGlobalEventArray' has a wrong offset!");

// Class DungeonCrawler.DCGameObjectLinker
// 0x0010 (0x0308 - 0x02F8)
class ADCGameObjectLinker final : public ADCActorBase
{
public:
	uint8                                         Pad_265C[0x10];                                    // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameObjectLinker">();
	}
	static class ADCGameObjectLinker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameObjectLinker>();
	}
};
static_assert(alignof(ADCGameObjectLinker) == 0x000008, "Wrong alignment on ADCGameObjectLinker");
static_assert(sizeof(ADCGameObjectLinker) == 0x000308, "Wrong size on ADCGameObjectLinker");

// Class DungeonCrawler.DCMovementModifierDataAsset
// 0x0018 (0x0060 - 0x0048)
class UDCMovementModifierDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           ExactEventTag;                                     // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Add;                                               // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiply;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZMultiply;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleMultiply;                              // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMovementModifierDataAsset">();
	}
	static class UDCMovementModifierDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMovementModifierDataAsset>();
	}
};
static_assert(alignof(UDCMovementModifierDataAsset) == 0x000008, "Wrong alignment on UDCMovementModifierDataAsset");
static_assert(sizeof(UDCMovementModifierDataAsset) == 0x000060, "Wrong size on UDCMovementModifierDataAsset");
static_assert(offsetof(UDCMovementModifierDataAsset, ExactEventTag) == 0x000048, "Member 'UDCMovementModifierDataAsset::ExactEventTag' has a wrong offset!");
static_assert(offsetof(UDCMovementModifierDataAsset, Add) == 0x000050, "Member 'UDCMovementModifierDataAsset::Add' has a wrong offset!");
static_assert(offsetof(UDCMovementModifierDataAsset, Multiply) == 0x000054, "Member 'UDCMovementModifierDataAsset::Multiply' has a wrong offset!");
static_assert(offsetof(UDCMovementModifierDataAsset, JumpZMultiply) == 0x000058, "Member 'UDCMovementModifierDataAsset::JumpZMultiply' has a wrong offset!");
static_assert(offsetof(UDCMovementModifierDataAsset, GravityScaleMultiply) == 0x00005C, "Member 'UDCMovementModifierDataAsset::GravityScaleMultiply' has a wrong offset!");

// Class DungeonCrawler.DCUIEffectorWidgetBase
// 0x0000 (0x02C0 - 0x02C0)
class UDCUIEffectorWidgetBase : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCUIEffectorWidgetBase">();
	}
	static class UDCUIEffectorWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCUIEffectorWidgetBase>();
	}
};
static_assert(alignof(UDCUIEffectorWidgetBase) == 0x000008, "Wrong alignment on UDCUIEffectorWidgetBase");
static_assert(sizeof(UDCUIEffectorWidgetBase) == 0x0002C0, "Wrong size on UDCUIEffectorWidgetBase");

// Class DungeonCrawler.DCUIFadeEffectWidget
// 0x0030 (0x02F0 - 0x02C0)
class UDCUIFadeEffectWidget final : public UDCUIEffectorWidgetBase
{
public:
	class UDCCommonActivatableWidgetBase*         CommonActivatableWidgetBaseClass;                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            UIEffectCurve;                                     // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalUIEffectDuration;                             // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UIEffectTimeScale;                                 // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265D[0x18];                                    // 0x02D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDCCommonActivatableWidgetBase* FindParentActivatableWidget();
	void OnActiveEffectPanelVisibilityChanged(ESlateVisibility NewVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCUIFadeEffectWidget">();
	}
	static class UDCUIFadeEffectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCUIFadeEffectWidget>();
	}
};
static_assert(alignof(UDCUIFadeEffectWidget) == 0x000008, "Wrong alignment on UDCUIFadeEffectWidget");
static_assert(sizeof(UDCUIFadeEffectWidget) == 0x0002F0, "Wrong size on UDCUIFadeEffectWidget");
static_assert(offsetof(UDCUIFadeEffectWidget, CommonActivatableWidgetBaseClass) == 0x0002C0, "Member 'UDCUIFadeEffectWidget::CommonActivatableWidgetBaseClass' has a wrong offset!");
static_assert(offsetof(UDCUIFadeEffectWidget, UIEffectCurve) == 0x0002C8, "Member 'UDCUIFadeEffectWidget::UIEffectCurve' has a wrong offset!");
static_assert(offsetof(UDCUIFadeEffectWidget, TotalUIEffectDuration) == 0x0002D0, "Member 'UDCUIFadeEffectWidget::TotalUIEffectDuration' has a wrong offset!");
static_assert(offsetof(UDCUIFadeEffectWidget, UIEffectTimeScale) == 0x0002D4, "Member 'UDCUIFadeEffectWidget::UIEffectTimeScale' has a wrong offset!");

// Class DungeonCrawler.DCGEModifierDataAsset
// 0x0028 (0x0070 - 0x0048)
class UDCGEModifierDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           TargetGameplayEffectTag;                           // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetRequiredStateTag;                            // 0x0050(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetType;                                        // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectType;                                        // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Add;                                               // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiply;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGEModifierDataAsset">();
	}
	static class UDCGEModifierDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGEModifierDataAsset>();
	}
};
static_assert(alignof(UDCGEModifierDataAsset) == 0x000008, "Wrong alignment on UDCGEModifierDataAsset");
static_assert(sizeof(UDCGEModifierDataAsset) == 0x000070, "Wrong size on UDCGEModifierDataAsset");
static_assert(offsetof(UDCGEModifierDataAsset, TargetGameplayEffectTag) == 0x000048, "Member 'UDCGEModifierDataAsset::TargetGameplayEffectTag' has a wrong offset!");
static_assert(offsetof(UDCGEModifierDataAsset, TargetRequiredStateTag) == 0x000050, "Member 'UDCGEModifierDataAsset::TargetRequiredStateTag' has a wrong offset!");
static_assert(offsetof(UDCGEModifierDataAsset, TargetType) == 0x000058, "Member 'UDCGEModifierDataAsset::TargetType' has a wrong offset!");
static_assert(offsetof(UDCGEModifierDataAsset, EffectType) == 0x000060, "Member 'UDCGEModifierDataAsset::EffectType' has a wrong offset!");
static_assert(offsetof(UDCGEModifierDataAsset, Add) == 0x000068, "Member 'UDCGEModifierDataAsset::Add' has a wrong offset!");
static_assert(offsetof(UDCGEModifierDataAsset, Multiply) == 0x00006C, "Member 'UDCGEModifierDataAsset::Multiply' has a wrong offset!");

// Class DungeonCrawler.DCGameplayCueManager
// 0x0000 (0x02C0 - 0x02C0)
class UDCGameplayCueManager final : public UGameplayCueManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayCueManager">();
	}
	static class UDCGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayCueManager>();
	}
};
static_assert(alignof(UDCGameplayCueManager) == 0x000008, "Wrong alignment on UDCGameplayCueManager");
static_assert(sizeof(UDCGameplayCueManager) == 0x0002C0, "Wrong size on UDCGameplayCueManager");

// Class DungeonCrawler.DCWaitingGameMode
// 0x0008 (0x0500 - 0x04F8)
class ADCWaitingGameMode final : public ADCIngameGameMode
{
public:
	uint8                                         Pad_265E[0x8];                                     // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWaitingGameMode">();
	}
	static class ADCWaitingGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCWaitingGameMode>();
	}
};
static_assert(alignof(ADCWaitingGameMode) == 0x000008, "Wrong alignment on ADCWaitingGameMode");
static_assert(sizeof(ADCWaitingGameMode) == 0x000500, "Wrong size on ADCWaitingGameMode");

// Class DungeonCrawler.DCGameplayCueTagGroupDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCGameplayCueTagGroupDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCGameplayCueTagGroupItemData> GameplayCueTagGroupItemArray;                      // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayCueTagGroupDataAsset">();
	}
	static class UDCGameplayCueTagGroupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameplayCueTagGroupDataAsset>();
	}
};
static_assert(alignof(UDCGameplayCueTagGroupDataAsset) == 0x000008, "Wrong alignment on UDCGameplayCueTagGroupDataAsset");
static_assert(sizeof(UDCGameplayCueTagGroupDataAsset) == 0x000058, "Wrong size on UDCGameplayCueTagGroupDataAsset");
static_assert(offsetof(UDCGameplayCueTagGroupDataAsset, GameplayCueTagGroupItemArray) == 0x000048, "Member 'UDCGameplayCueTagGroupDataAsset::GameplayCueTagGroupItemArray' has a wrong offset!");

// Class DungeonCrawler.DCGameplayTagCollider
// 0x0108 (0x0400 - 0x02F8)
class ADCGameplayTagCollider : public ADCActorBase
{
public:
	class UAccountLink*                           OwnerAccountLink;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 OwnerAccountId;                                    // 0x0300(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TargetAccountId;                                   // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAccountLink*                           TargetAccountLink;                                 // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   TargetPlayerPawn;                                  // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAccountDataReplication                TargetAccountDataReplication;                      // 0x0330(0x0090)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  TargetOwnedGameplayeTags;                          // 0x03C0(0x0020)(NativeAccessSpecifierPrivate)
	float                                         ColliderRadius;                                    // 0x03E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265F[0x4];                                     // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       GameplayTagOverlapSphere;                          // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDCTagCollisionDetectorComponent*> OverlapDetectorComponentArray;                     // 0x03F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnOverlapping();
	void OnRep_TargetAccountId(const class FString& InOldTargetAccountId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameplayTagCollider">();
	}
	static class ADCGameplayTagCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameplayTagCollider>();
	}
};
static_assert(alignof(ADCGameplayTagCollider) == 0x000008, "Wrong alignment on ADCGameplayTagCollider");
static_assert(sizeof(ADCGameplayTagCollider) == 0x000400, "Wrong size on ADCGameplayTagCollider");
static_assert(offsetof(ADCGameplayTagCollider, OwnerAccountLink) == 0x0002F8, "Member 'ADCGameplayTagCollider::OwnerAccountLink' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, OwnerAccountId) == 0x000300, "Member 'ADCGameplayTagCollider::OwnerAccountId' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, TargetAccountId) == 0x000310, "Member 'ADCGameplayTagCollider::TargetAccountId' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, TargetAccountLink) == 0x000320, "Member 'ADCGameplayTagCollider::TargetAccountLink' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, TargetPlayerPawn) == 0x000328, "Member 'ADCGameplayTagCollider::TargetPlayerPawn' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, TargetAccountDataReplication) == 0x000330, "Member 'ADCGameplayTagCollider::TargetAccountDataReplication' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, TargetOwnedGameplayeTags) == 0x0003C0, "Member 'ADCGameplayTagCollider::TargetOwnedGameplayeTags' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, ColliderRadius) == 0x0003E0, "Member 'ADCGameplayTagCollider::ColliderRadius' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, GameplayTagOverlapSphere) == 0x0003E8, "Member 'ADCGameplayTagCollider::GameplayTagOverlapSphere' has a wrong offset!");
static_assert(offsetof(ADCGameplayTagCollider, OverlapDetectorComponentArray) == 0x0003F0, "Member 'ADCGameplayTagCollider::OverlapDetectorComponentArray' has a wrong offset!");

// Class DungeonCrawler.DCWorldSettings
// 0x0000 (0x04B8 - 0x04B8)
class ADCWorldSettings final : public AWorldSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWorldSettings">();
	}
	static class ADCWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCWorldSettings>();
	}
};
static_assert(alignof(ADCWorldSettings) == 0x000008, "Wrong alignment on ADCWorldSettings");
static_assert(sizeof(ADCWorldSettings) == 0x0004B8, "Wrong size on ADCWorldSettings");

// Class DungeonCrawler.DCGameSessionInfoWidget
// 0x0050 (0x0460 - 0x0410)
class UDCGameSessionInfoWidget final : public UCommonActivatableWidget
{
public:
	class FText                                   RegionText;                                        // 0x0410(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   GameIdText;                                        // 0x0428(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UListView*                              PlayerInfoList;                                    // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   AdditionalInfoText;                                // 0x0448(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSessionInfoWidget">();
	}
	static class UDCGameSessionInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameSessionInfoWidget>();
	}
};
static_assert(alignof(UDCGameSessionInfoWidget) == 0x000008, "Wrong alignment on UDCGameSessionInfoWidget");
static_assert(sizeof(UDCGameSessionInfoWidget) == 0x000460, "Wrong size on UDCGameSessionInfoWidget");
static_assert(offsetof(UDCGameSessionInfoWidget, RegionText) == 0x000410, "Member 'UDCGameSessionInfoWidget::RegionText' has a wrong offset!");
static_assert(offsetof(UDCGameSessionInfoWidget, GameIdText) == 0x000428, "Member 'UDCGameSessionInfoWidget::GameIdText' has a wrong offset!");
static_assert(offsetof(UDCGameSessionInfoWidget, PlayerInfoList) == 0x000440, "Member 'UDCGameSessionInfoWidget::PlayerInfoList' has a wrong offset!");
static_assert(offsetof(UDCGameSessionInfoWidget, AdditionalInfoText) == 0x000448, "Member 'UDCGameSessionInfoWidget::AdditionalInfoText' has a wrong offset!");

// Class DungeonCrawler.DCGameSessionPlayerInfoEntryWidget
// 0x0020 (0x0378 - 0x0358)
class UDCGameSessionPlayerInfoEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2662[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PlayerInfoText;                                    // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSessionPlayerInfoEntryWidget">();
	}
	static class UDCGameSessionPlayerInfoEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameSessionPlayerInfoEntryWidget>();
	}
};
static_assert(alignof(UDCGameSessionPlayerInfoEntryWidget) == 0x000008, "Wrong alignment on UDCGameSessionPlayerInfoEntryWidget");
static_assert(sizeof(UDCGameSessionPlayerInfoEntryWidget) == 0x000378, "Wrong size on UDCGameSessionPlayerInfoEntryWidget");
static_assert(offsetof(UDCGameSessionPlayerInfoEntryWidget, PlayerInfoText) == 0x000360, "Member 'UDCGameSessionPlayerInfoEntryWidget::PlayerInfoText' has a wrong offset!");

// Class DungeonCrawler.DescData
// 0x0018 (0x0060 - 0x0048)
class UDescData : public UDCDataAssetBase
{
public:
	class FText                                   DescriptionFormatTextId;                           // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void GetDescription(const class UDescDataParam* InDescDataParam, TArray<class FText>* OutDescTextArray) const;
	float GetExecImpactPower(const class UDescDataParam* InDescDataParam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DescData">();
	}
	static class UDescData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDescData>();
	}
};
static_assert(alignof(UDescData) == 0x000008, "Wrong alignment on UDescData");
static_assert(sizeof(UDescData) == 0x000060, "Wrong size on UDescData");
static_assert(offsetof(UDescData, DescriptionFormatTextId) == 0x000048, "Member 'UDescData::DescriptionFormatTextId' has a wrong offset!");

// Class DungeonCrawler.DCGameSpawnableComponent
// 0x0008 (0x00A8 - 0x00A0)
class UDCGameSpawnableComponent final : public UDCActorComponent
{
public:
	bool                                          bCastShadows;                                      // 0x00A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2664[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bCastShadows(bool bOldCastShadows);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSpawnableComponent">();
	}
	static class UDCGameSpawnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameSpawnableComponent>();
	}
};
static_assert(alignof(UDCGameSpawnableComponent) == 0x000008, "Wrong alignment on UDCGameSpawnableComponent");
static_assert(sizeof(UDCGameSpawnableComponent) == 0x0000A8, "Wrong size on UDCGameSpawnableComponent");
static_assert(offsetof(UDCGameSpawnableComponent, bCastShadows) == 0x0000A0, "Member 'UDCGameSpawnableComponent::bCastShadows' has a wrong offset!");

// Class DungeonCrawler.DCGameSpawnerGroup
// 0x0018 (0x0310 - 0x02F8)
class ADCGameSpawnerGroup final : public ADCActorBase
{
public:
	int32                                         Count;                                             // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2665[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ClientDestroyActorNameArray;                       // 0x0300(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_ClientDestroyActorNameArray(const TArray<class FString>& OldClientDestroyActorNameArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameSpawnerGroup">();
	}
	static class ADCGameSpawnerGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGameSpawnerGroup>();
	}
};
static_assert(alignof(ADCGameSpawnerGroup) == 0x000008, "Wrong alignment on ADCGameSpawnerGroup");
static_assert(sizeof(ADCGameSpawnerGroup) == 0x000310, "Wrong size on ADCGameSpawnerGroup");
static_assert(offsetof(ADCGameSpawnerGroup, Count) == 0x0002F8, "Member 'ADCGameSpawnerGroup::Count' has a wrong offset!");
static_assert(offsetof(ADCGameSpawnerGroup, ClientDestroyActorNameArray) == 0x000300, "Member 'ADCGameSpawnerGroup::ClientDestroyActorNameArray' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteShopDataAsset
// 0x0028 (0x00D0 - 0x00A8)
class UDCLobbyEmoteShopDataAsset final : public UDCShopDataAsset
{
public:
	TSoftObjectPtr<class UDCLobbyEmoteDataAsset>  StockData;                                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteShopDataAsset">();
	}
	static class UDCLobbyEmoteShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteShopDataAsset>();
	}
};
static_assert(alignof(UDCLobbyEmoteShopDataAsset) == 0x000008, "Wrong alignment on UDCLobbyEmoteShopDataAsset");
static_assert(sizeof(UDCLobbyEmoteShopDataAsset) == 0x0000D0, "Wrong size on UDCLobbyEmoteShopDataAsset");
static_assert(offsetof(UDCLobbyEmoteShopDataAsset, StockData) == 0x0000A8, "Member 'UDCLobbyEmoteShopDataAsset::StockData' has a wrong offset!");

// Class DungeonCrawler.DCGameUserSettings
// 0x0418 (0x0560 - 0x0148)
class UDCGameUserSettings final : public UGameUserSettings
{
public:
	uint8                                         Pad_2666[0xA0];                                    // 0x0148(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameUserSettingControls               GameUserSettingControlsSaved;                      // 0x01E8(0x0040)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2667[0x80];                                    // 0x0228(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameUserSettingAudios                 GameUserSettingAudiosSaved;                        // 0x02A8(0x0030)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2668[0x60];                                    // 0x02D8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameUserSettingVideoDisplay           GameUserSettingVideoDisplaySaved;                  // 0x0338(0x0040)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2669[0x110];                                   // 0x0378(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InputConfigName;                                   // 0x0488(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadedMappableConfigPair>      RegisteredInputConfigs;                            // 0x0490(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FKey>                CustomKeyboardConfig;                              // 0x04A0(0x0050)(Config, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FKey>                PendingCustomKeyboardConfig;                       // 0x04F0(0x0050)(NativeAccessSpecifierPrivate)
	int32                                         OverrideAntialiasingMode;                          // 0x0540(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_266A[0x4];                                     // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastConnectedServerAddress;                        // 0x0548(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_266B[0x8];                                     // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UPlayerMappableInputConfig* GetInputConfigByName(class FName ConfigName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGameUserSettings">();
	}
	static class UDCGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGameUserSettings>();
	}
};
static_assert(alignof(UDCGameUserSettings) == 0x000008, "Wrong alignment on UDCGameUserSettings");
static_assert(sizeof(UDCGameUserSettings) == 0x000560, "Wrong size on UDCGameUserSettings");
static_assert(offsetof(UDCGameUserSettings, GameUserSettingControlsSaved) == 0x0001E8, "Member 'UDCGameUserSettings::GameUserSettingControlsSaved' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, GameUserSettingAudiosSaved) == 0x0002A8, "Member 'UDCGameUserSettings::GameUserSettingAudiosSaved' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, GameUserSettingVideoDisplaySaved) == 0x000338, "Member 'UDCGameUserSettings::GameUserSettingVideoDisplaySaved' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, InputConfigName) == 0x000488, "Member 'UDCGameUserSettings::InputConfigName' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, RegisteredInputConfigs) == 0x000490, "Member 'UDCGameUserSettings::RegisteredInputConfigs' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, CustomKeyboardConfig) == 0x0004A0, "Member 'UDCGameUserSettings::CustomKeyboardConfig' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, PendingCustomKeyboardConfig) == 0x0004F0, "Member 'UDCGameUserSettings::PendingCustomKeyboardConfig' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, OverrideAntialiasingMode) == 0x000540, "Member 'UDCGameUserSettings::OverrideAntialiasingMode' has a wrong offset!");
static_assert(offsetof(UDCGameUserSettings, LastConnectedServerAddress) == 0x000548, "Member 'UDCGameUserSettings::LastConnectedServerAddress' has a wrong offset!");

// Class DungeonCrawler.DCShopItemListEntryWidgetData
// 0x0008 (0x0030 - 0x0028)
class UDCShopItemListEntryWidgetData final : public UObject
{
public:
	class UDCShopDataAsset*                       Data;                                              // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopItemListEntryWidgetData">();
	}
	static class UDCShopItemListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopItemListEntryWidgetData>();
	}
};
static_assert(alignof(UDCShopItemListEntryWidgetData) == 0x000008, "Wrong alignment on UDCShopItemListEntryWidgetData");
static_assert(sizeof(UDCShopItemListEntryWidgetData) == 0x000030, "Wrong size on UDCShopItemListEntryWidgetData");
static_assert(offsetof(UDCShopItemListEntryWidgetData, Data) == 0x000028, "Member 'UDCShopItemListEntryWidgetData::Data' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTraceOnServer
// 0x0000 (0x03F0 - 0x03F0)
class ADCGATA_AimTraceOnServer final : public ADCGATA_AimTrace
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTraceOnServer">();
	}
	static class ADCGATA_AimTraceOnServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTraceOnServer>();
	}
};
static_assert(alignof(ADCGATA_AimTraceOnServer) == 0x000010, "Wrong alignment on ADCGATA_AimTraceOnServer");
static_assert(sizeof(ADCGATA_AimTraceOnServer) == 0x0003F0, "Wrong size on ADCGATA_AimTraceOnServer");

// Class DungeonCrawler.DCShopPurchaseProcessWidget
// 0x00A8 (0x0400 - 0x0358)
class UDCShopPurchaseProcessWidget : public UDCWidgetBase
{
public:
	TSubclassOf<class UDCShopCurrencyTypeSelectPopupBase> CurrencyTypeSelectPopupClass;                      // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCShopConfirmPurchasePopupBase> ConfirmPurchasePopupClass;                         // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266C[0x51];                                    // 0x0368(0x0051)(Fixing Size After Last Property [ Dumper-7 ])
	EDCShopCurrencyType                           SelectedCurrencyType;                              // 0x03B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCShopItemType                               SelectedShopItemType;                              // 0x03BA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_266D[0x1];                                     // 0x03BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        SelectedShopId;                                    // 0x03BC(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_266E[0x4];                                     // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCShopItemInfo                        SelectedShopItemInfo;                              // 0x03D0(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopPurchaseProcessWidget">();
	}
	static class UDCShopPurchaseProcessWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopPurchaseProcessWidget>();
	}
};
static_assert(alignof(UDCShopPurchaseProcessWidget) == 0x000008, "Wrong alignment on UDCShopPurchaseProcessWidget");
static_assert(sizeof(UDCShopPurchaseProcessWidget) == 0x000400, "Wrong size on UDCShopPurchaseProcessWidget");
static_assert(offsetof(UDCShopPurchaseProcessWidget, CurrencyTypeSelectPopupClass) == 0x000358, "Member 'UDCShopPurchaseProcessWidget::CurrencyTypeSelectPopupClass' has a wrong offset!");
static_assert(offsetof(UDCShopPurchaseProcessWidget, ConfirmPurchasePopupClass) == 0x000360, "Member 'UDCShopPurchaseProcessWidget::ConfirmPurchasePopupClass' has a wrong offset!");
static_assert(offsetof(UDCShopPurchaseProcessWidget, SelectedCurrencyType) == 0x0003B9, "Member 'UDCShopPurchaseProcessWidget::SelectedCurrencyType' has a wrong offset!");
static_assert(offsetof(UDCShopPurchaseProcessWidget, SelectedShopItemType) == 0x0003BA, "Member 'UDCShopPurchaseProcessWidget::SelectedShopItemType' has a wrong offset!");
static_assert(offsetof(UDCShopPurchaseProcessWidget, SelectedShopId) == 0x0003BC, "Member 'UDCShopPurchaseProcessWidget::SelectedShopId' has a wrong offset!");
static_assert(offsetof(UDCShopPurchaseProcessWidget, SelectedShopItemInfo) == 0x0003D0, "Member 'UDCShopPurchaseProcessWidget::SelectedShopItemInfo' has a wrong offset!");

// Class DungeonCrawler.DCGATA_AimTraceToSocket
// 0x0050 (0x0440 - 0x03F0)
class ADCGATA_AimTraceToSocket final : public ADCGATA_AimTrace
{
public:
	FMulticastInlineDelegateProperty_             SocketSightBlocked;                                // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SocketSightUnblocked;                              // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0418(0x0028)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_AimTraceToSocket">();
	}
	static class ADCGATA_AimTraceToSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_AimTraceToSocket>();
	}
};
static_assert(alignof(ADCGATA_AimTraceToSocket) == 0x000010, "Wrong alignment on ADCGATA_AimTraceToSocket");
static_assert(sizeof(ADCGATA_AimTraceToSocket) == 0x000440, "Wrong size on ADCGATA_AimTraceToSocket");
static_assert(offsetof(ADCGATA_AimTraceToSocket, SocketSightBlocked) == 0x0003E8, "Member 'ADCGATA_AimTraceToSocket::SocketSightBlocked' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceToSocket, SocketSightUnblocked) == 0x0003F8, "Member 'ADCGATA_AimTraceToSocket::SocketSightUnblocked' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceToSocket, SkeletalMeshComponent) == 0x000408, "Member 'ADCGATA_AimTraceToSocket::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceToSocket, SocketName) == 0x000410, "Member 'ADCGATA_AimTraceToSocket::SocketName' has a wrong offset!");
static_assert(offsetof(ADCGATA_AimTraceToSocket, TargetData) == 0x000418, "Member 'ADCGATA_AimTraceToSocket::TargetData' has a wrong offset!");

// Class DungeonCrawler.DCGATA_GroundTraceWithMaxHeightOnServer
// 0x0000 (0x0420 - 0x0420)
class ADCGATA_GroundTraceWithMaxHeightOnServer final : public ADCGATA_GroundTraceWithMaxHeight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_GroundTraceWithMaxHeightOnServer">();
	}
	static class ADCGATA_GroundTraceWithMaxHeightOnServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_GroundTraceWithMaxHeightOnServer>();
	}
};
static_assert(alignof(ADCGATA_GroundTraceWithMaxHeightOnServer) == 0x000010, "Wrong alignment on ADCGATA_GroundTraceWithMaxHeightOnServer");
static_assert(sizeof(ADCGATA_GroundTraceWithMaxHeightOnServer) == 0x000420, "Wrong size on ADCGATA_GroundTraceWithMaxHeightOnServer");

// Class DungeonCrawler.DCSkeletalMeshComponent
// 0x0060 (0x1000 - 0x0FA0)
class UDCSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_266F[0x60];                                    // 0x0FA0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void SetAffectNavigation(bool bRelevant);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSkeletalMeshComponent">();
	}
	static class UDCSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSkeletalMeshComponent>();
	}
};
static_assert(alignof(UDCSkeletalMeshComponent) == 0x000010, "Wrong alignment on UDCSkeletalMeshComponent");
static_assert(sizeof(UDCSkeletalMeshComponent) == 0x001000, "Wrong size on UDCSkeletalMeshComponent");

// Class DungeonCrawler.DCGATA_LineCollisionOnServer
// 0x0000 (0x0510 - 0x0510)
class ADCGATA_LineCollisionOnServer final : public ADCGATA_LineCollision
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGATA_LineCollisionOnServer">();
	}
	static class ADCGATA_LineCollisionOnServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCGATA_LineCollisionOnServer>();
	}
};
static_assert(alignof(ADCGATA_LineCollisionOnServer) == 0x000010, "Wrong alignment on ADCGATA_LineCollisionOnServer");
static_assert(sizeof(ADCGATA_LineCollisionOnServer) == 0x000510, "Wrong size on ADCGATA_LineCollisionOnServer");

// Class DungeonCrawler.DCGeometryCollectionComponent
// 0x0000 (0x0BE0 - 0x0BE0)
class UDCGeometryCollectionComponent final : public UGeometryCollectionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGeometryCollectionComponent">();
	}
	static class UDCGeometryCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGeometryCollectionComponent>();
	}
};
static_assert(alignof(UDCGeometryCollectionComponent) == 0x000010, "Wrong alignment on UDCGeometryCollectionComponent");
static_assert(sizeof(UDCGeometryCollectionComponent) == 0x000BE0, "Wrong size on UDCGeometryCollectionComponent");

// Class DungeonCrawler.DCReligionConvetCompletePopup
// 0x0030 (0x04C0 - 0x0490)
class UDCReligionConvetCompletePopup final : public UCommonPopupBase
{
public:
	class UTextBlock*                             ReligionNameText;                                  // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CompleteText;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ImageSize;                                         // 0x04A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionConvetCompletePopupData*     ReligionCompletePopupData;                         // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();
	void SetReligionImageEvent(const struct FSlateBrush& Bursh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionConvetCompletePopup">();
	}
	static class UDCReligionConvetCompletePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionConvetCompletePopup>();
	}
};
static_assert(alignof(UDCReligionConvetCompletePopup) == 0x000008, "Wrong alignment on UDCReligionConvetCompletePopup");
static_assert(sizeof(UDCReligionConvetCompletePopup) == 0x0004C0, "Wrong size on UDCReligionConvetCompletePopup");
static_assert(offsetof(UDCReligionConvetCompletePopup, ReligionNameText) == 0x000490, "Member 'UDCReligionConvetCompletePopup::ReligionNameText' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopup, CompleteText) == 0x000498, "Member 'UDCReligionConvetCompletePopup::CompleteText' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopup, Btn_One_Confirm) == 0x0004A0, "Member 'UDCReligionConvetCompletePopup::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopup, ImageSize) == 0x0004A8, "Member 'UDCReligionConvetCompletePopup::ImageSize' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopup, ReligionCompletePopupData) == 0x0004B8, "Member 'UDCReligionConvetCompletePopup::ReligionCompletePopupData' has a wrong offset!");

// Class DungeonCrawler.DCGiftCodeRewardPopupBase
// 0x0020 (0x04B0 - 0x0490)
class UDCGiftCodeRewardPopupBase final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         GiftHorizontalBox;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRewardItemWidget>        GiftItemWidgetClass;                               // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGiftCodeRewardPopupData*             GiftCodeRewardPopupData;                           // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCGiftCodeRewardPopupBase">();
	}
	static class UDCGiftCodeRewardPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCGiftCodeRewardPopupBase>();
	}
};
static_assert(alignof(UDCGiftCodeRewardPopupBase) == 0x000008, "Wrong alignment on UDCGiftCodeRewardPopupBase");
static_assert(sizeof(UDCGiftCodeRewardPopupBase) == 0x0004B0, "Wrong size on UDCGiftCodeRewardPopupBase");
static_assert(offsetof(UDCGiftCodeRewardPopupBase, Btn_One_Confirm) == 0x000490, "Member 'UDCGiftCodeRewardPopupBase::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCGiftCodeRewardPopupBase, GiftHorizontalBox) == 0x000498, "Member 'UDCGiftCodeRewardPopupBase::GiftHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCGiftCodeRewardPopupBase, GiftItemWidgetClass) == 0x0004A0, "Member 'UDCGiftCodeRewardPopupBase::GiftItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCGiftCodeRewardPopupBase, GiftCodeRewardPopupData) == 0x0004A8, "Member 'UDCGiftCodeRewardPopupBase::GiftCodeRewardPopupData' has a wrong offset!");

// Class DungeonCrawler.DCReligionOfferingCompletePopup
// 0x0010 (0x04A0 - 0x0490)
class UDCReligionOfferingCompletePopup final : public UCommonPopupBase
{
public:
	class UTextBlock*                             OfferingCountText;                                 // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionOfferingCompletePopup">();
	}
	static class UDCReligionOfferingCompletePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionOfferingCompletePopup>();
	}
};
static_assert(alignof(UDCReligionOfferingCompletePopup) == 0x000008, "Wrong alignment on UDCReligionOfferingCompletePopup");
static_assert(sizeof(UDCReligionOfferingCompletePopup) == 0x0004A0, "Wrong size on UDCReligionOfferingCompletePopup");
static_assert(offsetof(UDCReligionOfferingCompletePopup, OfferingCountText) == 0x000490, "Member 'UDCReligionOfferingCompletePopup::OfferingCountText' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingCompletePopup, Btn_One_Confirm) == 0x000498, "Member 'UDCReligionOfferingCompletePopup::Btn_One_Confirm' has a wrong offset!");

// Class DungeonCrawler.DCIdTagGroupDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCIdTagGroupDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCIdTagGroupItemData>          IdTagGroupItemArray;                               // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIdTagGroupDataAsset">();
	}
	static class UDCIdTagGroupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCIdTagGroupDataAsset>();
	}
};
static_assert(alignof(UDCIdTagGroupDataAsset) == 0x000008, "Wrong alignment on UDCIdTagGroupDataAsset");
static_assert(sizeof(UDCIdTagGroupDataAsset) == 0x000058, "Wrong size on UDCIdTagGroupDataAsset");
static_assert(offsetof(UDCIdTagGroupDataAsset, IdTagGroupItemArray) == 0x000048, "Member 'UDCIdTagGroupDataAsset::IdTagGroupItemArray' has a wrong offset!");

// Class DungeonCrawler.DCIngameInventoryControllerComponent
// 0x0000 (0x00C0 - 0x00C0)
class UDCIngameInventoryControllerComponent final : public UDCInventoryControllerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIngameInventoryControllerComponent">();
	}
	static class UDCIngameInventoryControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCIngameInventoryControllerComponent>();
	}
};
static_assert(alignof(UDCIngameInventoryControllerComponent) == 0x000008, "Wrong alignment on UDCIngameInventoryControllerComponent");
static_assert(sizeof(UDCIngameInventoryControllerComponent) == 0x0000C0, "Wrong size on UDCIngameInventoryControllerComponent");

// Class DungeonCrawler.DCInGameQuestLog
// 0x0008 (0x0360 - 0x0358)
class UDCInGameQuestLog final : public UDCWidgetBase
{
public:
	class UDCInGameQuestLogDealTableWidget*       DealTableQuestWidget;                              // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnQuestLogVisibilityChange(bool bIsEmpty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInGameQuestLog">();
	}
	static class UDCInGameQuestLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInGameQuestLog>();
	}
};
static_assert(alignof(UDCInGameQuestLog) == 0x000008, "Wrong alignment on UDCInGameQuestLog");
static_assert(sizeof(UDCInGameQuestLog) == 0x000360, "Wrong size on UDCInGameQuestLog");
static_assert(offsetof(UDCInGameQuestLog, DealTableQuestWidget) == 0x000358, "Member 'UDCInGameQuestLog::DealTableQuestWidget' has a wrong offset!");

// Class DungeonCrawler.DCTradePhaseConfirmWidget
// 0x0020 (0x0378 - 0x0358)
class UDCTradePhaseConfirmWidget final : public UDCWidgetBase
{
public:
	int32                                         TradeFee;                                          // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2670[0x4];                                     // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCTradeBoxWidget*                      TradeBoxLocal;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTradeBoxWidget*                      TradeBoxRemote;                                    // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelTradeButton;                                 // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginTradeConfirm();
	void OnCancelTradeButtonClicked();
	void OnLocalTraderCheckBoxStateChanged(bool bIsChecked);
	void OnResponseLocalTraderConfirmRequestResult(bool bRequestSucceed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradePhaseConfirmWidget">();
	}
	static class UDCTradePhaseConfirmWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradePhaseConfirmWidget>();
	}
};
static_assert(alignof(UDCTradePhaseConfirmWidget) == 0x000008, "Wrong alignment on UDCTradePhaseConfirmWidget");
static_assert(sizeof(UDCTradePhaseConfirmWidget) == 0x000378, "Wrong size on UDCTradePhaseConfirmWidget");
static_assert(offsetof(UDCTradePhaseConfirmWidget, TradeFee) == 0x000358, "Member 'UDCTradePhaseConfirmWidget::TradeFee' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseConfirmWidget, TradeBoxLocal) == 0x000360, "Member 'UDCTradePhaseConfirmWidget::TradeBoxLocal' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseConfirmWidget, TradeBoxRemote) == 0x000368, "Member 'UDCTradePhaseConfirmWidget::TradeBoxRemote' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseConfirmWidget, CancelTradeButton) == 0x000370, "Member 'UDCTradePhaseConfirmWidget::CancelTradeButton' has a wrong offset!");

// Class DungeonCrawler.DCIngameUserManager
// 0x00B8 (0x00E8 - 0x0030)
class UDCIngameUserManager final : public UDCUserInfoManagerBase
{
public:
	TMap<struct FDCAccountId, struct FDCIngameUser> IngameUsers;                                       // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2671[0x68];                                    // 0x0080(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCIngameUserManager">();
	}
	static class UDCIngameUserManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCIngameUserManager>();
	}
};
static_assert(alignof(UDCIngameUserManager) == 0x000008, "Wrong alignment on UDCIngameUserManager");
static_assert(sizeof(UDCIngameUserManager) == 0x0000E8, "Wrong size on UDCIngameUserManager");
static_assert(offsetof(UDCIngameUserManager, IngameUsers) == 0x000030, "Member 'UDCIngameUserManager::IngameUsers' has a wrong offset!");

// Class DungeonCrawler.DCInputNumberWidget
// 0x0038 (0x02F8 - 0x02C0)
class UDCInputNumberWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2672[0x20];                                    // 0x02C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USlider*                                Slider;                                            // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonAccept;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonCancel;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ManualClick();
	void OnAccepted();
	void OnCancelled();

	bool IsValidText(const class FText& Text) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInputNumberWidget">();
	}
	static class UDCInputNumberWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInputNumberWidget>();
	}
};
static_assert(alignof(UDCInputNumberWidget) == 0x000008, "Wrong alignment on UDCInputNumberWidget");
static_assert(sizeof(UDCInputNumberWidget) == 0x0002F8, "Wrong size on UDCInputNumberWidget");
static_assert(offsetof(UDCInputNumberWidget, Slider) == 0x0002E0, "Member 'UDCInputNumberWidget::Slider' has a wrong offset!");
static_assert(offsetof(UDCInputNumberWidget, ButtonAccept) == 0x0002E8, "Member 'UDCInputNumberWidget::ButtonAccept' has a wrong offset!");
static_assert(offsetof(UDCInputNumberWidget, ButtonCancel) == 0x0002F0, "Member 'UDCInputNumberWidget::ButtonCancel' has a wrong offset!");

// Class DungeonCrawler.DCInventoryCharacter
// 0x0010 (0x0750 - 0x0740)
class ADCInventoryCharacter final : public ADCCharacterV2
{
public:
	class ADCCharacterLobbyCapture*               LobbyCharacter;                                    // 0x0738(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0740(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2674[0x8];                                     // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryCharacter">();
	}
	static class ADCInventoryCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCInventoryCharacter>();
	}
};
static_assert(alignof(ADCInventoryCharacter) == 0x000010, "Wrong alignment on ADCInventoryCharacter");
static_assert(sizeof(ADCInventoryCharacter) == 0x000750, "Wrong size on ADCInventoryCharacter");
static_assert(offsetof(ADCInventoryCharacter, LobbyCharacter) == 0x000738, "Member 'ADCInventoryCharacter::LobbyCharacter' has a wrong offset!");
static_assert(offsetof(ADCInventoryCharacter, PlayerCharacter) == 0x000740, "Member 'ADCInventoryCharacter::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.DCTrainingOptionSlotWidgetBase
// 0x0060 (0x16C0 - 0x1660)
class UDCTrainingOptionSlotWidgetBase final : public UDCCommonButtonBase
{
public:
	uint8                                         Pad_2675[0x10];                                    // 0x1658(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSelected;                                       // 0x1668(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2676[0x7];                                     // 0x1669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCTrainingOptionWidgetBase*            TrainingOptionWidget;                              // 0x1670(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCTrainingOptionInfo                  OptionInfo;                                        // 0x1678(0x0040)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2677[0x8];                                     // 0x16B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActive(const float Delay);
	void OnAnyOptionSelected();
	void OnClear();
	void OnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingOptionSlotWidgetBase">();
	}
	static class UDCTrainingOptionSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingOptionSlotWidgetBase>();
	}
};
static_assert(alignof(UDCTrainingOptionSlotWidgetBase) == 0x000010, "Wrong alignment on UDCTrainingOptionSlotWidgetBase");
static_assert(sizeof(UDCTrainingOptionSlotWidgetBase) == 0x0016C0, "Wrong size on UDCTrainingOptionSlotWidgetBase");
static_assert(offsetof(UDCTrainingOptionSlotWidgetBase, bIsSelected) == 0x001668, "Member 'UDCTrainingOptionSlotWidgetBase::bIsSelected' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionSlotWidgetBase, TrainingOptionWidget) == 0x001670, "Member 'UDCTrainingOptionSlotWidgetBase::TrainingOptionWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionSlotWidgetBase, OptionInfo) == 0x001678, "Member 'UDCTrainingOptionSlotWidgetBase::OptionInfo' has a wrong offset!");

// Class DungeonCrawler.DCInventoryComponent
// 0x0000 (0x0180 - 0x0180)
class UDCInventoryComponent : public UDCInventoryContainerComponent
{
public:
	bool AddItemData(const struct FItemData& ItemData);
	bool AddItemDatas(EDCInventoryId InventoryId, const TArray<struct FItemData>& ItemDatas);
	bool AddItemDataToInventory(EDCInventoryId InventoryId, const struct FItemData& ItemData);
	void ClearInventoryItems();
	bool InitExpandableBox(EDCInventoryId InventoryId, const TArray<struct FItemData>& ItemDatas);

	void AddSoulHeart_Temp() const;
	void PlayItemSoundClient(const struct FDCItemInfo& Item, const struct FGameplayTag& Tag) const;
	void PlayItemSoundNetMulticast(const struct FDCItemInfo& Item, const struct FGameplayTag& Tag) const;
	void PlayItemSoundServer(const struct FDCItemInfo& Item, const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryComponent">();
	}
	static class UDCInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryComponent>();
	}
};
static_assert(alignof(UDCInventoryComponent) == 0x000008, "Wrong alignment on UDCInventoryComponent");
static_assert(sizeof(UDCInventoryComponent) == 0x000180, "Wrong size on UDCInventoryComponent");

// Class DungeonCrawler.DCInventorySetWidget
// 0x0050 (0x0430 - 0x03E0)
class UDCInventorySetWidget final : public UDCInventoryWidgetBase
{
public:
	TSubclassOf<class UDCCharacterInventoryWidget> CharacterInventoryWidgetClass;                     // 0x03E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCBagWidget>               StashInventoryWidgetClass;                         // 0x03E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCInventoryTabButtonWidget> TabButtonWidgetClass;                              // 0x03F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBuyButtonEnabled;                                 // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267F[0x7];                                     // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           TabBox;                                            // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    BuyButton;                                         // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCPurchaseConfirmPopupWidget> PurchaseConfirmPopupWidgetClass;                   // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  Comp;                                              // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInventory;                                        // 0x0428(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStash;                                            // 0x0429(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2680[0x6];                                     // 0x042A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPurchaseConfirm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventorySetWidget">();
	}
	static class UDCInventorySetWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventorySetWidget>();
	}
};
static_assert(alignof(UDCInventorySetWidget) == 0x000008, "Wrong alignment on UDCInventorySetWidget");
static_assert(sizeof(UDCInventorySetWidget) == 0x000430, "Wrong size on UDCInventorySetWidget");
static_assert(offsetof(UDCInventorySetWidget, CharacterInventoryWidgetClass) == 0x0003E0, "Member 'UDCInventorySetWidget::CharacterInventoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, StashInventoryWidgetClass) == 0x0003E8, "Member 'UDCInventorySetWidget::StashInventoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, TabButtonWidgetClass) == 0x0003F0, "Member 'UDCInventorySetWidget::TabButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, bBuyButtonEnabled) == 0x0003F8, "Member 'UDCInventorySetWidget::bBuyButtonEnabled' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, WidgetSwitcher) == 0x000400, "Member 'UDCInventorySetWidget::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, TabBox) == 0x000408, "Member 'UDCInventorySetWidget::TabBox' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, BuyButton) == 0x000410, "Member 'UDCInventorySetWidget::BuyButton' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, PurchaseConfirmPopupWidgetClass) == 0x000418, "Member 'UDCInventorySetWidget::PurchaseConfirmPopupWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, Comp) == 0x000420, "Member 'UDCInventorySetWidget::Comp' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, bInventory) == 0x000428, "Member 'UDCInventorySetWidget::bInventory' has a wrong offset!");
static_assert(offsetof(UDCInventorySetWidget, bStash) == 0x000429, "Member 'UDCInventorySetWidget::bStash' has a wrong offset!");

// Class DungeonCrawler.DCInventoryTabButtonWidget
// 0x0010 (0x1680 - 0x1670)
class UDCInventoryTabButtonWidget final : public UDCStateButtonWidgetBase
{
public:
	EDCInventoryId                                InventoryId;                                       // 0x1670(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2681[0xF];                                     // 0x1671(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryTabButtonWidget">();
	}
	static class UDCInventoryTabButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryTabButtonWidget>();
	}
};
static_assert(alignof(UDCInventoryTabButtonWidget) == 0x000010, "Wrong alignment on UDCInventoryTabButtonWidget");
static_assert(sizeof(UDCInventoryTabButtonWidget) == 0x001680, "Wrong size on UDCInventoryTabButtonWidget");
static_assert(offsetof(UDCInventoryTabButtonWidget, InventoryId) == 0x001670, "Member 'UDCInventoryTabButtonWidget::InventoryId' has a wrong offset!");

// Class DungeonCrawler.DCShowingKeyWidgetBase
// 0x0000 (0x0358 - 0x0358)
class UDCShowingKeyWidgetBase : public UDCWidgetBase
{
public:
	void HandleInputMethodChanged(ECommonInputType InInputType);
	void OnInputBindChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShowingKeyWidgetBase">();
	}
	static class UDCShowingKeyWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShowingKeyWidgetBase>();
	}
};
static_assert(alignof(UDCShowingKeyWidgetBase) == 0x000008, "Wrong alignment on UDCShowingKeyWidgetBase");
static_assert(sizeof(UDCShowingKeyWidgetBase) == 0x000358, "Wrong size on UDCShowingKeyWidgetBase");

// Class DungeonCrawler.GameCancelTipWidget
// 0x0000 (0x0358 - 0x0358)
class UGameCancelTipWidget final : public UDCShowingKeyWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameCancelTipWidget">();
	}
	static class UGameCancelTipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameCancelTipWidget>();
	}
};
static_assert(alignof(UGameCancelTipWidget) == 0x000008, "Wrong alignment on UGameCancelTipWidget");
static_assert(sizeof(UGameCancelTipWidget) == 0x000358, "Wrong size on UGameCancelTipWidget");

// Class DungeonCrawler.DCItemActorAbilityBase
// 0x0010 (0x05B0 - 0x05A0)
class UDCItemActorAbilityBase : public UDCGameplayAbilityBase
{
public:
	class AItemActor*                             SourceItemActor;                                   // 0x05A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                SourceAbilitySystemComponent;                      // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemActorAbilityBase">();
	}
	static class UDCItemActorAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemActorAbilityBase>();
	}
};
static_assert(alignof(UDCItemActorAbilityBase) == 0x000008, "Wrong alignment on UDCItemActorAbilityBase");
static_assert(sizeof(UDCItemActorAbilityBase) == 0x0005B0, "Wrong size on UDCItemActorAbilityBase");
static_assert(offsetof(UDCItemActorAbilityBase, SourceItemActor) == 0x0005A0, "Member 'UDCItemActorAbilityBase::SourceItemActor' has a wrong offset!");
static_assert(offsetof(UDCItemActorAbilityBase, SourceAbilitySystemComponent) == 0x0005A8, "Member 'UDCItemActorAbilityBase::SourceAbilitySystemComponent' has a wrong offset!");

// Class DungeonCrawler.DCItemActorBase
// 0x01E8 (0x04E0 - 0x02F8)
class ADCItemActorBase : public ADCActorBase
{
public:
	uint8                                         Pad_2682[0x38];                                    // 0x02F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCItemInfo                            ItemInfo;                                          // 0x0330(0x0168)(Net, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtDataItem*                           ArtData;                                           // 0x0498(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             SoundData;                                         // 0x04A0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemConsumeDataAsset*                ConsumeData;                                       // 0x04A8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2683[0x30];                                    // 0x04B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ArtData(class UArtDataItem* OldArtData);
	void OnRep_ItemInfo(const struct FDCItemInfo& OldItemInfo);

	struct FGameplayTag GetIdTag() const;
	class UArtDataItem* GetItemArtData(const float WaitAsyncLoadingSeconds) const;
	const struct FDCItemInfo GetItemInfo() const;
	int64 GetItemUniqueId() const;
	struct FGameplayTag GetRarity() const;
	struct FGameplayTag GetSlotType() const;
	struct FGameplayTag GetUtilityType() const;
	TArray<struct FGameplayTag> GetWeaponTypes() const;
	bool IsShield() const;
	bool IsSoulHeart() const;
	bool IsUtility() const;
	bool IsWeapon() const;
	bool IsWeaponSlotEquippable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemActorBase">();
	}
	static class ADCItemActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCItemActorBase>();
	}
};
static_assert(alignof(ADCItemActorBase) == 0x000008, "Wrong alignment on ADCItemActorBase");
static_assert(sizeof(ADCItemActorBase) == 0x0004E0, "Wrong size on ADCItemActorBase");
static_assert(offsetof(ADCItemActorBase, ItemInfo) == 0x000330, "Member 'ADCItemActorBase::ItemInfo' has a wrong offset!");
static_assert(offsetof(ADCItemActorBase, ArtData) == 0x000498, "Member 'ADCItemActorBase::ArtData' has a wrong offset!");
static_assert(offsetof(ADCItemActorBase, SoundData) == 0x0004A0, "Member 'ADCItemActorBase::SoundData' has a wrong offset!");
static_assert(offsetof(ADCItemActorBase, ConsumeData) == 0x0004A8, "Member 'ADCItemActorBase::ConsumeData' has a wrong offset!");

// Class DungeonCrawler.GameEmoteSlotWidget
// 0x0020 (0x0378 - 0x0358)
class UGameEmoteSlotWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2685[0x20];                                    // 0x0358(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReset();
	void OnSelectionChanged(bool bIsSelected);
	void OnSetEmoteArtData(const class UArtDataEmote* InArtEmoteData);
	void Reset();
	void SelectionChange(bool bIsSelected);
	void SetEmoteData(const class UDCEmoteDataAsset* InDesignDataEmote);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEmoteSlotWidget">();
	}
	static class UGameEmoteSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEmoteSlotWidget>();
	}
};
static_assert(alignof(UGameEmoteSlotWidget) == 0x000008, "Wrong alignment on UGameEmoteSlotWidget");
static_assert(sizeof(UGameEmoteSlotWidget) == 0x000378, "Wrong size on UGameEmoteSlotWidget");

// Class DungeonCrawler.DCItemBundleInfoDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCItemBundleInfoDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDDCItemBundleInfoItem>         ItemBundleInfoItemArray;                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemBundleInfoDataAsset">();
	}
	static class UDCItemBundleInfoDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemBundleInfoDataAsset>();
	}
};
static_assert(alignof(UDCItemBundleInfoDataAsset) == 0x000008, "Wrong alignment on UDCItemBundleInfoDataAsset");
static_assert(sizeof(UDCItemBundleInfoDataAsset) == 0x000058, "Wrong size on UDCItemBundleInfoDataAsset");
static_assert(offsetof(UDCItemBundleInfoDataAsset, ItemBundleInfoItemArray) == 0x000048, "Member 'UDCItemBundleInfoDataAsset::ItemBundleInfoItemArray' has a wrong offset!");

// Class DungeonCrawler.DCItemPropertyTypeDataAsset
// 0x0060 (0x00A8 - 0x0048)
class UDCItemPropertyTypeDataAsset final : public UDCTableDataAsset
{
public:
	int32                                         PropertyTypeGroupId;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PropertyType;                                      // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PerkId;                                            // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillId;                                           // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpellId;                                           // 0x0074(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2686[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectType;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueRatio;                                        // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryTooltipPriority;                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryTooltipPriority;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2687[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemPropertyTypeDataAsset">();
	}
	static class UDCItemPropertyTypeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemPropertyTypeDataAsset>();
	}
};
static_assert(alignof(UDCItemPropertyTypeDataAsset) == 0x000008, "Wrong alignment on UDCItemPropertyTypeDataAsset");
static_assert(sizeof(UDCItemPropertyTypeDataAsset) == 0x0000A8, "Wrong size on UDCItemPropertyTypeDataAsset");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, PropertyTypeGroupId) == 0x000048, "Member 'UDCItemPropertyTypeDataAsset::PropertyTypeGroupId' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, PropertyType) == 0x00004C, "Member 'UDCItemPropertyTypeDataAsset::PropertyType' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, PerkId) == 0x000054, "Member 'UDCItemPropertyTypeDataAsset::PerkId' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, SkillId) == 0x000064, "Member 'UDCItemPropertyTypeDataAsset::SkillId' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, SpellId) == 0x000074, "Member 'UDCItemPropertyTypeDataAsset::SpellId' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, EffectClass) == 0x000088, "Member 'UDCItemPropertyTypeDataAsset::EffectClass' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, EffectType) == 0x000090, "Member 'UDCItemPropertyTypeDataAsset::EffectType' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, ValueRatio) == 0x000098, "Member 'UDCItemPropertyTypeDataAsset::ValueRatio' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, PrimaryTooltipPriority) == 0x00009C, "Member 'UDCItemPropertyTypeDataAsset::PrimaryTooltipPriority' has a wrong offset!");
static_assert(offsetof(UDCItemPropertyTypeDataAsset, SecondaryTooltipPriority) == 0x0000A0, "Member 'UDCItemPropertyTypeDataAsset::SecondaryTooltipPriority' has a wrong offset!");

// Class DungeonCrawler.GameHitDirectionManagerWidget
// 0x0030 (0x0388 - 0x0358)
class UGameHitDirectionManagerWidget final : public UDCWidgetBase
{
public:
	TArray<class UDCWidgetBase*>                  HitDirectionWidgetList;                            // 0x0358(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameHitDirectionWidget>    HitDirectionWidget;                                // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameHitDirectionWidget*                AllDirectionWidget;                                // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameHitDirectionWidget*                HealingWidget;                                     // 0x0378(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawnCount;                                        // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2688[0x4];                                     // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHitDirectionManagerWidget">();
	}
	static class UGameHitDirectionManagerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHitDirectionManagerWidget>();
	}
};
static_assert(alignof(UGameHitDirectionManagerWidget) == 0x000008, "Wrong alignment on UGameHitDirectionManagerWidget");
static_assert(sizeof(UGameHitDirectionManagerWidget) == 0x000388, "Wrong size on UGameHitDirectionManagerWidget");
static_assert(offsetof(UGameHitDirectionManagerWidget, HitDirectionWidgetList) == 0x000358, "Member 'UGameHitDirectionManagerWidget::HitDirectionWidgetList' has a wrong offset!");
static_assert(offsetof(UGameHitDirectionManagerWidget, HitDirectionWidget) == 0x000368, "Member 'UGameHitDirectionManagerWidget::HitDirectionWidget' has a wrong offset!");
static_assert(offsetof(UGameHitDirectionManagerWidget, AllDirectionWidget) == 0x000370, "Member 'UGameHitDirectionManagerWidget::AllDirectionWidget' has a wrong offset!");
static_assert(offsetof(UGameHitDirectionManagerWidget, HealingWidget) == 0x000378, "Member 'UGameHitDirectionManagerWidget::HealingWidget' has a wrong offset!");
static_assert(offsetof(UGameHitDirectionManagerWidget, SpawnCount) == 0x000380, "Member 'UGameHitDirectionManagerWidget::SpawnCount' has a wrong offset!");

// Class DungeonCrawler.DCItemConsumeDataAsset
// 0x0020 (0x0068 - 0x0048)
class UDCItemConsumeDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   ConsumeText;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ConsumeDuration;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConsumeInteractSpeedBonusRatio;                    // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemConsumeDataAsset">();
	}
	static class UDCItemConsumeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemConsumeDataAsset>();
	}
};
static_assert(alignof(UDCItemConsumeDataAsset) == 0x000008, "Wrong alignment on UDCItemConsumeDataAsset");
static_assert(sizeof(UDCItemConsumeDataAsset) == 0x000068, "Wrong size on UDCItemConsumeDataAsset");
static_assert(offsetof(UDCItemConsumeDataAsset, ConsumeText) == 0x000048, "Member 'UDCItemConsumeDataAsset::ConsumeText' has a wrong offset!");
static_assert(offsetof(UDCItemConsumeDataAsset, ConsumeDuration) == 0x000060, "Member 'UDCItemConsumeDataAsset::ConsumeDuration' has a wrong offset!");
static_assert(offsetof(UDCItemConsumeDataAsset, ConsumeInteractSpeedBonusRatio) == 0x000064, "Member 'UDCItemConsumeDataAsset::ConsumeInteractSpeedBonusRatio' has a wrong offset!");

// Class DungeonCrawler.DCItemDragDropOperation
// 0x0170 (0x0200 - 0x0090)
class UDCItemDragDropOperation final : public UDragDropOperation
{
public:
	class UDCInventoryBase*                       Inventory;                                         // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            ItemInfo;                                          // 0x0098(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemDragDropOperation">();
	}
	static class UDCItemDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemDragDropOperation>();
	}
};
static_assert(alignof(UDCItemDragDropOperation) == 0x000008, "Wrong alignment on UDCItemDragDropOperation");
static_assert(sizeof(UDCItemDragDropOperation) == 0x000200, "Wrong size on UDCItemDragDropOperation");
static_assert(offsetof(UDCItemDragDropOperation, Inventory) == 0x000090, "Member 'UDCItemDragDropOperation::Inventory' has a wrong offset!");
static_assert(offsetof(UDCItemDragDropOperation, ItemInfo) == 0x000098, "Member 'UDCItemDragDropOperation::ItemInfo' has a wrong offset!");

// Class DungeonCrawler.GameInventoryGroupWidget
// 0x0030 (0x04D8 - 0x04A8)
class UGameInventoryGroupWidget final : public UGameGroupWidgetBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ItemCountSelectWidgetClass;                        // 0x04B0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnItemDrop(const struct FItemData& ItemData, class AActor* OldOwnerActor);
	void OnItemDropOne(const struct FItemData& ItemData, class AActor* OldOwnerActor);
	void OnPopItemSelectWidget(const struct FItemData& ItemData, class AActor* OldOwnerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInventoryGroupWidget">();
	}
	static class UGameInventoryGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInventoryGroupWidget>();
	}
};
static_assert(alignof(UGameInventoryGroupWidget) == 0x000008, "Wrong alignment on UGameInventoryGroupWidget");
static_assert(sizeof(UGameInventoryGroupWidget) == 0x0004D8, "Wrong size on UGameInventoryGroupWidget");
static_assert(offsetof(UGameInventoryGroupWidget, AccountLink) == 0x0004A8, "Member 'UGameInventoryGroupWidget::AccountLink' has a wrong offset!");
static_assert(offsetof(UGameInventoryGroupWidget, ItemCountSelectWidgetClass) == 0x0004B0, "Member 'UGameInventoryGroupWidget::ItemCountSelectWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCItemPreviewDataAsset
// 0x0090 (0x00C0 - 0x0030)
class UDCItemPreviewDataAsset final : public UDataAsset
{
public:
	class UTexture2D*                             PreviewIconTexture;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PreviewActorClass;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PreviewRotation;                                   // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2689[0x8];                                     // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreviewCameraTransform;                            // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemPreviewDataAsset">();
	}
	static class UDCItemPreviewDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemPreviewDataAsset>();
	}
};
static_assert(alignof(UDCItemPreviewDataAsset) == 0x000010, "Wrong alignment on UDCItemPreviewDataAsset");
static_assert(sizeof(UDCItemPreviewDataAsset) == 0x0000C0, "Wrong size on UDCItemPreviewDataAsset");
static_assert(offsetof(UDCItemPreviewDataAsset, PreviewIconTexture) == 0x000030, "Member 'UDCItemPreviewDataAsset::PreviewIconTexture' has a wrong offset!");
static_assert(offsetof(UDCItemPreviewDataAsset, PreviewActorClass) == 0x000038, "Member 'UDCItemPreviewDataAsset::PreviewActorClass' has a wrong offset!");
static_assert(offsetof(UDCItemPreviewDataAsset, PreviewRotation) == 0x000040, "Member 'UDCItemPreviewDataAsset::PreviewRotation' has a wrong offset!");
static_assert(offsetof(UDCItemPreviewDataAsset, PreviewCameraTransform) == 0x000060, "Member 'UDCItemPreviewDataAsset::PreviewCameraTransform' has a wrong offset!");

// Class DungeonCrawler.DCItemSkinDataAsset
// 0x00C0 (0x0108 - 0x0048)
class UDCItemSkinDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCItemSkinDataAsset;                          // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemActor>                 ItemActor;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectileActor>           ProjectileActor;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropsActorBase>            InstallActor;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActor;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataUtility>         Art;                                               // 0x0098(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetItem;                                        // 0x00C0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemPreviewDataAsset*                ItemPreview;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x00D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDCGameplayEffectDataAsset*>     CharacterEquipEffects;                             // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinDataAsset">();
	}
	static class UDCItemSkinDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSkinDataAsset>();
	}
};
static_assert(alignof(UDCItemSkinDataAsset) == 0x000008, "Wrong alignment on UDCItemSkinDataAsset");
static_assert(sizeof(UDCItemSkinDataAsset) == 0x000108, "Wrong size on UDCItemSkinDataAsset");
static_assert(offsetof(UDCItemSkinDataAsset, Name_DCItemSkinDataAsset) == 0x000048, "Member 'UDCItemSkinDataAsset::Name_DCItemSkinDataAsset' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, FlavorText) == 0x000060, "Member 'UDCItemSkinDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, ItemActor) == 0x000078, "Member 'UDCItemSkinDataAsset::ItemActor' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, ProjectileActor) == 0x000080, "Member 'UDCItemSkinDataAsset::ProjectileActor' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, InstallActor) == 0x000088, "Member 'UDCItemSkinDataAsset::InstallActor' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, ItemHolderActor) == 0x000090, "Member 'UDCItemSkinDataAsset::ItemHolderActor' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, Art) == 0x000098, "Member 'UDCItemSkinDataAsset::Art' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, TargetItem) == 0x0000C0, "Member 'UDCItemSkinDataAsset::TargetItem' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, ItemPreview) == 0x0000C8, "Member 'UDCItemSkinDataAsset::ItemPreview' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, SoundData) == 0x0000D0, "Member 'UDCItemSkinDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCItemSkinDataAsset, CharacterEquipEffects) == 0x0000F8, "Member 'UDCItemSkinDataAsset::CharacterEquipEffects' has a wrong offset!");

// Class DungeonCrawler.DescDataAbility
// 0x0000 (0x0060 - 0x0060)
class UDescDataAbility : public UDescData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DescDataAbility">();
	}
	static class UDescDataAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDescDataAbility>();
	}
};
static_assert(alignof(UDescDataAbility) == 0x000008, "Wrong alignment on UDescDataAbility");
static_assert(sizeof(UDescDataAbility) == 0x000060, "Wrong size on UDescDataAbility");

// Class DungeonCrawler.DescDataAbilityWeapon
// 0x0000 (0x0060 - 0x0060)
class UDescDataAbilityWeapon final : public UDescDataAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DescDataAbilityWeapon">();
	}
	static class UDescDataAbilityWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDescDataAbilityWeapon>();
	}
};
static_assert(alignof(UDescDataAbilityWeapon) == 0x000008, "Wrong alignment on UDescDataAbilityWeapon");
static_assert(sizeof(UDescDataAbilityWeapon) == 0x000060, "Wrong size on UDescDataAbilityWeapon");

// Class DungeonCrawler.DCItemSkinViewerActor
// 0x00D8 (0x03D0 - 0x02F8)
class ADCItemSkinViewerActor final : public ADCActorBase
{
public:
	float                                         StartRotateLocation;                               // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateSpeed;                                       // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             PreviewCameraDefaultTransform;                     // 0x0300(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   PreviewHolderComponent;                            // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSceneCaptureComponent2D*             SceneCaptureComponent;                             // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, class UArtDataItem*> ItemSkinViewTargetMap;                             // 0x0370(0x0050)(NativeAccessSpecifierPrivate)
	class UDCAkComponent*                         DCAKEmitter;                                       // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCAkComponent*                         DCAKListener;                                      // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSkinViewerActor">();
	}
	static class ADCItemSkinViewerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCItemSkinViewerActor>();
	}
};
static_assert(alignof(ADCItemSkinViewerActor) == 0x000010, "Wrong alignment on ADCItemSkinViewerActor");
static_assert(sizeof(ADCItemSkinViewerActor) == 0x0003D0, "Wrong size on ADCItemSkinViewerActor");
static_assert(offsetof(ADCItemSkinViewerActor, StartRotateLocation) == 0x0002F8, "Member 'ADCItemSkinViewerActor::StartRotateLocation' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, RotateSpeed) == 0x0002FC, "Member 'ADCItemSkinViewerActor::RotateSpeed' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, PreviewCameraDefaultTransform) == 0x000300, "Member 'ADCItemSkinViewerActor::PreviewCameraDefaultTransform' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, PreviewHolderComponent) == 0x000360, "Member 'ADCItemSkinViewerActor::PreviewHolderComponent' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, SceneCaptureComponent) == 0x000368, "Member 'ADCItemSkinViewerActor::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, ItemSkinViewTargetMap) == 0x000370, "Member 'ADCItemSkinViewerActor::ItemSkinViewTargetMap' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, DCAKEmitter) == 0x0003C0, "Member 'ADCItemSkinViewerActor::DCAKEmitter' has a wrong offset!");
static_assert(offsetof(ADCItemSkinViewerActor, DCAKListener) == 0x0003C8, "Member 'ADCItemSkinViewerActor::DCAKListener' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetBaseItem
// 0x0010 (0x0058 - 0x0048)
class UDesignDataAssetBaseItem final : public UDCDataAssetBase
{
public:
	struct FDesignDataBaseItem                    Item;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetBaseItem">();
	}
	static class UDesignDataAssetBaseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetBaseItem>();
	}
};
static_assert(alignof(UDesignDataAssetBaseItem) == 0x000008, "Wrong alignment on UDesignDataAssetBaseItem");
static_assert(sizeof(UDesignDataAssetBaseItem) == 0x000058, "Wrong size on UDesignDataAssetBaseItem");
static_assert(offsetof(UDesignDataAssetBaseItem, Item) == 0x000048, "Member 'UDesignDataAssetBaseItem::Item' has a wrong offset!");

// Class DungeonCrawler.DCItemSwitchAbilityBase
// 0x0058 (0x05F8 - 0x05A0)
class UDCItemSwitchAbilityBase : public UDCCharacterAbilityBase
{
public:
	class UDCCharacterAbilitySystemComponent*     CharacterASC;                                      // 0x05A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEquipmentComponent*                  EquipComp;                                         // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCItemSwitchEventData                 ItemSwitchEventData;                               // 0x05B0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CharacterMontageTag;                               // 0x05E8(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinished;                                         // 0x05F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268A[0x7];                                     // 0x05F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterMontageEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCharacterMontageFinished(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCharacterMontageInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSwitchAbilityBase">();
	}
	static class UDCItemSwitchAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSwitchAbilityBase>();
	}
};
static_assert(alignof(UDCItemSwitchAbilityBase) == 0x000008, "Wrong alignment on UDCItemSwitchAbilityBase");
static_assert(sizeof(UDCItemSwitchAbilityBase) == 0x0005F8, "Wrong size on UDCItemSwitchAbilityBase");
static_assert(offsetof(UDCItemSwitchAbilityBase, CharacterASC) == 0x0005A0, "Member 'UDCItemSwitchAbilityBase::CharacterASC' has a wrong offset!");
static_assert(offsetof(UDCItemSwitchAbilityBase, EquipComp) == 0x0005A8, "Member 'UDCItemSwitchAbilityBase::EquipComp' has a wrong offset!");
static_assert(offsetof(UDCItemSwitchAbilityBase, ItemSwitchEventData) == 0x0005B0, "Member 'UDCItemSwitchAbilityBase::ItemSwitchEventData' has a wrong offset!");
static_assert(offsetof(UDCItemSwitchAbilityBase, CharacterMontageTag) == 0x0005E8, "Member 'UDCItemSwitchAbilityBase::CharacterMontageTag' has a wrong offset!");
static_assert(offsetof(UDCItemSwitchAbilityBase, bFinished) == 0x0005F0, "Member 'UDCItemSwitchAbilityBase::bFinished' has a wrong offset!");

// Class DungeonCrawler.DCItemSwitchAbilityByHoldInfoAbility
// 0x0000 (0x05F8 - 0x05F8)
class UDCItemSwitchAbilityByHoldInfoAbility : public UDCItemSwitchAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSwitchAbilityByHoldInfoAbility">();
	}
	static class UDCItemSwitchAbilityByHoldInfoAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSwitchAbilityByHoldInfoAbility>();
	}
};
static_assert(alignof(UDCItemSwitchAbilityByHoldInfoAbility) == 0x000008, "Wrong alignment on UDCItemSwitchAbilityByHoldInfoAbility");
static_assert(sizeof(UDCItemSwitchAbilityByHoldInfoAbility) == 0x0005F8, "Wrong size on UDCItemSwitchAbilityByHoldInfoAbility");

// Class DungeonCrawler.DCQuestLogListEntryWidgetData
// 0x0020 (0x0048 - 0x0028)
class UDCQuestLogListEntryWidgetData final : public UObject
{
public:
	struct FDCQuestLogInfo                        QuestLogInfo;                                      // 0x0028(0x0020)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogListEntryWidgetData">();
	}
	static class UDCQuestLogListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogListEntryWidgetData>();
	}
};
static_assert(alignof(UDCQuestLogListEntryWidgetData) == 0x000008, "Wrong alignment on UDCQuestLogListEntryWidgetData");
static_assert(sizeof(UDCQuestLogListEntryWidgetData) == 0x000048, "Wrong size on UDCQuestLogListEntryWidgetData");
static_assert(offsetof(UDCQuestLogListEntryWidgetData, QuestLogInfo) == 0x000028, "Member 'UDCQuestLogListEntryWidgetData::QuestLogInfo' has a wrong offset!");

// Class DungeonCrawler.DCItemSwitchAbilityUpdatedItemsAbility
// 0x0000 (0x05F8 - 0x05F8)
class UDCItemSwitchAbilityUpdatedItemsAbility : public UDCItemSwitchAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemSwitchAbilityUpdatedItemsAbility">();
	}
	static class UDCItemSwitchAbilityUpdatedItemsAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemSwitchAbilityUpdatedItemsAbility>();
	}
};
static_assert(alignof(UDCItemSwitchAbilityUpdatedItemsAbility) == 0x000008, "Wrong alignment on UDCItemSwitchAbilityUpdatedItemsAbility");
static_assert(sizeof(UDCItemSwitchAbilityUpdatedItemsAbility) == 0x0005F8, "Wrong size on UDCItemSwitchAbilityUpdatedItemsAbility");

// Class DungeonCrawler.DesignDataAssetPropsInteract
// 0x00C0 (0x0108 - 0x0048)
class UDesignDataAssetPropsInteract final : public UDCDataAssetBase
{
public:
	struct FDesignDataPropsInteract               Item;                                              // 0x0048(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetPropsInteract">();
	}
	static class UDesignDataAssetPropsInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetPropsInteract>();
	}
};
static_assert(alignof(UDesignDataAssetPropsInteract) == 0x000008, "Wrong alignment on UDesignDataAssetPropsInteract");
static_assert(sizeof(UDesignDataAssetPropsInteract) == 0x000108, "Wrong size on UDesignDataAssetPropsInteract");
static_assert(offsetof(UDesignDataAssetPropsInteract, Item) == 0x000048, "Member 'UDesignDataAssetPropsInteract::Item' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipControlInfoWidget
// 0x0010 (0x0670 - 0x0660)
class UDCItemTooltipControlInfoWidget final : public UDCItemWidgetBase
{
public:
	bool                                          bIsControllable;                                   // 0x0660(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268B[0x7];                                     // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             ItemControlInfoText;                               // 0x0668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipControlInfoWidget">();
	}
	static class UDCItemTooltipControlInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipControlInfoWidget>();
	}
};
static_assert(alignof(UDCItemTooltipControlInfoWidget) == 0x000008, "Wrong alignment on UDCItemTooltipControlInfoWidget");
static_assert(sizeof(UDCItemTooltipControlInfoWidget) == 0x000670, "Wrong size on UDCItemTooltipControlInfoWidget");
static_assert(offsetof(UDCItemTooltipControlInfoWidget, bIsControllable) == 0x000660, "Member 'UDCItemTooltipControlInfoWidget::bIsControllable' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipControlInfoWidget, ItemControlInfoText) == 0x000668, "Member 'UDCItemTooltipControlInfoWidget::ItemControlInfoText' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipNameWidget
// 0x0068 (0x06C8 - 0x0660)
class UDCItemTooltipNameWidget final : public UDCItemWidgetBase
{
public:
	struct FGameplayTag                           Rarity;                                            // 0x0660(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSoulHeart;                                      // 0x0668(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268C[0x7];                                     // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0670(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FNickname                              SoulHeartNickname;                                 // 0x0688(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipNameWidget">();
	}
	static class UDCItemTooltipNameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipNameWidget>();
	}
};
static_assert(alignof(UDCItemTooltipNameWidget) == 0x000008, "Wrong alignment on UDCItemTooltipNameWidget");
static_assert(sizeof(UDCItemTooltipNameWidget) == 0x0006C8, "Wrong size on UDCItemTooltipNameWidget");
static_assert(offsetof(UDCItemTooltipNameWidget, Rarity) == 0x000660, "Member 'UDCItemTooltipNameWidget::Rarity' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipNameWidget, bIsSoulHeart) == 0x000668, "Member 'UDCItemTooltipNameWidget::bIsSoulHeart' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipNameWidget, ItemName) == 0x000670, "Member 'UDCItemTooltipNameWidget::ItemName' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipNameWidget, SoulHeartNickname) == 0x000688, "Member 'UDCItemTooltipNameWidget::SoulHeartNickname' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipStatWidget
// 0x0020 (0x0680 - 0x0660)
class UDCItemTooltipStatWidget final : public UDCItemWidgetBase
{
public:
	uint8                                         Pad_268D[0x8];                                     // 0x0660(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           VerticalBox;                                       // 0x0668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCItemTooltipStatElementWidget> PrimaryChildWidgetClass;                           // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCItemTooltipStatElementWidget> SecondaryChildWidgetClass;                         // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipStatWidget">();
	}
	static class UDCItemTooltipStatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipStatWidget>();
	}
};
static_assert(alignof(UDCItemTooltipStatWidget) == 0x000008, "Wrong alignment on UDCItemTooltipStatWidget");
static_assert(sizeof(UDCItemTooltipStatWidget) == 0x000680, "Wrong size on UDCItemTooltipStatWidget");
static_assert(offsetof(UDCItemTooltipStatWidget, VerticalBox) == 0x000668, "Member 'UDCItemTooltipStatWidget::VerticalBox' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipStatWidget, PrimaryChildWidgetClass) == 0x000670, "Member 'UDCItemTooltipStatWidget::PrimaryChildWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipStatWidget, SecondaryChildWidgetClass) == 0x000678, "Member 'UDCItemTooltipStatWidget::SecondaryChildWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetItemProperty
// 0x0010 (0x0058 - 0x0048)
class UDesignDataAssetItemProperty final : public UDCDataAssetBase
{
public:
	struct FDesignDataItemProperty                Item;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItemProperty">();
	}
	static class UDesignDataAssetItemProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItemProperty>();
	}
};
static_assert(alignof(UDesignDataAssetItemProperty) == 0x000008, "Wrong alignment on UDesignDataAssetItemProperty");
static_assert(sizeof(UDesignDataAssetItemProperty) == 0x000058, "Wrong size on UDesignDataAssetItemProperty");
static_assert(offsetof(UDesignDataAssetItemProperty, Item) == 0x000048, "Member 'UDesignDataAssetItemProperty::Item' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipAbilityElementWidget
// 0x0008 (0x02C8 - 0x02C0)
class UDCItemTooltipAbilityElementWidget final : public UUserWidget
{
public:
	class URichTextBlock*                         RichTextBlock;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipAbilityElementWidget">();
	}
	static class UDCItemTooltipAbilityElementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipAbilityElementWidget>();
	}
};
static_assert(alignof(UDCItemTooltipAbilityElementWidget) == 0x000008, "Wrong alignment on UDCItemTooltipAbilityElementWidget");
static_assert(sizeof(UDCItemTooltipAbilityElementWidget) == 0x0002C8, "Wrong size on UDCItemTooltipAbilityElementWidget");
static_assert(offsetof(UDCItemTooltipAbilityElementWidget, RichTextBlock) == 0x0002C0, "Member 'UDCItemTooltipAbilityElementWidget::RichTextBlock' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipAbilityWidget
// 0x0010 (0x0670 - 0x0660)
class UDCItemTooltipAbilityWidget final : public UDCItemWidgetBase
{
public:
	class UVerticalBox*                           VerticalBox;                                       // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCItemTooltipAbilityElementWidget> ChildWidgetClass;                                  // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipAbilityWidget">();
	}
	static class UDCItemTooltipAbilityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipAbilityWidget>();
	}
};
static_assert(alignof(UDCItemTooltipAbilityWidget) == 0x000008, "Wrong alignment on UDCItemTooltipAbilityWidget");
static_assert(sizeof(UDCItemTooltipAbilityWidget) == 0x000670, "Wrong size on UDCItemTooltipAbilityWidget");
static_assert(offsetof(UDCItemTooltipAbilityWidget, VerticalBox) == 0x000660, "Member 'UDCItemTooltipAbilityWidget::VerticalBox' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipAbilityWidget, ChildWidgetClass) == 0x000668, "Member 'UDCItemTooltipAbilityWidget::ChildWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget
// 0x0008 (0x02C8 - 0x02C0)
class UDCItemTooltipRequiredAttributeEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_268E[0x8];                                     // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanEquipByRequiredAttribute() const;
	EItemRequirementType GetRequiredAttributeType() const;
	int32 GetRequiredAttributeValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipRequiredAttributeEntryWidget">();
	}
	static class UDCItemTooltipRequiredAttributeEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipRequiredAttributeEntryWidget>();
	}
};
static_assert(alignof(UDCItemTooltipRequiredAttributeEntryWidget) == 0x000008, "Wrong alignment on UDCItemTooltipRequiredAttributeEntryWidget");
static_assert(sizeof(UDCItemTooltipRequiredAttributeEntryWidget) == 0x0002C8, "Wrong size on UDCItemTooltipRequiredAttributeEntryWidget");

// Class DungeonCrawler.DCSpawnPoolComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDCSpawnPoolComponent final : public UDCActorComponent
{
public:
	struct FPrimaryAssetId                        PropsId;                                           // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268F[0x10];                                    // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APropsActorBase* Rent();
	void Return(class APropsActorBase* RentedPropActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSpawnPoolComponent">();
	}
	static class UDCSpawnPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSpawnPoolComponent>();
	}
};
static_assert(alignof(UDCSpawnPoolComponent) == 0x000008, "Wrong alignment on UDCSpawnPoolComponent");
static_assert(sizeof(UDCSpawnPoolComponent) == 0x0000C0, "Wrong size on UDCSpawnPoolComponent");
static_assert(offsetof(UDCSpawnPoolComponent, PropsId) == 0x0000A0, "Member 'UDCSpawnPoolComponent::PropsId' has a wrong offset!");

// Class DungeonCrawler.DCItemTooltipInfoWidget
// 0x0048 (0x06A8 - 0x0660)
class UDCItemTooltipInfoWidget final : public UDCItemWidgetBase
{
public:
	bool                                          bIsItemRarityAny;                                  // 0x0660(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0661(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2690[0x2];                                     // 0x0662(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SlotType;                                          // 0x0664(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RarityType;                                        // 0x066C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2691[0x4];                                     // 0x0674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   WeaponTypes;                                       // 0x0678(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HandType;                                          // 0x0688(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ArmorType;                                         // 0x0690(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           UtilityType;                                       // 0x0698(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCItemLootState                              LootState;                                         // 0x06A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2692[0x7];                                     // 0x06A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTooltipInfoWidget">();
	}
	static class UDCItemTooltipInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTooltipInfoWidget>();
	}
};
static_assert(alignof(UDCItemTooltipInfoWidget) == 0x000008, "Wrong alignment on UDCItemTooltipInfoWidget");
static_assert(sizeof(UDCItemTooltipInfoWidget) == 0x0006A8, "Wrong size on UDCItemTooltipInfoWidget");
static_assert(offsetof(UDCItemTooltipInfoWidget, bIsItemRarityAny) == 0x000660, "Member 'UDCItemTooltipInfoWidget::bIsItemRarityAny' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, ItemType) == 0x000661, "Member 'UDCItemTooltipInfoWidget::ItemType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, SlotType) == 0x000664, "Member 'UDCItemTooltipInfoWidget::SlotType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, RarityType) == 0x00066C, "Member 'UDCItemTooltipInfoWidget::RarityType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, WeaponTypes) == 0x000678, "Member 'UDCItemTooltipInfoWidget::WeaponTypes' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, HandType) == 0x000688, "Member 'UDCItemTooltipInfoWidget::HandType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, ArmorType) == 0x000690, "Member 'UDCItemTooltipInfoWidget::ArmorType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, UtilityType) == 0x000698, "Member 'UDCItemTooltipInfoWidget::UtilityType' has a wrong offset!");
static_assert(offsetof(UDCItemTooltipInfoWidget, LootState) == 0x0006A0, "Member 'UDCItemTooltipInfoWidget::LootState' has a wrong offset!");

// Class DungeonCrawler.DCItemInfoEntryWidget
// 0x0008 (0x06C0 - 0x06B8)
class UDCItemInfoEntryWidget final : public UDCItemCommonWidget
{
public:
	uint8                                         Pad_2693[0x8];                                     // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemInfoEntryWidget">();
	}
	static class UDCItemInfoEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemInfoEntryWidget>();
	}
};
static_assert(alignof(UDCItemInfoEntryWidget) == 0x000008, "Wrong alignment on UDCItemInfoEntryWidget");
static_assert(sizeof(UDCItemInfoEntryWidget) == 0x0006C0, "Wrong size on UDCItemInfoEntryWidget");

// Class DungeonCrawler.DCSpellWidgetBase
// 0x0058 (0x03B0 - 0x0358)
class UDCSpellWidgetBase final : public UDCWidgetBase
{
public:
	class UImage*                                 SpellIcon;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTooltipWidget>           SpellTooltipWidgetClass;                           // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSet;                                              // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2694[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SpellName;                                         // 0x0370(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class FText                                   SpellDesc;                                         // 0x0388(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        DescId;                                            // 0x03A0(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetSpellTooltipWidget();
	void OnArtDataSet(const class UArtDataSpell* ArtData);
	void OnReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSpellWidgetBase">();
	}
	static class UDCSpellWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSpellWidgetBase>();
	}
};
static_assert(alignof(UDCSpellWidgetBase) == 0x000008, "Wrong alignment on UDCSpellWidgetBase");
static_assert(sizeof(UDCSpellWidgetBase) == 0x0003B0, "Wrong size on UDCSpellWidgetBase");
static_assert(offsetof(UDCSpellWidgetBase, SpellIcon) == 0x000358, "Member 'UDCSpellWidgetBase::SpellIcon' has a wrong offset!");
static_assert(offsetof(UDCSpellWidgetBase, SpellTooltipWidgetClass) == 0x000360, "Member 'UDCSpellWidgetBase::SpellTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCSpellWidgetBase, bSet) == 0x000368, "Member 'UDCSpellWidgetBase::bSet' has a wrong offset!");
static_assert(offsetof(UDCSpellWidgetBase, SpellName) == 0x000370, "Member 'UDCSpellWidgetBase::SpellName' has a wrong offset!");
static_assert(offsetof(UDCSpellWidgetBase, SpellDesc) == 0x000388, "Member 'UDCSpellWidgetBase::SpellDesc' has a wrong offset!");
static_assert(offsetof(UDCSpellWidgetBase, DescId) == 0x0003A0, "Member 'UDCSpellWidgetBase::DescId' has a wrong offset!");

// Class DungeonCrawler.DCItemTypeArtData
// 0x0050 (0x0098 - 0x0048)
class UDCItemTypeArtData final : public UArtDataBase
{
public:
	TMap<EDCItemType, struct FDCItemTypeRarityIconData> RarityIconDataByItemType;                          // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemTypeArtData">();
	}
	static class UDCItemTypeArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemTypeArtData>();
	}
};
static_assert(alignof(UDCItemTypeArtData) == 0x000008, "Wrong alignment on UDCItemTypeArtData");
static_assert(sizeof(UDCItemTypeArtData) == 0x000098, "Wrong size on UDCItemTypeArtData");
static_assert(offsetof(UDCItemTypeArtData, RarityIconDataByItemType) == 0x000048, "Member 'UDCItemTypeArtData::RarityIconDataByItemType' has a wrong offset!");

// Class DungeonCrawler.DCReadOnlyValidator
// 0x0000 (0x0030 - 0x0030)
class UDCReadOnlyValidator final : public UDCInventoryValidatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReadOnlyValidator">();
	}
	static class UDCReadOnlyValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReadOnlyValidator>();
	}
};
static_assert(alignof(UDCReadOnlyValidator) == 0x000008, "Wrong alignment on UDCReadOnlyValidator");
static_assert(sizeof(UDCReadOnlyValidator) == 0x000030, "Wrong size on UDCReadOnlyValidator");

// Class DungeonCrawler.DCTabListWidgetBase
// 0x0060 (0x0440 - 0x03E0)
class UDCTabListWidgetBase : public UCommonTabListWidgetBase
{
public:
	TSubclassOf<class UDCTabButtonWidgetBase>     TabButtonWidgetClass;                              // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           TabButtonTextList;                                 // 0x03E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           TabNameIdList;                                     // 0x03F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        ContentWidgetList;                                 // 0x0408(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         VisibleTabCount;                                   // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2695[0x4];                                     // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           TabParent;                                         // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonActionWidget*                    PreviousTabAction;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonActionWidget*                    NextTabAction;                                     // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonAnimatedSwitcher*                SwitcherToLink;                                    // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ActivateFirstSelectableTab();
	void OnTabButtonSelected(class FName TabId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTabListWidgetBase">();
	}
	static class UDCTabListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTabListWidgetBase>();
	}
};
static_assert(alignof(UDCTabListWidgetBase) == 0x000008, "Wrong alignment on UDCTabListWidgetBase");
static_assert(sizeof(UDCTabListWidgetBase) == 0x000440, "Wrong size on UDCTabListWidgetBase");
static_assert(offsetof(UDCTabListWidgetBase, TabButtonWidgetClass) == 0x0003E0, "Member 'UDCTabListWidgetBase::TabButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, TabButtonTextList) == 0x0003E8, "Member 'UDCTabListWidgetBase::TabButtonTextList' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, TabNameIdList) == 0x0003F8, "Member 'UDCTabListWidgetBase::TabNameIdList' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, ContentWidgetList) == 0x000408, "Member 'UDCTabListWidgetBase::ContentWidgetList' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, VisibleTabCount) == 0x000418, "Member 'UDCTabListWidgetBase::VisibleTabCount' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, TabParent) == 0x000420, "Member 'UDCTabListWidgetBase::TabParent' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, PreviousTabAction) == 0x000428, "Member 'UDCTabListWidgetBase::PreviousTabAction' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, NextTabAction) == 0x000430, "Member 'UDCTabListWidgetBase::NextTabAction' has a wrong offset!");
static_assert(offsetof(UDCTabListWidgetBase, SwitcherToLink) == 0x000438, "Member 'UDCTabListWidgetBase::SwitcherToLink' has a wrong offset!");

// Class DungeonCrawler.DCMerchantWishListValidator
// 0x0008 (0x0038 - 0x0030)
class UDCMerchantWishListValidator final : public UDCInventoryValidatorBase
{
public:
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantWishListValidator">();
	}
	static class UDCMerchantWishListValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantWishListValidator>();
	}
};
static_assert(alignof(UDCMerchantWishListValidator) == 0x000008, "Wrong alignment on UDCMerchantWishListValidator");
static_assert(sizeof(UDCMerchantWishListValidator) == 0x000038, "Wrong size on UDCMerchantWishListValidator");
static_assert(offsetof(UDCMerchantWishListValidator, MerchantComponent) == 0x000030, "Member 'UDCMerchantWishListValidator::MerchantComponent' has a wrong offset!");

// Class DungeonCrawler.DCSuppliedItemFilterValidator
// 0x0000 (0x0030 - 0x0030)
class UDCSuppliedItemFilterValidator final : public UDCInventoryValidatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSuppliedItemFilterValidator">();
	}
	static class UDCSuppliedItemFilterValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSuppliedItemFilterValidator>();
	}
};
static_assert(alignof(UDCSuppliedItemFilterValidator) == 0x000008, "Wrong alignment on UDCSuppliedItemFilterValidator");
static_assert(sizeof(UDCSuppliedItemFilterValidator) == 0x000030, "Wrong size on UDCSuppliedItemFilterValidator");

// Class DungeonCrawler.DCLockedItemFilterValidator
// 0x0018 (0x0048 - 0x0030)
class UDCLockedItemFilterValidator final : public UDCInventoryValidatorBase
{
public:
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMetaTradeComponent*                  TradeComponent;                                    // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceComponent*                MarketplaceComponent;                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLockedItemFilterValidator">();
	}
	static class UDCLockedItemFilterValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLockedItemFilterValidator>();
	}
};
static_assert(alignof(UDCLockedItemFilterValidator) == 0x000008, "Wrong alignment on UDCLockedItemFilterValidator");
static_assert(sizeof(UDCLockedItemFilterValidator) == 0x000048, "Wrong size on UDCLockedItemFilterValidator");
static_assert(offsetof(UDCLockedItemFilterValidator, MerchantComponent) == 0x000030, "Member 'UDCLockedItemFilterValidator::MerchantComponent' has a wrong offset!");
static_assert(offsetof(UDCLockedItemFilterValidator, TradeComponent) == 0x000038, "Member 'UDCLockedItemFilterValidator::TradeComponent' has a wrong offset!");
static_assert(offsetof(UDCLockedItemFilterValidator, MarketplaceComponent) == 0x000040, "Member 'UDCLockedItemFilterValidator::MarketplaceComponent' has a wrong offset!");

// Class DungeonCrawler.StatisticsSeasonTabItemWidgetData
// 0x0040 (0x0068 - 0x0028)
class UStatisticsSeasonTabItemWidgetData final : public UObject
{
public:
	struct FLeaderboardInfo                       LeaderboardInfo;                                   // 0x0028(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsSeasonTabItemWidgetData">();
	}
	static class UStatisticsSeasonTabItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsSeasonTabItemWidgetData>();
	}
};
static_assert(alignof(UStatisticsSeasonTabItemWidgetData) == 0x000008, "Wrong alignment on UStatisticsSeasonTabItemWidgetData");
static_assert(sizeof(UStatisticsSeasonTabItemWidgetData) == 0x000068, "Wrong size on UStatisticsSeasonTabItemWidgetData");
static_assert(offsetof(UStatisticsSeasonTabItemWidgetData, LeaderboardInfo) == 0x000028, "Member 'UStatisticsSeasonTabItemWidgetData::LeaderboardInfo' has a wrong offset!");

// Class DungeonCrawler.DCLootStateMergeFilterValidator
// 0x0000 (0x0030 - 0x0030)
class UDCLootStateMergeFilterValidator final : public UDCInventoryValidatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLootStateMergeFilterValidator">();
	}
	static class UDCLootStateMergeFilterValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLootStateMergeFilterValidator>();
	}
};
static_assert(alignof(UDCLootStateMergeFilterValidator) == 0x000008, "Wrong alignment on UDCLootStateMergeFilterValidator");
static_assert(sizeof(UDCLootStateMergeFilterValidator) == 0x000030, "Wrong size on UDCLootStateMergeFilterValidator");

// Class DungeonCrawler.DCTargetType
// 0x0000 (0x0028 - 0x0028)
class UDCTargetType : public UObject
{
public:
	void GetTargets(class AActor* TargetingOwnerActor, class AActor* TargetingAvatarActor, const struct FGameplayEventData& EventData, TArray<struct FHitResult>* OutHitResults, TArray<class AActor*>* OutActors) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTargetType">();
	}
	static class UDCTargetType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTargetType>();
	}
};
static_assert(alignof(UDCTargetType) == 0x000008, "Wrong alignment on UDCTargetType");
static_assert(sizeof(UDCTargetType) == 0x000028, "Wrong size on UDCTargetType");

// Class DungeonCrawler.DCTargetType_UseEventData
// 0x0000 (0x0028 - 0x0028)
class UDCTargetType_UseEventData final : public UDCTargetType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTargetType_UseEventData">();
	}
	static class UDCTargetType_UseEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTargetType_UseEventData>();
	}
};
static_assert(alignof(UDCTargetType_UseEventData) == 0x000008, "Wrong alignment on UDCTargetType_UseEventData");
static_assert(sizeof(UDCTargetType_UseEventData) == 0x000028, "Wrong size on UDCTargetType_UseEventData");

// Class DungeonCrawler.DCExpressmanFilterValidator
// 0x0018 (0x0048 - 0x0030)
class UDCExpressmanFilterValidator final : public UDCInventoryValidatorBase
{
public:
	uint8                                         Pad_2696[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCExpressmanComponent*                 ExpressmanComponent;                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCExpressmanFilterValidator">();
	}
	static class UDCExpressmanFilterValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCExpressmanFilterValidator>();
	}
};
static_assert(alignof(UDCExpressmanFilterValidator) == 0x000008, "Wrong alignment on UDCExpressmanFilterValidator");
static_assert(sizeof(UDCExpressmanFilterValidator) == 0x000048, "Wrong size on UDCExpressmanFilterValidator");
static_assert(offsetof(UDCExpressmanFilterValidator, ExpressmanComponent) == 0x000040, "Member 'UDCExpressmanFilterValidator::ExpressmanComponent' has a wrong offset!");

// Class DungeonCrawler.DCKillLogItemWidgetData
// 0x01D0 (0x01F8 - 0x0028)
class UDCKillLogItemWidgetData final : public UObject
{
public:
	struct FGameKillLogData                       GameKillLogData;                                   // 0x0028(0x0118)(NativeAccessSpecifierPublic)
	struct FGameFloorLogData                      GameFloorLogData;                                  // 0x0140(0x0098)(NativeAccessSpecifierPublic)
	EDCKillLogWidgetType                          LogType;                                           // 0x01D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2697[0x7];                                     // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AnnounceText;                                      // 0x01E0(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCKillLogItemWidgetData">();
	}
	static class UDCKillLogItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCKillLogItemWidgetData>();
	}
};
static_assert(alignof(UDCKillLogItemWidgetData) == 0x000008, "Wrong alignment on UDCKillLogItemWidgetData");
static_assert(sizeof(UDCKillLogItemWidgetData) == 0x0001F8, "Wrong size on UDCKillLogItemWidgetData");
static_assert(offsetof(UDCKillLogItemWidgetData, GameKillLogData) == 0x000028, "Member 'UDCKillLogItemWidgetData::GameKillLogData' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetData, GameFloorLogData) == 0x000140, "Member 'UDCKillLogItemWidgetData::GameFloorLogData' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetData, LogType) == 0x0001D8, "Member 'UDCKillLogItemWidgetData::LogType' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetData, AnnounceText) == 0x0001E0, "Member 'UDCKillLogItemWidgetData::AnnounceText' has a wrong offset!");

// Class DungeonCrawler.DCKillLogItemWidgetBase
// 0x0070 (0x03C8 - 0x0358)
class UDCKillLogItemWidgetBase final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2698[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescriptionText;                                   // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   KilledNameText;                                    // 0x0378(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   InstigatorText;                                    // 0x0390(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   EffectCauserText;                                  // 0x03A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UDCKillLogItemWidgetData*               WidgetData;                                        // 0x03C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSetAnnounce();
	void OnSetFloorLog();
	void OnSetKillLog(bool bIsHitHead);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCKillLogItemWidgetBase">();
	}
	static class UDCKillLogItemWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCKillLogItemWidgetBase>();
	}
};
static_assert(alignof(UDCKillLogItemWidgetBase) == 0x000008, "Wrong alignment on UDCKillLogItemWidgetBase");
static_assert(sizeof(UDCKillLogItemWidgetBase) == 0x0003C8, "Wrong size on UDCKillLogItemWidgetBase");
static_assert(offsetof(UDCKillLogItemWidgetBase, DescriptionText) == 0x000360, "Member 'UDCKillLogItemWidgetBase::DescriptionText' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetBase, KilledNameText) == 0x000378, "Member 'UDCKillLogItemWidgetBase::KilledNameText' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetBase, InstigatorText) == 0x000390, "Member 'UDCKillLogItemWidgetBase::InstigatorText' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetBase, EffectCauserText) == 0x0003A8, "Member 'UDCKillLogItemWidgetBase::EffectCauserText' has a wrong offset!");
static_assert(offsetof(UDCKillLogItemWidgetBase, WidgetData) == 0x0003C0, "Member 'UDCKillLogItemWidgetBase::WidgetData' has a wrong offset!");

// Class DungeonCrawler.DCKillLogWidgetBase
// 0x0020 (0x0378 - 0x0358)
class UDCKillLogWidgetBase final : public UDCWidgetBase
{
public:
	class UListView*                              KillLogList;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLogNum;                                         // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2699[0x4];                                     // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCKillLogItemWidgetData*>       KillLogListItemWidgetDataArray;                    // 0x0368(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCKillLogWidgetBase">();
	}
	static class UDCKillLogWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCKillLogWidgetBase>();
	}
};
static_assert(alignof(UDCKillLogWidgetBase) == 0x000008, "Wrong alignment on UDCKillLogWidgetBase");
static_assert(sizeof(UDCKillLogWidgetBase) == 0x000378, "Wrong size on UDCKillLogWidgetBase");
static_assert(offsetof(UDCKillLogWidgetBase, KillLogList) == 0x000358, "Member 'UDCKillLogWidgetBase::KillLogList' has a wrong offset!");
static_assert(offsetof(UDCKillLogWidgetBase, MaxLogNum) == 0x000360, "Member 'UDCKillLogWidgetBase::MaxLogNum' has a wrong offset!");
static_assert(offsetof(UDCKillLogWidgetBase, KillLogListItemWidgetDataArray) == 0x000368, "Member 'UDCKillLogWidgetBase::KillLogListItemWidgetDataArray' has a wrong offset!");

// Class DungeonCrawler.EmoteComponent
// 0x00F8 (0x0198 - 0x00A0)
class UEmoteComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_269A[0x70];                                    // 0x00A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCEmoteSlotInfo>               EmoteSlotInfoArray;                                // 0x0110(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FPrimaryAssetId>           EmoteSlotMap;                                      // 0x0120(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     OwnerGameplayAbilitySpecHandles;                   // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    OwnerGameplayEffectHandles;                        // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FRandomStream                          RandomStream;                                      // 0x0190(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnRep_EmoteSlotInfoArray(const TArray<struct FDCEmoteSlotInfo>& OldEmoteSlotInfoArray);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteComponent">();
	}
	static class UEmoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteComponent>();
	}
};
static_assert(alignof(UEmoteComponent) == 0x000008, "Wrong alignment on UEmoteComponent");
static_assert(sizeof(UEmoteComponent) == 0x000198, "Wrong size on UEmoteComponent");
static_assert(offsetof(UEmoteComponent, EmoteSlotInfoArray) == 0x000110, "Member 'UEmoteComponent::EmoteSlotInfoArray' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, EmoteSlotMap) == 0x000120, "Member 'UEmoteComponent::EmoteSlotMap' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, OwnerGameplayAbilitySpecHandles) == 0x000170, "Member 'UEmoteComponent::OwnerGameplayAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, OwnerGameplayEffectHandles) == 0x000180, "Member 'UEmoteComponent::OwnerGameplayEffectHandles' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, RandomStream) == 0x000190, "Member 'UEmoteComponent::RandomStream' has a wrong offset!");

// Class DungeonCrawler.DCKnightLinkWidgetBase
// 0x0000 (0x0358 - 0x0358)
class UDCKnightLinkWidgetBase final : public UDCWidgetBase
{
public:
	void OnClickedKnightLink();
	void OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCKnightLinkWidgetBase">();
	}
	static class UDCKnightLinkWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCKnightLinkWidgetBase>();
	}
};
static_assert(alignof(UDCKnightLinkWidgetBase) == 0x000008, "Wrong alignment on UDCKnightLinkWidgetBase");
static_assert(sizeof(UDCKnightLinkWidgetBase) == 0x000358, "Wrong size on UDCKnightLinkWidgetBase");

// Class DungeonCrawler.DCLeaderboardRankEFDataAsset
// 0x0000 (0x0048 - 0x0048)
class UDCLeaderboardRankEFDataAsset final : public UDCTableDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardRankEFDataAsset">();
	}
	static class UDCLeaderboardRankEFDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardRankEFDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardRankEFDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardRankEFDataAsset");
static_assert(sizeof(UDCLeaderboardRankEFDataAsset) == 0x000048, "Wrong size on UDCLeaderboardRankEFDataAsset");

// Class DungeonCrawler.DCLeaderboardRankAPDataAsset
// 0x0008 (0x0050 - 0x0048)
class UDCLeaderboardRankAPDataAsset final : public UDCTableDataAsset
{
public:
	EGameType                                     GameType;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269C[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredTotalAP;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardRankAPDataAsset">();
	}
	static class UDCLeaderboardRankAPDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardRankAPDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardRankAPDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardRankAPDataAsset");
static_assert(sizeof(UDCLeaderboardRankAPDataAsset) == 0x000050, "Wrong size on UDCLeaderboardRankAPDataAsset");
static_assert(offsetof(UDCLeaderboardRankAPDataAsset, GameType) == 0x000048, "Member 'UDCLeaderboardRankAPDataAsset::GameType' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankAPDataAsset, RequiredTotalAP) == 0x00004C, "Member 'UDCLeaderboardRankAPDataAsset::RequiredTotalAP' has a wrong offset!");

// Class DungeonCrawler.DCLeaderboardRankGroupDataAsset
// 0x00C0 (0x0108 - 0x0048)
class UDCLeaderboardRankGroupDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   RankGroupName;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         APRating;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269D[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCRewardDataAsset>      RankReward;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCRewardDataAsset>      RankReward2;                                       // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCRewardDataAsset>      RankReward3;                                       // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCRewardDataAsset>      RankReward4;                                       // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardRankGroupDataAsset">();
	}
	static class UDCLeaderboardRankGroupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardRankGroupDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardRankGroupDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardRankGroupDataAsset");
static_assert(sizeof(UDCLeaderboardRankGroupDataAsset) == 0x000108, "Wrong size on UDCLeaderboardRankGroupDataAsset");
static_assert(offsetof(UDCLeaderboardRankGroupDataAsset, RankGroupName) == 0x000048, "Member 'UDCLeaderboardRankGroupDataAsset::RankGroupName' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankGroupDataAsset, APRating) == 0x000060, "Member 'UDCLeaderboardRankGroupDataAsset::APRating' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankGroupDataAsset, RankReward) == 0x000068, "Member 'UDCLeaderboardRankGroupDataAsset::RankReward' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankGroupDataAsset, RankReward2) == 0x000090, "Member 'UDCLeaderboardRankGroupDataAsset::RankReward2' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankGroupDataAsset, RankReward3) == 0x0000B8, "Member 'UDCLeaderboardRankGroupDataAsset::RankReward3' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankGroupDataAsset, RankReward4) == 0x0000E0, "Member 'UDCLeaderboardRankGroupDataAsset::RankReward4' has a wrong offset!");

// Class DungeonCrawler.InventoryComponent
// 0x0170 (0x0210 - 0x00A0)
class UInventoryComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_269E[0x70];                                    // 0x00A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	EInventoryType                                InventoryType;                                     // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269F[0x3];                                     // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHorizontalSlotCount;                            // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalSlotCount;                                    // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A0[0x1C];                                    // 0x011C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RowCount;                                          // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A1[0x4];                                     // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSlotInfo>                      SlotInfoArray;                                     // 0x0140(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FEmptySlotInfoArray>       EmptySlotInfoMap;                                  // 0x0150(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UItem*>                     ItemMap;                                           // 0x01A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemData>                      ContainingItems;                                   // 0x01F0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int64                                         TotalGoldCount;                                    // 0x0200(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A2[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddContainingItem(const struct FItemData& ItemData);
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ClientShowMessage(const class FText& OutputMessage);
	void OnRep_ContainingItems(const TArray<struct FItemData>& OldContainingItems);
	void OnRep_TotalGoldCount(int64 OldTotalGoldCount);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	EInventoryType GetInventoryType() const;
	class UItem* GetItemByItemUniqueId(int64 InItemUniqueId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000210, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, InventoryType) == 0x000110, "Member 'UInventoryComponent::InventoryType' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, MaxHorizontalSlotCount) == 0x000114, "Member 'UInventoryComponent::MaxHorizontalSlotCount' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, TotalSlotCount) == 0x000118, "Member 'UInventoryComponent::TotalSlotCount' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, RowCount) == 0x000138, "Member 'UInventoryComponent::RowCount' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, SlotInfoArray) == 0x000140, "Member 'UInventoryComponent::SlotInfoArray' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, EmptySlotInfoMap) == 0x000150, "Member 'UInventoryComponent::EmptySlotInfoMap' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemMap) == 0x0001A0, "Member 'UInventoryComponent::ItemMap' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ContainingItems) == 0x0001F0, "Member 'UInventoryComponent::ContainingItems' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, TotalGoldCount) == 0x000200, "Member 'UInventoryComponent::TotalGoldCount' has a wrong offset!");

// Class DungeonCrawler.DCLeaderboardRankDataAsset
// 0x0068 (0x00B0 - 0x0048)
class UDCLeaderboardRankDataAsset final : public UDCTableDataAsset
{
public:
	TSoftObjectPtr<class UDCLeaderboardRankGroupDataAsset> LeaderboardRankGroup;                              // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RankName;                                          // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         RankSubGrade;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A4[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCLeaderboardRankAPDataAsset>> LeaderboardRankAPs;                                // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCLeaderboardRankEFDataAsset>> LeaderboardRankEFs;                                // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardRankDataAsset">();
	}
	static class UDCLeaderboardRankDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardRankDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardRankDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardRankDataAsset");
static_assert(sizeof(UDCLeaderboardRankDataAsset) == 0x0000B0, "Wrong size on UDCLeaderboardRankDataAsset");
static_assert(offsetof(UDCLeaderboardRankDataAsset, LeaderboardRankGroup) == 0x000048, "Member 'UDCLeaderboardRankDataAsset::LeaderboardRankGroup' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankDataAsset, RankName) == 0x000070, "Member 'UDCLeaderboardRankDataAsset::RankName' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankDataAsset, RankSubGrade) == 0x000088, "Member 'UDCLeaderboardRankDataAsset::RankSubGrade' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankDataAsset, LeaderboardRankAPs) == 0x000090, "Member 'UDCLeaderboardRankDataAsset::LeaderboardRankAPs' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardRankDataAsset, LeaderboardRankEFs) == 0x0000A0, "Member 'UDCLeaderboardRankDataAsset::LeaderboardRankEFs' has a wrong offset!");

// Class DungeonCrawler.DCLeaderboardContentDataAsset
// 0x0060 (0x00A8 - 0x0048)
class UDCLeaderboardContentDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   ContentName;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ContentDesc;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ContentScoreName;                                  // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ELeaderboardContentType                       ContentType;                                       // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A5[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCMonsterDataAsset>> SlayerMonsterIds;                                  // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardContentDataAsset">();
	}
	static class UDCLeaderboardContentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardContentDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardContentDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardContentDataAsset");
static_assert(sizeof(UDCLeaderboardContentDataAsset) == 0x0000A8, "Wrong size on UDCLeaderboardContentDataAsset");
static_assert(offsetof(UDCLeaderboardContentDataAsset, ContentName) == 0x000048, "Member 'UDCLeaderboardContentDataAsset::ContentName' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardContentDataAsset, ContentDesc) == 0x000060, "Member 'UDCLeaderboardContentDataAsset::ContentDesc' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardContentDataAsset, ContentScoreName) == 0x000078, "Member 'UDCLeaderboardContentDataAsset::ContentScoreName' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardContentDataAsset, ContentType) == 0x000090, "Member 'UDCLeaderboardContentDataAsset::ContentType' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardContentDataAsset, SlayerMonsterIds) == 0x000098, "Member 'UDCLeaderboardContentDataAsset::SlayerMonsterIds' has a wrong offset!");

// Class DungeonCrawler.DCLeaderboardSheetDataAsset
// 0x0018 (0x0060 - 0x0048)
class UDCLeaderboardSheetDataAsset final : public UDCTableDataAsset
{
public:
	EGameType                                     GameType;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A6[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCLeaderboardContentDataAsset>> LeaderboardContents;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardSheetDataAsset">();
	}
	static class UDCLeaderboardSheetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardSheetDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardSheetDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardSheetDataAsset");
static_assert(sizeof(UDCLeaderboardSheetDataAsset) == 0x000060, "Wrong size on UDCLeaderboardSheetDataAsset");
static_assert(offsetof(UDCLeaderboardSheetDataAsset, GameType) == 0x000048, "Member 'UDCLeaderboardSheetDataAsset::GameType' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardSheetDataAsset, LeaderboardContents) == 0x000050, "Member 'UDCLeaderboardSheetDataAsset::LeaderboardContents' has a wrong offset!");

// Class DungeonCrawler.DCLeaderboardDataAsset
// 0x0040 (0x0088 - 0x0048)
class UDCLeaderboardDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   SeasonName;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCLeaderboardSheetDataAsset>> LeaderboardSheets;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCLeaderboardRankDataAsset>> LeaderboardRanks;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         LeaderBoardRankRewardIdx;                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const class UDCLeaderboardRankDataAsset* GetNextLeaderboardRankData(const class UDCLeaderboardRankDataAsset* InLeaderboardRankData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLeaderboardDataAsset">();
	}
	static class UDCLeaderboardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLeaderboardDataAsset>();
	}
};
static_assert(alignof(UDCLeaderboardDataAsset) == 0x000008, "Wrong alignment on UDCLeaderboardDataAsset");
static_assert(sizeof(UDCLeaderboardDataAsset) == 0x000088, "Wrong size on UDCLeaderboardDataAsset");
static_assert(offsetof(UDCLeaderboardDataAsset, SeasonName) == 0x000048, "Member 'UDCLeaderboardDataAsset::SeasonName' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardDataAsset, LeaderboardSheets) == 0x000060, "Member 'UDCLeaderboardDataAsset::LeaderboardSheets' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardDataAsset, LeaderboardRanks) == 0x000070, "Member 'UDCLeaderboardDataAsset::LeaderboardRanks' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardDataAsset, LeaderBoardRankRewardIdx) == 0x000080, "Member 'UDCLeaderboardDataAsset::LeaderBoardRankRewardIdx' has a wrong offset!");
static_assert(offsetof(UDCLeaderboardDataAsset, Order) == 0x000084, "Member 'UDCLeaderboardDataAsset::Order' has a wrong offset!");

// Class DungeonCrawler.FloorRuleInterface
// 0x0000 (0x0028 - 0x0028)
class IFloorRuleInterface final : public IInterface
{
public:
	void BindFloorRuleDataDelegate(TDelegate<void(struct FGameFloorRuleData& InFloorRuleData)> InBindDelegate);
	void BindFloorRuleFinishedDelegate(TDelegate<void()> InBindDelegate);
	void UnbindFloorRuleDataDelegate(class UObject* InBoundObject);

	struct FGameFloorRuleData GetFloorRuleData() const;
	void LogHandleFloorRuleData(const class UObject* InHandler, const struct FGameFloorRuleData& InFloorRuleData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorRuleInterface">();
	}
	static class IFloorRuleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFloorRuleInterface>();
	}
};
static_assert(alignof(IFloorRuleInterface) == 0x000008, "Wrong alignment on IFloorRuleInterface");
static_assert(sizeof(IFloorRuleInterface) == 0x000028, "Wrong size on IFloorRuleInterface");

// Class DungeonCrawler.DCLearningTokensWidgetBase
// 0x00D8 (0x03C0 - 0x02E8)
class UDCLearningTokensWidgetBase final : public UCommonUserWidget
{
public:
	int32                                         TokenCount;                                        // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A7[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NextTokenLevelText;                                // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanSelectMaster;                                  // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A8[0x7];                                     // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCountButtonWidget*                   RedeemButton;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRedeemLearningTokenCheckPopup> RedeemLearningTokenCheckPopupClass;                // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              CharacterTileView;                                 // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCTrainingCharacterInfo               SelectedTrainingCharacter;                         // 0x0328(0x0098)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnCharacterTileViewSelectionChanged(class UObject* Item);
	void OnClickRedeemButton();

	struct FNickname GetSelectedCharacterNickname() const;
	class FText GetSelectedClassText() const;
	bool IsMasterSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLearningTokensWidgetBase">();
	}
	static class UDCLearningTokensWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLearningTokensWidgetBase>();
	}
};
static_assert(alignof(UDCLearningTokensWidgetBase) == 0x000008, "Wrong alignment on UDCLearningTokensWidgetBase");
static_assert(sizeof(UDCLearningTokensWidgetBase) == 0x0003C0, "Wrong size on UDCLearningTokensWidgetBase");
static_assert(offsetof(UDCLearningTokensWidgetBase, TokenCount) == 0x0002E8, "Member 'UDCLearningTokensWidgetBase::TokenCount' has a wrong offset!");
static_assert(offsetof(UDCLearningTokensWidgetBase, NextTokenLevelText) == 0x0002F0, "Member 'UDCLearningTokensWidgetBase::NextTokenLevelText' has a wrong offset!");
static_assert(offsetof(UDCLearningTokensWidgetBase, bCanSelectMaster) == 0x000308, "Member 'UDCLearningTokensWidgetBase::bCanSelectMaster' has a wrong offset!");
static_assert(offsetof(UDCLearningTokensWidgetBase, RedeemButton) == 0x000310, "Member 'UDCLearningTokensWidgetBase::RedeemButton' has a wrong offset!");
static_assert(offsetof(UDCLearningTokensWidgetBase, RedeemLearningTokenCheckPopupClass) == 0x000318, "Member 'UDCLearningTokensWidgetBase::RedeemLearningTokenCheckPopupClass' has a wrong offset!");
static_assert(offsetof(UDCLearningTokensWidgetBase, CharacterTileView) == 0x000320, "Member 'UDCLearningTokensWidgetBase::CharacterTileView' has a wrong offset!");
static_assert(offsetof(UDCLearningTokensWidgetBase, SelectedTrainingCharacter) == 0x000328, "Member 'UDCLearningTokensWidgetBase::SelectedTrainingCharacter' has a wrong offset!");

// Class DungeonCrawler.VoipPartyMemberSettingWidgetData
// 0x0050 (0x0078 - 0x0028)
class UVoipPartyMemberSettingWidgetData final : public UObject
{
public:
	struct FVoipPartyMemberData                   VoipPartyMemberData;                               // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipPartyMemberSettingWidgetData">();
	}
	static class UVoipPartyMemberSettingWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipPartyMemberSettingWidgetData>();
	}
};
static_assert(alignof(UVoipPartyMemberSettingWidgetData) == 0x000008, "Wrong alignment on UVoipPartyMemberSettingWidgetData");
static_assert(sizeof(UVoipPartyMemberSettingWidgetData) == 0x000078, "Wrong size on UVoipPartyMemberSettingWidgetData");
static_assert(offsetof(UVoipPartyMemberSettingWidgetData, VoipPartyMemberData) == 0x000028, "Member 'UVoipPartyMemberSettingWidgetData::VoipPartyMemberData' has a wrong offset!");

// Class DungeonCrawler.DCLegendaryStatusPopupData
// 0x0000 (0x0030 - 0x0030)
class UDCLegendaryStatusPopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLegendaryStatusPopupData">();
	}
	static class UDCLegendaryStatusPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLegendaryStatusPopupData>();
	}
};
static_assert(alignof(UDCLegendaryStatusPopupData) == 0x000008, "Wrong alignment on UDCLegendaryStatusPopupData");
static_assert(sizeof(UDCLegendaryStatusPopupData) == 0x000030, "Wrong size on UDCLegendaryStatusPopupData");

// Class DungeonCrawler.DCLegendaryStatusPopup
// 0x0020 (0x04B0 - 0x0490)
class UDCLegendaryStatusPopup : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    ShopShortcutButton;                                // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CloseButton;                                       // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableUpgradeAccountStatus;                       // 0x04A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A9[0x7];                                     // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCLegendaryStatusPopupData*            LegendaryStatusPopupData;                          // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Close();
	void OnSetAccountStatus(const EDCAccountStatus& InAccountStatus);
	void OnSetAccountStatusUpgradeShopInfo(const struct FDCAccountStatusUpgradeShopInfo& InShopInfo);
	void OnSetContentsBlockHours(const EServicePolicyType InPolicyType, const int32 InBlockHours);
	void OnShopShortcutButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLegendaryStatusPopup">();
	}
	static class UDCLegendaryStatusPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLegendaryStatusPopup>();
	}
};
static_assert(alignof(UDCLegendaryStatusPopup) == 0x000008, "Wrong alignment on UDCLegendaryStatusPopup");
static_assert(sizeof(UDCLegendaryStatusPopup) == 0x0004B0, "Wrong size on UDCLegendaryStatusPopup");
static_assert(offsetof(UDCLegendaryStatusPopup, ShopShortcutButton) == 0x000490, "Member 'UDCLegendaryStatusPopup::ShopShortcutButton' has a wrong offset!");
static_assert(offsetof(UDCLegendaryStatusPopup, CloseButton) == 0x000498, "Member 'UDCLegendaryStatusPopup::CloseButton' has a wrong offset!");
static_assert(offsetof(UDCLegendaryStatusPopup, bEnableUpgradeAccountStatus) == 0x0004A0, "Member 'UDCLegendaryStatusPopup::bEnableUpgradeAccountStatus' has a wrong offset!");
static_assert(offsetof(UDCLegendaryStatusPopup, LegendaryStatusPopupData) == 0x0004A8, "Member 'UDCLegendaryStatusPopup::LegendaryStatusPopupData' has a wrong offset!");

// Class DungeonCrawler.DCLevelSequenceActor
// 0x0030 (0x0368 - 0x0338)
class ADCLevelSequenceActor final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_26AB[0x8];                                     // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PauseTag;                                          // 0x0348(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PlayTag;                                           // 0x0350(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PlayReverseTag;                                    // 0x0358(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayOnce;                                         // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AC[0x7];                                     // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessSequence(const struct FGameplayTag& InEventTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLevelSequenceActor">();
	}
	static class ADCLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLevelSequenceActor>();
	}
};
static_assert(alignof(ADCLevelSequenceActor) == 0x000008, "Wrong alignment on ADCLevelSequenceActor");
static_assert(sizeof(ADCLevelSequenceActor) == 0x000368, "Wrong size on ADCLevelSequenceActor");
static_assert(offsetof(ADCLevelSequenceActor, AbilitySystemComponent) == 0x000340, "Member 'ADCLevelSequenceActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ADCLevelSequenceActor, PauseTag) == 0x000348, "Member 'ADCLevelSequenceActor::PauseTag' has a wrong offset!");
static_assert(offsetof(ADCLevelSequenceActor, PlayTag) == 0x000350, "Member 'ADCLevelSequenceActor::PlayTag' has a wrong offset!");
static_assert(offsetof(ADCLevelSequenceActor, PlayReverseTag) == 0x000358, "Member 'ADCLevelSequenceActor::PlayReverseTag' has a wrong offset!");
static_assert(offsetof(ADCLevelSequenceActor, bPlayOnce) == 0x000360, "Member 'ADCLevelSequenceActor::bPlayOnce' has a wrong offset!");

// Class DungeonCrawler.GameActorStatusSlotWidget
// 0x0038 (0x0390 - 0x0358)
class UGameActorStatusSlotWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_26AD[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 TimeGauge;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameActorStatusSlotWidgetData         WidgetData;                                        // 0x0368(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AE[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorStatusData(const struct FActorStatusData& NewValue, const struct FActorStatusData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameActorStatusSlotWidget">();
	}
	static class UGameActorStatusSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameActorStatusSlotWidget>();
	}
};
static_assert(alignof(UGameActorStatusSlotWidget) == 0x000008, "Wrong alignment on UGameActorStatusSlotWidget");
static_assert(sizeof(UGameActorStatusSlotWidget) == 0x000390, "Wrong size on UGameActorStatusSlotWidget");
static_assert(offsetof(UGameActorStatusSlotWidget, TimeGauge) == 0x000360, "Member 'UGameActorStatusSlotWidget::TimeGauge' has a wrong offset!");
static_assert(offsetof(UGameActorStatusSlotWidget, WidgetData) == 0x000368, "Member 'UGameActorStatusSlotWidget::WidgetData' has a wrong offset!");

// Class DungeonCrawler.DCLightSourceComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDCLightSourceComponent final : public UDCActorComponent
{
public:
	TArray<class UPointLightComponent*>           PointLightComponentArray;                          // 0x00A0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              NiagaraComponentArray;                             // 0x00B0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLightSourceComponent">();
	}
	static class UDCLightSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLightSourceComponent>();
	}
};
static_assert(alignof(UDCLightSourceComponent) == 0x000008, "Wrong alignment on UDCLightSourceComponent");
static_assert(sizeof(UDCLightSourceComponent) == 0x0000C0, "Wrong size on UDCLightSourceComponent");
static_assert(offsetof(UDCLightSourceComponent, PointLightComponentArray) == 0x0000A0, "Member 'UDCLightSourceComponent::PointLightComponentArray' has a wrong offset!");
static_assert(offsetof(UDCLightSourceComponent, NiagaraComponentArray) == 0x0000B0, "Member 'UDCLightSourceComponent::NiagaraComponentArray' has a wrong offset!");

// Class DungeonCrawler.DCLoadingScreenWidget
// 0x0028 (0x02E8 - 0x02C0)
class UDCLoadingScreenWidget : public UUserWidget
{
public:
	TArray<struct FDungeonLoadingImageInfo>       DungeonLoadingImageInfoArray;                      // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           DescTextArray;                                     // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AF[0x8];                                     // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdated(class UTexture2D* InLoadingImage, const class FText& InDescText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLoadingScreenWidget">();
	}
	static class UDCLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLoadingScreenWidget>();
	}
};
static_assert(alignof(UDCLoadingScreenWidget) == 0x000008, "Wrong alignment on UDCLoadingScreenWidget");
static_assert(sizeof(UDCLoadingScreenWidget) == 0x0002E8, "Wrong size on UDCLoadingScreenWidget");
static_assert(offsetof(UDCLoadingScreenWidget, DungeonLoadingImageInfoArray) == 0x0002C0, "Member 'UDCLoadingScreenWidget::DungeonLoadingImageInfoArray' has a wrong offset!");
static_assert(offsetof(UDCLoadingScreenWidget, DescTextArray) == 0x0002D0, "Member 'UDCLoadingScreenWidget::DescTextArray' has a wrong offset!");

// Class DungeonCrawler.DCLoadoutPageWidget
// 0x0030 (0x04E8 - 0x04B8)
class UDCLoadoutPageWidget final : public ULobbyGroupWidgetBase
{
public:
	class UDCCharacterInventoryWidget*            CharacterInventoryWidget;                          // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventorySetWidget*                  InventorySetWidget;                                // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryStatusWidget*                 StatusWidget;                                      // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventorySkillListWidgetBase*          SkillsWidget;                                      // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCaptureStudioWidget*                 CaptureStudioWidget;                               // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetFame();
	int32 GetLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLoadoutPageWidget">();
	}
	static class UDCLoadoutPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLoadoutPageWidget>();
	}
};
static_assert(alignof(UDCLoadoutPageWidget) == 0x000008, "Wrong alignment on UDCLoadoutPageWidget");
static_assert(sizeof(UDCLoadoutPageWidget) == 0x0004E8, "Wrong size on UDCLoadoutPageWidget");
static_assert(offsetof(UDCLoadoutPageWidget, CharacterInventoryWidget) == 0x0004B8, "Member 'UDCLoadoutPageWidget::CharacterInventoryWidget' has a wrong offset!");
static_assert(offsetof(UDCLoadoutPageWidget, InventorySetWidget) == 0x0004C0, "Member 'UDCLoadoutPageWidget::InventorySetWidget' has a wrong offset!");
static_assert(offsetof(UDCLoadoutPageWidget, StatusWidget) == 0x0004C8, "Member 'UDCLoadoutPageWidget::StatusWidget' has a wrong offset!");
static_assert(offsetof(UDCLoadoutPageWidget, SkillsWidget) == 0x0004D0, "Member 'UDCLoadoutPageWidget::SkillsWidget' has a wrong offset!");
static_assert(offsetof(UDCLoadoutPageWidget, CaptureStudioWidget) == 0x0004D8, "Member 'UDCLoadoutPageWidget::CaptureStudioWidget' has a wrong offset!");
static_assert(offsetof(UDCLoadoutPageWidget, InventoryComponent) == 0x0004E0, "Member 'UDCLoadoutPageWidget::InventoryComponent' has a wrong offset!");

// Class DungeonCrawler.DCPurchaseConfirmPopupData
// 0x0020 (0x0050 - 0x0030)
class UDCPurchaseConfirmPopupData final : public UPopupDataBase
{
public:
	class FText                                   Message;                                           // 0x0030(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FDCPrice                               Price;                                             // 0x0048(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	const class FText GetMessage() const;
	const struct FDCPrice GetPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPurchaseConfirmPopupData">();
	}
	static class UDCPurchaseConfirmPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPurchaseConfirmPopupData>();
	}
};
static_assert(alignof(UDCPurchaseConfirmPopupData) == 0x000008, "Wrong alignment on UDCPurchaseConfirmPopupData");
static_assert(sizeof(UDCPurchaseConfirmPopupData) == 0x000050, "Wrong size on UDCPurchaseConfirmPopupData");
static_assert(offsetof(UDCPurchaseConfirmPopupData, Message) == 0x000030, "Member 'UDCPurchaseConfirmPopupData::Message' has a wrong offset!");
static_assert(offsetof(UDCPurchaseConfirmPopupData, Price) == 0x000048, "Member 'UDCPurchaseConfirmPopupData::Price' has a wrong offset!");

// Class DungeonCrawler.DCLobbyCaptureViewerActor
// 0x0210 (0x0508 - 0x02F8)
class ADCLobbyCaptureViewerActor final : public ADCActorBase
{
public:
	uint8                                         Pad_26B0[0x10];                                    // 0x02F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DefaultActorRotation;                              // 0x0308(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StartRotateLocation;                               // 0x0320(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B1[0x4];                                     // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        CharacterRootScene;                                // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CharacterMesh;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartHead;                                          // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartHelmet;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartGloves;                                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartChest;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartPants;                                         // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBoots;                                         // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBack;                                          // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterSkinComponent*              CharacterSkinComponent;                            // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemSkinComponent*                   ItemSkinComponent;                                 // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCArmorSkinComponent*                  ArmorSkinComponent;                                // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterDataComponent*              DataComponent;                                     // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCharacterPartsComponent*             PartsComponent;                                    // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSceneCaptureComponent2D*             SceneCapture2D;                                    // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B2[0xC8];                                    // 0x03A8(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLink*                           AccountLink;                                       // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26B3[0x10];                                    // 0x0478(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCItemId, class AItemActor*>     ContainingActorMap;                                // 0x0488(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_26B4[0x20];                                    // 0x04D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAkComponent*                         DCAKEmitter;                                       // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCAkComponent*                         DCAKListener;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitActorRotation();
	void SetActorRotation(float InYaw);
	void SetMeshRotationSpeedMultiplier(float Value);
	void SetStartRotateLocation(float InStartPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyCaptureViewerActor">();
	}
	static class ADCLobbyCaptureViewerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLobbyCaptureViewerActor>();
	}
};
static_assert(alignof(ADCLobbyCaptureViewerActor) == 0x000008, "Wrong alignment on ADCLobbyCaptureViewerActor");
static_assert(sizeof(ADCLobbyCaptureViewerActor) == 0x000508, "Wrong size on ADCLobbyCaptureViewerActor");
static_assert(offsetof(ADCLobbyCaptureViewerActor, DefaultActorRotation) == 0x000308, "Member 'ADCLobbyCaptureViewerActor::DefaultActorRotation' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, StartRotateLocation) == 0x000320, "Member 'ADCLobbyCaptureViewerActor::StartRotateLocation' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, AbilitySystemComponent) == 0x000328, "Member 'ADCLobbyCaptureViewerActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, CharacterRootScene) == 0x000330, "Member 'ADCLobbyCaptureViewerActor::CharacterRootScene' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, CharacterMesh) == 0x000338, "Member 'ADCLobbyCaptureViewerActor::CharacterMesh' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartHead) == 0x000340, "Member 'ADCLobbyCaptureViewerActor::PartHead' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartHelmet) == 0x000348, "Member 'ADCLobbyCaptureViewerActor::PartHelmet' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartGloves) == 0x000350, "Member 'ADCLobbyCaptureViewerActor::PartGloves' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartChest) == 0x000358, "Member 'ADCLobbyCaptureViewerActor::PartChest' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartPants) == 0x000360, "Member 'ADCLobbyCaptureViewerActor::PartPants' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartBoots) == 0x000368, "Member 'ADCLobbyCaptureViewerActor::PartBoots' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartBack) == 0x000370, "Member 'ADCLobbyCaptureViewerActor::PartBack' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, CharacterSkinComponent) == 0x000378, "Member 'ADCLobbyCaptureViewerActor::CharacterSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, ItemSkinComponent) == 0x000380, "Member 'ADCLobbyCaptureViewerActor::ItemSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, ArmorSkinComponent) == 0x000388, "Member 'ADCLobbyCaptureViewerActor::ArmorSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, DataComponent) == 0x000390, "Member 'ADCLobbyCaptureViewerActor::DataComponent' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, PartsComponent) == 0x000398, "Member 'ADCLobbyCaptureViewerActor::PartsComponent' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, SceneCapture2D) == 0x0003A0, "Member 'ADCLobbyCaptureViewerActor::SceneCapture2D' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, AccountLink) == 0x000470, "Member 'ADCLobbyCaptureViewerActor::AccountLink' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, ContainingActorMap) == 0x000488, "Member 'ADCLobbyCaptureViewerActor::ContainingActorMap' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, DCAKEmitter) == 0x0004F8, "Member 'ADCLobbyCaptureViewerActor::DCAKEmitter' has a wrong offset!");
static_assert(offsetof(ADCLobbyCaptureViewerActor, DCAKListener) == 0x000500, "Member 'ADCLobbyCaptureViewerActor::DCAKListener' has a wrong offset!");

// Class DungeonCrawler.DCLobbyCreateCharacter
// 0x0000 (0x0740 - 0x0740)
class ADCLobbyCreateCharacter : public ADCCharacterV2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyCreateCharacter">();
	}
	static class ADCLobbyCreateCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLobbyCreateCharacter>();
	}
};
static_assert(alignof(ADCLobbyCreateCharacter) == 0x000010, "Wrong alignment on ADCLobbyCreateCharacter");
static_assert(sizeof(ADCLobbyCreateCharacter) == 0x000740, "Wrong size on ADCLobbyCreateCharacter");

// Class DungeonCrawler.TradeChannelChatWidget
// 0x0208 (0x0738 - 0x0530)
class UTradeChannelChatWidget final : public UChatSetWidgetBase
{
public:
	class UDCCommonButtonBase*                    Btn_ReadRules;                                     // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatFilterWidget*                      TypeChatFilterWidget;                              // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatFilterWidget*                      IdTagChatFilterWidget;                             // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatFilterWidget*                      RarityChatFilterWidget;                            // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatFilterWidget*                      SlotChatFilterWidget;                              // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatFilterWidget*                      PropertyChatFilterWidget;                          // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatFilterWidget*                      CharacterTypeChatFilterWidget;                     // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTradeSubscriptionPopup>  TradersGuildRulesPopupClass;                       // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCChatRoomDataAsset*                   ChatRoomData;                                      // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ChannelName;                                       // 0x0578(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B5[0x10];                                    // 0x0590(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCMetaTradeComponent*                  MetaTradeComponent;                                // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26B6[0x190];                                   // 0x05A8(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddCharacterTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnAddIdTagChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnAddPropertyChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnAddRarityChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnAddSlotChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnAddTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnCharacterTypeChatFilterReset();
	void OnIdTagChatFilterReset();
	void OnPropertyChatFilterReset();
	void OnRarityChatFilterReset();
	void OnReadRulesButtonClicked();
	void OnRemoveCharacterTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnRemoveIdTagChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnRemovePropertyChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnRemoveRarityChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnRemoveSlotChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnRemoveTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag);
	void OnSlotChatFilterReset();
	void OnTypeChatFilterReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeChannelChatWidget">();
	}
	static class UTradeChannelChatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeChannelChatWidget>();
	}
};
static_assert(alignof(UTradeChannelChatWidget) == 0x000008, "Wrong alignment on UTradeChannelChatWidget");
static_assert(sizeof(UTradeChannelChatWidget) == 0x000738, "Wrong size on UTradeChannelChatWidget");
static_assert(offsetof(UTradeChannelChatWidget, Btn_ReadRules) == 0x000530, "Member 'UTradeChannelChatWidget::Btn_ReadRules' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, TypeChatFilterWidget) == 0x000538, "Member 'UTradeChannelChatWidget::TypeChatFilterWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, IdTagChatFilterWidget) == 0x000540, "Member 'UTradeChannelChatWidget::IdTagChatFilterWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, RarityChatFilterWidget) == 0x000548, "Member 'UTradeChannelChatWidget::RarityChatFilterWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, SlotChatFilterWidget) == 0x000550, "Member 'UTradeChannelChatWidget::SlotChatFilterWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, PropertyChatFilterWidget) == 0x000558, "Member 'UTradeChannelChatWidget::PropertyChatFilterWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, CharacterTypeChatFilterWidget) == 0x000560, "Member 'UTradeChannelChatWidget::CharacterTypeChatFilterWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, TradersGuildRulesPopupClass) == 0x000568, "Member 'UTradeChannelChatWidget::TradersGuildRulesPopupClass' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, ChatRoomData) == 0x000570, "Member 'UTradeChannelChatWidget::ChatRoomData' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, ChannelName) == 0x000578, "Member 'UTradeChannelChatWidget::ChannelName' has a wrong offset!");
static_assert(offsetof(UTradeChannelChatWidget, MetaTradeComponent) == 0x0005A0, "Member 'UTradeChannelChatWidget::MetaTradeComponent' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteArtData
// 0x0008 (0x0050 - 0x0048)
class UDCLobbyEmoteArtData final : public UArtDataBase
{
public:
	class UTexture2D*                             LobbyEmoteIconTexture;                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteArtData">();
	}
	static class UDCLobbyEmoteArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteArtData>();
	}
};
static_assert(alignof(UDCLobbyEmoteArtData) == 0x000008, "Wrong alignment on UDCLobbyEmoteArtData");
static_assert(sizeof(UDCLobbyEmoteArtData) == 0x000050, "Wrong size on UDCLobbyEmoteArtData");
static_assert(offsetof(UDCLobbyEmoteArtData, LobbyEmoteIconTexture) == 0x000048, "Member 'UDCLobbyEmoteArtData::LobbyEmoteIconTexture' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteComponent
// 0x0098 (0x0138 - 0x00A0)
class UDCLobbyEmoteComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_26B7[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCLobbyEmoteSlotInfo>          LobbyEmoteSlotInfoArray;                           // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FPrimaryAssetId>           LobbyEmoteSlotMap;                                 // 0x00C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     OwnerGameplayAbilitySpecHandles;                   // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    OwnerGameplayEffectHandles;                        // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteComponent">();
	}
	static class UDCLobbyEmoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteComponent>();
	}
};
static_assert(alignof(UDCLobbyEmoteComponent) == 0x000008, "Wrong alignment on UDCLobbyEmoteComponent");
static_assert(sizeof(UDCLobbyEmoteComponent) == 0x000138, "Wrong size on UDCLobbyEmoteComponent");
static_assert(offsetof(UDCLobbyEmoteComponent, LobbyEmoteSlotInfoArray) == 0x0000B8, "Member 'UDCLobbyEmoteComponent::LobbyEmoteSlotInfoArray' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteComponent, LobbyEmoteSlotMap) == 0x0000C8, "Member 'UDCLobbyEmoteComponent::LobbyEmoteSlotMap' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteComponent, OwnerGameplayAbilitySpecHandles) == 0x000118, "Member 'UDCLobbyEmoteComponent::OwnerGameplayAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteComponent, OwnerGameplayEffectHandles) == 0x000128, "Member 'UDCLobbyEmoteComponent::OwnerGameplayEffectHandles' has a wrong offset!");

// Class DungeonCrawler.DCQuestChapterListWidget
// 0x0008 (0x0360 - 0x0358)
class UDCQuestChapterListWidget final : public UDCWidgetBase
{
public:
	class UCommonListView*                        QuestChapterListView;                              // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestChapterListWidget">();
	}
	static class UDCQuestChapterListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestChapterListWidget>();
	}
};
static_assert(alignof(UDCQuestChapterListWidget) == 0x000008, "Wrong alignment on UDCQuestChapterListWidget");
static_assert(sizeof(UDCQuestChapterListWidget) == 0x000360, "Wrong size on UDCQuestChapterListWidget");
static_assert(offsetof(UDCQuestChapterListWidget, QuestChapterListView) == 0x000358, "Member 'UDCQuestChapterListWidget::QuestChapterListView' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteDataAsset
// 0x0080 (0x00C8 - 0x0048)
class UDCLobbyEmoteDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCLobbyEmoteDataAsset;                        // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LobbyEmoteTag;                                     // 0x0078(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCLobbyEmoteArtData>    ArtData;                                           // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteDataAsset">();
	}
	static class UDCLobbyEmoteDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteDataAsset>();
	}
};
static_assert(alignof(UDCLobbyEmoteDataAsset) == 0x000008, "Wrong alignment on UDCLobbyEmoteDataAsset");
static_assert(sizeof(UDCLobbyEmoteDataAsset) == 0x0000C8, "Wrong size on UDCLobbyEmoteDataAsset");
static_assert(offsetof(UDCLobbyEmoteDataAsset, Name_DCLobbyEmoteDataAsset) == 0x000048, "Member 'UDCLobbyEmoteDataAsset::Name_DCLobbyEmoteDataAsset' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteDataAsset, FlavorText) == 0x000060, "Member 'UDCLobbyEmoteDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteDataAsset, LobbyEmoteTag) == 0x000078, "Member 'UDCLobbyEmoteDataAsset::LobbyEmoteTag' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteDataAsset, ArtData) == 0x000080, "Member 'UDCLobbyEmoteDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteDataAsset, Abilities) == 0x0000A8, "Member 'UDCLobbyEmoteDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteDataAsset, Effects) == 0x0000B8, "Member 'UDCLobbyEmoteDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteGroupWidgetBase
// 0x0088 (0x0540 - 0x04B8)
class UDCLobbyEmoteGroupWidgetBase final : public ULobbyGroupWidgetBase
{
public:
	uint8                                         Pad_26B8[0x10];                                    // 0x04B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCCharacterLobbyCapture*               CharacterLobbyCapture;                             // 0x04C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectedEmoteIndex;                                // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B9[0x4];                                     // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_1;                                  // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_2;                                  // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_3;                                  // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_4;                                  // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_5;                                  // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_6;                                  // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_7;                                  // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLobbyEmoteSlotWidget*                LobbyEmoteSlot_8;                                  // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LobbyEmoteNameText;                                // 0x0518(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCLobbyEmoteSlotWidget*>        LobbyEmoteSlots;                                   // 0x0530(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	ESlateVisibility GetVisibilityBySelectedEmote();
	void OnEmoteSelectClose();
	void OnEmoteSelectPopup();
	void OnSelectedEmoteIndexChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteGroupWidgetBase">();
	}
	static class UDCLobbyEmoteGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteGroupWidgetBase>();
	}
};
static_assert(alignof(UDCLobbyEmoteGroupWidgetBase) == 0x000008, "Wrong alignment on UDCLobbyEmoteGroupWidgetBase");
static_assert(sizeof(UDCLobbyEmoteGroupWidgetBase) == 0x000540, "Wrong size on UDCLobbyEmoteGroupWidgetBase");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, CharacterLobbyCapture) == 0x0004C8, "Member 'UDCLobbyEmoteGroupWidgetBase::CharacterLobbyCapture' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, SelectedEmoteIndex) == 0x0004D0, "Member 'UDCLobbyEmoteGroupWidgetBase::SelectedEmoteIndex' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_1) == 0x0004D8, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_1' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_2) == 0x0004E0, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_2' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_3) == 0x0004E8, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_3' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_4) == 0x0004F0, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_4' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_5) == 0x0004F8, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_5' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_6) == 0x000500, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_6' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_7) == 0x000508, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_7' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlot_8) == 0x000510, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlot_8' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteNameText) == 0x000518, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteNameText' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteGroupWidgetBase, LobbyEmoteSlots) == 0x000530, "Member 'UDCLobbyEmoteGroupWidgetBase::LobbyEmoteSlots' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteListEntryWidgetData
// 0x0018 (0x0040 - 0x0028)
class UDCLobbyEmoteListEntryWidgetData final : public UObject
{
public:
	struct FDCLobbyEmoteInfo                      LobbyEmoteInfo;                                    // 0x0028(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BA[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteListEntryWidgetData">();
	}
	static class UDCLobbyEmoteListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteListEntryWidgetData>();
	}
};
static_assert(alignof(UDCLobbyEmoteListEntryWidgetData) == 0x000008, "Wrong alignment on UDCLobbyEmoteListEntryWidgetData");
static_assert(sizeof(UDCLobbyEmoteListEntryWidgetData) == 0x000040, "Wrong size on UDCLobbyEmoteListEntryWidgetData");
static_assert(offsetof(UDCLobbyEmoteListEntryWidgetData, LobbyEmoteInfo) == 0x000028, "Member 'UDCLobbyEmoteListEntryWidgetData::LobbyEmoteInfo' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteListEntryWidgetData, bIsSelected) == 0x000038, "Member 'UDCLobbyEmoteListEntryWidgetData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteWidget
// 0x0080 (0x0510 - 0x0490)
class UDCLobbyEmoteWidget : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_26BB[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LobbyEmoteName;                                    // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   LobbyEmoteFlavorText;                              // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             LobbyEmoteIconTexture;                             // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        LobbyEmoteId;                                      // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26BC[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCGameTooltipWithFlavorTextWidget*     EmoteTooltipWidget;                                // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCCustomizeDragVisualWidget> LobbyEmoteDragVisualWidgetClass;                   // 0x0508(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UUserWidget* GetTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteWidget">();
	}
	static class UDCLobbyEmoteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteWidget>();
	}
};
static_assert(alignof(UDCLobbyEmoteWidget) == 0x000008, "Wrong alignment on UDCLobbyEmoteWidget");
static_assert(sizeof(UDCLobbyEmoteWidget) == 0x000510, "Wrong size on UDCLobbyEmoteWidget");
static_assert(offsetof(UDCLobbyEmoteWidget, LobbyEmoteName) == 0x0004A8, "Member 'UDCLobbyEmoteWidget::LobbyEmoteName' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, LobbyEmoteFlavorText) == 0x0004C0, "Member 'UDCLobbyEmoteWidget::LobbyEmoteFlavorText' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, LobbyEmoteIconTexture) == 0x0004D8, "Member 'UDCLobbyEmoteWidget::LobbyEmoteIconTexture' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, LobbyEmoteId) == 0x0004E0, "Member 'UDCLobbyEmoteWidget::LobbyEmoteId' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, bIsEquipped) == 0x0004F0, "Member 'UDCLobbyEmoteWidget::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, TooltipWidgetClass) == 0x0004F8, "Member 'UDCLobbyEmoteWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, EmoteTooltipWidget) == 0x000500, "Member 'UDCLobbyEmoteWidget::EmoteTooltipWidget' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteWidget, LobbyEmoteDragVisualWidgetClass) == 0x000508, "Member 'UDCLobbyEmoteWidget::LobbyEmoteDragVisualWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCQuestContentEscapeDataAsset
// 0x0008 (0x0068 - 0x0060)
class UDCQuestContentEscapeDataAsset final : public UDCQuestContentDataAsset
{
public:
	bool                                          ConsecutiveEscape;                                 // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoDamage;                                          // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x0062(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BD[0x1];                                     // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentEscapeDataAsset">();
	}
	static class UDCQuestContentEscapeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentEscapeDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentEscapeDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentEscapeDataAsset");
static_assert(sizeof(UDCQuestContentEscapeDataAsset) == 0x000068, "Wrong size on UDCQuestContentEscapeDataAsset");
static_assert(offsetof(UDCQuestContentEscapeDataAsset, ConsecutiveEscape) == 0x000060, "Member 'UDCQuestContentEscapeDataAsset::ConsecutiveEscape' has a wrong offset!");
static_assert(offsetof(UDCQuestContentEscapeDataAsset, NoDamage) == 0x000061, "Member 'UDCQuestContentEscapeDataAsset::NoDamage' has a wrong offset!");
static_assert(offsetof(UDCQuestContentEscapeDataAsset, HealthRequirementType) == 0x000062, "Member 'UDCQuestContentEscapeDataAsset::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentEscapeDataAsset, HealthRequirementRatio) == 0x000064, "Member 'UDCQuestContentEscapeDataAsset::HealthRequirementRatio' has a wrong offset!");

// Class DungeonCrawler.DCLobbyEmoteListEntryWidget
// 0x0010 (0x0520 - 0x0510)
class UDCLobbyEmoteListEntryWidget final : public UDCLobbyEmoteWidget
{
public:
	uint8                                         Pad_26BE[0x10];                                    // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESlateVisibility GetSelectedVisibility();
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteListEntryWidget">();
	}
	static class UDCLobbyEmoteListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteListEntryWidget>();
	}
};
static_assert(alignof(UDCLobbyEmoteListEntryWidget) == 0x000008, "Wrong alignment on UDCLobbyEmoteListEntryWidget");
static_assert(sizeof(UDCLobbyEmoteListEntryWidget) == 0x000520, "Wrong size on UDCLobbyEmoteListEntryWidget");

// Class DungeonCrawler.DCLobbyEmoteSlotWidget
// 0x0030 (0x0388 - 0x0358)
class UDCLobbyEmoteSlotWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_26BF[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LobbyEmoteName;                                    // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             LobbyEmoteIconTexture;                             // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C0[0x8];                                     // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESlateVisibility GetLobbyEmoteIconVisibility();
	void OnSelectionChanged(bool bIsSelected);
	void Reset();
	void SelectionChange(bool bIsSelected);
	void SetLobbyEmoteData(const class UDCLobbyEmoteDataAsset* InDesignDataLobbyEmote);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyEmoteSlotWidget">();
	}
	static class UDCLobbyEmoteSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyEmoteSlotWidget>();
	}
};
static_assert(alignof(UDCLobbyEmoteSlotWidget) == 0x000008, "Wrong alignment on UDCLobbyEmoteSlotWidget");
static_assert(sizeof(UDCLobbyEmoteSlotWidget) == 0x000388, "Wrong size on UDCLobbyEmoteSlotWidget");
static_assert(offsetof(UDCLobbyEmoteSlotWidget, LobbyEmoteName) == 0x000360, "Member 'UDCLobbyEmoteSlotWidget::LobbyEmoteName' has a wrong offset!");
static_assert(offsetof(UDCLobbyEmoteSlotWidget, LobbyEmoteIconTexture) == 0x000378, "Member 'UDCLobbyEmoteSlotWidget::LobbyEmoteIconTexture' has a wrong offset!");

// Class DungeonCrawler.DCMetaGameMode
// 0x0000 (0x03A8 - 0x03A8)
class ADCMetaGameMode : public ADCGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaGameMode">();
	}
	static class ADCMetaGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCMetaGameMode>();
	}
};
static_assert(alignof(ADCMetaGameMode) == 0x000008, "Wrong alignment on ADCMetaGameMode");
static_assert(sizeof(ADCMetaGameMode) == 0x0003A8, "Wrong size on ADCMetaGameMode");

// Class DungeonCrawler.DCLobbyGameMode
// 0x0018 (0x03C0 - 0x03A8)
class ADCLobbyGameMode final : public ADCMetaGameMode
{
public:
	uint8                                         Pad_26C1[0x18];                                    // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyGameMode">();
	}
	static class ADCLobbyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLobbyGameMode>();
	}
};
static_assert(alignof(ADCLobbyGameMode) == 0x000008, "Wrong alignment on ADCLobbyGameMode");
static_assert(sizeof(ADCLobbyGameMode) == 0x0003C0, "Wrong size on ADCLobbyGameMode");

// Class DungeonCrawler.DCQuestContentPropsDataAsset
// 0x0030 (0x0090 - 0x0060)
class UDCQuestContentPropsDataAsset final : public UDCQuestContentDataAsset
{
public:
	EDCQuestContentPropsType                      PropsType;                                         // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C2[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PropsIdTag;                                        // 0x0064(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x006C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SingleSession;                                     // 0x0074(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0075(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x0076(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C3[0x1];                                     // 0x0077(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C4[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTagQueryData>>   TagQueryData;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentPropsDataAsset">();
	}
	static class UDCQuestContentPropsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentPropsDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentPropsDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentPropsDataAsset");
static_assert(sizeof(UDCQuestContentPropsDataAsset) == 0x000090, "Wrong size on UDCQuestContentPropsDataAsset");
static_assert(offsetof(UDCQuestContentPropsDataAsset, PropsType) == 0x000060, "Member 'UDCQuestContentPropsDataAsset::PropsType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, PropsIdTag) == 0x000064, "Member 'UDCQuestContentPropsDataAsset::PropsIdTag' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, GradeType) == 0x00006C, "Member 'UDCQuestContentPropsDataAsset::GradeType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, SingleSession) == 0x000074, "Member 'UDCQuestContentPropsDataAsset::SingleSession' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, MustEscape) == 0x000075, "Member 'UDCQuestContentPropsDataAsset::MustEscape' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, HealthRequirementType) == 0x000076, "Member 'UDCQuestContentPropsDataAsset::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, HealthRequirementRatio) == 0x000078, "Member 'UDCQuestContentPropsDataAsset::HealthRequirementRatio' has a wrong offset!");
static_assert(offsetof(UDCQuestContentPropsDataAsset, TagQueryData) == 0x000080, "Member 'UDCQuestContentPropsDataAsset::TagQueryData' has a wrong offset!");

// Class DungeonCrawler.DCLobbyGameState
// 0x0000 (0x07B0 - 0x07B0)
class ADCLobbyGameState final : public ADCGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyGameState">();
	}
	static class ADCLobbyGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLobbyGameState>();
	}
};
static_assert(alignof(ADCLobbyGameState) == 0x000008, "Wrong alignment on ADCLobbyGameState");
static_assert(sizeof(ADCLobbyGameState) == 0x0007B0, "Wrong size on ADCLobbyGameState");

// Class DungeonCrawler.DCLobbyHUD
// 0x00B0 (0x0448 - 0x0398)
class ADCLobbyHUD final : public ADCHUD
{
public:
	TMap<EDCCaptureStudioType, TSubclassOf<class ADCCaptureStudioActor>> CaptureStudioActorClasses;                         // 0x0398(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EDCCaptureStudioType, class ADCCaptureStudioActor*> CaptureStudioActors;                               // 0x03E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADCItemSkinViewerActor>     ItemSkinViewerActorClass;                          // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCItemSkinViewerActor*                 ItemSkinViewerActor;                               // 0x0440(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyHUD">();
	}
	static class ADCLobbyHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLobbyHUD>();
	}
};
static_assert(alignof(ADCLobbyHUD) == 0x000008, "Wrong alignment on ADCLobbyHUD");
static_assert(sizeof(ADCLobbyHUD) == 0x000448, "Wrong size on ADCLobbyHUD");
static_assert(offsetof(ADCLobbyHUD, CaptureStudioActorClasses) == 0x000398, "Member 'ADCLobbyHUD::CaptureStudioActorClasses' has a wrong offset!");
static_assert(offsetof(ADCLobbyHUD, CaptureStudioActors) == 0x0003E8, "Member 'ADCLobbyHUD::CaptureStudioActors' has a wrong offset!");
static_assert(offsetof(ADCLobbyHUD, ItemSkinViewerActorClass) == 0x000438, "Member 'ADCLobbyHUD::ItemSkinViewerActorClass' has a wrong offset!");
static_assert(offsetof(ADCLobbyHUD, ItemSkinViewerActor) == 0x000440, "Member 'ADCLobbyHUD::ItemSkinViewerActor' has a wrong offset!");

// Class DungeonCrawler.DCLobbyTabButton
// 0x0000 (0x1660 - 0x1660)
class UDCLobbyTabButton final : public UDCCommonButtonBase
{
public:
	bool                                          bShowNewIndicator;                                 // 0x1658(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowCheckIndicator;                               // 0x1659(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCWidgetLobbyTabType                         TabType;                                           // 0x165A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C5[0x5];                                     // 0x165B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTabType(EDCWidgetLobbyTabType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLobbyTabButton">();
	}
	static class UDCLobbyTabButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLobbyTabButton>();
	}
};
static_assert(alignof(UDCLobbyTabButton) == 0x000010, "Wrong alignment on UDCLobbyTabButton");
static_assert(sizeof(UDCLobbyTabButton) == 0x001660, "Wrong size on UDCLobbyTabButton");
static_assert(offsetof(UDCLobbyTabButton, bShowNewIndicator) == 0x001658, "Member 'UDCLobbyTabButton::bShowNewIndicator' has a wrong offset!");
static_assert(offsetof(UDCLobbyTabButton, bShowCheckIndicator) == 0x001659, "Member 'UDCLobbyTabButton::bShowCheckIndicator' has a wrong offset!");
static_assert(offsetof(UDCLobbyTabButton, TabType) == 0x00165A, "Member 'UDCLobbyTabButton::TabType' has a wrong offset!");

// Class DungeonCrawler.DCLocalLoginSaveGame
// 0x0020 (0x0048 - 0x0028)
class UDCLocalLoginSaveGame final : public USaveGame
{
public:
	class FString                                 IpAddress;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Nickname;                                          // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLocalLoginSaveGame">();
	}
	static class UDCLocalLoginSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLocalLoginSaveGame>();
	}
};
static_assert(alignof(UDCLocalLoginSaveGame) == 0x000008, "Wrong alignment on UDCLocalLoginSaveGame");
static_assert(sizeof(UDCLocalLoginSaveGame) == 0x000048, "Wrong size on UDCLocalLoginSaveGame");
static_assert(offsetof(UDCLocalLoginSaveGame, IpAddress) == 0x000028, "Member 'UDCLocalLoginSaveGame::IpAddress' has a wrong offset!");
static_assert(offsetof(UDCLocalLoginSaveGame, Nickname) == 0x000038, "Member 'UDCLocalLoginSaveGame::Nickname' has a wrong offset!");

// Class DungeonCrawler.DCReportPlayerHighRollerWidget
// 0x0080 (0x0340 - 0x02C0)
class UDCReportPlayerHighRollerWidget final : public UUserWidget
{
public:
	class UMultiLineEditableTextBox*              ReportEditableMultiTextBox;                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UComboBoxWidget*                        PlayerListComboBox;                                // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ReportCategoryCheckList;                           // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ReportHintText;                                    // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReportTextMaxCountText;                            // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReportTextCurrentCountText;                        // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCReportPlayerChecklistSlotWidget> ReportPlayerChecklistWidgetClass;                  // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C6[0x18];                                    // 0x0328(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanReport();
	void HandleCheckStatedChanged(EDCReportPlayerCategory InCategory, bool InbNewChecked);
	void OnCancelClicked();
	void OnPlayerListComboBoxItemSelected(class UObject* Item);
	void OnReportClicked();
	void OnSelectionChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerHighRollerWidget">();
	}
	static class UDCReportPlayerHighRollerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerHighRollerWidget>();
	}
};
static_assert(alignof(UDCReportPlayerHighRollerWidget) == 0x000008, "Wrong alignment on UDCReportPlayerHighRollerWidget");
static_assert(sizeof(UDCReportPlayerHighRollerWidget) == 0x000340, "Wrong size on UDCReportPlayerHighRollerWidget");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, ReportEditableMultiTextBox) == 0x0002C0, "Member 'UDCReportPlayerHighRollerWidget::ReportEditableMultiTextBox' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, PlayerListComboBox) == 0x0002C8, "Member 'UDCReportPlayerHighRollerWidget::PlayerListComboBox' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, ReportCategoryCheckList) == 0x0002D0, "Member 'UDCReportPlayerHighRollerWidget::ReportCategoryCheckList' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, ReportHintText) == 0x0002D8, "Member 'UDCReportPlayerHighRollerWidget::ReportHintText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, ReportTextMaxCountText) == 0x0002F0, "Member 'UDCReportPlayerHighRollerWidget::ReportTextMaxCountText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, ReportTextCurrentCountText) == 0x000308, "Member 'UDCReportPlayerHighRollerWidget::ReportTextCurrentCountText' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerHighRollerWidget, ReportPlayerChecklistWidgetClass) == 0x000320, "Member 'UDCReportPlayerHighRollerWidget::ReportPlayerChecklistWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCLocalLoginGameMode
// 0x0000 (0x0338 - 0x0338)
class ADCLocalLoginGameMode final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLocalLoginGameMode">();
	}
	static class ADCLocalLoginGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLocalLoginGameMode>();
	}
};
static_assert(alignof(ADCLocalLoginGameMode) == 0x000008, "Wrong alignment on ADCLocalLoginGameMode");
static_assert(sizeof(ADCLocalLoginGameMode) == 0x000338, "Wrong size on ADCLocalLoginGameMode");

// Class DungeonCrawler.DCLocalLoginWidget
// 0x0000 (0x02C0 - 0x02C0)
class UDCLocalLoginWidget final : public UUserWidget
{
public:
	void OnLoginButtonClicked(const class FString& IpAddress, const class FString& Nickname);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLocalLoginWidget">();
	}
	static class UDCLocalLoginWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLocalLoginWidget>();
	}
};
static_assert(alignof(UDCLocalLoginWidget) == 0x000008, "Wrong alignment on UDCLocalLoginWidget");
static_assert(sizeof(UDCLocalLoginWidget) == 0x0002C0, "Wrong size on UDCLocalLoginWidget");

// Class DungeonCrawler.DCLogEventManager
// 0x00B0 (0x00E0 - 0x0030)
class UDCLogEventManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_26C7[0xB0];                                    // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLogEventManager">();
	}
	static class UDCLogEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLogEventManager>();
	}
};
static_assert(alignof(UDCLogEventManager) == 0x000008, "Wrong alignment on UDCLogEventManager");
static_assert(sizeof(UDCLogEventManager) == 0x0000E0, "Wrong size on UDCLogEventManager");

// Class DungeonCrawler.DCLoginGameMode
// 0x0088 (0x0430 - 0x03A8)
class ADCLoginGameMode final : public ADCGameModeBase
{
public:
	uint8                                         Pad_26C8[0x80];                                    // 0x03A8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCCommonActivatableWidgetBase> SecretTokenPopupWidgetClass;                       // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLoginGameMode">();
	}
	static class ADCLoginGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCLoginGameMode>();
	}
};
static_assert(alignof(ADCLoginGameMode) == 0x000008, "Wrong alignment on ADCLoginGameMode");
static_assert(sizeof(ADCLoginGameMode) == 0x000430, "Wrong size on ADCLoginGameMode");
static_assert(offsetof(ADCLoginGameMode, SecretTokenPopupWidgetClass) == 0x000428, "Member 'ADCLoginGameMode::SecretTokenPopupWidgetClass' has a wrong offset!");

// Class DungeonCrawler.DCReportTicketButtonWidget
// 0x0000 (0x0358 - 0x0358)
class UDCReportTicketButtonWidget final : public UDCWidgetBase
{
public:
	void OnClickReportButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportTicketButtonWidget">();
	}
	static class UDCReportTicketButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportTicketButtonWidget>();
	}
};
static_assert(alignof(UDCReportTicketButtonWidget) == 0x000008, "Wrong alignment on UDCReportTicketButtonWidget");
static_assert(sizeof(UDCReportTicketButtonWidget) == 0x000358, "Wrong size on UDCReportTicketButtonWidget");

// Class DungeonCrawler.VoipPartySettingWidget
// 0x0010 (0x0368 - 0x0358)
class UVoipPartySettingWidget : public UDCWidgetBase
{
public:
	class UListView*                              PartyMemberSettingListView;                        // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C9[0x8];                                     // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnbVoipGlobal(bool NewValue, bool OldValue);
	void OnVoipGlobalSet(bool InbVoipGlobal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipPartySettingWidget">();
	}
	static class UVoipPartySettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipPartySettingWidget>();
	}
};
static_assert(alignof(UVoipPartySettingWidget) == 0x000008, "Wrong alignment on UVoipPartySettingWidget");
static_assert(sizeof(UVoipPartySettingWidget) == 0x000368, "Wrong size on UVoipPartySettingWidget");
static_assert(offsetof(UVoipPartySettingWidget, PartyMemberSettingListView) == 0x000358, "Member 'UVoipPartySettingWidget::PartyMemberSettingListView' has a wrong offset!");

// Class DungeonCrawler.DCLootAbilityV2
// 0x0100 (0x06A0 - 0x05A0)
class UDCLootAbilityV2 : public UDCGameplayAbilityBase
{
public:
	float                                         AllowDistanceThreshold;                            // 0x05A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26CA[0x4];                                     // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCLootComponent*                       LootComp;                                          // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             HitResult;                                         // 0x05B0(0x00E8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AActor*                                 LootTargetActor;                                   // 0x0698(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOufOfRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLootAbilityV2">();
	}
	static class UDCLootAbilityV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLootAbilityV2>();
	}
};
static_assert(alignof(UDCLootAbilityV2) == 0x000008, "Wrong alignment on UDCLootAbilityV2");
static_assert(sizeof(UDCLootAbilityV2) == 0x0006A0, "Wrong size on UDCLootAbilityV2");
static_assert(offsetof(UDCLootAbilityV2, AllowDistanceThreshold) == 0x0005A0, "Member 'UDCLootAbilityV2::AllowDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UDCLootAbilityV2, LootComp) == 0x0005A8, "Member 'UDCLootAbilityV2::LootComp' has a wrong offset!");
static_assert(offsetof(UDCLootAbilityV2, HitResult) == 0x0005B0, "Member 'UDCLootAbilityV2::HitResult' has a wrong offset!");
static_assert(offsetof(UDCLootAbilityV2, LootTargetActor) == 0x000698, "Member 'UDCLootAbilityV2::LootTargetActor' has a wrong offset!");

// Class DungeonCrawler.DCLootComponent
// 0x0090 (0x0130 - 0x00A0)
class UDCLootComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_26CB[0x78];                                    // 0x00A0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	EDCLootTargetType                             LootType;                                          // 0x0118(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26CC[0x7];                                     // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0120(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        TargetChestClone;                                  // 0x0128(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool ClearLootTarget();
	void ClearLootTarget_Server();
	void OnRep_TargetActor(class AActor* OldTargetActor);
	bool SetLootTarget(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLootComponent">();
	}
	static class UDCLootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLootComponent>();
	}
};
static_assert(alignof(UDCLootComponent) == 0x000008, "Wrong alignment on UDCLootComponent");
static_assert(sizeof(UDCLootComponent) == 0x000130, "Wrong size on UDCLootComponent");
static_assert(offsetof(UDCLootComponent, LootType) == 0x000118, "Member 'UDCLootComponent::LootType' has a wrong offset!");
static_assert(offsetof(UDCLootComponent, TargetActor) == 0x000120, "Member 'UDCLootComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(UDCLootComponent, TargetChestClone) == 0x000128, "Member 'UDCLootComponent::TargetChestClone' has a wrong offset!");

// Class DungeonCrawler.DCLootDropDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCLootDropDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCLootDropItemData>            LootDropItemArray;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLootDropDataAsset">();
	}
	static class UDCLootDropDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLootDropDataAsset>();
	}
};
static_assert(alignof(UDCLootDropDataAsset) == 0x000008, "Wrong alignment on UDCLootDropDataAsset");
static_assert(sizeof(UDCLootDropDataAsset) == 0x000058, "Wrong size on UDCLootDropDataAsset");
static_assert(offsetof(UDCLootDropDataAsset, LootDropItemArray) == 0x000048, "Member 'UDCLootDropDataAsset::LootDropItemArray' has a wrong offset!");

// Class DungeonCrawler.DCLootDropRateDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCLootDropRateDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCLootDropRateItemData>        LootDropRateItemArray;                             // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLootDropRateDataAsset">();
	}
	static class UDCLootDropRateDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLootDropRateDataAsset>();
	}
};
static_assert(alignof(UDCLootDropRateDataAsset) == 0x000008, "Wrong alignment on UDCLootDropRateDataAsset");
static_assert(sizeof(UDCLootDropRateDataAsset) == 0x000058, "Wrong size on UDCLootDropRateDataAsset");
static_assert(offsetof(UDCLootDropRateDataAsset, LootDropRateItemArray) == 0x000048, "Member 'UDCLootDropRateDataAsset::LootDropRateItemArray' has a wrong offset!");

// Class DungeonCrawler.DCLootDropGroupDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCLootDropGroupDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCLootDropGroupItemData>       LootDropGroupItemArray;                            // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCLootDropGroupDataAsset">();
	}
	static class UDCLootDropGroupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCLootDropGroupDataAsset>();
	}
};
static_assert(alignof(UDCLootDropGroupDataAsset) == 0x000008, "Wrong alignment on UDCLootDropGroupDataAsset");
static_assert(sizeof(UDCLootDropGroupDataAsset) == 0x000058, "Wrong size on UDCLootDropGroupDataAsset");
static_assert(offsetof(UDCLootDropGroupDataAsset, LootDropGroupItemArray) == 0x000048, "Member 'UDCLootDropGroupDataAsset::LootDropGroupItemArray' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceButtonBase
// 0x0010 (0x1670 - 0x1660)
class UDCMarketplaceButtonBase final : public UDCCommonButtonBase
{
public:
	bool                                          bShowIndicator;                                    // 0x1658(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26CE[0x7];                                     // 0x1659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCMarketplacePaymentItemInfo>  PaymentInfos;                                      // 0x1660(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnMarketplaceButtonClicked();
	void OnMarketplaceEnterSucceed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceButtonBase">();
	}
	static class UDCMarketplaceButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceButtonBase>();
	}
};
static_assert(alignof(UDCMarketplaceButtonBase) == 0x000010, "Wrong alignment on UDCMarketplaceButtonBase");
static_assert(sizeof(UDCMarketplaceButtonBase) == 0x001670, "Wrong size on UDCMarketplaceButtonBase");
static_assert(offsetof(UDCMarketplaceButtonBase, bShowIndicator) == 0x001658, "Member 'UDCMarketplaceButtonBase::bShowIndicator' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceButtonBase, PaymentInfos) == 0x001660, "Member 'UDCMarketplaceButtonBase::PaymentInfos' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceComponent
// 0x01F8 (0x0298 - 0x00A0)
class UDCMarketplaceComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_26CF[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TransferSound;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ListingCompletedSound;                             // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          TradeCompletedSound;                               // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCMarketplaceInfo                     MarketplaceInfo;                                   // 0x00D8(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FDCMarketplacePaymentItemInfo>  MarketplacePaymentItemInfos;                       // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCMarketplaceItemInfo>         MarketplaceItems;                                  // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<EDCMarketplaceFilterType, struct FFilterStringArray> RequestedFilterMap;                                // 0x0118(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FDCMarketplaceSortInfo                 RequestedSortInfo;                                 // 0x0168(0x0002)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26D0[0x2];                                     // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentPage;                                       // 0x016C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPage;                                           // 0x0170(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26D1[0x4];                                     // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCMarketplaceMyListInfo>       MyListedItems;                                     // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCItemId>                      RequiredItemsDealTable;                            // 0x0188(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EDCMarketplaceState                           MarketplaceState;                                  // 0x0198(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26D2[0xFF];                                    // 0x0199(0x00FF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceComponent">();
	}
	static class UDCMarketplaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceComponent>();
	}
};
static_assert(alignof(UDCMarketplaceComponent) == 0x000008, "Wrong alignment on UDCMarketplaceComponent");
static_assert(sizeof(UDCMarketplaceComponent) == 0x000298, "Wrong size on UDCMarketplaceComponent");
static_assert(offsetof(UDCMarketplaceComponent, TransferSound) == 0x0000B8, "Member 'UDCMarketplaceComponent::TransferSound' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, ListingCompletedSound) == 0x0000C0, "Member 'UDCMarketplaceComponent::ListingCompletedSound' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, TradeCompletedSound) == 0x0000C8, "Member 'UDCMarketplaceComponent::TradeCompletedSound' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, InventoryComponent) == 0x0000D0, "Member 'UDCMarketplaceComponent::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, MarketplaceInfo) == 0x0000D8, "Member 'UDCMarketplaceComponent::MarketplaceInfo' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, MarketplacePaymentItemInfos) == 0x0000F8, "Member 'UDCMarketplaceComponent::MarketplacePaymentItemInfos' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, MarketplaceItems) == 0x000108, "Member 'UDCMarketplaceComponent::MarketplaceItems' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, RequestedFilterMap) == 0x000118, "Member 'UDCMarketplaceComponent::RequestedFilterMap' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, RequestedSortInfo) == 0x000168, "Member 'UDCMarketplaceComponent::RequestedSortInfo' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, CurrentPage) == 0x00016C, "Member 'UDCMarketplaceComponent::CurrentPage' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, MaxPage) == 0x000170, "Member 'UDCMarketplaceComponent::MaxPage' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, MyListedItems) == 0x000178, "Member 'UDCMarketplaceComponent::MyListedItems' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, RequiredItemsDealTable) == 0x000188, "Member 'UDCMarketplaceComponent::RequiredItemsDealTable' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceComponent, MarketplaceState) == 0x000198, "Member 'UDCMarketplaceComponent::MarketplaceState' has a wrong offset!");

// Class DungeonCrawler.DCMarketplacePaymentDataAsset
// 0x0038 (0x0080 - 0x0048)
class UDCMarketplacePaymentDataAsset final : public UDCTableDataAsset
{
public:
	TSoftObjectPtr<class UDCItemDataAsset>        BaseItem;                                          // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCItemDataAsset>> AllowedBaseItemContainers;                         // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplacePaymentDataAsset">();
	}
	static class UDCMarketplacePaymentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplacePaymentDataAsset>();
	}
};
static_assert(alignof(UDCMarketplacePaymentDataAsset) == 0x000008, "Wrong alignment on UDCMarketplacePaymentDataAsset");
static_assert(sizeof(UDCMarketplacePaymentDataAsset) == 0x000080, "Wrong size on UDCMarketplacePaymentDataAsset");
static_assert(offsetof(UDCMarketplacePaymentDataAsset, BaseItem) == 0x000048, "Member 'UDCMarketplacePaymentDataAsset::BaseItem' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePaymentDataAsset, AllowedBaseItemContainers) == 0x000070, "Member 'UDCMarketplacePaymentDataAsset::AllowedBaseItemContainers' has a wrong offset!");

// Class DungeonCrawler.DCRopeBase
// 0x0058 (0x0438 - 0x03E0)
class ADCRopeBase : public APropsActorBase
{
public:
	class USceneComponent*                        RootRope;                                          // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RopeMesh;                                          // 0x03E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          HoldingBox;                                        // 0x03F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowRope;                                       // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D3[0x3];                                     // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveUpSpeed;                                       // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDownSpeed;                                     // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumdHeight;                                    // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumHeight;                                     // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D4[0x4];                                     // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCRopeMoveData                        RopeMoveData;                                      // 0x0410(0x0020)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26D5[0x8];                                     // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveRope();
	void OnRep_RopeMoveData(const struct FDCRopeMoveData& InOldRopeMoveData);
	void RopeArriveMinimumHeight();
	void RopeBeginDown();
	void RopeEscapeComplete();
	void RopeInteractSucceed();
	void SetInteractMeshCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRopeBase">();
	}
	static class ADCRopeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCRopeBase>();
	}
};
static_assert(alignof(ADCRopeBase) == 0x000008, "Wrong alignment on ADCRopeBase");
static_assert(sizeof(ADCRopeBase) == 0x000438, "Wrong size on ADCRopeBase");
static_assert(offsetof(ADCRopeBase, RootRope) == 0x0003E0, "Member 'ADCRopeBase::RootRope' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, RopeMesh) == 0x0003E8, "Member 'ADCRopeBase::RopeMesh' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, HoldingBox) == 0x0003F0, "Member 'ADCRopeBase::HoldingBox' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, bIsShowRope) == 0x0003F8, "Member 'ADCRopeBase::bIsShowRope' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, MoveUpSpeed) == 0x0003FC, "Member 'ADCRopeBase::MoveUpSpeed' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, MoveDownSpeed) == 0x000400, "Member 'ADCRopeBase::MoveDownSpeed' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, MaximumdHeight) == 0x000404, "Member 'ADCRopeBase::MaximumdHeight' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, MinimumHeight) == 0x000408, "Member 'ADCRopeBase::MinimumHeight' has a wrong offset!");
static_assert(offsetof(ADCRopeBase, RopeMoveData) == 0x000410, "Member 'ADCRopeBase::RopeMoveData' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceDataAsset
// 0x0030 (0x0078 - 0x0048)
class UDCMarketplaceDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCMarketplaceDataAsset;                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D6[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCMarketplacePaymentDataAsset>> BasePayments;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceDataAsset">();
	}
	static class UDCMarketplaceDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceDataAsset>();
	}
};
static_assert(alignof(UDCMarketplaceDataAsset) == 0x000008, "Wrong alignment on UDCMarketplaceDataAsset");
static_assert(sizeof(UDCMarketplaceDataAsset) == 0x000078, "Wrong size on UDCMarketplaceDataAsset");
static_assert(offsetof(UDCMarketplaceDataAsset, Name_DCMarketplaceDataAsset) == 0x000048, "Member 'UDCMarketplaceDataAsset::Name_DCMarketplaceDataAsset' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceDataAsset, Order) == 0x000060, "Member 'UDCMarketplaceDataAsset::Order' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceDataAsset, BasePayments) == 0x000068, "Member 'UDCMarketplaceDataAsset::BasePayments' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceGroupWidgetBase
// 0x0020 (0x04D8 - 0x04B8)
class UDCMarketplaceGroupWidgetBase final : public ULobbyGroupWidgetBase
{
public:
	class UTopTitleWidgetBase*                    TopTitle;                                          // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTabListWidgetBase*                   TabList;                                           // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMarketplaceListWidgetBase*           ViewMarketWidget;                                  // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceMyListWidgetBase*         MyListingsWidget;                                  // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnButtonBack();
	void OnHasAnySoldItem(bool bHasAny);
	void OnTabSelected(class FName InTabButtonId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceGroupWidgetBase">();
	}
	static class UDCMarketplaceGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceGroupWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceGroupWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceGroupWidgetBase");
static_assert(sizeof(UDCMarketplaceGroupWidgetBase) == 0x0004D8, "Wrong size on UDCMarketplaceGroupWidgetBase");
static_assert(offsetof(UDCMarketplaceGroupWidgetBase, TopTitle) == 0x0004B8, "Member 'UDCMarketplaceGroupWidgetBase::TopTitle' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceGroupWidgetBase, TabList) == 0x0004C0, "Member 'UDCMarketplaceGroupWidgetBase::TabList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceGroupWidgetBase, ViewMarketWidget) == 0x0004C8, "Member 'UDCMarketplaceGroupWidgetBase::ViewMarketWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceGroupWidgetBase, MyListingsWidget) == 0x0004D0, "Member 'UDCMarketplaceGroupWidgetBase::MyListingsWidget' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceInterface
// 0x0000 (0x0028 - 0x0028)
class IDCMarketplaceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceInterface">();
	}
	static class IDCMarketplaceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCMarketplaceInterface>();
	}
};
static_assert(alignof(IDCMarketplaceInterface) == 0x000008, "Wrong alignment on IDCMarketplaceInterface");
static_assert(sizeof(IDCMarketplaceInterface) == 0x000028, "Wrong size on IDCMarketplaceInterface");

// Class DungeonCrawler.DCMarketplaceItemInfoWidgetBase
// 0x01F8 (0x0550 - 0x0358)
class UDCMarketplaceItemInfoWidgetBase : public UDCWidgetBase
{
public:
	uint8                                         Pad_26D7[0x18];                                    // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCItemTooltipWidget>       ItemTooltipWidgetClass;                            // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ItemRarityType;                                    // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemName;                                          // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTimespan                              RemainTime;                                        // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Price;                                             // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStack;                                         // 0x03A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D8[0x3];                                     // 0x03A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UnitPriceText;                                     // 0x03A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCItemInfo                            ItemInfo;                                          // 0x03C8(0x0168)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         ListingId;                                         // 0x0530(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D9[0x18];                                    // 0x0538(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDCItemTooltipWidget* GetItemTooltipWidget();

	int32 GetCount() const;
	bool IsExpiredItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceItemInfoWidgetBase">();
	}
	static class UDCMarketplaceItemInfoWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceItemInfoWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceItemInfoWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceItemInfoWidgetBase");
static_assert(sizeof(UDCMarketplaceItemInfoWidgetBase) == 0x000550, "Wrong size on UDCMarketplaceItemInfoWidgetBase");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, ItemTooltipWidgetClass) == 0x000370, "Member 'UDCMarketplaceItemInfoWidgetBase::ItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, ItemRarityType) == 0x000378, "Member 'UDCMarketplaceItemInfoWidgetBase::ItemRarityType' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, ItemName) == 0x000380, "Member 'UDCMarketplaceItemInfoWidgetBase::ItemName' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, RemainTime) == 0x000398, "Member 'UDCMarketplaceItemInfoWidgetBase::RemainTime' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, Price) == 0x0003A0, "Member 'UDCMarketplaceItemInfoWidgetBase::Price' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, bCanStack) == 0x0003A4, "Member 'UDCMarketplaceItemInfoWidgetBase::bCanStack' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, UnitPriceText) == 0x0003A8, "Member 'UDCMarketplaceItemInfoWidgetBase::UnitPriceText' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, ItemImage) == 0x0003C0, "Member 'UDCMarketplaceItemInfoWidgetBase::ItemImage' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, ItemInfo) == 0x0003C8, "Member 'UDCMarketplaceItemInfoWidgetBase::ItemInfo' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemInfoWidgetBase, ListingId) == 0x000530, "Member 'UDCMarketplaceItemInfoWidgetBase::ListingId' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequireDungeonDetailEntry
// 0x0010 (0x0368 - 0x0358)
class UDCQuestRequireDungeonDetailEntry final : public UDCWidgetBase
{
public:
	uint8                                         Pad_26DA[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         DetailText;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequireDungeonDetailEntry">();
	}
	static class UDCQuestRequireDungeonDetailEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequireDungeonDetailEntry>();
	}
};
static_assert(alignof(UDCQuestRequireDungeonDetailEntry) == 0x000008, "Wrong alignment on UDCQuestRequireDungeonDetailEntry");
static_assert(sizeof(UDCQuestRequireDungeonDetailEntry) == 0x000368, "Wrong size on UDCQuestRequireDungeonDetailEntry");
static_assert(offsetof(UDCQuestRequireDungeonDetailEntry, DetailText) == 0x000360, "Member 'UDCQuestRequireDungeonDetailEntry::DetailText' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceItemManageWidgetBase
// 0x0228 (0x0580 - 0x0358)
class UDCMarketplaceItemManageWidgetBase final : public UDCWidgetBase
{
public:
	uint8                                         Pad_26DB[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    ButtonListing;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonCancelListing;                               // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonRetrieve;                                    // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              RemainTime;                                        // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ListedPrice;                                       // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26DC[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCMarketplaceItemWidget*               TargetItemWidget;                                  // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCFeatureUnlockRemainTimeWidget*       FeatureLockTimerWidget;                            // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCMarketplaceMyListInfo               SelectedListItem;                                  // 0x03A0(0x01D0)(Transient, NativeAccessSpecifierPrivate)
	class UEditableTextBox*                       PriceEditableText;                                 // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26DD[0x4];                                     // 0x0578(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsListingLocked;                                  // 0x057C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCAccountStatus                              AccountStatus;                                     // 0x057D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26DE[0x2];                                     // 0x057E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonCancelListingClicked();
	void OnButtonListingClicked();
	void OnButtonRetrieveClicked();
	void OnFeatureLockTimerRunsOut();
	void OnPriceTextChanged(const class FText& InText);
	void OnTargetItemClickEvent(const struct FDCItemId& ItemId, const struct FPointerEvent& MouseEvent, bool bIsLocked, bool bIsItemReadOnly);

	bool CannotListingItem() const;
	int32 GetFixedListingFee() const;
	int32 GetListingExpiredDays() const;
	int32 GetListingFee() const;
	EDCMarketplaceMyListState GetListItemState() const;
	int32 GetPriceLimit() const;
	int32 GetVariableListingFee() const;
	int32 GetVariableListingFeeRate() const;
	bool IsListingPriceSet() const;
	void OnItemStateChanged(const EDCMarketplaceMyListState& State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceItemManageWidgetBase">();
	}
	static class UDCMarketplaceItemManageWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceItemManageWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceItemManageWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceItemManageWidgetBase");
static_assert(sizeof(UDCMarketplaceItemManageWidgetBase) == 0x000580, "Wrong size on UDCMarketplaceItemManageWidgetBase");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, ButtonListing) == 0x000368, "Member 'UDCMarketplaceItemManageWidgetBase::ButtonListing' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, ButtonCancelListing) == 0x000370, "Member 'UDCMarketplaceItemManageWidgetBase::ButtonCancelListing' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, ButtonRetrieve) == 0x000378, "Member 'UDCMarketplaceItemManageWidgetBase::ButtonRetrieve' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, RemainTime) == 0x000380, "Member 'UDCMarketplaceItemManageWidgetBase::RemainTime' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, ListedPrice) == 0x000388, "Member 'UDCMarketplaceItemManageWidgetBase::ListedPrice' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, TargetItemWidget) == 0x000390, "Member 'UDCMarketplaceItemManageWidgetBase::TargetItemWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, FeatureLockTimerWidget) == 0x000398, "Member 'UDCMarketplaceItemManageWidgetBase::FeatureLockTimerWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, SelectedListItem) == 0x0003A0, "Member 'UDCMarketplaceItemManageWidgetBase::SelectedListItem' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, PriceEditableText) == 0x000570, "Member 'UDCMarketplaceItemManageWidgetBase::PriceEditableText' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, bIsListingLocked) == 0x00057C, "Member 'UDCMarketplaceItemManageWidgetBase::bIsListingLocked' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemManageWidgetBase, AccountStatus) == 0x00057D, "Member 'UDCMarketplaceItemManageWidgetBase::AccountStatus' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetItemContainer
// 0x0018 (0x0060 - 0x0048)
class UDesignDataAssetItemContainer final : public UDCDataAssetBase
{
public:
	struct FDesignDataItemContainer               Item;                                              // 0x0048(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E0[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItemContainer">();
	}
	static class UDesignDataAssetItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItemContainer>();
	}
};
static_assert(alignof(UDesignDataAssetItemContainer) == 0x000008, "Wrong alignment on UDesignDataAssetItemContainer");
static_assert(sizeof(UDesignDataAssetItemContainer) == 0x000060, "Wrong size on UDesignDataAssetItemContainer");
static_assert(offsetof(UDesignDataAssetItemContainer, Item) == 0x000048, "Member 'UDesignDataAssetItemContainer::Item' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceItemWidget
// 0x0018 (0x0678 - 0x0660)
class UDCMarketplaceItemWidget final : public UDCItemWidgetBase
{
public:
	TSubclassOf<class UDCItemTooltipWidget>       ItemTooltipWidgetClass;                            // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x0668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               ItemSizeBox;                                       // 0x0670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UDCItemTooltipWidget* GetItemTooltipWidget();

	bool IsItemSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceItemWidget">();
	}
	static class UDCMarketplaceItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceItemWidget>();
	}
};
static_assert(alignof(UDCMarketplaceItemWidget) == 0x000008, "Wrong alignment on UDCMarketplaceItemWidget");
static_assert(sizeof(UDCMarketplaceItemWidget) == 0x000678, "Wrong size on UDCMarketplaceItemWidget");
static_assert(offsetof(UDCMarketplaceItemWidget, ItemTooltipWidgetClass) == 0x000660, "Member 'UDCMarketplaceItemWidget::ItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemWidget, ItemImage) == 0x000668, "Member 'UDCMarketplaceItemWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceItemWidget, ItemSizeBox) == 0x000670, "Member 'UDCMarketplaceItemWidget::ItemSizeBox' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceListEntryWidgetData
// 0x01D0 (0x01F8 - 0x0028)
class UDCMarketplaceListEntryWidgetData final : public UObject
{
public:
	struct FDCMarketplaceItemInfo                 MarketplaceItemInfo;                               // 0x0028(0x01C0)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FDCMarketplaceFilterInfo>       AttributeFilters;                                  // 0x01E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceListEntryWidgetData">();
	}
	static class UDCMarketplaceListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceListEntryWidgetData>();
	}
};
static_assert(alignof(UDCMarketplaceListEntryWidgetData) == 0x000008, "Wrong alignment on UDCMarketplaceListEntryWidgetData");
static_assert(sizeof(UDCMarketplaceListEntryWidgetData) == 0x0001F8, "Wrong size on UDCMarketplaceListEntryWidgetData");
static_assert(offsetof(UDCMarketplaceListEntryWidgetData, MarketplaceItemInfo) == 0x000028, "Member 'UDCMarketplaceListEntryWidgetData::MarketplaceItemInfo' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetData, AttributeFilters) == 0x0001E8, "Member 'UDCMarketplaceListEntryWidgetData::AttributeFilters' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceListEntryWidgetBase
// 0x00A8 (0x05F8 - 0x0550)
class UDCMarketplaceListEntryWidgetBase final : public UDCMarketplaceItemInfoWidgetBase
{
public:
	uint8                                         Pad_26E1[0x8];                                     // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RarityText;                                        // 0x0558(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   SlotText;                                          // 0x0570(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   TypeText;                                          // 0x0588(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsMyList;                                         // 0x05A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E2[0x7];                                     // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    ButtonBuy;                                         // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StaticAttributeValue;                              // 0x05B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RandomAttributeValue;                              // 0x05B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNickname                              SellerName;                                        // 0x05B8(0x0040)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnButtonBuyClicked();

	class FText GetRandomAttributeValue() const;
	class FText GetStaticAttributeValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceListEntryWidgetBase">();
	}
	static class UDCMarketplaceListEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceListEntryWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceListEntryWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceListEntryWidgetBase");
static_assert(sizeof(UDCMarketplaceListEntryWidgetBase) == 0x0005F8, "Wrong size on UDCMarketplaceListEntryWidgetBase");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, RarityText) == 0x000558, "Member 'UDCMarketplaceListEntryWidgetBase::RarityText' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, SlotText) == 0x000570, "Member 'UDCMarketplaceListEntryWidgetBase::SlotText' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, TypeText) == 0x000588, "Member 'UDCMarketplaceListEntryWidgetBase::TypeText' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, bIsMyList) == 0x0005A0, "Member 'UDCMarketplaceListEntryWidgetBase::bIsMyList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, ButtonBuy) == 0x0005A8, "Member 'UDCMarketplaceListEntryWidgetBase::ButtonBuy' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, StaticAttributeValue) == 0x0005B0, "Member 'UDCMarketplaceListEntryWidgetBase::StaticAttributeValue' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, RandomAttributeValue) == 0x0005B4, "Member 'UDCMarketplaceListEntryWidgetBase::RandomAttributeValue' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListEntryWidgetBase, SellerName) == 0x0005B8, "Member 'UDCMarketplaceListEntryWidgetBase::SellerName' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementCommonWidget
// 0x0018 (0x0370 - 0x0358)
class UDCQuestRequirementCommonWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_26E3[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UListView*                              RequirementListView;                               // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              RequirementDetailListView;                         // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementCommonWidget">();
	}
	static class UDCQuestRequirementCommonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementCommonWidget>();
	}
};
static_assert(alignof(UDCQuestRequirementCommonWidget) == 0x000008, "Wrong alignment on UDCQuestRequirementCommonWidget");
static_assert(sizeof(UDCQuestRequirementCommonWidget) == 0x000370, "Wrong size on UDCQuestRequirementCommonWidget");
static_assert(offsetof(UDCQuestRequirementCommonWidget, RequirementListView) == 0x000360, "Member 'UDCQuestRequirementCommonWidget::RequirementListView' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementCommonWidget, RequirementDetailListView) == 0x000368, "Member 'UDCQuestRequirementCommonWidget::RequirementDetailListView' has a wrong offset!");

// Class DungeonCrawler.DCSearchableComboBoxWidgetDataBase
// 0x0018 (0x0040 - 0x0028)
class UDCSearchableComboBoxWidgetDataBase : public UObject
{
public:
	class FText                                   EntryText;                                         // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSearchableComboBoxWidgetDataBase">();
	}
	static class UDCSearchableComboBoxWidgetDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSearchableComboBoxWidgetDataBase>();
	}
};
static_assert(alignof(UDCSearchableComboBoxWidgetDataBase) == 0x000008, "Wrong alignment on UDCSearchableComboBoxWidgetDataBase");
static_assert(sizeof(UDCSearchableComboBoxWidgetDataBase) == 0x000040, "Wrong size on UDCSearchableComboBoxWidgetDataBase");
static_assert(offsetof(UDCSearchableComboBoxWidgetDataBase, EntryText) == 0x000028, "Member 'UDCSearchableComboBoxWidgetDataBase::EntryText' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetSpell
// 0x00D8 (0x0120 - 0x0048)
class UDesignDataAssetSpell final : public UDCDataAssetBase
{
public:
	struct FDesignDataSpell                       Item;                                              // 0x0048(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetSpell">();
	}
	static class UDesignDataAssetSpell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetSpell>();
	}
};
static_assert(alignof(UDesignDataAssetSpell) == 0x000008, "Wrong alignment on UDesignDataAssetSpell");
static_assert(sizeof(UDesignDataAssetSpell) == 0x000120, "Wrong size on UDesignDataAssetSpell");
static_assert(offsetof(UDesignDataAssetSpell, Item) == 0x000048, "Member 'UDesignDataAssetSpell::Item' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceFilterWidgetDataBase
// 0x0028 (0x0068 - 0x0040)
class UDCMarketplaceFilterWidgetDataBase final : public UDCSearchableComboBoxWidgetDataBase
{
public:
	EDCMarketplaceFilterType                      FilterType;                                        // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E4[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FilterString;                                      // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterStringArray                     FilterStringArray;                                 // 0x0058(0x0010)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceFilterWidgetDataBase">();
	}
	static class UDCMarketplaceFilterWidgetDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceFilterWidgetDataBase>();
	}
};
static_assert(alignof(UDCMarketplaceFilterWidgetDataBase) == 0x000008, "Wrong alignment on UDCMarketplaceFilterWidgetDataBase");
static_assert(sizeof(UDCMarketplaceFilterWidgetDataBase) == 0x000068, "Wrong size on UDCMarketplaceFilterWidgetDataBase");
static_assert(offsetof(UDCMarketplaceFilterWidgetDataBase, FilterType) == 0x000040, "Member 'UDCMarketplaceFilterWidgetDataBase::FilterType' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceFilterWidgetDataBase, FilterString) == 0x000048, "Member 'UDCMarketplaceFilterWidgetDataBase::FilterString' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceFilterWidgetDataBase, FilterStringArray) == 0x000058, "Member 'UDCMarketplaceFilterWidgetDataBase::FilterStringArray' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceListWidgetBase
// 0x01C8 (0x0520 - 0x0358)
class UDCMarketplaceListWidgetBase final : public UDCWidgetBase
{
public:
	int32                                         CurrentPage;                                       // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPage;                                           // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSortButtonWidget*                    SortByItemNameButton;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSortButtonWidget*                    SortByItemRarityButton;                            // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    SearchButton;                                      // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    RecentButton;                                      // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ResetFilterButton;                                 // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSortButtonWidget*                    SortByItemStaticAttributeButton;                   // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSortButtonWidget*                    SortByItemRandomAttributeButton;                   // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSortButtonWidget*                    SortByItemPriceButton;                             // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemNameComboBox;                                  // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemRarityComboBox;                                // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemSlotComboBox;                                  // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemTypeComboBox;                                  // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemStaticAttributeComboBox;                       // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemRandomAttributeComboBox;                       // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            ItemClassRequirementComboBox;                      // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDCMarketplaceFilterType, struct FFilterStringArray> FilterMap;                                         // 0x03D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UDCSortButtonWidget*> SortButtonMap;                                     // 0x0428(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UListView*                              MarketplaceItemList;                               // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    NextPageButton;                                    // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCommonButtonBase*                    PrevPageButton;                                    // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCMarketplaceSortInfo                 CurrentSortInfo;                                   // 0x0490(0x0002)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26E5[0x6];                                     // 0x0492(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   FilterIdTagList;                                   // 0x0498(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   FilterRarityTagList;                               // 0x04A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   FilterSlotTagList;                                 // 0x04B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   FilterTypeTagList;                                 // 0x04C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                FilterStaticAttributeList;                         // 0x04D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                FilterRandomAttributeList;                         // 0x04E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                FilterClassRequirementList;                        // 0x04F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                StoreClassRequirementFilterList;                   // 0x0508(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26E6[0x8];                                     // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckSortButtonSortable();
	void OnComboBoxItemSelectionAddition(class UObject* SelectedItem);
	void OnComboBoxItemSelectionChanged(class UObject* SelectedItem);
	void OnComboBoxItemSelectionCleared(class UObject* SelectedItem);
	void OnNextPageButtonClicked();
	void OnPrevPageButtonClicked();
	void OnResetFilterButtonClicked();
	void OnSearchButtonClicked();
	void OnSortButtonClicked(const class FName& Target, const EDCSortButtonState& State);
	void UpdatePageButton(bool bInRecent);

	bool IsAnyFilterSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceListWidgetBase">();
	}
	static class UDCMarketplaceListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceListWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceListWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceListWidgetBase");
static_assert(sizeof(UDCMarketplaceListWidgetBase) == 0x000520, "Wrong size on UDCMarketplaceListWidgetBase");
static_assert(offsetof(UDCMarketplaceListWidgetBase, CurrentPage) == 0x000358, "Member 'UDCMarketplaceListWidgetBase::CurrentPage' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, MaxPage) == 0x00035C, "Member 'UDCMarketplaceListWidgetBase::MaxPage' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SortByItemNameButton) == 0x000360, "Member 'UDCMarketplaceListWidgetBase::SortByItemNameButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SortByItemRarityButton) == 0x000368, "Member 'UDCMarketplaceListWidgetBase::SortByItemRarityButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SearchButton) == 0x000370, "Member 'UDCMarketplaceListWidgetBase::SearchButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, RecentButton) == 0x000378, "Member 'UDCMarketplaceListWidgetBase::RecentButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ResetFilterButton) == 0x000380, "Member 'UDCMarketplaceListWidgetBase::ResetFilterButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SortByItemStaticAttributeButton) == 0x000388, "Member 'UDCMarketplaceListWidgetBase::SortByItemStaticAttributeButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SortByItemRandomAttributeButton) == 0x000390, "Member 'UDCMarketplaceListWidgetBase::SortByItemRandomAttributeButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SortByItemPriceButton) == 0x000398, "Member 'UDCMarketplaceListWidgetBase::SortByItemPriceButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemNameComboBox) == 0x0003A0, "Member 'UDCMarketplaceListWidgetBase::ItemNameComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemRarityComboBox) == 0x0003A8, "Member 'UDCMarketplaceListWidgetBase::ItemRarityComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemSlotComboBox) == 0x0003B0, "Member 'UDCMarketplaceListWidgetBase::ItemSlotComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemTypeComboBox) == 0x0003B8, "Member 'UDCMarketplaceListWidgetBase::ItemTypeComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemStaticAttributeComboBox) == 0x0003C0, "Member 'UDCMarketplaceListWidgetBase::ItemStaticAttributeComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemRandomAttributeComboBox) == 0x0003C8, "Member 'UDCMarketplaceListWidgetBase::ItemRandomAttributeComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, ItemClassRequirementComboBox) == 0x0003D0, "Member 'UDCMarketplaceListWidgetBase::ItemClassRequirementComboBox' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterMap) == 0x0003D8, "Member 'UDCMarketplaceListWidgetBase::FilterMap' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, SortButtonMap) == 0x000428, "Member 'UDCMarketplaceListWidgetBase::SortButtonMap' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, MarketplaceItemList) == 0x000478, "Member 'UDCMarketplaceListWidgetBase::MarketplaceItemList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, NextPageButton) == 0x000480, "Member 'UDCMarketplaceListWidgetBase::NextPageButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, PrevPageButton) == 0x000488, "Member 'UDCMarketplaceListWidgetBase::PrevPageButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, CurrentSortInfo) == 0x000490, "Member 'UDCMarketplaceListWidgetBase::CurrentSortInfo' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterIdTagList) == 0x000498, "Member 'UDCMarketplaceListWidgetBase::FilterIdTagList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterRarityTagList) == 0x0004A8, "Member 'UDCMarketplaceListWidgetBase::FilterRarityTagList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterSlotTagList) == 0x0004B8, "Member 'UDCMarketplaceListWidgetBase::FilterSlotTagList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterTypeTagList) == 0x0004C8, "Member 'UDCMarketplaceListWidgetBase::FilterTypeTagList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterStaticAttributeList) == 0x0004D8, "Member 'UDCMarketplaceListWidgetBase::FilterStaticAttributeList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterRandomAttributeList) == 0x0004E8, "Member 'UDCMarketplaceListWidgetBase::FilterRandomAttributeList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, FilterClassRequirementList) == 0x0004F8, "Member 'UDCMarketplaceListWidgetBase::FilterClassRequirementList' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceListWidgetBase, StoreClassRequirementFilterList) == 0x000508, "Member 'UDCMarketplaceListWidgetBase::StoreClassRequirementFilterList' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceMyListEntryWidgetData
// 0x01F0 (0x0218 - 0x0028)
class UDCMarketplaceMyListEntryWidgetData final : public UObject
{
public:
	struct FDCMarketplaceMyListInfo               MyListItemInfo;                                    // 0x0028(0x01D0)(Transient, NativeAccessSpecifierPublic)
	bool                                          bIsEmpty;                                          // 0x01F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E8[0x1F];                                    // 0x01F9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceMyListEntryWidgetData">();
	}
	static class UDCMarketplaceMyListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceMyListEntryWidgetData>();
	}
};
static_assert(alignof(UDCMarketplaceMyListEntryWidgetData) == 0x000008, "Wrong alignment on UDCMarketplaceMyListEntryWidgetData");
static_assert(sizeof(UDCMarketplaceMyListEntryWidgetData) == 0x000218, "Wrong size on UDCMarketplaceMyListEntryWidgetData");
static_assert(offsetof(UDCMarketplaceMyListEntryWidgetData, MyListItemInfo) == 0x000028, "Member 'UDCMarketplaceMyListEntryWidgetData::MyListItemInfo' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceMyListEntryWidgetData, bIsEmpty) == 0x0001F8, "Member 'UDCMarketplaceMyListEntryWidgetData::bIsEmpty' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementDungeonWidget
// 0x0018 (0x0370 - 0x0358)
class UDCQuestRequirementDungeonWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_26E9[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UListView*                              RequirementListView;                               // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              RequirementDetailListView;                         // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementDungeonWidget">();
	}
	static class UDCQuestRequirementDungeonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementDungeonWidget>();
	}
};
static_assert(alignof(UDCQuestRequirementDungeonWidget) == 0x000008, "Wrong alignment on UDCQuestRequirementDungeonWidget");
static_assert(sizeof(UDCQuestRequirementDungeonWidget) == 0x000370, "Wrong size on UDCQuestRequirementDungeonWidget");
static_assert(offsetof(UDCQuestRequirementDungeonWidget, RequirementListView) == 0x000360, "Member 'UDCQuestRequirementDungeonWidget::RequirementListView' has a wrong offset!");
static_assert(offsetof(UDCQuestRequirementDungeonWidget, RequirementDetailListView) == 0x000368, "Member 'UDCQuestRequirementDungeonWidget::RequirementDetailListView' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceMyListEntryWidgetBase
// 0x0008 (0x0558 - 0x0550)
class UDCMarketplaceMyListEntryWidgetBase final : public UDCMarketplaceItemInfoWidgetBase
{
public:
	uint8                                         Pad_26EA[0x8];                                     // 0x0550(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMarketplaceMyItemInfoUpdate();

	EDCMarketplaceMyListState GetListState() const;
	bool IsListing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceMyListEntryWidgetBase">();
	}
	static class UDCMarketplaceMyListEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceMyListEntryWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceMyListEntryWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceMyListEntryWidgetBase");
static_assert(sizeof(UDCMarketplaceMyListEntryWidgetBase) == 0x000558, "Wrong size on UDCMarketplaceMyListEntryWidgetBase");

// Class DungeonCrawler.DesignDataAssetMovementModifier
// 0x0018 (0x0060 - 0x0048)
class UDesignDataAssetMovementModifier final : public UDCDataAssetBase
{
public:
	struct FDesignDataMovementModifier            Item;                                              // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetMovementModifier">();
	}
	static class UDesignDataAssetMovementModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetMovementModifier>();
	}
};
static_assert(alignof(UDesignDataAssetMovementModifier) == 0x000008, "Wrong alignment on UDesignDataAssetMovementModifier");
static_assert(sizeof(UDesignDataAssetMovementModifier) == 0x000060, "Wrong size on UDesignDataAssetMovementModifier");
static_assert(offsetof(UDesignDataAssetMovementModifier, Item) == 0x000048, "Member 'UDesignDataAssetMovementModifier::Item' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceMyListWidgetBase
// 0x0038 (0x0390 - 0x0358)
class UDCMarketplaceMyListWidgetBase final : public UDCWidgetBase
{
public:
	EDCMarketplaceMyListState                     SelectedItemState;                                 // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26EB[0x7];                                     // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCMarketplacePaymentTransferWidgetBase* PaymentTransferWidget;                             // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              MyListingsListView;                                // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventorySetWidget*                  PlayerInventorySet;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceItemManageWidgetBase*     ListingItemManageWidget;                           // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDCMarketplaceComponent> MarketplaceComponent;                              // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26EC[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTargetItemWidgetClicked(const struct FDCItemId& ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceMyListWidgetBase">();
	}
	static class UDCMarketplaceMyListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceMyListWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplaceMyListWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplaceMyListWidgetBase");
static_assert(sizeof(UDCMarketplaceMyListWidgetBase) == 0x000390, "Wrong size on UDCMarketplaceMyListWidgetBase");
static_assert(offsetof(UDCMarketplaceMyListWidgetBase, SelectedItemState) == 0x000358, "Member 'UDCMarketplaceMyListWidgetBase::SelectedItemState' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceMyListWidgetBase, PaymentTransferWidget) == 0x000360, "Member 'UDCMarketplaceMyListWidgetBase::PaymentTransferWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceMyListWidgetBase, MyListingsListView) == 0x000368, "Member 'UDCMarketplaceMyListWidgetBase::MyListingsListView' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceMyListWidgetBase, PlayerInventorySet) == 0x000370, "Member 'UDCMarketplaceMyListWidgetBase::PlayerInventorySet' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceMyListWidgetBase, ListingItemManageWidget) == 0x000378, "Member 'UDCMarketplaceMyListWidgetBase::ListingItemManageWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceMyListWidgetBase, MarketplaceComponent) == 0x000380, "Member 'UDCMarketplaceMyListWidgetBase::MarketplaceComponent' has a wrong offset!");

// Class DungeonCrawler.DCMarketplacePaymentTransferWidgetBase
// 0x01F0 (0x0548 - 0x0358)
class UDCMarketplacePaymentTransferWidgetBase final : public UDCWidgetBase
{
public:
	class UDCCommonButtonBase*                    TransferItemsButton;                               // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CloseListingButton;                                // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              RemainDestuctionTime;                              // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMarketplaceItemWidget*               SoldItemWidget;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCMarketplaceMyListInfo               SelectedListItem;                                  // 0x0378(0x01D0)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnCloseListingButtonClicked();
	void OnMarketplaceMyItemInfoUpdated();
	void OnPaymentsDestroyed();
	void OnTransferButtonClicked();

	int32 GetPirce() const;
	bool IsDestoryed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplacePaymentTransferWidgetBase">();
	}
	static class UDCMarketplacePaymentTransferWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplacePaymentTransferWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplacePaymentTransferWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplacePaymentTransferWidgetBase");
static_assert(sizeof(UDCMarketplacePaymentTransferWidgetBase) == 0x000548, "Wrong size on UDCMarketplacePaymentTransferWidgetBase");
static_assert(offsetof(UDCMarketplacePaymentTransferWidgetBase, TransferItemsButton) == 0x000358, "Member 'UDCMarketplacePaymentTransferWidgetBase::TransferItemsButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePaymentTransferWidgetBase, CloseListingButton) == 0x000360, "Member 'UDCMarketplacePaymentTransferWidgetBase::CloseListingButton' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePaymentTransferWidgetBase, RemainDestuctionTime) == 0x000368, "Member 'UDCMarketplacePaymentTransferWidgetBase::RemainDestuctionTime' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePaymentTransferWidgetBase, SoldItemWidget) == 0x000370, "Member 'UDCMarketplacePaymentTransferWidgetBase::SoldItemWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePaymentTransferWidgetBase, SelectedListItem) == 0x000378, "Member 'UDCMarketplacePaymentTransferWidgetBase::SelectedListItem' has a wrong offset!");

// Class DungeonCrawler.DCMarketplaceRequiredItemData
// 0x0060 (0x0088 - 0x0028)
class UDCMarketplaceRequiredItemData final : public UObject
{
public:
	class UDCItemDataAsset*                       DataAsset;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStack;                                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26ED[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCItemInfo, int32>               FilledInfos;                                       // 0x0038(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplaceRequiredItemData">();
	}
	static class UDCMarketplaceRequiredItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplaceRequiredItemData>();
	}
};
static_assert(alignof(UDCMarketplaceRequiredItemData) == 0x000008, "Wrong alignment on UDCMarketplaceRequiredItemData");
static_assert(sizeof(UDCMarketplaceRequiredItemData) == 0x000088, "Wrong size on UDCMarketplaceRequiredItemData");
static_assert(offsetof(UDCMarketplaceRequiredItemData, DataAsset) == 0x000028, "Member 'UDCMarketplaceRequiredItemData::DataAsset' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceRequiredItemData, MaxStack) == 0x000030, "Member 'UDCMarketplaceRequiredItemData::MaxStack' has a wrong offset!");
static_assert(offsetof(UDCMarketplaceRequiredItemData, FilledInfos) == 0x000038, "Member 'UDCMarketplaceRequiredItemData::FilledInfos' has a wrong offset!");

// Class DungeonCrawler.DCRecentMatchCharacterSlotWidgetData
// 0x0080 (0x00A8 - 0x0028)
class UDCRecentMatchCharacterSlotWidgetData final : public UObject
{
public:
	struct FDCCommunityCharacterInfo              Info;                                              // 0x0028(0x0078)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsFriend;                                         // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26EE[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRecentMatchCharacterSlotWidgetData">();
	}
	static class UDCRecentMatchCharacterSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRecentMatchCharacterSlotWidgetData>();
	}
};
static_assert(alignof(UDCRecentMatchCharacterSlotWidgetData) == 0x000008, "Wrong alignment on UDCRecentMatchCharacterSlotWidgetData");
static_assert(sizeof(UDCRecentMatchCharacterSlotWidgetData) == 0x0000A8, "Wrong size on UDCRecentMatchCharacterSlotWidgetData");
static_assert(offsetof(UDCRecentMatchCharacterSlotWidgetData, Info) == 0x000028, "Member 'UDCRecentMatchCharacterSlotWidgetData::Info' has a wrong offset!");
static_assert(offsetof(UDCRecentMatchCharacterSlotWidgetData, bIsFriend) == 0x0000A0, "Member 'UDCRecentMatchCharacterSlotWidgetData::bIsFriend' has a wrong offset!");

// Class DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase
// 0x0048 (0x0500 - 0x04B8)
class UDCMarketplacePurchaseGroupWidgetBase final : public ULobbyGroupWidgetBase
{
public:
	int32                                         Price;                                             // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26EF[0x4];                                     // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTopTitleWidgetBase*                    TopTitle;                                          // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonDeal;                                        // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonFill;                                        // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCInventorySetWidget*                  PlayerInventorySet;                                // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceItemInfoWidgetBase*       ItemInfoWidget;                                    // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceItemWidget*               ItemWidget;                                        // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceRequiredItemData*         RequiredItemData;                                  // 0x04F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDCMarketplaceComponent> MarketplaceComponent;                              // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnButtonBack();
	void OnButtonDeal();
	void OnButtonFill();

	int32 GetCounterTotalPayment() const;
	void OnAnyItemFilled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMarketplacePurchaseGroupWidgetBase">();
	}
	static class UDCMarketplacePurchaseGroupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMarketplacePurchaseGroupWidgetBase>();
	}
};
static_assert(alignof(UDCMarketplacePurchaseGroupWidgetBase) == 0x000008, "Wrong alignment on UDCMarketplacePurchaseGroupWidgetBase");
static_assert(sizeof(UDCMarketplacePurchaseGroupWidgetBase) == 0x000500, "Wrong size on UDCMarketplacePurchaseGroupWidgetBase");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, Price) == 0x0004B8, "Member 'UDCMarketplacePurchaseGroupWidgetBase::Price' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, TopTitle) == 0x0004C0, "Member 'UDCMarketplacePurchaseGroupWidgetBase::TopTitle' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, ButtonDeal) == 0x0004C8, "Member 'UDCMarketplacePurchaseGroupWidgetBase::ButtonDeal' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, ButtonFill) == 0x0004D0, "Member 'UDCMarketplacePurchaseGroupWidgetBase::ButtonFill' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, PlayerInventorySet) == 0x0004D8, "Member 'UDCMarketplacePurchaseGroupWidgetBase::PlayerInventorySet' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, ItemInfoWidget) == 0x0004E0, "Member 'UDCMarketplacePurchaseGroupWidgetBase::ItemInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, ItemWidget) == 0x0004E8, "Member 'UDCMarketplacePurchaseGroupWidgetBase::ItemWidget' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, RequiredItemData) == 0x0004F0, "Member 'UDCMarketplacePurchaseGroupWidgetBase::RequiredItemData' has a wrong offset!");
static_assert(offsetof(UDCMarketplacePurchaseGroupWidgetBase, MarketplaceComponent) == 0x0004F8, "Member 'UDCMarketplacePurchaseGroupWidgetBase::MarketplaceComponent' has a wrong offset!");

// Class DungeonCrawler.DungeonSelectButtonWidget
// 0x0040 (0x16A0 - 0x1660)
class UDungeonSelectButtonWidget final : public UDCCommonButtonBase
{
public:
	struct FDungeonSelectButtonWidgetHandleData   WidgetHandleData;                                  // 0x1658(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26F0[0x28];                                    // 0x1678(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDungeonSelect();
	void OnbMatching(bool NewValue, bool OldValue);
	void OnDungeonRotationItemInfo(const struct FDungeonRotationItemInfo& NewValue, const struct FDungeonRotationItemInfo& OldValue);
	void OnDungeonRotationTimerData(const struct FDungeonRotationTimerData& NewValue, const struct FDungeonRotationTimerData& OldValue);
	void OnGameType(EGameType NewValue, EGameType OldValue);
	void OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce);
	void OnMatchMode(EMatchMode NewValue, EMatchMode OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSelectButtonWidget">();
	}
	static class UDungeonSelectButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSelectButtonWidget>();
	}
};
static_assert(alignof(UDungeonSelectButtonWidget) == 0x000010, "Wrong alignment on UDungeonSelectButtonWidget");
static_assert(sizeof(UDungeonSelectButtonWidget) == 0x0016A0, "Wrong size on UDungeonSelectButtonWidget");
static_assert(offsetof(UDungeonSelectButtonWidget, WidgetHandleData) == 0x001658, "Member 'UDungeonSelectButtonWidget::WidgetHandleData' has a wrong offset!");

// Class DungeonCrawler.DCMaterialComponent
// 0x0080 (0x0120 - 0x00A0)
class UDCMaterialComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_26F2[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCMaterialData>                BaseMaterialDataArray;                             // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EDCMaterialType, struct FDCMaterialSetData> MaterialSetDataMap;                                // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_26F3[0x10];                                    // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RefreshNextTickTimerHandle;                        // 0x0118(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMaterialComponent">();
	}
	static class UDCMaterialComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMaterialComponent>();
	}
};
static_assert(alignof(UDCMaterialComponent) == 0x000008, "Wrong alignment on UDCMaterialComponent");
static_assert(sizeof(UDCMaterialComponent) == 0x000120, "Wrong size on UDCMaterialComponent");
static_assert(offsetof(UDCMaterialComponent, BaseMaterialDataArray) == 0x0000A8, "Member 'UDCMaterialComponent::BaseMaterialDataArray' has a wrong offset!");
static_assert(offsetof(UDCMaterialComponent, MaterialSetDataMap) == 0x0000B8, "Member 'UDCMaterialComponent::MaterialSetDataMap' has a wrong offset!");
static_assert(offsetof(UDCMaterialComponent, RefreshNextTickTimerHandle) == 0x000118, "Member 'UDCMaterialComponent::RefreshNextTickTimerHandle' has a wrong offset!");

// Class DungeonCrawler.DCMaterialInterface
// 0x0000 (0x0028 - 0x0028)
class IDCMaterialInterface final : public IInterface
{
public:
	void RemoveOverrideMaterial(EDCMaterialType InMaterialType);
	void ResetBaseMaterial(class UMeshComponent* InMeshComponent);
	void SetBaseMaterial(class UMeshComponent* InMeshComponent, int32 InElementIndex, class UMaterialInterface* InMaterialInterface);
	void SetBaseMaterialBySlotName(class UMeshComponent* InMeshComponent, class FName MaterialSlotName, class UMaterialInterface* InMaterialInterface);
	void SetOverrideMaterial(EDCMaterialType InMaterialType, class UMaterialInterface* InMaterialInterface, bool bInSetRenderingPriority);
	void SetOverrideMaterialValue(EDCMaterialType InMaterialType, const class FName& InKey, float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMaterialInterface">();
	}
	static class IDCMaterialInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCMaterialInterface>();
	}
};
static_assert(alignof(IDCMaterialInterface) == 0x000008, "Wrong alignment on IDCMaterialInterface");
static_assert(sizeof(IDCMaterialInterface) == 0x000028, "Wrong size on IDCMaterialInterface");

// Class DungeonCrawler.DCMeleeAttackDataAsset
// 0x0058 (0x00A0 - 0x0048)
class UDCMeleeAttackDataAsset final : public UDCTableDataAsset
{
public:
	float                                         DamageRatio;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitPlayRate;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitPlayRateDuration;                               // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStuckByHitBox;                                  // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F8[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterStuckPlayRate;                            // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterStuckPlayRateDuration;                    // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterStuckBlendOutTime;                        // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStuckByShield;                                  // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F9[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeakShieldStuckPlayRate;                           // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeakShieldStuckPlayRateDuration;                   // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeakShieldStuckBlendOutTime;                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidShieldStuckPlayRate;                            // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidShieldStuckPlayRateDuration;                    // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidShieldStuckBlendOutTime;                        // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyShieldStuckPlayRate;                          // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyShieldStuckPlayRateDuration;                  // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyShieldStuckBlendOutTime;                      // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStuckByStaticObject;                            // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FA[0x3];                                     // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticObjectStuckPlayRate;                         // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticObjectStuckPlayRateDuration;                 // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticObjectStuckBlendOutTime;                     // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FB[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMeleeAttackDataAsset">();
	}
	static class UDCMeleeAttackDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMeleeAttackDataAsset>();
	}
};
static_assert(alignof(UDCMeleeAttackDataAsset) == 0x000008, "Wrong alignment on UDCMeleeAttackDataAsset");
static_assert(sizeof(UDCMeleeAttackDataAsset) == 0x0000A0, "Wrong size on UDCMeleeAttackDataAsset");
static_assert(offsetof(UDCMeleeAttackDataAsset, DamageRatio) == 0x000048, "Member 'UDCMeleeAttackDataAsset::DamageRatio' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, HitPlayRate) == 0x00004C, "Member 'UDCMeleeAttackDataAsset::HitPlayRate' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, HitPlayRateDuration) == 0x000050, "Member 'UDCMeleeAttackDataAsset::HitPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, CanStuckByHitBox) == 0x000054, "Member 'UDCMeleeAttackDataAsset::CanStuckByHitBox' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, CharacterStuckPlayRate) == 0x000058, "Member 'UDCMeleeAttackDataAsset::CharacterStuckPlayRate' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, CharacterStuckPlayRateDuration) == 0x00005C, "Member 'UDCMeleeAttackDataAsset::CharacterStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, CharacterStuckBlendOutTime) == 0x000060, "Member 'UDCMeleeAttackDataAsset::CharacterStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, CanStuckByShield) == 0x000064, "Member 'UDCMeleeAttackDataAsset::CanStuckByShield' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, WeakShieldStuckPlayRate) == 0x000068, "Member 'UDCMeleeAttackDataAsset::WeakShieldStuckPlayRate' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, WeakShieldStuckPlayRateDuration) == 0x00006C, "Member 'UDCMeleeAttackDataAsset::WeakShieldStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, WeakShieldStuckBlendOutTime) == 0x000070, "Member 'UDCMeleeAttackDataAsset::WeakShieldStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, MidShieldStuckPlayRate) == 0x000074, "Member 'UDCMeleeAttackDataAsset::MidShieldStuckPlayRate' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, MidShieldStuckPlayRateDuration) == 0x000078, "Member 'UDCMeleeAttackDataAsset::MidShieldStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, MidShieldStuckBlendOutTime) == 0x00007C, "Member 'UDCMeleeAttackDataAsset::MidShieldStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, HeavyShieldStuckPlayRate) == 0x000080, "Member 'UDCMeleeAttackDataAsset::HeavyShieldStuckPlayRate' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, HeavyShieldStuckPlayRateDuration) == 0x000084, "Member 'UDCMeleeAttackDataAsset::HeavyShieldStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, HeavyShieldStuckBlendOutTime) == 0x000088, "Member 'UDCMeleeAttackDataAsset::HeavyShieldStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, CanStuckByStaticObject) == 0x00008C, "Member 'UDCMeleeAttackDataAsset::CanStuckByStaticObject' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, StaticObjectStuckPlayRate) == 0x000090, "Member 'UDCMeleeAttackDataAsset::StaticObjectStuckPlayRate' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, StaticObjectStuckPlayRateDuration) == 0x000094, "Member 'UDCMeleeAttackDataAsset::StaticObjectStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UDCMeleeAttackDataAsset, StaticObjectStuckBlendOutTime) == 0x000098, "Member 'UDCMeleeAttackDataAsset::StaticObjectStuckBlendOutTime' has a wrong offset!");

// Class DungeonCrawler.DCPlayUserInfoWidget
// 0x0020 (0x0410 - 0x03F0)
class UDCPlayUserInfoWidget final : public ULobbyUserSlotBase
{
public:
	bool                                          bIsInDungeon;                                      // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMine;                                           // 0x03F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPartyLeader;                                    // 0x03F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26FC[0x1];                                     // 0x03F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedLocationIndex;                               // 0x03F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PartyMemberGearScore;                              // 0x03F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWidgetPartyUserLocate                        PartyUserLocate;                                   // 0x03FC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26FD[0x3];                                     // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCInventoryGearScoreWidget*            MyGearScoreWidget;                                 // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoipUserWidget*                        VoipOnOffWidget;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLocationUpdate(const bool bIsReady, const int32 MetaLocationIndex);
	void OnPlayPartyUserState(const EWidgetPlayUserPartyState InPartyMemberState);
	void OnPlayUserInfo(const struct FPlayPartyUserInfo& InPlaypartyUserInfo);
	void OnUpdateLobbyCharacterInfo(const struct FLobbyCharacterInfo& InLobbyCharacterInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayUserInfoWidget">();
	}
	static class UDCPlayUserInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayUserInfoWidget>();
	}
};
static_assert(alignof(UDCPlayUserInfoWidget) == 0x000008, "Wrong alignment on UDCPlayUserInfoWidget");
static_assert(sizeof(UDCPlayUserInfoWidget) == 0x000410, "Wrong size on UDCPlayUserInfoWidget");
static_assert(offsetof(UDCPlayUserInfoWidget, bIsInDungeon) == 0x0003F0, "Member 'UDCPlayUserInfoWidget::bIsInDungeon' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, bIsMine) == 0x0003F1, "Member 'UDCPlayUserInfoWidget::bIsMine' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, bIsPartyLeader) == 0x0003F2, "Member 'UDCPlayUserInfoWidget::bIsPartyLeader' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, CachedLocationIndex) == 0x0003F4, "Member 'UDCPlayUserInfoWidget::CachedLocationIndex' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, PartyMemberGearScore) == 0x0003F8, "Member 'UDCPlayUserInfoWidget::PartyMemberGearScore' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, PartyUserLocate) == 0x0003FC, "Member 'UDCPlayUserInfoWidget::PartyUserLocate' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, MyGearScoreWidget) == 0x000400, "Member 'UDCPlayUserInfoWidget::MyGearScoreWidget' has a wrong offset!");
static_assert(offsetof(UDCPlayUserInfoWidget, VoipOnOffWidget) == 0x000408, "Member 'UDCPlayUserInfoWidget::VoipOnOffWidget' has a wrong offset!");

// Class DungeonCrawler.DCMerchantBaseGearWidget
// 0x0028 (0x02E8 - 0x02C0)
class UDCMerchantBaseGearWidget final : public UUserWidget
{
public:
	class UDCCommonButtonBase*                    ButtonSet;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonEquip;                                       // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCEquipmentWidget*                     BaseGearEquipWidget;                               // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnButtonEquip();
	void OnButtonSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantBaseGearWidget">();
	}
	static class UDCMerchantBaseGearWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantBaseGearWidget>();
	}
};
static_assert(alignof(UDCMerchantBaseGearWidget) == 0x000008, "Wrong alignment on UDCMerchantBaseGearWidget");
static_assert(sizeof(UDCMerchantBaseGearWidget) == 0x0002E8, "Wrong size on UDCMerchantBaseGearWidget");
static_assert(offsetof(UDCMerchantBaseGearWidget, ButtonSet) == 0x0002C0, "Member 'UDCMerchantBaseGearWidget::ButtonSet' has a wrong offset!");
static_assert(offsetof(UDCMerchantBaseGearWidget, ButtonEquip) == 0x0002C8, "Member 'UDCMerchantBaseGearWidget::ButtonEquip' has a wrong offset!");
static_assert(offsetof(UDCMerchantBaseGearWidget, MerchantInfoWidget) == 0x0002D0, "Member 'UDCMerchantBaseGearWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantBaseGearWidget, BaseGearEquipWidget) == 0x0002D8, "Member 'UDCMerchantBaseGearWidget::BaseGearEquipWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantBaseGearWidget, MerchantComponent) == 0x0002E0, "Member 'UDCMerchantBaseGearWidget::MerchantComponent' has a wrong offset!");

// Class DungeonCrawler.DCMerchantComponent
// 0x0570 (0x06F0 - 0x0180)
class UDCMerchantComponent final : public UDCInventoryContainerComponent
{
public:
	uint8                                         Pad_26FF[0x1F8];                                   // 0x0180(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          BuySound;                                          // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          SellSound;                                         // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          CraftSound;                                        // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          StashAllSound;                                     // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          EquipBaseGearsSound;                               // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          QuestCompleteSound;                                // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          MindewipeCompleteSound;                            // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWidgetMerchantServiceCategoryType            CategoryType;                                      // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCMerchantServiceType                        ServiceType;                                       // 0x03B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2700[0x6];                                     // 0x03BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCMerchantId                          MerchantId;                                        // 0x03C0(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDCMerchantInfo>                MerchantInfos;                                     // 0x03D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2701[0x190];                                   // 0x03E0(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                WishList;                                          // 0x0570(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCQuestChapterInfo>            QuestChapterList;                                  // 0x0580(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCQuestLogInfo>                QuestLogList;                                      // 0x0590(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCMerchantBaseGearItemId, struct FDCInventoryDataElement> SavedBaseGears;                                    // 0x05A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCItemId>                      RequiredItemsDealTable;                            // 0x05F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<EDCMerchantFilterType, struct FGameplayTag> SaleFilterMap;                                     // 0x0600(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<EDCMerchantFilterType, struct FGameplayTag> BaseGearFilterMap;                                 // 0x0650(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UDCQuestChapterDataAsset*               SelectedQuestChapterData;                          // 0x06A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SelectedQuestLogMerchantId;                        // 0x06A8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SelectedQuestLogChapterId;                         // 0x06B8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2702[0x14];                                    // 0x06C8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        ShortcutMerchantId;                                // 0x06DC(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2703[0x4];                                     // 0x06EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantComponent">();
	}
	static class UDCMerchantComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantComponent>();
	}
};
static_assert(alignof(UDCMerchantComponent) == 0x000008, "Wrong alignment on UDCMerchantComponent");
static_assert(sizeof(UDCMerchantComponent) == 0x0006F0, "Wrong size on UDCMerchantComponent");
static_assert(offsetof(UDCMerchantComponent, BuySound) == 0x000378, "Member 'UDCMerchantComponent::BuySound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, SellSound) == 0x000380, "Member 'UDCMerchantComponent::SellSound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, CraftSound) == 0x000388, "Member 'UDCMerchantComponent::CraftSound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, StashAllSound) == 0x000390, "Member 'UDCMerchantComponent::StashAllSound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, EquipBaseGearsSound) == 0x000398, "Member 'UDCMerchantComponent::EquipBaseGearsSound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, QuestCompleteSound) == 0x0003A0, "Member 'UDCMerchantComponent::QuestCompleteSound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, MindewipeCompleteSound) == 0x0003A8, "Member 'UDCMerchantComponent::MindewipeCompleteSound' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, InventoryComponent) == 0x0003B0, "Member 'UDCMerchantComponent::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, CategoryType) == 0x0003B8, "Member 'UDCMerchantComponent::CategoryType' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, ServiceType) == 0x0003B9, "Member 'UDCMerchantComponent::ServiceType' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, MerchantId) == 0x0003C0, "Member 'UDCMerchantComponent::MerchantId' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, MerchantInfos) == 0x0003D0, "Member 'UDCMerchantComponent::MerchantInfos' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, WishList) == 0x000570, "Member 'UDCMerchantComponent::WishList' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, QuestChapterList) == 0x000580, "Member 'UDCMerchantComponent::QuestChapterList' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, QuestLogList) == 0x000590, "Member 'UDCMerchantComponent::QuestLogList' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, SavedBaseGears) == 0x0005A0, "Member 'UDCMerchantComponent::SavedBaseGears' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, RequiredItemsDealTable) == 0x0005F0, "Member 'UDCMerchantComponent::RequiredItemsDealTable' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, SaleFilterMap) == 0x000600, "Member 'UDCMerchantComponent::SaleFilterMap' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, BaseGearFilterMap) == 0x000650, "Member 'UDCMerchantComponent::BaseGearFilterMap' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, SelectedQuestChapterData) == 0x0006A0, "Member 'UDCMerchantComponent::SelectedQuestChapterData' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, SelectedQuestLogMerchantId) == 0x0006A8, "Member 'UDCMerchantComponent::SelectedQuestLogMerchantId' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, SelectedQuestLogChapterId) == 0x0006B8, "Member 'UDCMerchantComponent::SelectedQuestLogChapterId' has a wrong offset!");
static_assert(offsetof(UDCMerchantComponent, ShortcutMerchantId) == 0x0006DC, "Member 'UDCMerchantComponent::ShortcutMerchantId' has a wrong offset!");

// Class DungeonCrawler.DCBaseGearDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCBaseGearDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCBaseGearItemData>            BaseGearItemArray;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCBaseGearDataAsset">();
	}
	static class UDCBaseGearDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCBaseGearDataAsset>();
	}
};
static_assert(alignof(UDCBaseGearDataAsset) == 0x000008, "Wrong alignment on UDCBaseGearDataAsset");
static_assert(sizeof(UDCBaseGearDataAsset) == 0x000058, "Wrong size on UDCBaseGearDataAsset");
static_assert(offsetof(UDCBaseGearDataAsset, BaseGearItemArray) == 0x000048, "Member 'UDCBaseGearDataAsset::BaseGearItemArray' has a wrong offset!");

// Class DungeonCrawler.DCStockSellBackDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCStockSellBackDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCStockSellBackItemData>       StockSellBackItemArray;                            // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStockSellBackDataAsset">();
	}
	static class UDCStockSellBackDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStockSellBackDataAsset>();
	}
};
static_assert(alignof(UDCStockSellBackDataAsset) == 0x000008, "Wrong alignment on UDCStockSellBackDataAsset");
static_assert(sizeof(UDCStockSellBackDataAsset) == 0x000058, "Wrong size on UDCStockSellBackDataAsset");
static_assert(offsetof(UDCStockSellBackDataAsset, StockSellBackItemArray) == 0x000048, "Member 'UDCStockSellBackDataAsset::StockSellBackItemArray' has a wrong offset!");

// Class DungeonCrawler.DCPortraitCharacter
// 0x00F0 (0x0830 - 0x0740)
class ADCPortraitCharacter : public ADCCharacterV2
{
public:
	struct FUint32Point                           Size;                                              // 0x0738(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCSceneCaptureComponent2D*             PortraitCaptureComponent;                          // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PortraitCaptureLocationChangeThreshold;            // 0x0748(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PortraitCaptureRotationChangeThreshold;            // 0x074C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PortraitCaptureLastLocation;                       // 0x0750(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               PortraitCaptureLastRotation;                       // 0x0768(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 PortraitRenderTarget;                              // 0x0780(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2704[0x10];                                    // 0x0788(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          DefaultSkeletalMesh;                               // 0x0798(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              DefaultAnimInstance;                               // 0x07A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             DefaultOverrideMaterials;                          // 0x07A8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2705[0x8];                                     // 0x07B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PortraitCaptureDefaultTransform;                   // 0x07C0(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCShapeShiftDataAsset*                 ShapeShiftDataAsset;                               // 0x0820(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CaptureTimerHandle;                                // 0x0828(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPortraitCharacter">();
	}
	static class ADCPortraitCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPortraitCharacter>();
	}
};
static_assert(alignof(ADCPortraitCharacter) == 0x000010, "Wrong alignment on ADCPortraitCharacter");
static_assert(sizeof(ADCPortraitCharacter) == 0x000830, "Wrong size on ADCPortraitCharacter");
static_assert(offsetof(ADCPortraitCharacter, Size) == 0x000738, "Member 'ADCPortraitCharacter::Size' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitCaptureComponent) == 0x000740, "Member 'ADCPortraitCharacter::PortraitCaptureComponent' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitCaptureLocationChangeThreshold) == 0x000748, "Member 'ADCPortraitCharacter::PortraitCaptureLocationChangeThreshold' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitCaptureRotationChangeThreshold) == 0x00074C, "Member 'ADCPortraitCharacter::PortraitCaptureRotationChangeThreshold' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitCaptureLastLocation) == 0x000750, "Member 'ADCPortraitCharacter::PortraitCaptureLastLocation' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitCaptureLastRotation) == 0x000768, "Member 'ADCPortraitCharacter::PortraitCaptureLastRotation' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitRenderTarget) == 0x000780, "Member 'ADCPortraitCharacter::PortraitRenderTarget' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, DefaultSkeletalMesh) == 0x000798, "Member 'ADCPortraitCharacter::DefaultSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, DefaultAnimInstance) == 0x0007A0, "Member 'ADCPortraitCharacter::DefaultAnimInstance' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, DefaultOverrideMaterials) == 0x0007A8, "Member 'ADCPortraitCharacter::DefaultOverrideMaterials' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, PortraitCaptureDefaultTransform) == 0x0007C0, "Member 'ADCPortraitCharacter::PortraitCaptureDefaultTransform' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, ShapeShiftDataAsset) == 0x000820, "Member 'ADCPortraitCharacter::ShapeShiftDataAsset' has a wrong offset!");
static_assert(offsetof(ADCPortraitCharacter, CaptureTimerHandle) == 0x000828, "Member 'ADCPortraitCharacter::CaptureTimerHandle' has a wrong offset!");

// Class DungeonCrawler.DCStockBuyDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCStockBuyDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCStockBuyItemData>            StockBuyItemArray;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStockBuyDataAsset">();
	}
	static class UDCStockBuyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStockBuyDataAsset>();
	}
};
static_assert(alignof(UDCStockBuyDataAsset) == 0x000008, "Wrong alignment on UDCStockBuyDataAsset");
static_assert(sizeof(UDCStockBuyDataAsset) == 0x000058, "Wrong size on UDCStockBuyDataAsset");
static_assert(offsetof(UDCStockBuyDataAsset, StockBuyItemArray) == 0x000048, "Member 'UDCStockBuyDataAsset::StockBuyItemArray' has a wrong offset!");

// Class DungeonCrawler.DCStockCraftDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCStockCraftDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCStockCraftItemData>          StockCraftItemArray;                               // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStockCraftDataAsset">();
	}
	static class UDCStockCraftDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStockCraftDataAsset>();
	}
};
static_assert(alignof(UDCStockCraftDataAsset) == 0x000008, "Wrong alignment on UDCStockCraftDataAsset");
static_assert(sizeof(UDCStockCraftDataAsset) == 0x000058, "Wrong size on UDCStockCraftDataAsset");
static_assert(offsetof(UDCStockCraftDataAsset, StockCraftItemArray) == 0x000048, "Member 'UDCStockCraftDataAsset::StockCraftItemArray' has a wrong offset!");

// Class DungeonCrawler.DCMerchantAffinityDataAsset
// 0x0018 (0x0060 - 0x0048)
class UDCMerchantAffinityDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCMerchantAffinityDataAsset;                  // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantAffinityDataAsset">();
	}
	static class UDCMerchantAffinityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantAffinityDataAsset>();
	}
};
static_assert(alignof(UDCMerchantAffinityDataAsset) == 0x000008, "Wrong alignment on UDCMerchantAffinityDataAsset");
static_assert(sizeof(UDCMerchantAffinityDataAsset) == 0x000060, "Wrong size on UDCMerchantAffinityDataAsset");
static_assert(offsetof(UDCMerchantAffinityDataAsset, Name_DCMerchantAffinityDataAsset) == 0x000048, "Member 'UDCMerchantAffinityDataAsset::Name_DCMerchantAffinityDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCMerchantDataAsset
// 0x0068 (0x00B0 - 0x0048)
class UDCMerchantDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCMerchantDataAsset;                          // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   GreetingText;                                      // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataMerchant>        ArtData;                                           // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDCMerchantServiceType>                ServiceTypes;                                      // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantDataAsset">();
	}
	static class UDCMerchantDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantDataAsset>();
	}
};
static_assert(alignof(UDCMerchantDataAsset) == 0x000008, "Wrong alignment on UDCMerchantDataAsset");
static_assert(sizeof(UDCMerchantDataAsset) == 0x0000B0, "Wrong size on UDCMerchantDataAsset");
static_assert(offsetof(UDCMerchantDataAsset, Name_DCMerchantDataAsset) == 0x000048, "Member 'UDCMerchantDataAsset::Name_DCMerchantDataAsset' has a wrong offset!");
static_assert(offsetof(UDCMerchantDataAsset, GreetingText) == 0x000060, "Member 'UDCMerchantDataAsset::GreetingText' has a wrong offset!");
static_assert(offsetof(UDCMerchantDataAsset, ArtData) == 0x000078, "Member 'UDCMerchantDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCMerchantDataAsset, ServiceTypes) == 0x0000A0, "Member 'UDCMerchantDataAsset::ServiceTypes' has a wrong offset!");

// Class DungeonCrawler.DCPriceWidget
// 0x0008 (0x02C8 - 0x02C0)
class UDCPriceWidget final : public UUserWidget
{
public:
	struct FDCPrice                               Price;                                             // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPriceWidget">();
	}
	static class UDCPriceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPriceWidget>();
	}
};
static_assert(alignof(UDCPriceWidget) == 0x000008, "Wrong alignment on UDCPriceWidget");
static_assert(sizeof(UDCPriceWidget) == 0x0002C8, "Wrong size on UDCPriceWidget");
static_assert(offsetof(UDCPriceWidget, Price) == 0x0002C0, "Member 'UDCPriceWidget::Price' has a wrong offset!");

// Class DungeonCrawler.DCMerchantDealTablePurchaseWidget
// 0x0058 (0x0318 - 0x02C0)
class UDCMerchantDealTablePurchaseWidget final : public UUserWidget
{
public:
	TSubclassOf<class UDCMerchantRequiredEntryWidget> PurchaseItemWidgetClass;                           // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonFill;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonDeal;                                        // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              RemainTimespan;                                    // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRequiredItems;                                 // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2706[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCButtonNumberSetterWidget*            CountSetterWidget;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCMerchantServiceType                        WidgetServiceType;                                 // 0x02F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2707[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantItemWidget*                  TargetItemWidget;                                  // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         PurchaseItemHorizontalBox;                         // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantComponent*                   Comp;                                              // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnButtonDeal();
	void OnButtonFill();

	bool IsRequiredItemsFilled() const;
	bool IsTargetItemSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantDealTablePurchaseWidget">();
	}
	static class UDCMerchantDealTablePurchaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantDealTablePurchaseWidget>();
	}
};
static_assert(alignof(UDCMerchantDealTablePurchaseWidget) == 0x000008, "Wrong alignment on UDCMerchantDealTablePurchaseWidget");
static_assert(sizeof(UDCMerchantDealTablePurchaseWidget) == 0x000318, "Wrong size on UDCMerchantDealTablePurchaseWidget");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, PurchaseItemWidgetClass) == 0x0002C0, "Member 'UDCMerchantDealTablePurchaseWidget::PurchaseItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, ButtonFill) == 0x0002C8, "Member 'UDCMerchantDealTablePurchaseWidget::ButtonFill' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, ButtonDeal) == 0x0002D0, "Member 'UDCMerchantDealTablePurchaseWidget::ButtonDeal' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, RemainTimespan) == 0x0002D8, "Member 'UDCMerchantDealTablePurchaseWidget::RemainTimespan' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, bHasRequiredItems) == 0x0002E0, "Member 'UDCMerchantDealTablePurchaseWidget::bHasRequiredItems' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, CountSetterWidget) == 0x0002E8, "Member 'UDCMerchantDealTablePurchaseWidget::CountSetterWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, WidgetServiceType) == 0x0002F0, "Member 'UDCMerchantDealTablePurchaseWidget::WidgetServiceType' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, MerchantInfoWidget) == 0x0002F8, "Member 'UDCMerchantDealTablePurchaseWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, TargetItemWidget) == 0x000300, "Member 'UDCMerchantDealTablePurchaseWidget::TargetItemWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, PurchaseItemHorizontalBox) == 0x000308, "Member 'UDCMerchantDealTablePurchaseWidget::PurchaseItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTablePurchaseWidget, Comp) == 0x000310, "Member 'UDCMerchantDealTablePurchaseWidget::Comp' has a wrong offset!");

// Class DungeonCrawler.DCMerchantDealTableQuestWidget
// 0x0110 (0x03D0 - 0x02C0)
class UDCMerchantDealTableQuestWidget final : public UUserWidget
{
public:
	class UDCCommonButtonBase*                    ButtonAccept;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonComplete;                                    // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCQuestCompleteResultPopup> QuestCompleteResultPopupClass;                     // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RequiredLevelText;                                 // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequiredQuestText;                                 // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequiredAffinityText;                              // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRewardItemWidget>        RewardItemWidgetClass;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UListView*                              RequirementListView;                               // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         RewardItemHorizontalBox;                           // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCQuestRequirementFetchWidget*         FetchRequiredWidget;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCQuestInfo                           QuestInfo;                                         // 0x0348(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FDCMerchantId                          MerchantId;                                        // 0x0398(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCQuestCompleteInfo                   QuestCompleteInfo;                                 // 0x03A8(0x0028)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnButtonAccept();
	void OnButtonComplete();
	void OnButtonItemDeliver();
	void OnQuestInfoUpdated();

	EDCQuestState GetQuestState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantDealTableQuestWidget">();
	}
	static class UDCMerchantDealTableQuestWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantDealTableQuestWidget>();
	}
};
static_assert(alignof(UDCMerchantDealTableQuestWidget) == 0x000008, "Wrong alignment on UDCMerchantDealTableQuestWidget");
static_assert(sizeof(UDCMerchantDealTableQuestWidget) == 0x0003D0, "Wrong size on UDCMerchantDealTableQuestWidget");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, ButtonAccept) == 0x0002C0, "Member 'UDCMerchantDealTableQuestWidget::ButtonAccept' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, ButtonComplete) == 0x0002C8, "Member 'UDCMerchantDealTableQuestWidget::ButtonComplete' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, QuestCompleteResultPopupClass) == 0x0002D0, "Member 'UDCMerchantDealTableQuestWidget::QuestCompleteResultPopupClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, RequiredLevelText) == 0x0002D8, "Member 'UDCMerchantDealTableQuestWidget::RequiredLevelText' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, RequiredQuestText) == 0x0002F0, "Member 'UDCMerchantDealTableQuestWidget::RequiredQuestText' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, RequiredAffinityText) == 0x000308, "Member 'UDCMerchantDealTableQuestWidget::RequiredAffinityText' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, RewardItemWidgetClass) == 0x000320, "Member 'UDCMerchantDealTableQuestWidget::RewardItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, MerchantInfoWidget) == 0x000328, "Member 'UDCMerchantDealTableQuestWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, RequirementListView) == 0x000330, "Member 'UDCMerchantDealTableQuestWidget::RequirementListView' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, RewardItemHorizontalBox) == 0x000338, "Member 'UDCMerchantDealTableQuestWidget::RewardItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, FetchRequiredWidget) == 0x000340, "Member 'UDCMerchantDealTableQuestWidget::FetchRequiredWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, QuestInfo) == 0x000348, "Member 'UDCMerchantDealTableQuestWidget::QuestInfo' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, MerchantId) == 0x000398, "Member 'UDCMerchantDealTableQuestWidget::MerchantId' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableQuestWidget, QuestCompleteInfo) == 0x0003A8, "Member 'UDCMerchantDealTableQuestWidget::QuestCompleteInfo' has a wrong offset!");

// Class DungeonCrawler.DCMerchantDealTableSellWidget
// 0x0028 (0x0408 - 0x03E0)
class UDCMerchantDealTableSellWidget final : public UDCInventoryWidgetBase
{
public:
	class UDCCommonButtonBase*                    ButtonDeal;                                        // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           DealTableWidget;                                   // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDCItemId>                      PrevItems;                                         // 0x03F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnButtonDeal();
	void OnInventoryUpdated();

	int32 GetPrice() const;
	bool IsSellEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantDealTableSellWidget">();
	}
	static class UDCMerchantDealTableSellWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantDealTableSellWidget>();
	}
};
static_assert(alignof(UDCMerchantDealTableSellWidget) == 0x000008, "Wrong alignment on UDCMerchantDealTableSellWidget");
static_assert(sizeof(UDCMerchantDealTableSellWidget) == 0x000408, "Wrong size on UDCMerchantDealTableSellWidget");
static_assert(offsetof(UDCMerchantDealTableSellWidget, ButtonDeal) == 0x0003E0, "Member 'UDCMerchantDealTableSellWidget::ButtonDeal' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableSellWidget, MerchantInfoWidget) == 0x0003E8, "Member 'UDCMerchantDealTableSellWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableSellWidget, DealTableWidget) == 0x0003F0, "Member 'UDCMerchantDealTableSellWidget::DealTableWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantDealTableSellWidget, PrevItems) == 0x0003F8, "Member 'UDCMerchantDealTableSellWidget::PrevItems' has a wrong offset!");

// Class DungeonCrawler.DCMerchantInfoWidget
// 0x0068 (0x0328 - 0x02C0)
class UDCMerchantInfoWidget final : public UUserWidget
{
public:
	class FText                                   Name_DCMerchantInfoWidget;                         // 0x02C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Text;                                              // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UDCMerchantStatWidget*                  StatWidget;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Portrait;                                          // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   GreetingText;                                      // 0x0300(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FDCMerchantId                          MerchantId;                                        // 0x0318(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetInGameMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantInfoWidget">();
	}
	static class UDCMerchantInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantInfoWidget>();
	}
};
static_assert(alignof(UDCMerchantInfoWidget) == 0x000008, "Wrong alignment on UDCMerchantInfoWidget");
static_assert(sizeof(UDCMerchantInfoWidget) == 0x000328, "Wrong size on UDCMerchantInfoWidget");
static_assert(offsetof(UDCMerchantInfoWidget, Name_DCMerchantInfoWidget) == 0x0002C0, "Member 'UDCMerchantInfoWidget::Name_DCMerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantInfoWidget, Text) == 0x0002D8, "Member 'UDCMerchantInfoWidget::Text' has a wrong offset!");
static_assert(offsetof(UDCMerchantInfoWidget, StatWidget) == 0x0002F0, "Member 'UDCMerchantInfoWidget::StatWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantInfoWidget, Portrait) == 0x0002F8, "Member 'UDCMerchantInfoWidget::Portrait' has a wrong offset!");
static_assert(offsetof(UDCMerchantInfoWidget, GreetingText) == 0x000300, "Member 'UDCMerchantInfoWidget::GreetingText' has a wrong offset!");
static_assert(offsetof(UDCMerchantInfoWidget, MerchantId) == 0x000318, "Member 'UDCMerchantInfoWidget::MerchantId' has a wrong offset!");

// Class DungeonCrawler.DCPropAttributeSet
// 0x0000 (0x0AC0 - 0x0AC0)
class UDCPropAttributeSet final : public UDCAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPropAttributeSet">();
	}
	static class UDCPropAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPropAttributeSet>();
	}
};
static_assert(alignof(UDCPropAttributeSet) == 0x000008, "Wrong alignment on UDCPropAttributeSet");
static_assert(sizeof(UDCPropAttributeSet) == 0x000AC0, "Wrong size on UDCPropAttributeSet");

// Class DungeonCrawler.DCMerchantItemWidget
// 0x0040 (0x06A0 - 0x0660)
class UDCMerchantItemWidget : public UDCItemWidgetBase
{
public:
	TSubclassOf<class UDCItemTooltipWidget>       ItemTooltipWidgetClass;                            // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCQuestItemGroupTooltipWidget> ItemGroupTooltipWidgetClass;                       // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DealTableCount;                                    // 0x0670(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCItemGroupInfo                       GroupInfo;                                         // 0x0674(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EDCItemLootState                              LootState;                                         // 0x0684(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsItemRarityAny;                                  // 0x0685(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2708[0x2];                                     // 0x0686(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulkCount;                                         // 0x0688(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2709[0x4];                                     // 0x068C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ItemImage;                                         // 0x0690(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               ItemSizeBox;                                       // 0x0698(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetMerchantItemTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantItemWidget">();
	}
	static class UDCMerchantItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantItemWidget>();
	}
};
static_assert(alignof(UDCMerchantItemWidget) == 0x000008, "Wrong alignment on UDCMerchantItemWidget");
static_assert(sizeof(UDCMerchantItemWidget) == 0x0006A0, "Wrong size on UDCMerchantItemWidget");
static_assert(offsetof(UDCMerchantItemWidget, ItemTooltipWidgetClass) == 0x000660, "Member 'UDCMerchantItemWidget::ItemTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, ItemGroupTooltipWidgetClass) == 0x000668, "Member 'UDCMerchantItemWidget::ItemGroupTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, DealTableCount) == 0x000670, "Member 'UDCMerchantItemWidget::DealTableCount' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, GroupInfo) == 0x000674, "Member 'UDCMerchantItemWidget::GroupInfo' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, LootState) == 0x000684, "Member 'UDCMerchantItemWidget::LootState' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, bIsItemRarityAny) == 0x000685, "Member 'UDCMerchantItemWidget::bIsItemRarityAny' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, BulkCount) == 0x000688, "Member 'UDCMerchantItemWidget::BulkCount' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, ItemImage) == 0x000690, "Member 'UDCMerchantItemWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(UDCMerchantItemWidget, ItemSizeBox) == 0x000698, "Member 'UDCMerchantItemWidget::ItemSizeBox' has a wrong offset!");

// Class DungeonCrawler.DCMerchantListEntryWidgetData
// 0x0050 (0x0078 - 0x0028)
class UDCMerchantListEntryWidgetData final : public UObject
{
public:
	struct FDCMerchantInfo                        Info;                                              // 0x0028(0x0040)(Transient, NativeAccessSpecifierPublic)
	class UDCMerchantDataAsset*                   DataAsset;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            Widget;                                            // 0x0070(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantListEntryWidgetData">();
	}
	static class UDCMerchantListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantListEntryWidgetData>();
	}
};
static_assert(alignof(UDCMerchantListEntryWidgetData) == 0x000008, "Wrong alignment on UDCMerchantListEntryWidgetData");
static_assert(sizeof(UDCMerchantListEntryWidgetData) == 0x000078, "Wrong size on UDCMerchantListEntryWidgetData");
static_assert(offsetof(UDCMerchantListEntryWidgetData, Info) == 0x000028, "Member 'UDCMerchantListEntryWidgetData::Info' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidgetData, DataAsset) == 0x000068, "Member 'UDCMerchantListEntryWidgetData::DataAsset' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidgetData, Widget) == 0x000070, "Member 'UDCMerchantListEntryWidgetData::Widget' has a wrong offset!");

// Class DungeonCrawler.DCMerchantListEntryWidget
// 0x0060 (0x0320 - 0x02C0)
class UDCMerchantListEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_270A[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_DCMerchantListEntryWidget;                    // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class USoundData*                             SoundData;                                         // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Portrait;                                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantStatWidget*                  StatWidget;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCMerchantId                          ID;                                                // 0x02F8(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EDCMerchantServiceType>                Services;                                          // 0x0308(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bMouseButtonDown;                                  // 0x0318(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270B[0x7];                                     // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsOnNewAlram() const;
	bool IsOnSuccesAlram() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantListEntryWidget">();
	}
	static class UDCMerchantListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantListEntryWidget>();
	}
};
static_assert(alignof(UDCMerchantListEntryWidget) == 0x000008, "Wrong alignment on UDCMerchantListEntryWidget");
static_assert(sizeof(UDCMerchantListEntryWidget) == 0x000320, "Wrong size on UDCMerchantListEntryWidget");
static_assert(offsetof(UDCMerchantListEntryWidget, Name_DCMerchantListEntryWidget) == 0x0002C8, "Member 'UDCMerchantListEntryWidget::Name_DCMerchantListEntryWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidget, SoundData) == 0x0002E0, "Member 'UDCMerchantListEntryWidget::SoundData' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidget, Portrait) == 0x0002E8, "Member 'UDCMerchantListEntryWidget::Portrait' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidget, StatWidget) == 0x0002F0, "Member 'UDCMerchantListEntryWidget::StatWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidget, ID) == 0x0002F8, "Member 'UDCMerchantListEntryWidget::ID' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidget, Services) == 0x000308, "Member 'UDCMerchantListEntryWidget::Services' has a wrong offset!");
static_assert(offsetof(UDCMerchantListEntryWidget, bMouseButtonDown) == 0x000318, "Member 'UDCMerchantListEntryWidget::bMouseButtonDown' has a wrong offset!");

// Class DungeonCrawler.DCMerchantListPageWidget
// 0x0008 (0x04C0 - 0x04B8)
class UDCMerchantListPageWidget final : public ULobbyGroupWidgetBase
{
public:
	class UTileView*                              TileView;                                          // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSetCompletedTileView();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantListPageWidget">();
	}
	static class UDCMerchantListPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantListPageWidget>();
	}
};
static_assert(alignof(UDCMerchantListPageWidget) == 0x000008, "Wrong alignment on UDCMerchantListPageWidget");
static_assert(sizeof(UDCMerchantListPageWidget) == 0x0004C0, "Wrong size on UDCMerchantListPageWidget");
static_assert(offsetof(UDCMerchantListPageWidget, TileView) == 0x0004B8, "Member 'UDCMerchantListPageWidget::TileView' has a wrong offset!");

// Class DungeonCrawler.DCReligionBlessingDataAsset
// 0x0080 (0x00C8 - 0x0048)
class UDCReligionBlessingDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCReligionBlessingDataAsset;                  // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCReligionDataAsset>    Religion;                                          // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               DescData;                                          // 0x0098(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270C[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionBlessingDataAsset">();
	}
	static class UDCReligionBlessingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionBlessingDataAsset>();
	}
};
static_assert(alignof(UDCReligionBlessingDataAsset) == 0x000008, "Wrong alignment on UDCReligionBlessingDataAsset");
static_assert(sizeof(UDCReligionBlessingDataAsset) == 0x0000C8, "Wrong size on UDCReligionBlessingDataAsset");
static_assert(offsetof(UDCReligionBlessingDataAsset, Name_DCReligionBlessingDataAsset) == 0x000048, "Member 'UDCReligionBlessingDataAsset::Name_DCReligionBlessingDataAsset' has a wrong offset!");
static_assert(offsetof(UDCReligionBlessingDataAsset, Religion) == 0x000060, "Member 'UDCReligionBlessingDataAsset::Religion' has a wrong offset!");
static_assert(offsetof(UDCReligionBlessingDataAsset, Effects) == 0x000088, "Member 'UDCReligionBlessingDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCReligionBlessingDataAsset, DescData) == 0x000098, "Member 'UDCReligionBlessingDataAsset::DescData' has a wrong offset!");
static_assert(offsetof(UDCReligionBlessingDataAsset, Level) == 0x0000C0, "Member 'UDCReligionBlessingDataAsset::Level' has a wrong offset!");

// Class DungeonCrawler.DCMerchantMenuWidget
// 0x0000 (0x02C0 - 0x02C0)
class UDCMerchantMenuWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantMenuWidget">();
	}
	static class UDCMerchantMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantMenuWidget>();
	}
};
static_assert(alignof(UDCMerchantMenuWidget) == 0x000008, "Wrong alignment on UDCMerchantMenuWidget");
static_assert(sizeof(UDCMerchantMenuWidget) == 0x0002C0, "Wrong size on UDCMerchantMenuWidget");

// Class DungeonCrawler.DCMerchantMindwipeWidget
// 0x0048 (0x0308 - 0x02C0)
class UDCMerchantMindwipeWidget final : public UUserWidget
{
public:
	class UDCCommonButtonBase*                    ButtonForget;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              RemainResetTime;                                   // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainGauge;                                       // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MindwipePrice;                                     // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCPurchaseConfirmPopupWidget> PurchaseConfirmPopupWidgetClass;                   // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCMindwipeInfo                        MindwipeInfo;                                      // 0x02F0(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnButtonForget();

	const bool GetCanMindwipe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantMindwipeWidget">();
	}
	static class UDCMerchantMindwipeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantMindwipeWidget>();
	}
};
static_assert(alignof(UDCMerchantMindwipeWidget) == 0x000008, "Wrong alignment on UDCMerchantMindwipeWidget");
static_assert(sizeof(UDCMerchantMindwipeWidget) == 0x000308, "Wrong size on UDCMerchantMindwipeWidget");
static_assert(offsetof(UDCMerchantMindwipeWidget, ButtonForget) == 0x0002C0, "Member 'UDCMerchantMindwipeWidget::ButtonForget' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, RemainResetTime) == 0x0002C8, "Member 'UDCMerchantMindwipeWidget::RemainResetTime' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, RemainGauge) == 0x0002D0, "Member 'UDCMerchantMindwipeWidget::RemainGauge' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, MindwipePrice) == 0x0002D4, "Member 'UDCMerchantMindwipeWidget::MindwipePrice' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, PurchaseConfirmPopupWidgetClass) == 0x0002D8, "Member 'UDCMerchantMindwipeWidget::PurchaseConfirmPopupWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, MerchantInfoWidget) == 0x0002E0, "Member 'UDCMerchantMindwipeWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, MerchantComponent) == 0x0002E8, "Member 'UDCMerchantMindwipeWidget::MerchantComponent' has a wrong offset!");
static_assert(offsetof(UDCMerchantMindwipeWidget, MindwipeInfo) == 0x0002F0, "Member 'UDCMerchantMindwipeWidget::MindwipeInfo' has a wrong offset!");

// Class DungeonCrawler.DCMerchantFilterWidgetDataBase
// 0x0010 (0x0050 - 0x0040)
class UDCMerchantFilterWidgetDataBase final : public UDCSearchableComboBoxWidgetDataBase
{
public:
	EDCMerchantFilterType                         FilterType;                                        // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270D[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FilterTag;                                         // 0x0044(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270E[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantFilterWidgetDataBase">();
	}
	static class UDCMerchantFilterWidgetDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantFilterWidgetDataBase>();
	}
};
static_assert(alignof(UDCMerchantFilterWidgetDataBase) == 0x000008, "Wrong alignment on UDCMerchantFilterWidgetDataBase");
static_assert(sizeof(UDCMerchantFilterWidgetDataBase) == 0x000050, "Wrong size on UDCMerchantFilterWidgetDataBase");
static_assert(offsetof(UDCMerchantFilterWidgetDataBase, FilterType) == 0x000040, "Member 'UDCMerchantFilterWidgetDataBase::FilterType' has a wrong offset!");
static_assert(offsetof(UDCMerchantFilterWidgetDataBase, FilterTag) == 0x000044, "Member 'UDCMerchantFilterWidgetDataBase::FilterTag' has a wrong offset!");

// Class DungeonCrawler.DCMerchantPageWidget
// 0x0170 (0x0628 - 0x04B8)
class UDCMerchantPageWidget final : public ULobbyGroupWidgetBase
{
public:
	class UDCSearchableComboBoxWidget*            TradeItemNameFilter;                               // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            TradeItemRarityFilter;                             // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            BaseGearSlotFilter;                                // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSearchableComboBoxWidget*            BaseGearRarityFilter;                              // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ButtonBack;                                        // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventorySale;                                     // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventoryWish;                                     // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventoryCraft;                                    // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventoryBaseGear;                                 // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventoryMindwipe;                                 // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             SaleScrollBox;                                     // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             CraftScrollBox;                                    // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             BaseGearScrollBox;                                 // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventoryDungeonRecoveries;                        // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBagWidget*                           InventoryDungeonExpress;                           // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventorySetWidget*                  PlayerInventorySet;                                // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventorySetWidget*                  PlayerStashSet;                                    // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterInventoryWidget*            QuickPrepareCharacterInventory;                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantDealTablePurchaseWidget*     DealTableBuyWidget;                                // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantDealTableSellWidget*         DealTableSellWidget;                               // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantDealTablePurchaseWidget*     DealTableCraftWidget;                              // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantDealTableQuestWidget*        DealTableQuestWidget;                              // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantQuickPrepareWidget*          DealTableQuickPrepareWidget;                       // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantBaseGearWidget*              DealTableBaseGearWidget;                           // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantMindwipeWidget*              DealTableMindwipeWidget;                           // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantDealTablePurchaseWidget*     DealTableBuyRecoveryWidget;                        // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantDealTablePurchaseWidget*     DealTableBuyExpressWidget;                         // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        DummyInventory;                                    // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCTabListWidgetBase*                   MerchantTabList;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCTabListWidgetBase*                   TradeTabList;                                      // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCTabListWidgetBase*                   ServiceTabList;                                    // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCTabListWidgetBase*                   QuestTabList;                                      // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDCMerchantFilterType, struct FGameplayTag> FilterMap;                                         // 0x05C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<EDCMerchantMarker>                     MarkNotifyArray;                                   // 0x0610(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270F[0x8];                                     // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonBack();
	void OnCategoryTabSelected(class FName TabId);
	void OnComboBoxItemSelectionChanged(class UObject* SelectedItem);
	void OnComboBoxItemSelectionCleared(class UObject* SelectedItem);
	void OnServiceTabSelected(class FName TabId);
	void OnServiceTypeChanged(EDCMerchantServiceType ServiceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantPageWidget">();
	}
	static class UDCMerchantPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantPageWidget>();
	}
};
static_assert(alignof(UDCMerchantPageWidget) == 0x000008, "Wrong alignment on UDCMerchantPageWidget");
static_assert(sizeof(UDCMerchantPageWidget) == 0x000628, "Wrong size on UDCMerchantPageWidget");
static_assert(offsetof(UDCMerchantPageWidget, TradeItemNameFilter) == 0x0004B8, "Member 'UDCMerchantPageWidget::TradeItemNameFilter' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, TradeItemRarityFilter) == 0x0004C0, "Member 'UDCMerchantPageWidget::TradeItemRarityFilter' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, BaseGearSlotFilter) == 0x0004C8, "Member 'UDCMerchantPageWidget::BaseGearSlotFilter' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, BaseGearRarityFilter) == 0x0004D0, "Member 'UDCMerchantPageWidget::BaseGearRarityFilter' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, ButtonBack) == 0x0004D8, "Member 'UDCMerchantPageWidget::ButtonBack' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventorySale) == 0x0004E0, "Member 'UDCMerchantPageWidget::InventorySale' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventoryWish) == 0x0004E8, "Member 'UDCMerchantPageWidget::InventoryWish' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventoryCraft) == 0x0004F0, "Member 'UDCMerchantPageWidget::InventoryCraft' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventoryBaseGear) == 0x0004F8, "Member 'UDCMerchantPageWidget::InventoryBaseGear' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventoryMindwipe) == 0x000500, "Member 'UDCMerchantPageWidget::InventoryMindwipe' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, SaleScrollBox) == 0x000508, "Member 'UDCMerchantPageWidget::SaleScrollBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, CraftScrollBox) == 0x000510, "Member 'UDCMerchantPageWidget::CraftScrollBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, BaseGearScrollBox) == 0x000518, "Member 'UDCMerchantPageWidget::BaseGearScrollBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventoryDungeonRecoveries) == 0x000520, "Member 'UDCMerchantPageWidget::InventoryDungeonRecoveries' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, InventoryDungeonExpress) == 0x000528, "Member 'UDCMerchantPageWidget::InventoryDungeonExpress' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, PlayerInventorySet) == 0x000530, "Member 'UDCMerchantPageWidget::PlayerInventorySet' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, PlayerStashSet) == 0x000538, "Member 'UDCMerchantPageWidget::PlayerStashSet' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, QuickPrepareCharacterInventory) == 0x000540, "Member 'UDCMerchantPageWidget::QuickPrepareCharacterInventory' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableBuyWidget) == 0x000548, "Member 'UDCMerchantPageWidget::DealTableBuyWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableSellWidget) == 0x000550, "Member 'UDCMerchantPageWidget::DealTableSellWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableCraftWidget) == 0x000558, "Member 'UDCMerchantPageWidget::DealTableCraftWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableQuestWidget) == 0x000560, "Member 'UDCMerchantPageWidget::DealTableQuestWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableQuickPrepareWidget) == 0x000568, "Member 'UDCMerchantPageWidget::DealTableQuickPrepareWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableBaseGearWidget) == 0x000570, "Member 'UDCMerchantPageWidget::DealTableBaseGearWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableMindwipeWidget) == 0x000578, "Member 'UDCMerchantPageWidget::DealTableMindwipeWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableBuyRecoveryWidget) == 0x000580, "Member 'UDCMerchantPageWidget::DealTableBuyRecoveryWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DealTableBuyExpressWidget) == 0x000588, "Member 'UDCMerchantPageWidget::DealTableBuyExpressWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, DummyInventory) == 0x000590, "Member 'UDCMerchantPageWidget::DummyInventory' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, MerchantTabList) == 0x000598, "Member 'UDCMerchantPageWidget::MerchantTabList' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, TradeTabList) == 0x0005A0, "Member 'UDCMerchantPageWidget::TradeTabList' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, ServiceTabList) == 0x0005A8, "Member 'UDCMerchantPageWidget::ServiceTabList' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, QuestTabList) == 0x0005B0, "Member 'UDCMerchantPageWidget::QuestTabList' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, MerchantComponent) == 0x0005B8, "Member 'UDCMerchantPageWidget::MerchantComponent' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, FilterMap) == 0x0005C0, "Member 'UDCMerchantPageWidget::FilterMap' has a wrong offset!");
static_assert(offsetof(UDCMerchantPageWidget, MarkNotifyArray) == 0x000610, "Member 'UDCMerchantPageWidget::MarkNotifyArray' has a wrong offset!");

// Class DungeonCrawler.DCReligionKillPopup
// 0x0030 (0x04C0 - 0x0490)
class UDCReligionKillPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionKillWidget*                  SolarisWidget;                                     // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionKillWidget*                  NoxulonWidget;                                     // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionKillWidget*                  ZorinWidget;                                       // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionKillWidget*                  BlytharWidget;                                     // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionKillPopupData*               ReligionkillPopupData;                             // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionKillPopup">();
	}
	static class UDCReligionKillPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionKillPopup>();
	}
};
static_assert(alignof(UDCReligionKillPopup) == 0x000008, "Wrong alignment on UDCReligionKillPopup");
static_assert(sizeof(UDCReligionKillPopup) == 0x0004C0, "Wrong size on UDCReligionKillPopup");
static_assert(offsetof(UDCReligionKillPopup, Btn_One_Confirm) == 0x000490, "Member 'UDCReligionKillPopup::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCReligionKillPopup, SolarisWidget) == 0x000498, "Member 'UDCReligionKillPopup::SolarisWidget' has a wrong offset!");
static_assert(offsetof(UDCReligionKillPopup, NoxulonWidget) == 0x0004A0, "Member 'UDCReligionKillPopup::NoxulonWidget' has a wrong offset!");
static_assert(offsetof(UDCReligionKillPopup, ZorinWidget) == 0x0004A8, "Member 'UDCReligionKillPopup::ZorinWidget' has a wrong offset!");
static_assert(offsetof(UDCReligionKillPopup, BlytharWidget) == 0x0004B0, "Member 'UDCReligionKillPopup::BlytharWidget' has a wrong offset!");
static_assert(offsetof(UDCReligionKillPopup, ReligionkillPopupData) == 0x0004B8, "Member 'UDCReligionKillPopup::ReligionkillPopupData' has a wrong offset!");

// Class DungeonCrawler.DCMerchantQuickPrepareWidget
// 0x0040 (0x0300 - 0x02C0)
class UDCMerchantQuickPrepareWidget final : public UUserWidget
{
public:
	class UDCCommonButtonBase*                    ButtonStashAll;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantInfoWidget*                  MerchantInfoWidget;                                // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             TargetScrollBox;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         TargetHorizontalBox;                               // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDCItemWidgetBase>          TargetItemWidgetClass;                             // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2710[0x10];                                    // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonStashAll();

	bool HasAnyTargetItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantQuickPrepareWidget">();
	}
	static class UDCMerchantQuickPrepareWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantQuickPrepareWidget>();
	}
};
static_assert(alignof(UDCMerchantQuickPrepareWidget) == 0x000008, "Wrong alignment on UDCMerchantQuickPrepareWidget");
static_assert(sizeof(UDCMerchantQuickPrepareWidget) == 0x000300, "Wrong size on UDCMerchantQuickPrepareWidget");
static_assert(offsetof(UDCMerchantQuickPrepareWidget, ButtonStashAll) == 0x0002C0, "Member 'UDCMerchantQuickPrepareWidget::ButtonStashAll' has a wrong offset!");
static_assert(offsetof(UDCMerchantQuickPrepareWidget, MerchantInfoWidget) == 0x0002C8, "Member 'UDCMerchantQuickPrepareWidget::MerchantInfoWidget' has a wrong offset!");
static_assert(offsetof(UDCMerchantQuickPrepareWidget, TargetScrollBox) == 0x0002D0, "Member 'UDCMerchantQuickPrepareWidget::TargetScrollBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantQuickPrepareWidget, TargetHorizontalBox) == 0x0002D8, "Member 'UDCMerchantQuickPrepareWidget::TargetHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCMerchantQuickPrepareWidget, TargetItemWidgetClass) == 0x0002E0, "Member 'UDCMerchantQuickPrepareWidget::TargetItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMerchantQuickPrepareWidget, MerchantComponent) == 0x0002E8, "Member 'UDCMerchantQuickPrepareWidget::MerchantComponent' has a wrong offset!");

// Class DungeonCrawler.DCMerchantRequiredItemData
// 0x0078 (0x00A0 - 0x0028)
class UDCMerchantRequiredItemData : public UObject
{
public:
	class UDCItemDataAsset*                       DataAsset;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemGroupInfo                       ItemGroup;                                         // 0x0030(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemIdTag;                                         // 0x0040(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCItemLootState                              LootState;                                         // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2711[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStack;                                          // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FDCItemInfo, int32>               FilledInfos;                                       // 0x0050(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantRequiredItemData">();
	}
	static class UDCMerchantRequiredItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantRequiredItemData>();
	}
};
static_assert(alignof(UDCMerchantRequiredItemData) == 0x000008, "Wrong alignment on UDCMerchantRequiredItemData");
static_assert(sizeof(UDCMerchantRequiredItemData) == 0x0000A0, "Wrong size on UDCMerchantRequiredItemData");
static_assert(offsetof(UDCMerchantRequiredItemData, DataAsset) == 0x000028, "Member 'UDCMerchantRequiredItemData::DataAsset' has a wrong offset!");
static_assert(offsetof(UDCMerchantRequiredItemData, ItemGroup) == 0x000030, "Member 'UDCMerchantRequiredItemData::ItemGroup' has a wrong offset!");
static_assert(offsetof(UDCMerchantRequiredItemData, ItemIdTag) == 0x000040, "Member 'UDCMerchantRequiredItemData::ItemIdTag' has a wrong offset!");
static_assert(offsetof(UDCMerchantRequiredItemData, LootState) == 0x000048, "Member 'UDCMerchantRequiredItemData::LootState' has a wrong offset!");
static_assert(offsetof(UDCMerchantRequiredItemData, MaxStack) == 0x00004C, "Member 'UDCMerchantRequiredItemData::MaxStack' has a wrong offset!");
static_assert(offsetof(UDCMerchantRequiredItemData, FilledInfos) == 0x000050, "Member 'UDCMerchantRequiredItemData::FilledInfos' has a wrong offset!");

// Class DungeonCrawler.DCMerchantRequiredEntryWidget
// 0x0020 (0x06C0 - 0x06A0)
class UDCMerchantRequiredEntryWidget : public UDCMerchantItemWidget
{
public:
	uint8                                         Pad_2712[0x18];                                    // 0x06A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCMerchantRequiredItemData*            RequireItemData;                                   // 0x06B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetCurrentStack() const;
	int32 GetMaxStack() const;
	class UObject* GetRequireData() const;
	bool IsEmpty() const;
	bool IsFilled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantRequiredEntryWidget">();
	}
	static class UDCMerchantRequiredEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantRequiredEntryWidget>();
	}
};
static_assert(alignof(UDCMerchantRequiredEntryWidget) == 0x000008, "Wrong alignment on UDCMerchantRequiredEntryWidget");
static_assert(sizeof(UDCMerchantRequiredEntryWidget) == 0x0006C0, "Wrong size on UDCMerchantRequiredEntryWidget");
static_assert(offsetof(UDCMerchantRequiredEntryWidget, RequireItemData) == 0x0006B8, "Member 'UDCMerchantRequiredEntryWidget::RequireItemData' has a wrong offset!");

// Class DungeonCrawler.DCMerchantShortcutPopupData
// 0x0028 (0x0058 - 0x0030)
class UDCMerchantShortcutPopupData final : public UPopupDataBase
{
public:
	EDCMerchantServiceType                        ShortcutServiceType;                               // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2713[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PopupText;                                         // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UDCMerchantDataAsset*                   MerchantDataAsset;                                 // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantShortcutPopupData">();
	}
	static class UDCMerchantShortcutPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantShortcutPopupData>();
	}
};
static_assert(alignof(UDCMerchantShortcutPopupData) == 0x000008, "Wrong alignment on UDCMerchantShortcutPopupData");
static_assert(sizeof(UDCMerchantShortcutPopupData) == 0x000058, "Wrong size on UDCMerchantShortcutPopupData");
static_assert(offsetof(UDCMerchantShortcutPopupData, ShortcutServiceType) == 0x000030, "Member 'UDCMerchantShortcutPopupData::ShortcutServiceType' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupData, PopupText) == 0x000038, "Member 'UDCMerchantShortcutPopupData::PopupText' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupData, MerchantDataAsset) == 0x000050, "Member 'UDCMerchantShortcutPopupData::MerchantDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCReligionOfferingWidget
// 0x0078 (0x03D0 - 0x0358)
class UDCReligionOfferingWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2714[0x4];                                     // 0x0358(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Currency;                                          // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCInventoryComponent*                  Source;                                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2715[0x18];                                    // 0x0368(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    MinusTenBtn;                                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    MinusOneBtn;                                       // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    PlusOneBtn;                                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    PlusTenBtn;                                        // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    AcceptBtn;                                         // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelBtn;                                         // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OfferingTicketCountText;                           // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OfferingGoldCountText;                             // 0x03B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OfferingWidgetVisibleEvent;                        // 0x03C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void ChangeActivateOfferState(bool bIsActiavte);
	void DeactivateAcceptBtn();
	void ResetOfferingCount();
	void SetCurrencySource();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionOfferingWidget">();
	}
	static class UDCReligionOfferingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionOfferingWidget>();
	}
};
static_assert(alignof(UDCReligionOfferingWidget) == 0x000008, "Wrong alignment on UDCReligionOfferingWidget");
static_assert(sizeof(UDCReligionOfferingWidget) == 0x0003D0, "Wrong size on UDCReligionOfferingWidget");
static_assert(offsetof(UDCReligionOfferingWidget, Currency) == 0x00035C, "Member 'UDCReligionOfferingWidget::Currency' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, Source) == 0x000360, "Member 'UDCReligionOfferingWidget::Source' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, MinusTenBtn) == 0x000380, "Member 'UDCReligionOfferingWidget::MinusTenBtn' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, MinusOneBtn) == 0x000388, "Member 'UDCReligionOfferingWidget::MinusOneBtn' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, PlusOneBtn) == 0x000390, "Member 'UDCReligionOfferingWidget::PlusOneBtn' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, PlusTenBtn) == 0x000398, "Member 'UDCReligionOfferingWidget::PlusTenBtn' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, AcceptBtn) == 0x0003A0, "Member 'UDCReligionOfferingWidget::AcceptBtn' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, CancelBtn) == 0x0003A8, "Member 'UDCReligionOfferingWidget::CancelBtn' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, OfferingTicketCountText) == 0x0003B0, "Member 'UDCReligionOfferingWidget::OfferingTicketCountText' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, OfferingGoldCountText) == 0x0003B8, "Member 'UDCReligionOfferingWidget::OfferingGoldCountText' has a wrong offset!");
static_assert(offsetof(UDCReligionOfferingWidget, OfferingWidgetVisibleEvent) == 0x0003C0, "Member 'UDCReligionOfferingWidget::OfferingWidgetVisibleEvent' has a wrong offset!");

// Class DungeonCrawler.DCMerchantShortcutPopupBase
// 0x0070 (0x0500 - 0x0490)
class UDCMerchantShortcutPopupBase final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_QuickPrepareShortcut;                          // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_BaseGearShortcut;                              // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Ok;                                            // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Ok_OneButton;                                  // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Cancel;                                        // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MerchantPortraitImage;                             // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDCMerchantDataAsset>    MerchantData;                                      // 0x04C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMerchantDataAsset*                   MerchantDataAsset;                                 // 0x04E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2716[0x10];                                    // 0x04F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBaseGearShortcutButtonClicked();
	void OnCancelButtonClicked();
	void OnOkButtonClicked();
	void OnQuickPrepareShortcutButtonClicked();
	void OnSetMerchantShortcutPopupData(class UDCMerchantShortcutPopupData* PopupData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantShortcutPopupBase">();
	}
	static class UDCMerchantShortcutPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantShortcutPopupBase>();
	}
};
static_assert(alignof(UDCMerchantShortcutPopupBase) == 0x000008, "Wrong alignment on UDCMerchantShortcutPopupBase");
static_assert(sizeof(UDCMerchantShortcutPopupBase) == 0x000500, "Wrong size on UDCMerchantShortcutPopupBase");
static_assert(offsetof(UDCMerchantShortcutPopupBase, Btn_QuickPrepareShortcut) == 0x000490, "Member 'UDCMerchantShortcutPopupBase::Btn_QuickPrepareShortcut' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, Btn_BaseGearShortcut) == 0x000498, "Member 'UDCMerchantShortcutPopupBase::Btn_BaseGearShortcut' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, Btn_Ok) == 0x0004A0, "Member 'UDCMerchantShortcutPopupBase::Btn_Ok' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, Btn_Ok_OneButton) == 0x0004A8, "Member 'UDCMerchantShortcutPopupBase::Btn_Ok_OneButton' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, Btn_Cancel) == 0x0004B0, "Member 'UDCMerchantShortcutPopupBase::Btn_Cancel' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, MerchantPortraitImage) == 0x0004B8, "Member 'UDCMerchantShortcutPopupBase::MerchantPortraitImage' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, MerchantData) == 0x0004C0, "Member 'UDCMerchantShortcutPopupBase::MerchantData' has a wrong offset!");
static_assert(offsetof(UDCMerchantShortcutPopupBase, MerchantDataAsset) == 0x0004E8, "Member 'UDCMerchantShortcutPopupBase::MerchantDataAsset' has a wrong offset!");

// Class DungeonCrawler.DCMerchantStatWidget
// 0x0030 (0x02F0 - 0x02C0)
class UDCMerchantStatWidget final : public UUserWidget
{
public:
	int32                                         Affinity;                                          // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2717[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AffinityText;                                      // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         MerchantFlag;                                      // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2718[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              RemainTime;                                        // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMerchantStatWidget">();
	}
	static class UDCMerchantStatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMerchantStatWidget>();
	}
};
static_assert(alignof(UDCMerchantStatWidget) == 0x000008, "Wrong alignment on UDCMerchantStatWidget");
static_assert(sizeof(UDCMerchantStatWidget) == 0x0002F0, "Wrong size on UDCMerchantStatWidget");
static_assert(offsetof(UDCMerchantStatWidget, Affinity) == 0x0002C0, "Member 'UDCMerchantStatWidget::Affinity' has a wrong offset!");
static_assert(offsetof(UDCMerchantStatWidget, AffinityText) == 0x0002C8, "Member 'UDCMerchantStatWidget::AffinityText' has a wrong offset!");
static_assert(offsetof(UDCMerchantStatWidget, MerchantFlag) == 0x0002E0, "Member 'UDCMerchantStatWidget::MerchantFlag' has a wrong offset!");
static_assert(offsetof(UDCMerchantStatWidget, RemainTime) == 0x0002E8, "Member 'UDCMerchantStatWidget::RemainTime' has a wrong offset!");

// Class DungeonCrawler.StatusSlotWidget
// 0x0010 (0x0368 - 0x0358)
class UStatusSlotWidget final : public UDCWidgetBase
{
public:
	class UButton*                                Btn_Check;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_Off_On;                             // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusSlotWidget">();
	}
	static class UStatusSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusSlotWidget>();
	}
};
static_assert(alignof(UStatusSlotWidget) == 0x000008, "Wrong alignment on UStatusSlotWidget");
static_assert(sizeof(UStatusSlotWidget) == 0x000368, "Wrong size on UStatusSlotWidget");
static_assert(offsetof(UStatusSlotWidget, Btn_Check) == 0x000358, "Member 'UStatusSlotWidget::Btn_Check' has a wrong offset!");
static_assert(offsetof(UStatusSlotWidget, WidgetSwitcher_Off_On) == 0x000360, "Member 'UStatusSlotWidget::WidgetSwitcher_Off_On' has a wrong offset!");

// Class DungeonCrawler.DCMetaCustomizeComponent
// 0x0000 (0x01B0 - 0x01B0)
class UDCMetaCustomizeComponent final : public UDCCustomizeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaCustomizeComponent">();
	}
	static class UDCMetaCustomizeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMetaCustomizeComponent>();
	}
};
static_assert(alignof(UDCMetaCustomizeComponent) == 0x000008, "Wrong alignment on UDCMetaCustomizeComponent");
static_assert(sizeof(UDCMetaCustomizeComponent) == 0x0001B0, "Wrong size on UDCMetaCustomizeComponent");

// Class DungeonCrawler.DCMetaGameSession
// 0x0000 (0x03F8 - 0x03F8)
class ADCMetaGameSession final : public ADCGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaGameSession">();
	}
	static class ADCMetaGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCMetaGameSession>();
	}
};
static_assert(alignof(ADCMetaGameSession) == 0x000008, "Wrong alignment on ADCMetaGameSession");
static_assert(sizeof(ADCMetaGameSession) == 0x0003F8, "Wrong size on ADCMetaGameSession");

// Class DungeonCrawler.DCPlayerController
// 0x02D8 (0x0B30 - 0x0858)
class ADCPlayerController : public APlayerController
{
public:
	uint8                                         Pad_2719[0x58];                                    // 0x0858(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x08B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271A[0x50];                                    // 0x08B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADCPortraitCharacter>       PortraitCharacterClass;                            // 0x0908(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             VoipOnSoundData;                                   // 0x0910(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             VoipOffSoundData;                                  // 0x0918(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             PushToTalkOnSoundData;                             // 0x0920(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             PushToTalkOffSoundData;                            // 0x0928(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271B[0x10];                                    // 0x0930(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0940(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAccountLink*                           AccountLink;                                       // 0x0950(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TargetAccountId;                                   // 0x0958(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271C[0x8];                                     // 0x0968(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCPartyId                             TargetPartyId;                                     // 0x0970(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ClientStateName;                                   // 0x0980(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271D[0x58];                                    // 0x0988(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedServer;                                    // 0x09E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271E[0x4];                                     // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FGMEffectHandleType> GMActorEffectHandleMap;                            // 0x09E8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FDCReportedInfo>                ReportedInfoArray;                                 // 0x0A38(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ADCPortraitCharacter*>           PortraitCharacters;                                // 0x0A48(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271F[0x20];                                    // 0x0A58(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCLootComponent*                       LootComponent;                                     // 0x0A78(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCExpressmanComponent*                 ExpressmanComponent;                               // 0x0A80(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryControllerComponent*        InventoryControllerComponent;                      // 0x0A88(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpellCastComponent*                    SpellCastComponent;                                // 0x0A90(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCReportSystem*                        ReportSystem;                                      // 0x0A98(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCCharacterBase*                       InspectTarget;                                     // 0x0AA0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2720[0x50];                                    // 0x0AA8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCPersonalPlayerInfo                  PersonalPlayerInfo;                                // 0x0AF8(0x0038)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void AckPlayerCharacterLocation_Client(const struct FDCAccountId& InAccountId, const struct FVector& InPlayerPawnLocation, const struct FRotator& InPlayerPawnRotation);
	void Announce_Client(const struct FGameAnnounceData& AnnounceData);
	void ArenaNextPhaseForDebug_Server();
	void ArenaPrepareStartPointForDebug_Server();
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ChangeParty_Server(const struct FDCPartyId& InPartyId);
	void EscapeForDebug_Server();
	void ExitUser(const EDCExitType ExitType);
	void ExitUser_Server(const EDCExitType ExitType);
	class AActor* GetDebugFaceTargetActor();
	void Gm(const class FString& InCmd);
	void GmServer(const class FString& InKey, const class FString& InCmd);
	bool IsTargetAccountSelf();
	void LogClientAliveToServiceReceive();
	void LogClientAliveToServiceSend();
	void NextFloorRuleForDebug_Server();
	void NotifySystemMessage_Client(const class FText& SystemMessage, const float Duration);
	void OnAnyPlayerDied(const struct FDCPlayerInfo& InPlayerInfo);
	void OnBackToLobbyConfirmed(const EPopupResult PopupResult);
	void OnClientCall(const struct FCallData& CallData);
	bool OnDungeonDownOverlapped(class ADCPlayerCharacterBase* InCharacter);
	bool OnDungeonEscapeOverlapped(class ADCPlayerCharacterBase* InCharacter);
	void OnExitClicked();
	void OnExitConfirmed(const EPopupResult PopupResult);
	void OnFMsgGameAnnounceNotifyClient(const struct FGameAnnounceData& InGameAnnounceData);
	void OnFMsgGameFloorLogNotify_Client(const struct FMsgGameFloorLogNotify& Msg);
	void OnFMsgGameKillLogNotify_Client(const struct FMsgGameKillLogNotify& Msg);
	void OnGameStateNotify(const struct FGameStateData& InGameStateData);
	void OnKilledByUser_Client(const struct FDCAccountId& Killer);
	void OnLobbyClicked();
	void OnPartyChat(const struct FChatData& InChatData);
	void OnPawnChanged(class APawn* InOldPawn, class APawn* InNewPawn);
	void OnPortalScrollOverlapped(class AFloorPortalScrollBase* Portal, class ADCPlayerCharacterBase* InCharacter);
	void OnRep_AccountId(const class FString& OldId);
	void OnRep_InspectTarget(class ADCCharacterBase* OldInspectTarget);
	void OnRep_PersonalPlayerInfo(const struct FDCPersonalPlayerInfo& OldPlayerInfo);
	void OnRep_ReportedInfoArray(const TArray<struct FDCReportedInfo>& InOldReportedInfoArray);
	void OnServerCall(const struct FCallData& CallData);
	void OnServerNotify(const struct FNotifyData& NotifyData);
	void OnSpectateTarget(const struct FDCAccountId& SpectateAccountId);
	void OnUnmuted();
	void OnUserExited_Client(const EDCExitType ExitType);
	void PauseFloorRuleForDebug_Server();
	void ReportPlayer_Server(const struct FDCReportPlayerInfo& InReportPlayerInfo);
	void RequestPartyChatServer(const struct FChatData& InChatData);
	void RequestPlayerCharacterLocation_Server(const struct FDCAccountId& InAccountId);
	void ResumeFloorRuleForDebug_Server();
	void ServerDebugGiveGameplayEffectToTarget(const class FString& InKey, class AActor* TargetActor, const struct FPrimaryAssetId& GameplayEffectAssetId);
	void ServerDebugInjectItemToTarget(const TArray<struct FItemData>& InItemDataArray, EInventoryType TargetInventoryType);
	void ServerDebugSetupTagToTarget(const class FString& InKey, class AActor* TargetActor, const class FString& TagOptionString);
	void ServerDebugSpawnItem(const class FString& InKey, class AActor* SpawnActor, const struct FPrimaryAssetId& SpawnItemAssetId);
	void ServerEventBroadcastTriggered(EDCServerTriggeredEventType EventType, int64 ServerFrame);
	void ServerToggleAnim();
	void SetClientReady_Server();
	void SetInspectTarget_Server(class ADCCharacterBase* InInspectTarget);
	void SetMerchnatListToQuestInterface();
	void SetQuestLogListToQuestInterface();
	void SpawnResurrectionCharacterForDebug_Server(const struct FDCAccountId& InAccountId, const bool bRecoverItem, const int32 LifeSpan);
	void StartToWearItem_Client(const struct FItemData& InWearingItemData, class AActor* InWearingActor, float InDuration, const class FText& InDescription);
	void StatServer();
	void TerminateBase();
	void ToggleAnimBP();
	void TravelFloorMatchmaking_Client(const struct FDCGameLiftSessionId& SessionId, const class FString& Address, const class FString& ServiceUrl);
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void VerifyReconnection_Server();

	const struct FAccountSessionData GetAccountSessionData() const;
	class UDCExpressmanComponent* GetExpressmanComponent() const;
	class UDCLootComponent* GetLootComponent() const;
	const struct FDCPersonalPlayerInfo GetPersonalPlayerInfo() const;
	bool IsDungeonResultShowResult() const;
	void OnLastQuestUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerController">();
	}
	static class ADCPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerController>();
	}
};
static_assert(alignof(ADCPlayerController) == 0x000008, "Wrong alignment on ADCPlayerController");
static_assert(sizeof(ADCPlayerController) == 0x000B30, "Wrong size on ADCPlayerController");
static_assert(offsetof(ADCPlayerController, BaseObject) == 0x0008B0, "Member 'ADCPlayerController::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, PortraitCharacterClass) == 0x000908, "Member 'ADCPlayerController::PortraitCharacterClass' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, VoipOnSoundData) == 0x000910, "Member 'ADCPlayerController::VoipOnSoundData' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, VoipOffSoundData) == 0x000918, "Member 'ADCPlayerController::VoipOffSoundData' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, PushToTalkOnSoundData) == 0x000920, "Member 'ADCPlayerController::PushToTalkOnSoundData' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, PushToTalkOffSoundData) == 0x000928, "Member 'ADCPlayerController::PushToTalkOffSoundData' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, AccountId) == 0x000940, "Member 'ADCPlayerController::AccountId' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, AccountLink) == 0x000950, "Member 'ADCPlayerController::AccountLink' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, TargetAccountId) == 0x000958, "Member 'ADCPlayerController::TargetAccountId' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, TargetPartyId) == 0x000970, "Member 'ADCPlayerController::TargetPartyId' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, ClientStateName) == 0x000980, "Member 'ADCPlayerController::ClientStateName' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, MaxSpeedServer) == 0x0009E0, "Member 'ADCPlayerController::MaxSpeedServer' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, GMActorEffectHandleMap) == 0x0009E8, "Member 'ADCPlayerController::GMActorEffectHandleMap' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, ReportedInfoArray) == 0x000A38, "Member 'ADCPlayerController::ReportedInfoArray' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, PortraitCharacters) == 0x000A48, "Member 'ADCPlayerController::PortraitCharacters' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, LootComponent) == 0x000A78, "Member 'ADCPlayerController::LootComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, ExpressmanComponent) == 0x000A80, "Member 'ADCPlayerController::ExpressmanComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, InventoryControllerComponent) == 0x000A88, "Member 'ADCPlayerController::InventoryControllerComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, SpellCastComponent) == 0x000A90, "Member 'ADCPlayerController::SpellCastComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, ReportSystem) == 0x000A98, "Member 'ADCPlayerController::ReportSystem' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, InspectTarget) == 0x000AA0, "Member 'ADCPlayerController::InspectTarget' has a wrong offset!");
static_assert(offsetof(ADCPlayerController, PersonalPlayerInfo) == 0x000AF8, "Member 'ADCPlayerController::PersonalPlayerInfo' has a wrong offset!");

// Class DungeonCrawler.DCReplayPlayerController
// 0x0008 (0x0B38 - 0x0B30)
class ADCReplayPlayerController final : public ADCPlayerController
{
public:
	TSubclassOf<class ADCIngameHUD>               DeathCamHudClass;                                  // 0x0B30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReplayPlayerController">();
	}
	static class ADCReplayPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCReplayPlayerController>();
	}
};
static_assert(alignof(ADCReplayPlayerController) == 0x000008, "Wrong alignment on ADCReplayPlayerController");
static_assert(sizeof(ADCReplayPlayerController) == 0x000B38, "Wrong size on ADCReplayPlayerController");
static_assert(offsetof(ADCReplayPlayerController, DeathCamHudClass) == 0x000B30, "Member 'ADCReplayPlayerController::DeathCamHudClass' has a wrong offset!");

// Class DungeonCrawler.DCPlayerInventoryComponent
// 0x0000 (0x0180 - 0x0180)
class UDCPlayerInventoryComponent : public UDCInventoryComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerInventoryComponent">();
	}
	static class UDCPlayerInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerInventoryComponent>();
	}
};
static_assert(alignof(UDCPlayerInventoryComponent) == 0x000008, "Wrong alignment on UDCPlayerInventoryComponent");
static_assert(sizeof(UDCPlayerInventoryComponent) == 0x000180, "Wrong size on UDCPlayerInventoryComponent");

// Class DungeonCrawler.DCMetaInventoryComponent
// 0x00A0 (0x0220 - 0x0180)
class UDCMetaInventoryComponent final : public UDCPlayerInventoryComponent
{
public:
	TSet<class UDCItemSkinDataAsset*>             ItemSkins;                                         // 0x0180(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UDCArmorSkinDataAsset*>            ArmorSkins;                                        // 0x01D0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaInventoryComponent">();
	}
	static class UDCMetaInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMetaInventoryComponent>();
	}
};
static_assert(alignof(UDCMetaInventoryComponent) == 0x000008, "Wrong alignment on UDCMetaInventoryComponent");
static_assert(sizeof(UDCMetaInventoryComponent) == 0x000220, "Wrong size on UDCMetaInventoryComponent");
static_assert(offsetof(UDCMetaInventoryComponent, ItemSkins) == 0x000180, "Member 'UDCMetaInventoryComponent::ItemSkins' has a wrong offset!");
static_assert(offsetof(UDCMetaInventoryComponent, ArmorSkins) == 0x0001D0, "Member 'UDCMetaInventoryComponent::ArmorSkins' has a wrong offset!");

// Class DungeonCrawler.DCMetaInventoryControllerComponent
// 0x0008 (0x00C8 - 0x00C0)
class UDCMetaInventoryControllerComponent final : public UDCInventoryControllerComponent
{
public:
	class UDCInventoryBase*                       LastStashInventory;                                // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaInventoryControllerComponent">();
	}
	static class UDCMetaInventoryControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMetaInventoryControllerComponent>();
	}
};
static_assert(alignof(UDCMetaInventoryControllerComponent) == 0x000008, "Wrong alignment on UDCMetaInventoryControllerComponent");
static_assert(sizeof(UDCMetaInventoryControllerComponent) == 0x0000C8, "Wrong size on UDCMetaInventoryControllerComponent");
static_assert(offsetof(UDCMetaInventoryControllerComponent, LastStashInventory) == 0x0000C0, "Member 'UDCMetaInventoryControllerComponent::LastStashInventory' has a wrong offset!");

// Class DungeonCrawler.DCMetaPlayerController
// 0x0108 (0x0960 - 0x0858)
class ADCMetaPlayerController : public APlayerController
{
public:
	uint8                                         Pad_2728[0x58];                                    // 0x0858(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x08B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAccountLink*                           AccountLink;                                       // 0x08B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCAccountId                           TargetAccountId;                                   // 0x08C0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2729[0x30];                                    // 0x08D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundData*                             EscapeSoundData;                                   // 0x0900(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             VoipOnSoundData;                                   // 0x0908(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             VoipOffSoundData;                                  // 0x0910(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             PushToTalkOnSoundData;                             // 0x0918(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundData*                             PushToTalkOffSoundData;                            // 0x0920(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272A[0x8];                                     // 0x0928(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x0930(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCRecruitComponent*                    RecruitComponent;                                  // 0x0938(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCMarketplaceComponent*                MarketplaceComponent;                              // 0x0940(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryControllerComponent*        InventoryControllerComponent;                      // 0x0948(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMetaClassComponent*                    ClassComponent;                                    // 0x0950(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMetaPlayComponent*                     MetaPlayComponent;                                 // 0x0958(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	const struct FAccountSessionData GetAccountSessionData();
	void Gm(const class FString& InCmd);
	void OnExitClicked();
	void OnExitConfirmed(const EPopupResult PopupResult);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void UpdateGameState(const struct FGameStateData& InGameStateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaPlayerController">();
	}
	static class ADCMetaPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCMetaPlayerController>();
	}
};
static_assert(alignof(ADCMetaPlayerController) == 0x000008, "Wrong alignment on ADCMetaPlayerController");
static_assert(sizeof(ADCMetaPlayerController) == 0x000960, "Wrong size on ADCMetaPlayerController");
static_assert(offsetof(ADCMetaPlayerController, BaseObject) == 0x0008B0, "Member 'ADCMetaPlayerController::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, AccountLink) == 0x0008B8, "Member 'ADCMetaPlayerController::AccountLink' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, TargetAccountId) == 0x0008C0, "Member 'ADCMetaPlayerController::TargetAccountId' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, EscapeSoundData) == 0x000900, "Member 'ADCMetaPlayerController::EscapeSoundData' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, VoipOnSoundData) == 0x000908, "Member 'ADCMetaPlayerController::VoipOnSoundData' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, VoipOffSoundData) == 0x000910, "Member 'ADCMetaPlayerController::VoipOffSoundData' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, PushToTalkOnSoundData) == 0x000918, "Member 'ADCMetaPlayerController::PushToTalkOnSoundData' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, PushToTalkOffSoundData) == 0x000920, "Member 'ADCMetaPlayerController::PushToTalkOffSoundData' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, MerchantComponent) == 0x000930, "Member 'ADCMetaPlayerController::MerchantComponent' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, RecruitComponent) == 0x000938, "Member 'ADCMetaPlayerController::RecruitComponent' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, MarketplaceComponent) == 0x000940, "Member 'ADCMetaPlayerController::MarketplaceComponent' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, InventoryControllerComponent) == 0x000948, "Member 'ADCMetaPlayerController::InventoryControllerComponent' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, ClassComponent) == 0x000950, "Member 'ADCMetaPlayerController::ClassComponent' has a wrong offset!");
static_assert(offsetof(ADCMetaPlayerController, MetaPlayComponent) == 0x000958, "Member 'ADCMetaPlayerController::MetaPlayComponent' has a wrong offset!");

// Class DungeonCrawler.DCTradePhaseDealWidget
// 0x0020 (0x0378 - 0x0358)
class UDCTradePhaseDealWidget final : public UDCWidgetBase
{
public:
	int32                                         TradeFee;                                          // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LockDuration;                                      // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelTradeButton;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCTradeBoxWidget*                      TradeBoxLocal;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCTradeBoxWidget*                      TradeBoxRemote;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelTradeButtonClicked();
	void OnLocalTraderCheckBoxStateChanged(bool bIsChecked);
	void OnResponseLocalTraderRequestRequestResult(bool bRequestSucceed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradePhaseDealWidget">();
	}
	static class UDCTradePhaseDealWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradePhaseDealWidget>();
	}
};
static_assert(alignof(UDCTradePhaseDealWidget) == 0x000008, "Wrong alignment on UDCTradePhaseDealWidget");
static_assert(sizeof(UDCTradePhaseDealWidget) == 0x000378, "Wrong size on UDCTradePhaseDealWidget");
static_assert(offsetof(UDCTradePhaseDealWidget, TradeFee) == 0x000358, "Member 'UDCTradePhaseDealWidget::TradeFee' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseDealWidget, LockDuration) == 0x00035C, "Member 'UDCTradePhaseDealWidget::LockDuration' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseDealWidget, CancelTradeButton) == 0x000360, "Member 'UDCTradePhaseDealWidget::CancelTradeButton' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseDealWidget, TradeBoxLocal) == 0x000368, "Member 'UDCTradePhaseDealWidget::TradeBoxLocal' has a wrong offset!");
static_assert(offsetof(UDCTradePhaseDealWidget, TradeBoxRemote) == 0x000370, "Member 'UDCTradePhaseDealWidget::TradeBoxRemote' has a wrong offset!");

// Class DungeonCrawler.DCMetaReligionInterface
// 0x0000 (0x0028 - 0x0028)
class IDCMetaReligionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaReligionInterface">();
	}
	static class IDCMetaReligionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCMetaReligionInterface>();
	}
};
static_assert(alignof(IDCMetaReligionInterface) == 0x000008, "Wrong alignment on IDCMetaReligionInterface");
static_assert(sizeof(IDCMetaReligionInterface) == 0x000028, "Wrong size on IDCMetaReligionInterface");

// Class DungeonCrawler.MetaComponentBase
// 0x0060 (0x0100 - 0x00A0)
class UMetaComponentBase : public UDCActorComponent
{
public:
	uint8                                         Pad_272B[0x60];                                    // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaComponentBase">();
	}
	static class UMetaComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaComponentBase>();
	}
};
static_assert(alignof(UMetaComponentBase) == 0x000008, "Wrong alignment on UMetaComponentBase");
static_assert(sizeof(UMetaComponentBase) == 0x000100, "Wrong size on UMetaComponentBase");

// Class DungeonCrawler.DCMetaTradeComponent
// 0x0168 (0x0268 - 0x0100)
class UDCMetaTradeComponent final : public UMetaComponentBase
{
public:
	TSubclassOf<class UCommonPopupSWidget>        CommonPopupWidget;                                 // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTradeSucceed;                                    // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_272C[0x58];                                    // 0x0118(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ResetTimerHandle;                                  // 0x0170(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272D[0xD8];                                    // 0x0178(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCBoxInventory*                        TradingBoxLocal;                                   // 0x0250(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        TradingBoxRemote;                                  // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272E[0x8];                                     // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateResetTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMetaTradeComponent">();
	}
	static class UDCMetaTradeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMetaTradeComponent>();
	}
};
static_assert(alignof(UDCMetaTradeComponent) == 0x000008, "Wrong alignment on UDCMetaTradeComponent");
static_assert(sizeof(UDCMetaTradeComponent) == 0x000268, "Wrong size on UDCMetaTradeComponent");
static_assert(offsetof(UDCMetaTradeComponent, CommonPopupWidget) == 0x000100, "Member 'UDCMetaTradeComponent::CommonPopupWidget' has a wrong offset!");
static_assert(offsetof(UDCMetaTradeComponent, OnTradeSucceed) == 0x000108, "Member 'UDCMetaTradeComponent::OnTradeSucceed' has a wrong offset!");
static_assert(offsetof(UDCMetaTradeComponent, ResetTimerHandle) == 0x000170, "Member 'UDCMetaTradeComponent::ResetTimerHandle' has a wrong offset!");
static_assert(offsetof(UDCMetaTradeComponent, TradingBoxLocal) == 0x000250, "Member 'UDCMetaTradeComponent::TradingBoxLocal' has a wrong offset!");
static_assert(offsetof(UDCMetaTradeComponent, TradingBoxRemote) == 0x000258, "Member 'UDCMetaTradeComponent::TradingBoxRemote' has a wrong offset!");

// Class DungeonCrawler.DCModulePropsBase
// 0x0090 (0x0470 - 0x03E0)
class ADCModulePropsBase : public APropsActorBase
{
public:
	TSubclassOf<class APropsActorBase>            ChildPropsClass;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272F[0x8];                                     // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ChildPropsReletiveTransform;                       // 0x03F0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2730[0x8];                                     // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APropsActorBase*                        PreviewChildProps;                                 // 0x0458(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APropsActorBase*                        ChildProps;                                        // 0x0460(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2731[0x8];                                     // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCModulePropsBase">();
	}
	static class ADCModulePropsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCModulePropsBase>();
	}
};
static_assert(alignof(ADCModulePropsBase) == 0x000010, "Wrong alignment on ADCModulePropsBase");
static_assert(sizeof(ADCModulePropsBase) == 0x000470, "Wrong size on ADCModulePropsBase");
static_assert(offsetof(ADCModulePropsBase, ChildPropsClass) == 0x0003E0, "Member 'ADCModulePropsBase::ChildPropsClass' has a wrong offset!");
static_assert(offsetof(ADCModulePropsBase, ChildPropsReletiveTransform) == 0x0003F0, "Member 'ADCModulePropsBase::ChildPropsReletiveTransform' has a wrong offset!");
static_assert(offsetof(ADCModulePropsBase, PreviewChildProps) == 0x000458, "Member 'ADCModulePropsBase::PreviewChildProps' has a wrong offset!");
static_assert(offsetof(ADCModulePropsBase, ChildProps) == 0x000460, "Member 'ADCModulePropsBase::ChildProps' has a wrong offset!");

// Class DungeonCrawler.DCTrainingCharacterSlotWidgetBase
// 0x0090 (0x0378 - 0x02E8)
class UDCTrainingCharacterSlotWidgetBase final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2732[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              Nickname;                                          // 0x02F0(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ClassName;                                         // 0x0330(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   LevelText;                                         // 0x0348(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ClassPortrait;                                     // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ClassIcon;                                         // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMaster;                                         // 0x0370(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNPC;                                            // 0x0371(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasLearn;                                         // 0x0372(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCommingSoon;                                    // 0x0373(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2733[0x4];                                     // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSetMaster() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingCharacterSlotWidgetBase">();
	}
	static class UDCTrainingCharacterSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingCharacterSlotWidgetBase>();
	}
};
static_assert(alignof(UDCTrainingCharacterSlotWidgetBase) == 0x000008, "Wrong alignment on UDCTrainingCharacterSlotWidgetBase");
static_assert(sizeof(UDCTrainingCharacterSlotWidgetBase) == 0x000378, "Wrong size on UDCTrainingCharacterSlotWidgetBase");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, Nickname) == 0x0002F0, "Member 'UDCTrainingCharacterSlotWidgetBase::Nickname' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, ClassName) == 0x000330, "Member 'UDCTrainingCharacterSlotWidgetBase::ClassName' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, LevelText) == 0x000348, "Member 'UDCTrainingCharacterSlotWidgetBase::LevelText' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, ClassPortrait) == 0x000360, "Member 'UDCTrainingCharacterSlotWidgetBase::ClassPortrait' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, ClassIcon) == 0x000368, "Member 'UDCTrainingCharacterSlotWidgetBase::ClassIcon' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, bIsMaster) == 0x000370, "Member 'UDCTrainingCharacterSlotWidgetBase::bIsMaster' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, bIsNPC) == 0x000371, "Member 'UDCTrainingCharacterSlotWidgetBase::bIsNPC' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, bHasLearn) == 0x000372, "Member 'UDCTrainingCharacterSlotWidgetBase::bHasLearn' has a wrong offset!");
static_assert(offsetof(UDCTrainingCharacterSlotWidgetBase, bIsCommingSoon) == 0x000373, "Member 'UDCTrainingCharacterSlotWidgetBase::bIsCommingSoon' has a wrong offset!");

// Class DungeonCrawler.DCMonsterAIController
// 0x0098 (0x0458 - 0x03C0)
class ADCMonsterAIController : public AAIController
{
public:
	uint8                                         Pad_2734[0x58];                                    // 0x03C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2735[0x10];                                    // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TargetInvisibleStateTagContainer;                  // 0x0430(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2736[0x8];                                     // 0x0450(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ForceSightAll(bool bIsForce);
	void OnPerceptionUpdated(const TArray<class AActor*>& UpdatedActors);
	void OnTargetPerceptionInfoUpdated(const struct FActorPerceptionUpdateInfo& UpdateInfo);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterAIController">();
	}
	static class ADCMonsterAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCMonsterAIController>();
	}
};
static_assert(alignof(ADCMonsterAIController) == 0x000008, "Wrong alignment on ADCMonsterAIController");
static_assert(sizeof(ADCMonsterAIController) == 0x000458, "Wrong size on ADCMonsterAIController");
static_assert(offsetof(ADCMonsterAIController, BaseObject) == 0x000418, "Member 'ADCMonsterAIController::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCMonsterAIController, TargetInvisibleStateTagContainer) == 0x000430, "Member 'ADCMonsterAIController::TargetInvisibleStateTagContainer' has a wrong offset!");

// Class DungeonCrawler.DCMonsterAISystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCMonsterAISystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point);
	static void ExcludeSummonerAndPartyMembers(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray);
	static void FilterMonsterTargets(TArray<class ADCCharacterBase*>& TargetArray);
	static bool FilterMonsterTargetsByID(TArray<class ADCCharacterBase*>& TargetArray, const struct FPrimaryAssetId& ID);
	static void FilterPlayerCharacterTargets(TArray<class ADCCharacterBase*>& TargetArray);
	static bool FilterTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag);
	static bool FilterTargetsOverDistance(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance);
	static bool FilterTargetsOverXYRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float XYRange);
	static bool FilterTargetsOverZRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float ZRange);
	static bool FilterTargetsWithinDirectionAngleAndAllowedAngle(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float DirectionalAngle, float AllowedAngle);
	static bool FilterTargetsWithinDistance(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance);
	static bool FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance, float DirectionalAngle, float AllowedAngle);
	static bool FilterTargetsWithinXYRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float XYRange);
	static bool FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float XYRange, float ZRange, float DirectionalAngle, float AllowedAngle);
	static bool FilterTargetsWithinZRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float ZRange);
	static bool FilterUnTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag);
	static bool GetAggroMonster(class ADCCharacterBase* DCCharacterBase, TArray<class ADCMonsterBase*>& TargetArray);
	static float GetAggroPoint(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, bool* bSuccessfully);
	static bool GetAllTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray);
	static float GetBaseAttributeValue(class ADCCharacterBase*& DCCharacterBase, const struct FGameplayAttribute& GameplayAttribute, bool* bSuccessfully);
	static float GetCurrentAttributeValue(class ADCCharacterBase*& DCCharacterBase, const struct FGameplayAttribute& GameplayAttribute, bool* bSuccessfully);
	static bool GetDamageTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray);
	static bool GetHearingTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray);
	static int32 GetMinionCount(class ADCMonsterBase*& DCMonsterBase);
	static bool GetSightTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray);
	static class ADCCharacterBase* GetSummoner(class ADCMonsterBase* DCMonsterBase);
	static bool IsAvailablePath(class ADCMonsterBase*& DCMonsterBase, const struct FVector& DstLocation);
	static bool JumpToActor(class ADCCharacterBase*& DCCharacterBase, class AActor*& DstActor, float Power, bool bFavorHighArc);
	static bool JumpToLocation(class ADCCharacterBase*& DCCharacterBase, const struct FVector& DstLocation, float Power, bool bFavorHighArc);
	static bool MulAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point);
	static class ADCCharacterBase* PickRandomTarget(TArray<class ADCCharacterBase*>& TargetArray);
	static class ADCCharacterBase* PickTarget(TArray<class ADCCharacterBase*>& TargetArray, int32 Param_Index);
	static class ADCCharacterBase* PickTopAggroTarget(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray);
	static bool RemoveAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target);
	static bool RemoveAggroAll(class ADCCharacterBase* DCCharacterBase);
	static bool SetAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point);
	static bool SetAggroRate(class ADCCharacterBase*& DCCharacterBase, float Time, float Rate);
	static bool SortTargetsByAggro(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType);
	static bool SortTargetsByDistance(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType);
	static class ADCCharacterBase* SortTargetsByDistanceAndPickTarget(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType, int32 Param_Index);
	static bool SortTargetsByXYRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType);
	static bool SortTargetsByZRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType);
	static class ADCCharacterBase* SpawnMinion(class ADCMonsterBase*& DCMonsterBase, TSubclassOf<class ADCMonsterBase> MinionClass, float XYRange, bool* bSuccessfully);
	static bool SubAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterAISystemBlueprintLibrary">();
	}
	static class UDCMonsterAISystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMonsterAISystemBlueprintLibrary>();
	}
};
static_assert(alignof(UDCMonsterAISystemBlueprintLibrary) == 0x000008, "Wrong alignment on UDCMonsterAISystemBlueprintLibrary");
static_assert(sizeof(UDCMonsterAISystemBlueprintLibrary) == 0x000028, "Wrong size on UDCMonsterAISystemBlueprintLibrary");

// Class DungeonCrawler.DCMonsterAnimInstanceBase
// 0x0030 (0x0530 - 0x0500)
class UDCMonsterAnimInstanceBase : public UDCCharacterAnimInstanceBase
{
public:
	struct FVector                                ForwardVector;                                     // 0x0500(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStaggered;                                      // 0x0518(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPlayHitReaction;                            // 0x0519(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPlayHitReactionFlipFlop;                    // 0x051A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMontagePlayingOrHorizontalSpeed;                  // 0x051B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPlayStaggered;                              // 0x051C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationNone;                               // 0x051D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleEmpty;                          // 0x051E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleDeath;                          // 0x051F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleReloaded;                       // 0x0520(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleSpawn;                          // 0x0521(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleDeactivate;                     // 0x0522(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleActivate;                       // 0x0523(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdle;                               // 0x0524(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleClose;                          // 0x0525(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleOpen;                           // 0x0526(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleOpenForward;                    // 0x0527(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleOpenBackward;                   // 0x0528(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleOn;                             // 0x0529(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleDisarm;                         // 0x052A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateAnimationIdleRemove;                         // 0x052B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_275D[0x4];                                     // 0x052C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterAnimInstanceBase">();
	}
	static class UDCMonsterAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMonsterAnimInstanceBase>();
	}
};
static_assert(alignof(UDCMonsterAnimInstanceBase) == 0x000010, "Wrong alignment on UDCMonsterAnimInstanceBase");
static_assert(sizeof(UDCMonsterAnimInstanceBase) == 0x000530, "Wrong size on UDCMonsterAnimInstanceBase");
static_assert(offsetof(UDCMonsterAnimInstanceBase, ForwardVector) == 0x000500, "Member 'UDCMonsterAnimInstanceBase::ForwardVector' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bIsStaggered) == 0x000518, "Member 'UDCMonsterAnimInstanceBase::bIsStaggered' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bShouldPlayHitReaction) == 0x000519, "Member 'UDCMonsterAnimInstanceBase::bShouldPlayHitReaction' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bShouldPlayHitReactionFlipFlop) == 0x00051A, "Member 'UDCMonsterAnimInstanceBase::bShouldPlayHitReactionFlipFlop' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bMontagePlayingOrHorizontalSpeed) == 0x00051B, "Member 'UDCMonsterAnimInstanceBase::bMontagePlayingOrHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bShouldPlayStaggered) == 0x00051C, "Member 'UDCMonsterAnimInstanceBase::bShouldPlayStaggered' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationNone) == 0x00051D, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationNone' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleEmpty) == 0x00051E, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleEmpty' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleDeath) == 0x00051F, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleDeath' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleReloaded) == 0x000520, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleReloaded' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleSpawn) == 0x000521, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleSpawn' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleDeactivate) == 0x000522, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleDeactivate' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleActivate) == 0x000523, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleActivate' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdle) == 0x000524, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdle' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleClose) == 0x000525, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleClose' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleOpen) == 0x000526, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleOpen' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleOpenForward) == 0x000527, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleOpenForward' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleOpenBackward) == 0x000528, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleOpenBackward' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleOn) == 0x000529, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleOn' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleDisarm) == 0x00052A, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleDisarm' has a wrong offset!");
static_assert(offsetof(UDCMonsterAnimInstanceBase, bStateAnimationIdleRemove) == 0x00052B, "Member 'UDCMonsterAnimInstanceBase::bStateAnimationIdleRemove' has a wrong offset!");

// Class DungeonCrawler.DCMonsterBase
// 0x0400 (0x0E00 - 0x0A00)
#pragma pack(push, 0x1)
class alignas(0x10) ADCMonsterBase : public ADCCharacterBase
{
public:
	uint8                                         Pad_275E[0x30];                                    // 0x0A00(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRepRootMotionActive;                            // 0x0A30(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_275F[0x7];                                     // 0x0A31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      PlayerCharacterOverlapComponent;                   // 0x0A38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReferenceCounterComponent*           ReferenceCounterComponent;                         // 0x0A40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2760[0x70];                                    // 0x0A48(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        MonsterId;                                         // 0x0AB8(0x0010)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2761[0xC0];                                    // 0x0AC8(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UArtDataMonster*                        ArtDataMonster;                                    // 0x0B88(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         OrientRotationToMovement;                          // 0x0B90(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2762[0x77];                                    // 0x0B91(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         MonsterCollisionProfile;                           // 0x0C08(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2763[0x77];                                    // 0x0C09(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         PauseAnims;                                        // 0x0C80(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2764[0x7];                                     // 0x0C81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IMonsterSpawnableInterface> MonsterSpawnableInterface;                         // 0x0C88(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDesignDataAssetMonster*                DesignDataAssetMonster;                            // 0x0C98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAcceleration;                                   // 0x0CA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalAcceleration;                                // 0x0CA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0CA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2765[0x4];                                     // 0x0CAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnedPoint;                                      // 0x0CB0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATargetPoint*>                   TargetPoints;                                      // 0x0CC8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAggressive;                                       // 0x0CD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterCollisionProfile                      DefaultMonsterCollisionProfile;                    // 0x0CD9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2766[0x6];                                     // 0x0CDA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorAsset;                                     // 0x0CE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdollDeath;                                     // 0x0CE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDelayDeath;                                       // 0x0CE9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2767[0x2];                                     // 0x0CEA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddtionalPlayerCharacterOverlapCapsuleComponentHalfHeight; // 0x0CEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddtionalPlayerCharacterOverlapCapsuleComponentRadius; // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggroPerTime;                                      // 0x0CF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddtionalAggro;                                    // 0x0CF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAggroPoint;                                     // 0x0CFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseAggroSec;                                  // 0x0D00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseAggroPointRate;                            // 0x0D04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FAggroInfo>        AggroInfoMap;                                      // 0x0D08(0x0050)(NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ADCCharacterBase>> SightTargets;                                      // 0x0D58(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ADCCharacterBase>> HearingTargets;                                    // 0x0D68(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ADCCharacterBase>> Minions;                                           // 0x0D78(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2768[0x58];                                    // 0x0D88(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPreview;                                          // 0x0DE0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2769[0x17];                                    // 0x0DE1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeforeDeath();
	bool Burrow();
	void ChangeOrientRotationToMovement(const uint8 Value);
	void ChangePauseAnims(const uint8 Value);
	bool CheckClassType(const struct FGameplayTag& InClassTypeTag);
	bool CheckGradeType(const struct FGameplayTag& InGradeTypeTag);
	bool Death();
	bool Fly();
	const struct FDesignDataMonster GetDesignDataMonster();
	const struct FPrimaryAssetId GetMonsterId();
	bool Interactable();
	bool InteractableOnly();
	bool InteractableWithoutHit();
	bool Normal();
	bool NormalPhysics();
	void OnAfterDeath();
	void OnAsyncInitialized();
	void OnBeforeDeath();
	void OnDamaged(class ADCCharacterBase* DCCharacterBase);
	void OnFMsgGASAttributeNotifyBlueprint(const struct FMsgGASAttributeNotify& InMsg);
	void OnLostTarget(class ADCCharacterBase* InTarget);
	void OnNewTarget(class ADCCharacterBase* InTarget);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_bIsRepRootMotionActive(bool InOldbIsRepRootMotionActive);
	void OnRep_MonsterCollisionProfile(const uint8& OldMonsterCollisionProfile);
	void OnRep_MonsterId(const struct FPrimaryAssetId& InOldMonsterId);
	void OnRep_OrientRotationToMovement(const uint8& OldOrientRotationToMovement);
	void OnRep_PauseAnims(const uint8& OldPauseAnims);
	void OnSetAI();
	void OnStuckByShield(class ADCCharacterBase* InInstigator, class AActor* InEffectCauser);
	void SetDelayDeathStatus(bool bStatus);
	void SetMonsterId(const struct FPrimaryAssetId& InMonsterId);

	bool GetDelayDeathStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterBase">();
	}
	static class ADCMonsterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCMonsterBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADCMonsterBase) == 0x000010, "Wrong alignment on ADCMonsterBase");
static_assert(sizeof(ADCMonsterBase) == 0x000E00, "Wrong size on ADCMonsterBase");
static_assert(offsetof(ADCMonsterBase, bIsRepRootMotionActive) == 0x000A30, "Member 'ADCMonsterBase::bIsRepRootMotionActive' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, PlayerCharacterOverlapComponent) == 0x000A38, "Member 'ADCMonsterBase::PlayerCharacterOverlapComponent' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, ReferenceCounterComponent) == 0x000A40, "Member 'ADCMonsterBase::ReferenceCounterComponent' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, MonsterId) == 0x000AB8, "Member 'ADCMonsterBase::MonsterId' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, ArtDataMonster) == 0x000B88, "Member 'ADCMonsterBase::ArtDataMonster' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, OrientRotationToMovement) == 0x000B90, "Member 'ADCMonsterBase::OrientRotationToMovement' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, MonsterCollisionProfile) == 0x000C08, "Member 'ADCMonsterBase::MonsterCollisionProfile' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, PauseAnims) == 0x000C80, "Member 'ADCMonsterBase::PauseAnims' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, MonsterSpawnableInterface) == 0x000C88, "Member 'ADCMonsterBase::MonsterSpawnableInterface' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, DesignDataAssetMonster) == 0x000C98, "Member 'ADCMonsterBase::DesignDataAssetMonster' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, MinAcceleration) == 0x000CA0, "Member 'ADCMonsterBase::MinAcceleration' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, NormalAcceleration) == 0x000CA4, "Member 'ADCMonsterBase::NormalAcceleration' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, MaxAcceleration) == 0x000CA8, "Member 'ADCMonsterBase::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, SpawnedPoint) == 0x000CB0, "Member 'ADCMonsterBase::SpawnedPoint' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, TargetPoints) == 0x000CC8, "Member 'ADCMonsterBase::TargetPoints' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, bAggressive) == 0x000CD8, "Member 'ADCMonsterBase::bAggressive' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, DefaultMonsterCollisionProfile) == 0x000CD9, "Member 'ADCMonsterBase::DefaultMonsterCollisionProfile' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, BehaviorAsset) == 0x000CE0, "Member 'ADCMonsterBase::BehaviorAsset' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, bRagdollDeath) == 0x000CE8, "Member 'ADCMonsterBase::bRagdollDeath' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, bDelayDeath) == 0x000CE9, "Member 'ADCMonsterBase::bDelayDeath' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, AddtionalPlayerCharacterOverlapCapsuleComponentHalfHeight) == 0x000CEC, "Member 'ADCMonsterBase::AddtionalPlayerCharacterOverlapCapsuleComponentHalfHeight' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, AddtionalPlayerCharacterOverlapCapsuleComponentRadius) == 0x000CF0, "Member 'ADCMonsterBase::AddtionalPlayerCharacterOverlapCapsuleComponentRadius' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, AggroPerTime) == 0x000CF4, "Member 'ADCMonsterBase::AggroPerTime' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, AddtionalAggro) == 0x000CF8, "Member 'ADCMonsterBase::AddtionalAggro' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, MaxAggroPoint) == 0x000CFC, "Member 'ADCMonsterBase::MaxAggroPoint' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, DecreaseAggroSec) == 0x000D00, "Member 'ADCMonsterBase::DecreaseAggroSec' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, DecreaseAggroPointRate) == 0x000D04, "Member 'ADCMonsterBase::DecreaseAggroPointRate' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, AggroInfoMap) == 0x000D08, "Member 'ADCMonsterBase::AggroInfoMap' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, SightTargets) == 0x000D58, "Member 'ADCMonsterBase::SightTargets' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, HearingTargets) == 0x000D68, "Member 'ADCMonsterBase::HearingTargets' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, Minions) == 0x000D78, "Member 'ADCMonsterBase::Minions' has a wrong offset!");
static_assert(offsetof(ADCMonsterBase, bPreview) == 0x000DE0, "Member 'ADCMonsterBase::bPreview' has a wrong offset!");

// Class DungeonCrawler.DCTrainingOptionWidgetBase
// 0x0030 (0x02F0 - 0x02C0)
class UDCTrainingOptionWidgetBase final : public UUserWidget
{
public:
	class UPerkWidget*                            PerkWidget;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkillWidget*                           SkillWidget;                                       // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCSpellWidgetBase*                     SpellWidget;                                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMusicWidgetBase*                     MusicWidget;                                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShapeShiftWidgetBase*                ShapeShiftWidget;                                  // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCRewardItemWidget*                    RewardWidget;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSetTrainingRewardInfo(EDCTrainingState TrainingState, EDCTrainingClassAbilityType ClassAbilityType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingOptionWidgetBase">();
	}
	static class UDCTrainingOptionWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingOptionWidgetBase>();
	}
};
static_assert(alignof(UDCTrainingOptionWidgetBase) == 0x000008, "Wrong alignment on UDCTrainingOptionWidgetBase");
static_assert(sizeof(UDCTrainingOptionWidgetBase) == 0x0002F0, "Wrong size on UDCTrainingOptionWidgetBase");
static_assert(offsetof(UDCTrainingOptionWidgetBase, PerkWidget) == 0x0002C0, "Member 'UDCTrainingOptionWidgetBase::PerkWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionWidgetBase, SkillWidget) == 0x0002C8, "Member 'UDCTrainingOptionWidgetBase::SkillWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionWidgetBase, SpellWidget) == 0x0002D0, "Member 'UDCTrainingOptionWidgetBase::SpellWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionWidgetBase, MusicWidget) == 0x0002D8, "Member 'UDCTrainingOptionWidgetBase::MusicWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionWidgetBase, ShapeShiftWidget) == 0x0002E0, "Member 'UDCTrainingOptionWidgetBase::ShapeShiftWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingOptionWidgetBase, RewardWidget) == 0x0002E8, "Member 'UDCTrainingOptionWidgetBase::RewardWidget' has a wrong offset!");

// Class DungeonCrawler.DCMonsterDataAsset
// 0x0108 (0x0150 - 0x0048)
class UDCMonsterDataAsset final : public UDCTableDataAsset
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ClassType;                                         // 0x0050(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   CharacterTypes;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Name_DCMonsterDataAsset;                           // 0x0070(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCLootDropGroupDataAsset> LootDropGroup;                                     // 0x0088(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataMonster>         ArtData;                                           // 0x00B0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x00D8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCMonsterBase>             ActorClass;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTagQueryData>>   HitTagQueryData;                                   // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTagQueryData>>   BeHitTagQueryData;                                 // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         AdvPoint;                                          // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpPoint;                                          // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterDataAsset">();
	}
	static class UDCMonsterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMonsterDataAsset>();
	}
};
static_assert(alignof(UDCMonsterDataAsset) == 0x000008, "Wrong alignment on UDCMonsterDataAsset");
static_assert(sizeof(UDCMonsterDataAsset) == 0x000150, "Wrong size on UDCMonsterDataAsset");
static_assert(offsetof(UDCMonsterDataAsset, IdTag) == 0x000048, "Member 'UDCMonsterDataAsset::IdTag' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, ClassType) == 0x000050, "Member 'UDCMonsterDataAsset::ClassType' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, GradeType) == 0x000058, "Member 'UDCMonsterDataAsset::GradeType' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, CharacterTypes) == 0x000060, "Member 'UDCMonsterDataAsset::CharacterTypes' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, Name_DCMonsterDataAsset) == 0x000070, "Member 'UDCMonsterDataAsset::Name_DCMonsterDataAsset' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, LootDropGroup) == 0x000088, "Member 'UDCMonsterDataAsset::LootDropGroup' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, ArtData) == 0x0000B0, "Member 'UDCMonsterDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, SoundData) == 0x0000D8, "Member 'UDCMonsterDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, ActorClass) == 0x000100, "Member 'UDCMonsterDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, HitTagQueryData) == 0x000108, "Member 'UDCMonsterDataAsset::HitTagQueryData' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, BeHitTagQueryData) == 0x000118, "Member 'UDCMonsterDataAsset::BeHitTagQueryData' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, Abilities) == 0x000128, "Member 'UDCMonsterDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, Effects) == 0x000138, "Member 'UDCMonsterDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, AdvPoint) == 0x000148, "Member 'UDCMonsterDataAsset::AdvPoint' has a wrong offset!");
static_assert(offsetof(UDCMonsterDataAsset, ExpPoint) == 0x00014C, "Member 'UDCMonsterDataAsset::ExpPoint' has a wrong offset!");

// Class DungeonCrawler.DCMonsterGameplayAbilityBase
// 0x0008 (0x05A8 - 0x05A0)
class UDCMonsterGameplayAbilityBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterGameplayAbilityBase">();
	}
	static class UDCMonsterGameplayAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMonsterGameplayAbilityBase>();
	}
};
static_assert(alignof(UDCMonsterGameplayAbilityBase) == 0x000008, "Wrong alignment on UDCMonsterGameplayAbilityBase");
static_assert(sizeof(UDCMonsterGameplayAbilityBase) == 0x0005A8, "Wrong size on UDCMonsterGameplayAbilityBase");
static_assert(offsetof(UDCMonsterGameplayAbilityBase, MontageToPlay) == 0x0005A0, "Member 'UDCMonsterGameplayAbilityBase::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.DCMonsterSpawner
// 0x00D0 (0x0368 - 0x0298)
class ADCMonsterSpawner final : public AActor
{
public:
	uint8                                         Pad_276E[0x60];                                    // 0x0298(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BillboardComponent;                                // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ArrowComponent;                                    // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterSpawnerType                           BoundType;                                         // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLinked;                                          // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterCollisionProfile                      MonsterCollisionProfile;                           // 0x0312(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276F[0x5];                                     // 0x0313(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ADCMonsterBase>>     Monsters;                                          // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATargetPoint*>                   TargetPoints;                                      // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2770[0x28];                                    // 0x0340(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	TArray<class ADCMonsterBase*> Spawns();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);
	void UpdateGameState(const struct FGameStateData& InGameStateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMonsterSpawner">();
	}
	static class ADCMonsterSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCMonsterSpawner>();
	}
};
static_assert(alignof(ADCMonsterSpawner) == 0x000008, "Wrong alignment on ADCMonsterSpawner");
static_assert(sizeof(ADCMonsterSpawner) == 0x000368, "Wrong size on ADCMonsterSpawner");
static_assert(offsetof(ADCMonsterSpawner, BaseObject) == 0x0002F8, "Member 'ADCMonsterSpawner::BaseObject' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, BillboardComponent) == 0x000300, "Member 'ADCMonsterSpawner::BillboardComponent' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, ArrowComponent) == 0x000308, "Member 'ADCMonsterSpawner::ArrowComponent' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, BoundType) == 0x000310, "Member 'ADCMonsterSpawner::BoundType' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, IsLinked) == 0x000311, "Member 'ADCMonsterSpawner::IsLinked' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, MonsterCollisionProfile) == 0x000312, "Member 'ADCMonsterSpawner::MonsterCollisionProfile' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, Monsters) == 0x000318, "Member 'ADCMonsterSpawner::Monsters' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, Range) == 0x000328, "Member 'ADCMonsterSpawner::Range' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, Count) == 0x00032C, "Member 'ADCMonsterSpawner::Count' has a wrong offset!");
static_assert(offsetof(ADCMonsterSpawner, TargetPoints) == 0x000330, "Member 'ADCMonsterSpawner::TargetPoints' has a wrong offset!");

// Class DungeonCrawler.DCInventoryMoveAbility
// 0x0000 (0x0750 - 0x0750)
class UDCInventoryMoveAbility : public UDCInventoryAbilityBase
{
public:
	void OnMoveApplied();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCInventoryMoveAbility">();
	}
	static class UDCInventoryMoveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCInventoryMoveAbility>();
	}
};
static_assert(alignof(UDCInventoryMoveAbility) == 0x000008, "Wrong alignment on UDCInventoryMoveAbility");
static_assert(sizeof(UDCInventoryMoveAbility) == 0x000750, "Wrong size on UDCInventoryMoveAbility");

// Class DungeonCrawler.DCTriumphLevelDataAsset
// 0x0008 (0x0050 - 0x0048)
class UDCTriumphLevelDataAsset final : public UDCTableDataAsset
{
public:
	int32                                         ExpForNextLevel;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalExp;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTriumphLevelDataAsset">();
	}
	static class UDCTriumphLevelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTriumphLevelDataAsset>();
	}
};
static_assert(alignof(UDCTriumphLevelDataAsset) == 0x000008, "Wrong alignment on UDCTriumphLevelDataAsset");
static_assert(sizeof(UDCTriumphLevelDataAsset) == 0x000050, "Wrong size on UDCTriumphLevelDataAsset");
static_assert(offsetof(UDCTriumphLevelDataAsset, ExpForNextLevel) == 0x000048, "Member 'UDCTriumphLevelDataAsset::ExpForNextLevel' has a wrong offset!");
static_assert(offsetof(UDCTriumphLevelDataAsset, TotalExp) == 0x00004C, "Member 'UDCTriumphLevelDataAsset::TotalExp' has a wrong offset!");

// Class DungeonCrawler.TradeChatWidget
// 0x0018 (0x0548 - 0x0530)
class UTradeChatWidget final : public UChatSetWidgetBase
{
public:
	class UDCCommonButtonBase*                    Btn_ReadRules;                                     // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTradeSubscriptionPopup>  TradersGuildRulesPopupClass;                       // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2771[0x8];                                     // 0x0540(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReadRulesButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeChatWidget">();
	}
	static class UTradeChatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeChatWidget>();
	}
};
static_assert(alignof(UTradeChatWidget) == 0x000008, "Wrong alignment on UTradeChatWidget");
static_assert(sizeof(UTradeChatWidget) == 0x000548, "Wrong size on UTradeChatWidget");
static_assert(offsetof(UTradeChatWidget, Btn_ReadRules) == 0x000530, "Member 'UTradeChatWidget::Btn_ReadRules' has a wrong offset!");
static_assert(offsetof(UTradeChatWidget, TradersGuildRulesPopupClass) == 0x000538, "Member 'UTradeChatWidget::TradersGuildRulesPopupClass' has a wrong offset!");

// Class DungeonCrawler.DCMovementModeInterface
// 0x0000 (0x0028 - 0x0028)
class IDCMovementModeInterface final : public IInterface
{
public:
	void SetLadderMode(class UBoxComponent* InLadderBoxComponent);
	void SetWalkingMode();

	bool IsLadderMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMovementModeInterface">();
	}
	static class IDCMovementModeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCMovementModeInterface>();
	}
};
static_assert(alignof(IDCMovementModeInterface) == 0x000008, "Wrong alignment on IDCMovementModeInterface");
static_assert(sizeof(IDCMovementModeInterface) == 0x000028, "Wrong size on IDCMovementModeInterface");

// Class DungeonCrawler.DCMultiLineEditableTextBox
// 0x0020 (0x10C0 - 0x10A0)
class UDCMultiLineEditableTextBox final : public UMultiLineEditableTextBox
{
public:
	FMulticastInlineDelegateProperty_             OnCursorMoved;                                     // 0x1098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserScrolled;                                    // 0x10A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2772[0x8];                                     // 0x10B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Goto(int32 InLineIndex, int32 InOffset);

	bool AnyTextSelected() const;
	void InsertTextAtCursor(const class FString& InText) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMultiLineEditableTextBox">();
	}
	static class UDCMultiLineEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMultiLineEditableTextBox>();
	}
};
static_assert(alignof(UDCMultiLineEditableTextBox) == 0x000010, "Wrong alignment on UDCMultiLineEditableTextBox");
static_assert(sizeof(UDCMultiLineEditableTextBox) == 0x0010C0, "Wrong size on UDCMultiLineEditableTextBox");
static_assert(offsetof(UDCMultiLineEditableTextBox, OnCursorMoved) == 0x001098, "Member 'UDCMultiLineEditableTextBox::OnCursorMoved' has a wrong offset!");
static_assert(offsetof(UDCMultiLineEditableTextBox, OnUserScrolled) == 0x0010A8, "Member 'UDCMultiLineEditableTextBox::OnUserScrolled' has a wrong offset!");

// Class DungeonCrawler.DCMusicDataAsset
// 0x0128 (0x0170 - 0x0048)
class UDCMusicDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCMusicDataAsset;                             // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               Desc;                                              // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayType;                                          // 0x0098(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SourceType;                                        // 0x00A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetType;                                        // 0x00A8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MusicTier;                                         // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTime;                                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingDuration;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingInterval;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadRange;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoodRange;                                         // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerfectRange;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MusicTag;                                          // 0x00CC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2773[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UArtDataMusic>           ArtData;                                           // 0x00D8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0100(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPlayMusicData>          PlayMusicData;                                     // 0x0128(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMusicDataAsset">();
	}
	static class UDCMusicDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMusicDataAsset>();
	}
};
static_assert(alignof(UDCMusicDataAsset) == 0x000008, "Wrong alignment on UDCMusicDataAsset");
static_assert(sizeof(UDCMusicDataAsset) == 0x000170, "Wrong size on UDCMusicDataAsset");
static_assert(offsetof(UDCMusicDataAsset, Name_DCMusicDataAsset) == 0x000048, "Member 'UDCMusicDataAsset::Name_DCMusicDataAsset' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, Desc) == 0x000060, "Member 'UDCMusicDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, Classes) == 0x000088, "Member 'UDCMusicDataAsset::Classes' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, PlayType) == 0x000098, "Member 'UDCMusicDataAsset::PlayType' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, SourceType) == 0x0000A0, "Member 'UDCMusicDataAsset::SourceType' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, TargetType) == 0x0000A8, "Member 'UDCMusicDataAsset::TargetType' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, MusicTier) == 0x0000B0, "Member 'UDCMusicDataAsset::MusicTier' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, PlayTime) == 0x0000B4, "Member 'UDCMusicDataAsset::PlayTime' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, ChannelingDuration) == 0x0000B8, "Member 'UDCMusicDataAsset::ChannelingDuration' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, ChannelingInterval) == 0x0000BC, "Member 'UDCMusicDataAsset::ChannelingInterval' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, BadRange) == 0x0000C0, "Member 'UDCMusicDataAsset::BadRange' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, GoodRange) == 0x0000C4, "Member 'UDCMusicDataAsset::GoodRange' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, PerfectRange) == 0x0000C8, "Member 'UDCMusicDataAsset::PerfectRange' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, MusicTag) == 0x0000CC, "Member 'UDCMusicDataAsset::MusicTag' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, ArtData) == 0x0000D8, "Member 'UDCMusicDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, SoundData) == 0x000100, "Member 'UDCMusicDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, PlayMusicData) == 0x000128, "Member 'UDCMusicDataAsset::PlayMusicData' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, Abilities) == 0x000150, "Member 'UDCMusicDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCMusicDataAsset, Effects) == 0x000160, "Member 'UDCMusicDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCTooltipWidget
// 0x0010 (0x0368 - 0x0358)
class UDCTooltipWidget : public UDCWidgetBase
{
public:
	class UTextBlock*                             NameText;                                          // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DescriptionText;                                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetTooltipData(const class FText& InNameText, const class FText& InDescriptionText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTooltipWidget">();
	}
	static class UDCTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTooltipWidget>();
	}
};
static_assert(alignof(UDCTooltipWidget) == 0x000008, "Wrong alignment on UDCTooltipWidget");
static_assert(sizeof(UDCTooltipWidget) == 0x000368, "Wrong size on UDCTooltipWidget");
static_assert(offsetof(UDCTooltipWidget, NameText) == 0x000358, "Member 'UDCTooltipWidget::NameText' has a wrong offset!");
static_assert(offsetof(UDCTooltipWidget, DescriptionText) == 0x000360, "Member 'UDCTooltipWidget::DescriptionText' has a wrong offset!");

// Class DungeonCrawler.DCServerOptimizeSubsystem
// 0x0000 (0x0030 - 0x0030)
class UDCServerOptimizeSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCServerOptimizeSubsystem">();
	}
	static class UDCServerOptimizeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCServerOptimizeSubsystem>();
	}
};
static_assert(alignof(UDCServerOptimizeSubsystem) == 0x000008, "Wrong alignment on UDCServerOptimizeSubsystem");
static_assert(sizeof(UDCServerOptimizeSubsystem) == 0x000030, "Wrong size on UDCServerOptimizeSubsystem");

// Class DungeonCrawler.DCMusicTooltipWidget
// 0x0008 (0x0370 - 0x0368)
class UDCMusicTooltipWidget final : public UDCTooltipWidget
{
public:
	class UTextBlock*                             SourceTypeText;                                    // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetType(const struct FGameplayTag& SourceTypeTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMusicTooltipWidget">();
	}
	static class UDCMusicTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMusicTooltipWidget>();
	}
};
static_assert(alignof(UDCMusicTooltipWidget) == 0x000008, "Wrong alignment on UDCMusicTooltipWidget");
static_assert(sizeof(UDCMusicTooltipWidget) == 0x000370, "Wrong size on UDCMusicTooltipWidget");
static_assert(offsetof(UDCMusicTooltipWidget, SourceTypeText) == 0x000368, "Member 'UDCMusicTooltipWidget::SourceTypeText' has a wrong offset!");

// Class DungeonCrawler.DCMusicWidgetBase
// 0x0060 (0x03B8 - 0x0358)
class UDCMusicWidgetBase final : public UDCWidgetBase
{
public:
	class UImage*                                 MusicIcon;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCMusicTooltipWidget>      MusicTooltipWidgetClass;                           // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSet;                                              // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2774[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MusicName;                                         // 0x0370(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class FText                                   MusicDesc;                                         // 0x0388(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           MusicType;                                         // 0x03A0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        DescId;                                            // 0x03A8(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetMusicTooltipWidget();
	void OnArtDataSet(const class UArtDataMusic* ArtData);
	void OnReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCMusicWidgetBase">();
	}
	static class UDCMusicWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCMusicWidgetBase>();
	}
};
static_assert(alignof(UDCMusicWidgetBase) == 0x000008, "Wrong alignment on UDCMusicWidgetBase");
static_assert(sizeof(UDCMusicWidgetBase) == 0x0003B8, "Wrong size on UDCMusicWidgetBase");
static_assert(offsetof(UDCMusicWidgetBase, MusicIcon) == 0x000358, "Member 'UDCMusicWidgetBase::MusicIcon' has a wrong offset!");
static_assert(offsetof(UDCMusicWidgetBase, MusicTooltipWidgetClass) == 0x000360, "Member 'UDCMusicWidgetBase::MusicTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCMusicWidgetBase, bSet) == 0x000368, "Member 'UDCMusicWidgetBase::bSet' has a wrong offset!");
static_assert(offsetof(UDCMusicWidgetBase, MusicName) == 0x000370, "Member 'UDCMusicWidgetBase::MusicName' has a wrong offset!");
static_assert(offsetof(UDCMusicWidgetBase, MusicDesc) == 0x000388, "Member 'UDCMusicWidgetBase::MusicDesc' has a wrong offset!");
static_assert(offsetof(UDCMusicWidgetBase, MusicType) == 0x0003A0, "Member 'UDCMusicWidgetBase::MusicType' has a wrong offset!");
static_assert(offsetof(UDCMusicWidgetBase, DescId) == 0x0003A8, "Member 'UDCMusicWidgetBase::DescId' has a wrong offset!");

// Class DungeonCrawler.DCNavigationSystem
// 0x0000 (0x1590 - 0x1590)
class UDCNavigationSystem final : public UNavigationSystemV1
{
public:
	static bool FindPathToLocation(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCNavigationSystem">();
	}
	static class UDCNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCNavigationSystem>();
	}
};
static_assert(alignof(UDCNavigationSystem) == 0x000008, "Wrong alignment on UDCNavigationSystem");
static_assert(sizeof(UDCNavigationSystem) == 0x001590, "Wrong size on UDCNavigationSystem");

// Class DungeonCrawler.DCNetReplicationGraphConnection
// 0x0050 (0x03C8 - 0x0378)
class UDCNetReplicationGraphConnection final : public UNetReplicationGraphConnection
{
public:
	TSet<class AActor*>                           ActorSet;                                          // 0x0378(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCNetReplicationGraphConnection">();
	}
	static class UDCNetReplicationGraphConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCNetReplicationGraphConnection>();
	}
};
static_assert(alignof(UDCNetReplicationGraphConnection) == 0x000008, "Wrong alignment on UDCNetReplicationGraphConnection");
static_assert(sizeof(UDCNetReplicationGraphConnection) == 0x0003C8, "Wrong size on UDCNetReplicationGraphConnection");
static_assert(offsetof(UDCNetReplicationGraphConnection, ActorSet) == 0x000378, "Member 'UDCNetReplicationGraphConnection::ActorSet' has a wrong offset!");

// Class DungeonCrawler.DCShapeShiftWidgetBase
// 0x0050 (0x03A8 - 0x0358)
class UDCShapeShiftWidgetBase final : public UDCWidgetBase
{
public:
	class UImage*                                 ShapeShiftIcon;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTooltipWidget>           ShapeShiftTooltipWidgetClass;                      // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSet;                                              // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2776[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ShapeShiftName;                                    // 0x0370(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class FText                                   ShapeShiftDesc;                                    // 0x0388(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class UDescData*                              ShapeShiftDescData;                                // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetShapeShiftTooltipWidget();
	void OnArtDataSet(const class UDCCharacterShapeShiftArtData* ArtData);
	void OnReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShapeShiftWidgetBase">();
	}
	static class UDCShapeShiftWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShapeShiftWidgetBase>();
	}
};
static_assert(alignof(UDCShapeShiftWidgetBase) == 0x000008, "Wrong alignment on UDCShapeShiftWidgetBase");
static_assert(sizeof(UDCShapeShiftWidgetBase) == 0x0003A8, "Wrong size on UDCShapeShiftWidgetBase");
static_assert(offsetof(UDCShapeShiftWidgetBase, ShapeShiftIcon) == 0x000358, "Member 'UDCShapeShiftWidgetBase::ShapeShiftIcon' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftWidgetBase, ShapeShiftTooltipWidgetClass) == 0x000360, "Member 'UDCShapeShiftWidgetBase::ShapeShiftTooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftWidgetBase, bSet) == 0x000368, "Member 'UDCShapeShiftWidgetBase::bSet' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftWidgetBase, ShapeShiftName) == 0x000370, "Member 'UDCShapeShiftWidgetBase::ShapeShiftName' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftWidgetBase, ShapeShiftDesc) == 0x000388, "Member 'UDCShapeShiftWidgetBase::ShapeShiftDesc' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftWidgetBase, ShapeShiftDescData) == 0x0003A0, "Member 'UDCShapeShiftWidgetBase::ShapeShiftDescData' has a wrong offset!");

// Class DungeonCrawler.DCNPCBase
// 0x0020 (0x0E20 - 0x0E00)
class ADCNPCBase : public ADCMonsterBase
{
public:
	class UInteractableTargetComponent*           InteractableTargetComponent;                       // 0x0DF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDCPropsInteractDataAsset*>      InteractSettingArray;                              // 0x0E00(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2777[0x10];                                    // 0x0E10(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCNPCBase">();
	}
	static class ADCNPCBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCNPCBase>();
	}
};
static_assert(alignof(ADCNPCBase) == 0x000010, "Wrong alignment on ADCNPCBase");
static_assert(sizeof(ADCNPCBase) == 0x000E20, "Wrong size on ADCNPCBase");
static_assert(offsetof(ADCNPCBase, InteractableTargetComponent) == 0x000DF8, "Member 'ADCNPCBase::InteractableTargetComponent' has a wrong offset!");
static_assert(offsetof(ADCNPCBase, InteractSettingArray) == 0x000E00, "Member 'ADCNPCBase::InteractSettingArray' has a wrong offset!");

// Class DungeonCrawler.DCNPCExpressman
// 0x0040 (0x0E60 - 0x0E20)
class ADCNPCExpressman : public ADCNPCBase
{
public:
	uint8                                         Pad_2778[0x18];                                    // 0x0E20(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   DeliverySucceededTags;                             // 0x0E38(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   DeliveryFailedTags;                                // 0x0E48(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2779[0x8];                                     // 0x0E58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Despawn();
	void ExpressReaction(const bool bIsReaction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCNPCExpressman">();
	}
	static class ADCNPCExpressman* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCNPCExpressman>();
	}
};
static_assert(alignof(ADCNPCExpressman) == 0x000010, "Wrong alignment on ADCNPCExpressman");
static_assert(sizeof(ADCNPCExpressman) == 0x000E60, "Wrong size on ADCNPCExpressman");
static_assert(offsetof(ADCNPCExpressman, DeliverySucceededTags) == 0x000E38, "Member 'ADCNPCExpressman::DeliverySucceededTags' has a wrong offset!");
static_assert(offsetof(ADCNPCExpressman, DeliveryFailedTags) == 0x000E48, "Member 'ADCNPCExpressman::DeliveryFailedTags' has a wrong offset!");

// Class DungeonCrawler.DCNPCInteractAbility
// 0x0110 (0x06B0 - 0x05A0)
class UDCNPCInteractAbility : public UDCGameplayAbilityBase
{
public:
	float                                         AllowDistanceThreshold;                            // 0x05A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_277A[0x4];                                     // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCNPCBase*                             NPCTargetActor;                                    // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 InteractPlayer;                                    // 0x05B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCNPCType                                    NPCType;                                           // 0x05B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_277B[0x7];                                     // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x05C0(0x00E8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDCBoxInventory*                        ExpressInventory;                                  // 0x06A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFinish();
	void OnOutOfRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCNPCInteractAbility">();
	}
	static class UDCNPCInteractAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCNPCInteractAbility>();
	}
};
static_assert(alignof(UDCNPCInteractAbility) == 0x000008, "Wrong alignment on UDCNPCInteractAbility");
static_assert(sizeof(UDCNPCInteractAbility) == 0x0006B0, "Wrong size on UDCNPCInteractAbility");
static_assert(offsetof(UDCNPCInteractAbility, AllowDistanceThreshold) == 0x0005A0, "Member 'UDCNPCInteractAbility::AllowDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UDCNPCInteractAbility, NPCTargetActor) == 0x0005A8, "Member 'UDCNPCInteractAbility::NPCTargetActor' has a wrong offset!");
static_assert(offsetof(UDCNPCInteractAbility, InteractPlayer) == 0x0005B0, "Member 'UDCNPCInteractAbility::InteractPlayer' has a wrong offset!");
static_assert(offsetof(UDCNPCInteractAbility, NPCType) == 0x0005B8, "Member 'UDCNPCInteractAbility::NPCType' has a wrong offset!");
static_assert(offsetof(UDCNPCInteractAbility, HitResult) == 0x0005C0, "Member 'UDCNPCInteractAbility::HitResult' has a wrong offset!");
static_assert(offsetof(UDCNPCInteractAbility, ExpressInventory) == 0x0006A8, "Member 'UDCNPCInteractAbility::ExpressInventory' has a wrong offset!");

// Class DungeonCrawler.DCPartyChatInterface
// 0x0000 (0x0028 - 0x0028)
class IDCPartyChatInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPartyChatInterface">();
	}
	static class IDCPartyChatInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCPartyChatInterface>();
	}
};
static_assert(alignof(IDCPartyChatInterface) == 0x000008, "Wrong alignment on IDCPartyChatInterface");
static_assert(sizeof(IDCPartyChatInterface) == 0x000028, "Wrong size on IDCPartyChatInterface");

// Class DungeonCrawler.DCShopCurrencyTypeSelectPopupData
// 0x0058 (0x0088 - 0x0030)
class UDCShopCurrencyTypeSelectPopupData final : public UPopupDataBase
{
public:
	TMap<EDCShopCurrencyType, int32>              PriceMap;                                          // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	EDCShopCurrencyType                           InitCurrencyType;                                  // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277C[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopCurrencyTypeSelectPopupData">();
	}
	static class UDCShopCurrencyTypeSelectPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopCurrencyTypeSelectPopupData>();
	}
};
static_assert(alignof(UDCShopCurrencyTypeSelectPopupData) == 0x000008, "Wrong alignment on UDCShopCurrencyTypeSelectPopupData");
static_assert(sizeof(UDCShopCurrencyTypeSelectPopupData) == 0x000088, "Wrong size on UDCShopCurrencyTypeSelectPopupData");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupData, PriceMap) == 0x000030, "Member 'UDCShopCurrencyTypeSelectPopupData::PriceMap' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSelectPopupData, InitCurrencyType) == 0x000080, "Member 'UDCShopCurrencyTypeSelectPopupData::InitCurrencyType' has a wrong offset!");

// Class DungeonCrawler.DCPartyManager
// 0x0108 (0x0138 - 0x0030)
class UDCPartyManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_277D[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCPartyId, struct FDCPartyInfo>  PartyInfos;                                        // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCAccountId, struct FDCPartyId>  AccountPartyMap;                                   // 0x0098(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_277E[0x50];                                    // 0x00E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Add(const struct FDCPartyId& PartyId, const struct FDCAccountId& AccountId);
	void DebugOnScreen();
	void OnPlayerAdded(const struct FDCPlayerInfo& Info);
	void OnPlayerRemoved(const struct FDCPlayerInfo& RemovedPlayer);
	void OnPlayerUpdated(const struct FDCPlayerInfo& NewInfo, const struct FDCPlayerInfo& OldInfo);
	void Remove(const struct FDCPartyId& PartyId, const struct FDCAccountId& AccountId);
	void Update(const struct FDCPlayerInfo& Info);

	TArray<struct FDCPartyId> GetParties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPartyManager">();
	}
	static class UDCPartyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPartyManager>();
	}
};
static_assert(alignof(UDCPartyManager) == 0x000008, "Wrong alignment on UDCPartyManager");
static_assert(sizeof(UDCPartyManager) == 0x000138, "Wrong size on UDCPartyManager");
static_assert(offsetof(UDCPartyManager, PartyInfos) == 0x000048, "Member 'UDCPartyManager::PartyInfos' has a wrong offset!");
static_assert(offsetof(UDCPartyManager, AccountPartyMap) == 0x000098, "Member 'UDCPartyManager::AccountPartyMap' has a wrong offset!");

// Class DungeonCrawler.DCPartyMemberActorStatusRow
// 0x0028 (0x02E8 - 0x02C0)
class UDCPartyMemberActorStatusRow final : public UUserWidget
{
public:
	class UGameActorStatusSlotWidget*             PartyMemberActorStatusEntry1;                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameActorStatusSlotWidget*             PartyMemberActorStatusEntry2;                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameActorStatusSlotWidget*             PartyMemberActorStatusEntry3;                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGameActorStatusSlotWidget*>     PartyMemberActorStatusEntries;                     // 0x02D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPartyMemberActorStatusRow">();
	}
	static class UDCPartyMemberActorStatusRow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPartyMemberActorStatusRow>();
	}
};
static_assert(alignof(UDCPartyMemberActorStatusRow) == 0x000008, "Wrong alignment on UDCPartyMemberActorStatusRow");
static_assert(sizeof(UDCPartyMemberActorStatusRow) == 0x0002E8, "Wrong size on UDCPartyMemberActorStatusRow");
static_assert(offsetof(UDCPartyMemberActorStatusRow, PartyMemberActorStatusEntry1) == 0x0002C0, "Member 'UDCPartyMemberActorStatusRow::PartyMemberActorStatusEntry1' has a wrong offset!");
static_assert(offsetof(UDCPartyMemberActorStatusRow, PartyMemberActorStatusEntry2) == 0x0002C8, "Member 'UDCPartyMemberActorStatusRow::PartyMemberActorStatusEntry2' has a wrong offset!");
static_assert(offsetof(UDCPartyMemberActorStatusRow, PartyMemberActorStatusEntry3) == 0x0002D0, "Member 'UDCPartyMemberActorStatusRow::PartyMemberActorStatusEntry3' has a wrong offset!");
static_assert(offsetof(UDCPartyMemberActorStatusRow, PartyMemberActorStatusEntries) == 0x0002D8, "Member 'UDCPartyMemberActorStatusRow::PartyMemberActorStatusEntries' has a wrong offset!");

// Class DungeonCrawler.DCPedestalPortal
// 0x0098 (0x0478 - 0x03E0)
class ADCPedestalPortal final : public APropsActorBase
{
public:
	class UDCSessionRuleComponent*                SessionRuleComponent;                              // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADCPedestalPortalScrollBase> DownPedestalPortalScrollClass;                     // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADCPedestalPortalScrollBase> EscapePedestalPortalScrollClass;                   // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   PedestalPortalScrollActivateAbilityTriggerTagArray; // 0x03F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                PedestalPortalScrollHolderArray;                   // 0x0408(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 TimeRange;                                         // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<EDCPedestalPortalScrollNum>            PedestalPortalScrollNums;                          // 0x0428(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<EDCPortalScrollType>                   PedestalPortalScrollTypes;                         // 0x0438(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	EDCPortalScrollType                           ConfirmedPedestalPortalScrollType;                 // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFloorRulePhase                               TriggerFloorRulePhase;                             // 0x0449(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_277F[0x2];                                     // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriggerFloorRuleIndex;                             // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActivatePortalTime;                                // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PortalEffectDurationTime;                          // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRiseUp;                                         // 0x0458(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2780[0x1F];                                    // 0x0459(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlizzardData(const struct FGameBlizzardData& InBlizzardData);
	void OnDeathSwarmData(const struct FGameDeathSwarmData& InDeathSwarmData);
	void OnFloorRuleData(const struct FGameFloorRuleData& InFloorRuleData);
	void OnPortalEffect();
	void OnRep_ConfirmedPedestalPortalScrollType(const EDCPortalScrollType& InOldConfirmedPedestalPortalScrollType);
	void OnRep_IsRiseUp();
	void OnRightAfterDecidedPortalType();
	void RiseUpPortalHeadStone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPedestalPortal">();
	}
	static class ADCPedestalPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPedestalPortal>();
	}
};
static_assert(alignof(ADCPedestalPortal) == 0x000008, "Wrong alignment on ADCPedestalPortal");
static_assert(sizeof(ADCPedestalPortal) == 0x000478, "Wrong size on ADCPedestalPortal");
static_assert(offsetof(ADCPedestalPortal, SessionRuleComponent) == 0x0003E0, "Member 'ADCPedestalPortal::SessionRuleComponent' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, DownPedestalPortalScrollClass) == 0x0003E8, "Member 'ADCPedestalPortal::DownPedestalPortalScrollClass' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, EscapePedestalPortalScrollClass) == 0x0003F0, "Member 'ADCPedestalPortal::EscapePedestalPortalScrollClass' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, PedestalPortalScrollActivateAbilityTriggerTagArray) == 0x0003F8, "Member 'ADCPedestalPortal::PedestalPortalScrollActivateAbilityTriggerTagArray' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, PedestalPortalScrollHolderArray) == 0x000408, "Member 'ADCPedestalPortal::PedestalPortalScrollHolderArray' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, TimeRange) == 0x000418, "Member 'ADCPedestalPortal::TimeRange' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, PedestalPortalScrollNums) == 0x000428, "Member 'ADCPedestalPortal::PedestalPortalScrollNums' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, PedestalPortalScrollTypes) == 0x000438, "Member 'ADCPedestalPortal::PedestalPortalScrollTypes' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, ConfirmedPedestalPortalScrollType) == 0x000448, "Member 'ADCPedestalPortal::ConfirmedPedestalPortalScrollType' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, TriggerFloorRulePhase) == 0x000449, "Member 'ADCPedestalPortal::TriggerFloorRulePhase' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, TriggerFloorRuleIndex) == 0x00044C, "Member 'ADCPedestalPortal::TriggerFloorRuleIndex' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, ActivatePortalTime) == 0x000450, "Member 'ADCPedestalPortal::ActivatePortalTime' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, PortalEffectDurationTime) == 0x000454, "Member 'ADCPedestalPortal::PortalEffectDurationTime' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortal, bIsRiseUp) == 0x000458, "Member 'ADCPedestalPortal::bIsRiseUp' has a wrong offset!");

// Class DungeonCrawler.DCPedestalPortalScrollBase
// 0x0018 (0x03F8 - 0x03E0)
class ADCPedestalPortalScrollBase : public APropsActorBase
{
public:
	class UBoxComponent*                          PortalBoxCollision;                                // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOpen;                                           // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRiseUp;                                         // 0x03E9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCPortalScrollType                           PedestalPortalScrollType;                          // 0x03EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2781[0xD];                                     // 0x03EB(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginOverlapPortal(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndx, bool bFromSweep, const struct FHitResult& SweepResult);
	void ClosePortalScroll(class ADCPlayerCharacterBase* Character);
	void OnRep_IsOpen();
	void OnRep_IsRiseUp();
	void PortalOpen();
	void SetPortalHeadStoneMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPedestalPortalScrollBase">();
	}
	static class ADCPedestalPortalScrollBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPedestalPortalScrollBase>();
	}
};
static_assert(alignof(ADCPedestalPortalScrollBase) == 0x000008, "Wrong alignment on ADCPedestalPortalScrollBase");
static_assert(sizeof(ADCPedestalPortalScrollBase) == 0x0003F8, "Wrong size on ADCPedestalPortalScrollBase");
static_assert(offsetof(ADCPedestalPortalScrollBase, PortalBoxCollision) == 0x0003E0, "Member 'ADCPedestalPortalScrollBase::PortalBoxCollision' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortalScrollBase, bIsOpen) == 0x0003E8, "Member 'ADCPedestalPortalScrollBase::bIsOpen' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortalScrollBase, bIsRiseUp) == 0x0003E9, "Member 'ADCPedestalPortalScrollBase::bIsRiseUp' has a wrong offset!");
static_assert(offsetof(ADCPedestalPortalScrollBase, PedestalPortalScrollType) == 0x0003EA, "Member 'ADCPedestalPortalScrollBase::PedestalPortalScrollType' has a wrong offset!");

// Class DungeonCrawler.DCCharacterSkinShopDataAsset
// 0x0028 (0x00D0 - 0x00A8)
class UDCCharacterSkinShopDataAsset final : public UDCShopDataAsset
{
public:
	TSoftObjectPtr<class UDCCharacterSkinDataAsset> StockData;                                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCCharacterSkinShopDataAsset">();
	}
	static class UDCCharacterSkinShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCCharacterSkinShopDataAsset>();
	}
};
static_assert(alignof(UDCCharacterSkinShopDataAsset) == 0x000008, "Wrong alignment on UDCCharacterSkinShopDataAsset");
static_assert(sizeof(UDCCharacterSkinShopDataAsset) == 0x0000D0, "Wrong size on UDCCharacterSkinShopDataAsset");
static_assert(offsetof(UDCCharacterSkinShopDataAsset, StockData) == 0x0000A8, "Member 'UDCCharacterSkinShopDataAsset::StockData' has a wrong offset!");

// Class DungeonCrawler.DCPerfMonitor
// 0x0020 (0x0050 - 0x0030)
class UDCPerfMonitor final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_2783[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPerfMonitor">();
	}
	static class UDCPerfMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPerfMonitor>();
	}
};
static_assert(alignof(UDCPerfMonitor) == 0x000008, "Wrong alignment on UDCPerfMonitor");
static_assert(sizeof(UDCPerfMonitor) == 0x000050, "Wrong size on UDCPerfMonitor");

// Class DungeonCrawler.DCPerkDataAsset
// 0x00B8 (0x0100 - 0x0048)
class UDCPerkDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCPerkDataAsset;                              // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               DescData;                                          // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUse;                                            // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2784[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2785[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCIdTagGroupDataAsset*                 AllowIdTagGroup;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCIdTagGroupDataAsset*                 NotAllowIdTagGroup;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataPerk>            ArtData;                                           // 0x00B8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPerkDataAsset">();
	}
	static class UDCPerkDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPerkDataAsset>();
	}
};
static_assert(alignof(UDCPerkDataAsset) == 0x000008, "Wrong alignment on UDCPerkDataAsset");
static_assert(sizeof(UDCPerkDataAsset) == 0x000100, "Wrong size on UDCPerkDataAsset");
static_assert(offsetof(UDCPerkDataAsset, Name_DCPerkDataAsset) == 0x000048, "Member 'UDCPerkDataAsset::Name_DCPerkDataAsset' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, DescData) == 0x000060, "Member 'UDCPerkDataAsset::DescData' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, CanUse) == 0x000088, "Member 'UDCPerkDataAsset::CanUse' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, Classes) == 0x000090, "Member 'UDCPerkDataAsset::Classes' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, Radius) == 0x0000A0, "Member 'UDCPerkDataAsset::Radius' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, AllowIdTagGroup) == 0x0000A8, "Member 'UDCPerkDataAsset::AllowIdTagGroup' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, NotAllowIdTagGroup) == 0x0000B0, "Member 'UDCPerkDataAsset::NotAllowIdTagGroup' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, ArtData) == 0x0000B8, "Member 'UDCPerkDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, Abilities) == 0x0000E0, "Member 'UDCPerkDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCPerkDataAsset, Effects) == 0x0000F0, "Member 'UDCPerkDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCPerkDataComponent
// 0x0068 (0x0108 - 0x00A0)
class UDCPerkDataComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2786[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                PerkDataIds;                                       // 0x00B8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  WhiteListItems;                                    // 0x00C8(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlackListItems;                                    // 0x00E8(0x0020)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnRep_PerkDataIds(const TArray<struct FPrimaryAssetId>& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPerkDataComponent">();
	}
	static class UDCPerkDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPerkDataComponent>();
	}
};
static_assert(alignof(UDCPerkDataComponent) == 0x000008, "Wrong alignment on UDCPerkDataComponent");
static_assert(sizeof(UDCPerkDataComponent) == 0x000108, "Wrong size on UDCPerkDataComponent");
static_assert(offsetof(UDCPerkDataComponent, PerkDataIds) == 0x0000B8, "Member 'UDCPerkDataComponent::PerkDataIds' has a wrong offset!");
static_assert(offsetof(UDCPerkDataComponent, WhiteListItems) == 0x0000C8, "Member 'UDCPerkDataComponent::WhiteListItems' has a wrong offset!");
static_assert(offsetof(UDCPerkDataComponent, BlackListItems) == 0x0000E8, "Member 'UDCPerkDataComponent::BlackListItems' has a wrong offset!");

// Class DungeonCrawler.DCPlayerBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCPlayerBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class APawn* GetCurrentPlayerPawn(const class UObject* WorldContextObject);
	static void Log(const class FString& Str);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerBlueprintFunctionLibrary">();
	}
	static class UDCPlayerBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UDCPlayerBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UDCPlayerBlueprintFunctionLibrary");
static_assert(sizeof(UDCPlayerBlueprintFunctionLibrary) == 0x000028, "Wrong size on UDCPlayerBlueprintFunctionLibrary");

// Class DungeonCrawler.DCRecruitChannelWidget
// 0x0058 (0x0510 - 0x04B8)
class UDCRecruitChannelWidget final : public ULobbyGroupWidgetBase
{
public:
	class UDCChannelChatWidget*                   ChannelChatWidget;                                 // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCChannelPlayerListWidget*             ChannelPlayersWidget;                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        InventoryWidgetSwitcher;                           // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventorySetWidget*                  LocalInventorySetWidget;                           // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterInventoryWidget*            InspectingPlayerInventoryWidget;                   // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   ChannelTitle;                                      // 0x04E0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2787[0x18];                                    // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCloseInspectingInventoryClicked();
	void OnLeaveClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRecruitChannelWidget">();
	}
	static class UDCRecruitChannelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRecruitChannelWidget>();
	}
};
static_assert(alignof(UDCRecruitChannelWidget) == 0x000008, "Wrong alignment on UDCRecruitChannelWidget");
static_assert(sizeof(UDCRecruitChannelWidget) == 0x000510, "Wrong size on UDCRecruitChannelWidget");
static_assert(offsetof(UDCRecruitChannelWidget, ChannelChatWidget) == 0x0004B8, "Member 'UDCRecruitChannelWidget::ChannelChatWidget' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelWidget, ChannelPlayersWidget) == 0x0004C0, "Member 'UDCRecruitChannelWidget::ChannelPlayersWidget' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelWidget, InventoryWidgetSwitcher) == 0x0004C8, "Member 'UDCRecruitChannelWidget::InventoryWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelWidget, LocalInventorySetWidget) == 0x0004D0, "Member 'UDCRecruitChannelWidget::LocalInventorySetWidget' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelWidget, InspectingPlayerInventoryWidget) == 0x0004D8, "Member 'UDCRecruitChannelWidget::InspectingPlayerInventoryWidget' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelWidget, ChannelTitle) == 0x0004E0, "Member 'UDCRecruitChannelWidget::ChannelTitle' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterAnimInstanceBase
// 0x0160 (0x0660 - 0x0500)
class UDCPlayerCharacterAnimInstanceBase : public UDCCharacterAnimInstanceBase
{
public:
	bool                                          bHoldingTwoHandedItem;                             // 0x0500(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInFirstPersonPerspective;                       // 0x0501(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMontageLooping;                                 // 0x0502(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLadderClimbing;                                 // 0x0503(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsFullBodyAnimating;                  // 0x0504(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsResting;                            // 0x0505(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsSkillMontagePlaying;                // 0x0506(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsEmotePlaying;                       // 0x0507(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsAttackPrimary;                      // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsAttackSecondary;                    // 0x0509(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsItemEquipPrimary;                   // 0x050A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsItemEquipSecondary;                 // 0x050B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsItemEquipPrimaryTwoHanded;          // 0x050C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsItemEquipSecondaryTwoHanded;        // 0x050D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsPlayMusic;                          // 0x050E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsItemConsuming;                      // 0x050F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsInteractInstall;                    // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsAttackSpecial;                      // 0x0511(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsLadderClimbing;                     // 0x0512(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsBackstepping;                       // 0x0513(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsRopeHang;                           // 0x0514(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GameplayTag_bIsGhost;                              // 0x0515(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2788[0x2];                                     // 0x0516(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpStateMachineRemainAnimTimeRatio;               // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionStateMachineRemainAnimTimeRatio;         // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          HeadMeshAsset;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLocomotionAnimSet                     ItemAnimationSet;                                  // 0x0528(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLocomotionAnimSet                     SecondaryItemAnimationSet;                         // 0x0540(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  PrimaryMontageTagContainer;                        // 0x0558(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SecondaryMontageTagContainer;                      // 0x0578(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TwoHandedMontageTagContainer;                      // 0x0598(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LoopSectionNames;                                  // 0x05B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   JumpStateMachineName;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocomotionStateMachineName;                        // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsModifyBone;                                     // 0x05D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEmoteItemBoneModify;                            // 0x05D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2789[0x6];                                     // 0x05DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ItemModifyBoneTranslation_fk_weapon_l;             // 0x05E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278A[0x68];                                    // 0x05F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterAnimInstanceBase">();
	}
	static class UDCPlayerCharacterAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerCharacterAnimInstanceBase>();
	}
};
static_assert(alignof(UDCPlayerCharacterAnimInstanceBase) == 0x000010, "Wrong alignment on UDCPlayerCharacterAnimInstanceBase");
static_assert(sizeof(UDCPlayerCharacterAnimInstanceBase) == 0x000660, "Wrong size on UDCPlayerCharacterAnimInstanceBase");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, bHoldingTwoHandedItem) == 0x000500, "Member 'UDCPlayerCharacterAnimInstanceBase::bHoldingTwoHandedItem' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, bIsInFirstPersonPerspective) == 0x000501, "Member 'UDCPlayerCharacterAnimInstanceBase::bIsInFirstPersonPerspective' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, bIsMontageLooping) == 0x000502, "Member 'UDCPlayerCharacterAnimInstanceBase::bIsMontageLooping' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, bIsLadderClimbing) == 0x000503, "Member 'UDCPlayerCharacterAnimInstanceBase::bIsLadderClimbing' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsFullBodyAnimating) == 0x000504, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsFullBodyAnimating' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsResting) == 0x000505, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsResting' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsSkillMontagePlaying) == 0x000506, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsSkillMontagePlaying' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsEmotePlaying) == 0x000507, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsEmotePlaying' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsAttackPrimary) == 0x000508, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsAttackPrimary' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsAttackSecondary) == 0x000509, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsAttackSecondary' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsItemEquipPrimary) == 0x00050A, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsItemEquipPrimary' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsItemEquipSecondary) == 0x00050B, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsItemEquipSecondary' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsItemEquipPrimaryTwoHanded) == 0x00050C, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsItemEquipPrimaryTwoHanded' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsItemEquipSecondaryTwoHanded) == 0x00050D, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsItemEquipSecondaryTwoHanded' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsPlayMusic) == 0x00050E, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsPlayMusic' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsItemConsuming) == 0x00050F, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsItemConsuming' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsInteractInstall) == 0x000510, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsInteractInstall' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsAttackSpecial) == 0x000511, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsAttackSpecial' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsLadderClimbing) == 0x000512, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsLadderClimbing' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsBackstepping) == 0x000513, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsBackstepping' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsRopeHang) == 0x000514, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsRopeHang' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, GameplayTag_bIsGhost) == 0x000515, "Member 'UDCPlayerCharacterAnimInstanceBase::GameplayTag_bIsGhost' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, JumpStateMachineRemainAnimTimeRatio) == 0x000518, "Member 'UDCPlayerCharacterAnimInstanceBase::JumpStateMachineRemainAnimTimeRatio' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, LocomotionStateMachineRemainAnimTimeRatio) == 0x00051C, "Member 'UDCPlayerCharacterAnimInstanceBase::LocomotionStateMachineRemainAnimTimeRatio' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, HeadMeshAsset) == 0x000520, "Member 'UDCPlayerCharacterAnimInstanceBase::HeadMeshAsset' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, ItemAnimationSet) == 0x000528, "Member 'UDCPlayerCharacterAnimInstanceBase::ItemAnimationSet' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, SecondaryItemAnimationSet) == 0x000540, "Member 'UDCPlayerCharacterAnimInstanceBase::SecondaryItemAnimationSet' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, PrimaryMontageTagContainer) == 0x000558, "Member 'UDCPlayerCharacterAnimInstanceBase::PrimaryMontageTagContainer' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, SecondaryMontageTagContainer) == 0x000578, "Member 'UDCPlayerCharacterAnimInstanceBase::SecondaryMontageTagContainer' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, TwoHandedMontageTagContainer) == 0x000598, "Member 'UDCPlayerCharacterAnimInstanceBase::TwoHandedMontageTagContainer' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, LoopSectionNames) == 0x0005B8, "Member 'UDCPlayerCharacterAnimInstanceBase::LoopSectionNames' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, JumpStateMachineName) == 0x0005C8, "Member 'UDCPlayerCharacterAnimInstanceBase::JumpStateMachineName' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, LocomotionStateMachineName) == 0x0005D0, "Member 'UDCPlayerCharacterAnimInstanceBase::LocomotionStateMachineName' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, bIsModifyBone) == 0x0005D8, "Member 'UDCPlayerCharacterAnimInstanceBase::bIsModifyBone' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, bIsEmoteItemBoneModify) == 0x0005D9, "Member 'UDCPlayerCharacterAnimInstanceBase::bIsEmoteItemBoneModify' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterAnimInstanceBase, ItemModifyBoneTranslation_fk_weapon_l) == 0x0005E0, "Member 'UDCPlayerCharacterAnimInstanceBase::ItemModifyBoneTranslation_fk_weapon_l' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterBase
// 0x01B0 (0x0BB0 - 0x0A00)
class ADCPlayerCharacterBase : public ADCCharacterBase
{
public:
	uint8                                         Pad_278B[0x20];                                    // 0x0A00(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 PartHead;                                          // 0x0A20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartTongue;                                        // 0x0A28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartHelmet;                                        // 0x0A30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartGloves;                                        // 0x0A38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartChest;                                         // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartPants;                                         // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBoots;                                         // 0x0A50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartBack;                                          // 0x0A58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PartTail;                                          // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCPlayerCharacterKey                  CharacterKey;                                      // 0x0A68(0x0002)(Edit, Net, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278C[0x6];                                     // 0x0A6A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                OwnedSkillIdArray;                                 // 0x0A70(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FDCItemBoneModify>              ItemBoneModifies;                                  // 0x0A80(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278D[0x8];                                     // 0x0A90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCharacterDataComponent*              DataComponent;                                     // 0x0A98(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCCharacterPartsComponent*             PartsComponent;                                    // 0x0AA0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCPerkDataComponent*                   PerkDataComponent;                                 // 0x0AA8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCEquipmentComponent*                  EquipmentComponentV2;                              // 0x0AB0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCArmorSkinComponent*                  ArmorSkinComponent;                                // 0x0AB8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCInventoryMsgWrapperComponent*        MessageWrapperComponent;                           // 0x0AC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278E[0x20];                                    // 0x0AC8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDCSkillClassAbility, TSubclassOf<class UDCPlayerCharacterClassComponent>> CharacterClassComponentMap;                        // 0x0AE8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UDCDungeonModuleDataAsset*>      DungeonModuleDataArray;                            // 0x0B38(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278F[0x18];                                    // 0x0B48(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          DefaultSkeletalMesh;                               // 0x0B60(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              DefaultAnimInstance;                               // 0x0B68(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             DefaultOverrideMaterials;                          // 0x0B70(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2790[0x8];                                     // 0x0B80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USpellComponent*                        SpellComponent;                                    // 0x0B88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMusicComponent*                        MusicComponent;                                    // 0x0B90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClassShapeShiftComponent*              ClassShapeShiftComponent;                          // 0x0B98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2791[0x10];                                    // 0x0BA0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGender_Server(const EDCGender Gender);
	void ClientShowSystemMessage(const class FText& MessageText);
	bool GetFootstepLocationWithGameplayTag(const class UObject* WorldContextObject, const struct FGameplayTag& InFootstepTag, struct FHitResult* HitResult);
	void GetHoldingItemActors(TArray<class AItemActor*>* OutItemActors);
	void OnActionSkinChanged(const class UDCActionSkinDataAsset* ActionSkinData, const bool bIsEquipped);
	void OnRep_CharacterKey(const struct FDCPlayerCharacterKey& Old);
	void OnRep_ItemBoneModifies();
	void OnRep_OwnedSkillIdArray();
	void ResetDungeonModuleData(const class UDCDungeonModuleDataAsset* InDungeonModuleData);
	void SetDungeonModuleData(const class UDCDungeonModuleDataAsset* InDungeonModuleData);
	void SetWindforceToMovement(const struct FVector& WindVector);
	void SetWindforceVector(const struct FVector& WindforceVec);

	class UDCEquipmentComponent* GetEquipmentComponentV2() const;
	EDCGender GetGender() const;
	class UDCPerkDataComponent* GetPerkDataComponent() const;
	void ShowHitDirectionUIMessage(const class AActor* SourceActor, const struct FVector& HitDirection) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterBase">();
	}
	static class ADCPlayerCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerCharacterBase>();
	}
};
static_assert(alignof(ADCPlayerCharacterBase) == 0x000010, "Wrong alignment on ADCPlayerCharacterBase");
static_assert(sizeof(ADCPlayerCharacterBase) == 0x000BB0, "Wrong size on ADCPlayerCharacterBase");
static_assert(offsetof(ADCPlayerCharacterBase, PartHead) == 0x000A20, "Member 'ADCPlayerCharacterBase::PartHead' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartTongue) == 0x000A28, "Member 'ADCPlayerCharacterBase::PartTongue' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartHelmet) == 0x000A30, "Member 'ADCPlayerCharacterBase::PartHelmet' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartGloves) == 0x000A38, "Member 'ADCPlayerCharacterBase::PartGloves' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartChest) == 0x000A40, "Member 'ADCPlayerCharacterBase::PartChest' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartPants) == 0x000A48, "Member 'ADCPlayerCharacterBase::PartPants' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartBoots) == 0x000A50, "Member 'ADCPlayerCharacterBase::PartBoots' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartBack) == 0x000A58, "Member 'ADCPlayerCharacterBase::PartBack' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartTail) == 0x000A60, "Member 'ADCPlayerCharacterBase::PartTail' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, CharacterKey) == 0x000A68, "Member 'ADCPlayerCharacterBase::CharacterKey' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, OwnedSkillIdArray) == 0x000A70, "Member 'ADCPlayerCharacterBase::OwnedSkillIdArray' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, ItemBoneModifies) == 0x000A80, "Member 'ADCPlayerCharacterBase::ItemBoneModifies' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, DataComponent) == 0x000A98, "Member 'ADCPlayerCharacterBase::DataComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PartsComponent) == 0x000AA0, "Member 'ADCPlayerCharacterBase::PartsComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, PerkDataComponent) == 0x000AA8, "Member 'ADCPlayerCharacterBase::PerkDataComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, EquipmentComponentV2) == 0x000AB0, "Member 'ADCPlayerCharacterBase::EquipmentComponentV2' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, ArmorSkinComponent) == 0x000AB8, "Member 'ADCPlayerCharacterBase::ArmorSkinComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, MessageWrapperComponent) == 0x000AC0, "Member 'ADCPlayerCharacterBase::MessageWrapperComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, CharacterClassComponentMap) == 0x000AE8, "Member 'ADCPlayerCharacterBase::CharacterClassComponentMap' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, DungeonModuleDataArray) == 0x000B38, "Member 'ADCPlayerCharacterBase::DungeonModuleDataArray' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, DefaultSkeletalMesh) == 0x000B60, "Member 'ADCPlayerCharacterBase::DefaultSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, DefaultAnimInstance) == 0x000B68, "Member 'ADCPlayerCharacterBase::DefaultAnimInstance' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, DefaultOverrideMaterials) == 0x000B70, "Member 'ADCPlayerCharacterBase::DefaultOverrideMaterials' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, SpellComponent) == 0x000B88, "Member 'ADCPlayerCharacterBase::SpellComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, MusicComponent) == 0x000B90, "Member 'ADCPlayerCharacterBase::MusicComponent' has a wrong offset!");
static_assert(offsetof(ADCPlayerCharacterBase, ClassShapeShiftComponent) == 0x000B98, "Member 'ADCPlayerCharacterBase::ClassShapeShiftComponent' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterDataAsset
// 0x0138 (0x0180 - 0x0048)
class UDCPlayerCharacterDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCPlayerCharacterDataAsset;                   // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               Dialog;                                            // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               ClassInfo;                                         // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   CharacterTypes;                                    // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataPlayerCharacter> ArtData;                                           // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUse;                                            // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDefault;                                         // 0x0129(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExperimental;                                    // 0x012A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2794[0x5];                                     // 0x012B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCEmoteDataAsset>> Emotes;                                            // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCPerkDataAsset>> Perks;                                             // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EDCEquipmentSlotIndex>                 DefaultHands;                                      // 0x0170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterDataAsset">();
	}
	static class UDCPlayerCharacterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerCharacterDataAsset>();
	}
};
static_assert(alignof(UDCPlayerCharacterDataAsset) == 0x000008, "Wrong alignment on UDCPlayerCharacterDataAsset");
static_assert(sizeof(UDCPlayerCharacterDataAsset) == 0x000180, "Wrong size on UDCPlayerCharacterDataAsset");
static_assert(offsetof(UDCPlayerCharacterDataAsset, Name_DCPlayerCharacterDataAsset) == 0x000048, "Member 'UDCPlayerCharacterDataAsset::Name_DCPlayerCharacterDataAsset' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, Dialog) == 0x000060, "Member 'UDCPlayerCharacterDataAsset::Dialog' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, FlavorText) == 0x000088, "Member 'UDCPlayerCharacterDataAsset::FlavorText' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, ClassInfo) == 0x0000A0, "Member 'UDCPlayerCharacterDataAsset::ClassInfo' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, CharacterTypes) == 0x0000C8, "Member 'UDCPlayerCharacterDataAsset::CharacterTypes' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, ArtData) == 0x0000D8, "Member 'UDCPlayerCharacterDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, SoundData) == 0x000100, "Member 'UDCPlayerCharacterDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, CanUse) == 0x000128, "Member 'UDCPlayerCharacterDataAsset::CanUse' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, IsDefault) == 0x000129, "Member 'UDCPlayerCharacterDataAsset::IsDefault' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, IsExperimental) == 0x00012A, "Member 'UDCPlayerCharacterDataAsset::IsExperimental' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, Emotes) == 0x000130, "Member 'UDCPlayerCharacterDataAsset::Emotes' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, Abilities) == 0x000140, "Member 'UDCPlayerCharacterDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, Effects) == 0x000150, "Member 'UDCPlayerCharacterDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, Perks) == 0x000160, "Member 'UDCPlayerCharacterDataAsset::Perks' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterDataAsset, DefaultHands) == 0x000170, "Member 'UDCPlayerCharacterDataAsset::DefaultHands' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class IDCPlayerCharacterInterface final : public IInterface
{
public:
	class USkeletalMesh* GetPartHeadMeshAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterInterface">();
	}
	static class IDCPlayerCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCPlayerCharacterInterface>();
	}
};
static_assert(alignof(IDCPlayerCharacterInterface) == 0x000008, "Wrong alignment on IDCPlayerCharacterInterface");
static_assert(sizeof(IDCPlayerCharacterInterface) == 0x000028, "Wrong size on IDCPlayerCharacterInterface");

// Class DungeonCrawler.DCRedeemRewardTokenCheckPopup
// 0x0010 (0x04A0 - 0x0490)
class UDCRedeemRewardTokenCheckPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    RedeemButton;                                      // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelButton;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCancelButtonClicked();
	void OnRedeemButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRedeemRewardTokenCheckPopup">();
	}
	static class UDCRedeemRewardTokenCheckPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRedeemRewardTokenCheckPopup>();
	}
};
static_assert(alignof(UDCRedeemRewardTokenCheckPopup) == 0x000008, "Wrong alignment on UDCRedeemRewardTokenCheckPopup");
static_assert(sizeof(UDCRedeemRewardTokenCheckPopup) == 0x0004A0, "Wrong size on UDCRedeemRewardTokenCheckPopup");
static_assert(offsetof(UDCRedeemRewardTokenCheckPopup, RedeemButton) == 0x000490, "Member 'UDCRedeemRewardTokenCheckPopup::RedeemButton' has a wrong offset!");
static_assert(offsetof(UDCRedeemRewardTokenCheckPopup, CancelButton) == 0x000498, "Member 'UDCRedeemRewardTokenCheckPopup::CancelButton' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharacterLobbyAnimInstanceBase
// 0x0070 (0x03C0 - 0x0350)
class UDCPlayerCharacterLobbyAnimInstanceBase final : public UAnimInstance
{
public:
	class UAnimSequenceBase*                      Idle;                                              // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          HeadMeshAsset;                                     // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsModifyBone;                                     // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2795[0x67];                                    // 0x0359(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharacterLobbyAnimInstanceBase">();
	}
	static class UDCPlayerCharacterLobbyAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerCharacterLobbyAnimInstanceBase>();
	}
};
static_assert(alignof(UDCPlayerCharacterLobbyAnimInstanceBase) == 0x000010, "Wrong alignment on UDCPlayerCharacterLobbyAnimInstanceBase");
static_assert(sizeof(UDCPlayerCharacterLobbyAnimInstanceBase) == 0x0003C0, "Wrong size on UDCPlayerCharacterLobbyAnimInstanceBase");
static_assert(offsetof(UDCPlayerCharacterLobbyAnimInstanceBase, Idle) == 0x000348, "Member 'UDCPlayerCharacterLobbyAnimInstanceBase::Idle' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterLobbyAnimInstanceBase, HeadMeshAsset) == 0x000350, "Member 'UDCPlayerCharacterLobbyAnimInstanceBase::HeadMeshAsset' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharacterLobbyAnimInstanceBase, bIsModifyBone) == 0x000358, "Member 'UDCPlayerCharacterLobbyAnimInstanceBase::bIsModifyBone' has a wrong offset!");

// Class DungeonCrawler.DCPlayerCharMovementComponent
// 0x00B0 (0x1080 - 0x0FD0)
class UDCPlayerCharMovementComponent final : public UDCCharacterMovementComponent
{
public:
	uint8                                         Pad_2796[0x8];                                     // 0x0FD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLadderMovementSpeed;                            // 0x0FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingDecelerationLadder;                         // 0x0FDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultViewAngle;                                  // 0x0FE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderJumpPower;                                   // 0x0FE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2797[0xC];                                     // 0x0FE8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMovementModifier            LandedMovementModifier;                            // 0x0FF4(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2798[0x74];                                    // 0x100C(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerCharMovementComponent">();
	}
	static class UDCPlayerCharMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerCharMovementComponent>();
	}
};
static_assert(alignof(UDCPlayerCharMovementComponent) == 0x000010, "Wrong alignment on UDCPlayerCharMovementComponent");
static_assert(sizeof(UDCPlayerCharMovementComponent) == 0x001080, "Wrong size on UDCPlayerCharMovementComponent");
static_assert(offsetof(UDCPlayerCharMovementComponent, MaxLadderMovementSpeed) == 0x000FD8, "Member 'UDCPlayerCharMovementComponent::MaxLadderMovementSpeed' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharMovementComponent, BrakingDecelerationLadder) == 0x000FDC, "Member 'UDCPlayerCharMovementComponent::BrakingDecelerationLadder' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharMovementComponent, DefaultViewAngle) == 0x000FE0, "Member 'UDCPlayerCharMovementComponent::DefaultViewAngle' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharMovementComponent, LadderJumpPower) == 0x000FE4, "Member 'UDCPlayerCharMovementComponent::LadderJumpPower' has a wrong offset!");
static_assert(offsetof(UDCPlayerCharMovementComponent, LandedMovementModifier) == 0x000FF4, "Member 'UDCPlayerCharMovementComponent::LandedMovementModifier' has a wrong offset!");

// Class DungeonCrawler.DCPlayerChatComponent
// 0x00B8 (0x0158 - 0x00A0)
class UDCPlayerChatComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2799[0xB8];                                    // 0x00A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerChatComponent">();
	}
	static class UDCPlayerChatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerChatComponent>();
	}
};
static_assert(alignof(UDCPlayerChatComponent) == 0x000008, "Wrong alignment on UDCPlayerChatComponent");
static_assert(sizeof(UDCPlayerChatComponent) == 0x000158, "Wrong size on UDCPlayerChatComponent");

// Class DungeonCrawler.DCReligionBlessingLevelWidget
// 0x0038 (0x0390 - 0x0358)
class UDCReligionBlessingLevelWidget final : public UDCWidgetBase
{
public:
	class UTextBlock*                             BlessingOnText;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingOffText;                                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279A[0x20];                                    // 0x0370(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBlessingWidgetInfo(bool bIsActivate, const class FText& BlessingName, const int32 BlessingLevel, const class FText& BlessingDesc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionBlessingLevelWidget">();
	}
	static class UDCReligionBlessingLevelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionBlessingLevelWidget>();
	}
};
static_assert(alignof(UDCReligionBlessingLevelWidget) == 0x000008, "Wrong alignment on UDCReligionBlessingLevelWidget");
static_assert(sizeof(UDCReligionBlessingLevelWidget) == 0x000390, "Wrong size on UDCReligionBlessingLevelWidget");
static_assert(offsetof(UDCReligionBlessingLevelWidget, BlessingOnText) == 0x000358, "Member 'UDCReligionBlessingLevelWidget::BlessingOnText' has a wrong offset!");
static_assert(offsetof(UDCReligionBlessingLevelWidget, BlessingOffText) == 0x000360, "Member 'UDCReligionBlessingLevelWidget::BlessingOffText' has a wrong offset!");
static_assert(offsetof(UDCReligionBlessingLevelWidget, WidgetSwitcher) == 0x000368, "Member 'UDCReligionBlessingLevelWidget::WidgetSwitcher' has a wrong offset!");

// Class DungeonCrawler.DCPlayerDamageIndicatorComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDCPlayerDamageIndicatorComponent final : public UDCDamageIndicatorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerDamageIndicatorComponent">();
	}
	static class UDCPlayerDamageIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerDamageIndicatorComponent>();
	}
};
static_assert(alignof(UDCPlayerDamageIndicatorComponent) == 0x000008, "Wrong alignment on UDCPlayerDamageIndicatorComponent");
static_assert(sizeof(UDCPlayerDamageIndicatorComponent) == 0x0000A0, "Wrong size on UDCPlayerDamageIndicatorComponent");

// Class DungeonCrawler.DCPlayerInfoHolder
// 0x00E8 (0x0380 - 0x0298)
class ADCPlayerInfoHolder final : public AInfo
{
public:
	class ADCCharacterBase*                       PlayerCharacter;                                   // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCPlayerInfo                          PlayerInfo;                                        // 0x02A0(0x00E0)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_PlayerInfo(const struct FDCPlayerInfo& OldPlayerInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerInfoHolder">();
	}
	static class ADCPlayerInfoHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerInfoHolder>();
	}
};
static_assert(alignof(ADCPlayerInfoHolder) == 0x000008, "Wrong alignment on ADCPlayerInfoHolder");
static_assert(sizeof(ADCPlayerInfoHolder) == 0x000380, "Wrong size on ADCPlayerInfoHolder");
static_assert(offsetof(ADCPlayerInfoHolder, PlayerCharacter) == 0x000298, "Member 'ADCPlayerInfoHolder::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(ADCPlayerInfoHolder, PlayerInfo) == 0x0002A0, "Member 'ADCPlayerInfoHolder::PlayerInfo' has a wrong offset!");

// Class DungeonCrawler.DCPlayerManager
// 0x01C8 (0x01F8 - 0x0030)
class UDCPlayerManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_279D[0xD8];                                    // 0x0030(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCAccountId, struct FDCPlayerInfo> PlayerInfos;                                       // 0x0108(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279E[0xA0];                                    // 0x0158(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerManager">();
	}
	static class UDCPlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPlayerManager>();
	}
};
static_assert(alignof(UDCPlayerManager) == 0x000008, "Wrong alignment on UDCPlayerManager");
static_assert(sizeof(UDCPlayerManager) == 0x0001F8, "Wrong size on UDCPlayerManager");
static_assert(offsetof(UDCPlayerManager, PlayerInfos) == 0x000108, "Member 'UDCPlayerManager::PlayerInfos' has a wrong offset!");

// Class DungeonCrawler.DCPlayerPoint
// 0x0030 (0x02F8 - 0x02C8)
class ADCPlayerPoint : public APlayerStart
{
public:
	float                                         SpawningDistance;                                  // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnTickAngle;                                    // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279F[0x10];                                    // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnAngle;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A0[0x14];                                    // 0x02E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerPoint">();
	}
	static class ADCPlayerPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerPoint>();
	}
};
static_assert(alignof(ADCPlayerPoint) == 0x000008, "Wrong alignment on ADCPlayerPoint");
static_assert(sizeof(ADCPlayerPoint) == 0x0002F8, "Wrong size on ADCPlayerPoint");
static_assert(offsetof(ADCPlayerPoint, SpawningDistance) == 0x0002C8, "Member 'ADCPlayerPoint::SpawningDistance' has a wrong offset!");
static_assert(offsetof(ADCPlayerPoint, SpawnTickAngle) == 0x0002CC, "Member 'ADCPlayerPoint::SpawnTickAngle' has a wrong offset!");
static_assert(offsetof(ADCPlayerPoint, SpawnAngle) == 0x0002E0, "Member 'ADCPlayerPoint::SpawnAngle' has a wrong offset!");

// Class DungeonCrawler.DCReligionConvertPopupData
// 0x0110 (0x0140 - 0x0030)
class UDCReligionConvertPopupData final : public UPopupDataBase
{
public:
	class FText                                   ReligionName;                                      // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   ReligionSubName;                                   // 0x0048(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 ReligionId;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ReligionImage;                                     // 0x0070(0x00D0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionConvertPopupData">();
	}
	static class UDCReligionConvertPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionConvertPopupData>();
	}
};
static_assert(alignof(UDCReligionConvertPopupData) == 0x000010, "Wrong alignment on UDCReligionConvertPopupData");
static_assert(sizeof(UDCReligionConvertPopupData) == 0x000140, "Wrong size on UDCReligionConvertPopupData");
static_assert(offsetof(UDCReligionConvertPopupData, ReligionName) == 0x000030, "Member 'UDCReligionConvertPopupData::ReligionName' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopupData, ReligionSubName) == 0x000048, "Member 'UDCReligionConvertPopupData::ReligionSubName' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopupData, ReligionId) == 0x000060, "Member 'UDCReligionConvertPopupData::ReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionConvertPopupData, ReligionImage) == 0x000070, "Member 'UDCReligionConvertPopupData::ReligionImage' has a wrong offset!");

// Class DungeonCrawler.DCPlayerStart
// 0x0000 (0x02F8 - 0x02F8)
class ADCPlayerStart final : public ADCPlayerPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerStart">();
	}
	static class ADCPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerStart>();
	}
};
static_assert(alignof(ADCPlayerStart) == 0x000008, "Wrong alignment on ADCPlayerStart");
static_assert(sizeof(ADCPlayerStart) == 0x0002F8, "Wrong size on ADCPlayerStart");

// Class DungeonCrawler.DCPlayerDown
// 0x0000 (0x02F8 - 0x02F8)
class ADCPlayerDown final : public ADCPlayerPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerDown">();
	}
	static class ADCPlayerDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerDown>();
	}
};
static_assert(alignof(ADCPlayerDown) == 0x000008, "Wrong alignment on ADCPlayerDown");
static_assert(sizeof(ADCPlayerDown) == 0x0002F8, "Wrong size on ADCPlayerDown");

// Class DungeonCrawler.DCPlayerSpectator
// 0x0078 (0x03C0 - 0x0348)
class ADCPlayerSpectator final : public ASpectatorPawn
{
public:
	uint8                                         Pad_27A1[0x30];                                    // 0x0348(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCCharacterBase*                       TargetPlayerCharacter;                             // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A2[0x40];                                    // 0x0380(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPlayerSpectator">();
	}
	static class ADCPlayerSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPlayerSpectator>();
	}
};
static_assert(alignof(ADCPlayerSpectator) == 0x000008, "Wrong alignment on ADCPlayerSpectator");
static_assert(sizeof(ADCPlayerSpectator) == 0x0003C0, "Wrong size on ADCPlayerSpectator");
static_assert(offsetof(ADCPlayerSpectator, TargetPlayerCharacter) == 0x000378, "Member 'ADCPlayerSpectator::TargetPlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.DCPool
// 0x01F8 (0x0220 - 0x0028)
class UDCPool final : public UObject
{
public:
	TArray<class UObject*>                        ReferenceTable;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A3[0x190];                                   // 0x0038(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDCPoolingObjectType, class UDCMonsterDataAsset*> DataAssetMap;                                      // 0x01C8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A4[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPool">();
	}
	static class UDCPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPool>();
	}
};
static_assert(alignof(UDCPool) == 0x000008, "Wrong alignment on UDCPool");
static_assert(sizeof(UDCPool) == 0x000220, "Wrong size on UDCPool");
static_assert(offsetof(UDCPool, ReferenceTable) == 0x000028, "Member 'UDCPool::ReferenceTable' has a wrong offset!");
static_assert(offsetof(UDCPool, DataAssetMap) == 0x0001C8, "Member 'UDCPool::DataAssetMap' has a wrong offset!");

// Class DungeonCrawler.DCPreLobbyGameMode
// 0x0000 (0x03A8 - 0x03A8)
class ADCPreLobbyGameMode : public ADCMetaGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPreLobbyGameMode">();
	}
	static class ADCPreLobbyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCPreLobbyGameMode>();
	}
};
static_assert(alignof(ADCPreLobbyGameMode) == 0x000008, "Wrong alignment on ADCPreLobbyGameMode");
static_assert(sizeof(ADCPreLobbyGameMode) == 0x0003A8, "Wrong size on ADCPreLobbyGameMode");

// Class DungeonCrawler.DCProjectileDataAsset
// 0x0098 (0x00E0 - 0x0048)
class UDCProjectileDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCProjectileDataAsset;                        // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SourceType;                                        // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataProjectile>      ArtData;                                           // 0x0068(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0090(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectileActor>           ActorClass;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCProjectileDataAsset">();
	}
	static class UDCProjectileDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCProjectileDataAsset>();
	}
};
static_assert(alignof(UDCProjectileDataAsset) == 0x000008, "Wrong alignment on UDCProjectileDataAsset");
static_assert(sizeof(UDCProjectileDataAsset) == 0x0000E0, "Wrong size on UDCProjectileDataAsset");
static_assert(offsetof(UDCProjectileDataAsset, Name_DCProjectileDataAsset) == 0x000048, "Member 'UDCProjectileDataAsset::Name_DCProjectileDataAsset' has a wrong offset!");
static_assert(offsetof(UDCProjectileDataAsset, SourceType) == 0x000060, "Member 'UDCProjectileDataAsset::SourceType' has a wrong offset!");
static_assert(offsetof(UDCProjectileDataAsset, ArtData) == 0x000068, "Member 'UDCProjectileDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCProjectileDataAsset, SoundData) == 0x000090, "Member 'UDCProjectileDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCProjectileDataAsset, ActorClass) == 0x0000B8, "Member 'UDCProjectileDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UDCProjectileDataAsset, Abilities) == 0x0000C0, "Member 'UDCProjectileDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCProjectileDataAsset, Effects) == 0x0000D0, "Member 'UDCProjectileDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCPropsInteractDataAsset
// 0x0138 (0x0180 - 0x0048)
class UDCPropsInteractDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   InteractionName;                                   // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InteractionText;                                   // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInteractData>           InteractData;                                      // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   InteractTypes;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionalDuration;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractableTag;                                   // 0x00B8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x00C0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AbilityTriggerTag;                                 // 0x00C8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTagQueryData>           DetectTagQueryData;                                // 0x00D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTagQueryData>           InteractTagQueryData;                              // 0x00F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTagQueryData>           ConsumeTagQueryData;                               // 0x0120(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   BlockInteractionTags;                              // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCPropsSkillCheckDataAsset> SkillCheckData;                                    // 0x0158(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPropsInteractDataAsset">();
	}
	static class UDCPropsInteractDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPropsInteractDataAsset>();
	}
};
static_assert(alignof(UDCPropsInteractDataAsset) == 0x000008, "Wrong alignment on UDCPropsInteractDataAsset");
static_assert(sizeof(UDCPropsInteractDataAsset) == 0x000180, "Wrong size on UDCPropsInteractDataAsset");
static_assert(offsetof(UDCPropsInteractDataAsset, InteractionName) == 0x000048, "Member 'UDCPropsInteractDataAsset::InteractionName' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, InteractionText) == 0x000060, "Member 'UDCPropsInteractDataAsset::InteractionText' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, InteractData) == 0x000078, "Member 'UDCPropsInteractDataAsset::InteractData' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, InteractTypes) == 0x0000A0, "Member 'UDCPropsInteractDataAsset::InteractTypes' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, Duration) == 0x0000B0, "Member 'UDCPropsInteractDataAsset::Duration' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, ConditionalDuration) == 0x0000B4, "Member 'UDCPropsInteractDataAsset::ConditionalDuration' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, InteractableTag) == 0x0000B8, "Member 'UDCPropsInteractDataAsset::InteractableTag' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, TriggerTag) == 0x0000C0, "Member 'UDCPropsInteractDataAsset::TriggerTag' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, AbilityTriggerTag) == 0x0000C8, "Member 'UDCPropsInteractDataAsset::AbilityTriggerTag' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, DetectTagQueryData) == 0x0000D0, "Member 'UDCPropsInteractDataAsset::DetectTagQueryData' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, InteractTagQueryData) == 0x0000F8, "Member 'UDCPropsInteractDataAsset::InteractTagQueryData' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, ConsumeTagQueryData) == 0x000120, "Member 'UDCPropsInteractDataAsset::ConsumeTagQueryData' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, BlockInteractionTags) == 0x000148, "Member 'UDCPropsInteractDataAsset::BlockInteractionTags' has a wrong offset!");
static_assert(offsetof(UDCPropsInteractDataAsset, SkillCheckData) == 0x000158, "Member 'UDCPropsInteractDataAsset::SkillCheckData' has a wrong offset!");

// Class DungeonCrawler.DCQuestChapterListEntryWidgetData
// 0x0018 (0x0040 - 0x0028)
class UDCQuestChapterListEntryWidgetData final : public UObject
{
public:
	struct FDCQuestChapterInfo                    QuestChapterInfo;                                  // 0x0028(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestChapterListEntryWidgetData">();
	}
	static class UDCQuestChapterListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestChapterListEntryWidgetData>();
	}
};
static_assert(alignof(UDCQuestChapterListEntryWidgetData) == 0x000008, "Wrong alignment on UDCQuestChapterListEntryWidgetData");
static_assert(sizeof(UDCQuestChapterListEntryWidgetData) == 0x000040, "Wrong size on UDCQuestChapterListEntryWidgetData");
static_assert(offsetof(UDCQuestChapterListEntryWidgetData, QuestChapterInfo) == 0x000028, "Member 'UDCQuestChapterListEntryWidgetData::QuestChapterInfo' has a wrong offset!");

// Class DungeonCrawler.DCQuestCompleteResultPopup
// 0x0048 (0x04D8 - 0x0490)
class UDCQuestCompleteResultPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             MerchantPortrait;                                  // 0x0498(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   TitleText;                                         // 0x04A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   ResultText;                                        // 0x04B8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UDCQuestCompleteResultPopupData*        QuestCompleteResultPopupData;                      // 0x04D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestCompleteResultPopup">();
	}
	static class UDCQuestCompleteResultPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestCompleteResultPopup>();
	}
};
static_assert(alignof(UDCQuestCompleteResultPopup) == 0x000008, "Wrong alignment on UDCQuestCompleteResultPopup");
static_assert(sizeof(UDCQuestCompleteResultPopup) == 0x0004D8, "Wrong size on UDCQuestCompleteResultPopup");
static_assert(offsetof(UDCQuestCompleteResultPopup, Btn_One_Confirm) == 0x000490, "Member 'UDCQuestCompleteResultPopup::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCQuestCompleteResultPopup, MerchantPortrait) == 0x000498, "Member 'UDCQuestCompleteResultPopup::MerchantPortrait' has a wrong offset!");
static_assert(offsetof(UDCQuestCompleteResultPopup, TitleText) == 0x0004A0, "Member 'UDCQuestCompleteResultPopup::TitleText' has a wrong offset!");
static_assert(offsetof(UDCQuestCompleteResultPopup, ResultText) == 0x0004B8, "Member 'UDCQuestCompleteResultPopup::ResultText' has a wrong offset!");
static_assert(offsetof(UDCQuestCompleteResultPopup, QuestCompleteResultPopupData) == 0x0004D0, "Member 'UDCQuestCompleteResultPopup::QuestCompleteResultPopupData' has a wrong offset!");

// Class DungeonCrawler.DCQuestContentFetchDataAsset
// 0x0020 (0x0080 - 0x0060)
class UDCQuestContentFetchDataAsset final : public UDCQuestContentDataAsset
{
public:
	struct FGameplayTag                           ItemIdTag;                                         // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TypeTag;                                           // 0x0068(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x0070(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCItemLootState                              ItemLootState;                                     // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A5[0x7];                                     // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestContentFetchDataAsset">();
	}
	static class UDCQuestContentFetchDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestContentFetchDataAsset>();
	}
};
static_assert(alignof(UDCQuestContentFetchDataAsset) == 0x000008, "Wrong alignment on UDCQuestContentFetchDataAsset");
static_assert(sizeof(UDCQuestContentFetchDataAsset) == 0x000080, "Wrong size on UDCQuestContentFetchDataAsset");
static_assert(offsetof(UDCQuestContentFetchDataAsset, ItemIdTag) == 0x000060, "Member 'UDCQuestContentFetchDataAsset::ItemIdTag' has a wrong offset!");
static_assert(offsetof(UDCQuestContentFetchDataAsset, TypeTag) == 0x000068, "Member 'UDCQuestContentFetchDataAsset::TypeTag' has a wrong offset!");
static_assert(offsetof(UDCQuestContentFetchDataAsset, RarityType) == 0x000070, "Member 'UDCQuestContentFetchDataAsset::RarityType' has a wrong offset!");
static_assert(offsetof(UDCQuestContentFetchDataAsset, ItemLootState) == 0x000078, "Member 'UDCQuestContentFetchDataAsset::ItemLootState' has a wrong offset!");

// Class DungeonCrawler.DCQuestDataAsset
// 0x00B0 (0x00F8 - 0x0048)
class UDCQuestDataAsset final : public UDCTableDataAsset
{
public:
	TSoftObjectPtr<class UDCQuestDataAsset>       RequiredQuest;                                     // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredLevel;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAffinity;                                  // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCRewardDataAsset>      QuestReward;                                       // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x00A0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   GreetingText;                                      // 0x00B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CompleteText;                                      // 0x00D0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCQuestContentDataAsset>> QuestContents;                                     // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestDataAsset">();
	}
	static class UDCQuestDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestDataAsset>();
	}
};
static_assert(alignof(UDCQuestDataAsset) == 0x000008, "Wrong alignment on UDCQuestDataAsset");
static_assert(sizeof(UDCQuestDataAsset) == 0x0000F8, "Wrong size on UDCQuestDataAsset");
static_assert(offsetof(UDCQuestDataAsset, RequiredQuest) == 0x000048, "Member 'UDCQuestDataAsset::RequiredQuest' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, RequiredLevel) == 0x000070, "Member 'UDCQuestDataAsset::RequiredLevel' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, RequiredAffinity) == 0x000074, "Member 'UDCQuestDataAsset::RequiredAffinity' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, QuestReward) == 0x000078, "Member 'UDCQuestDataAsset::QuestReward' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, TitleText) == 0x0000A0, "Member 'UDCQuestDataAsset::TitleText' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, GreetingText) == 0x0000B8, "Member 'UDCQuestDataAsset::GreetingText' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, CompleteText) == 0x0000D0, "Member 'UDCQuestDataAsset::CompleteText' has a wrong offset!");
static_assert(offsetof(UDCQuestDataAsset, QuestContents) == 0x0000E8, "Member 'UDCQuestDataAsset::QuestContents' has a wrong offset!");

// Class DungeonCrawler.DCQuestListEntryWidget
// 0x0030 (0x0388 - 0x0358)
class UDCQuestListEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_27A6[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCompeleted;                                     // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocked;                                         // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A7[0x6];                                     // 0x037A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCQuestProgressSlotWidget*             ProgressSlotWidget;                                // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestListEntryWidget">();
	}
	static class UDCQuestListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestListEntryWidget>();
	}
};
static_assert(alignof(UDCQuestListEntryWidget) == 0x000008, "Wrong alignment on UDCQuestListEntryWidget");
static_assert(sizeof(UDCQuestListEntryWidget) == 0x000388, "Wrong size on UDCQuestListEntryWidget");
static_assert(offsetof(UDCQuestListEntryWidget, Title) == 0x000360, "Member 'UDCQuestListEntryWidget::Title' has a wrong offset!");
static_assert(offsetof(UDCQuestListEntryWidget, bIsCompeleted) == 0x000378, "Member 'UDCQuestListEntryWidget::bIsCompeleted' has a wrong offset!");
static_assert(offsetof(UDCQuestListEntryWidget, bIsLocked) == 0x000379, "Member 'UDCQuestListEntryWidget::bIsLocked' has a wrong offset!");
static_assert(offsetof(UDCQuestListEntryWidget, ProgressSlotWidget) == 0x000380, "Member 'UDCQuestListEntryWidget::ProgressSlotWidget' has a wrong offset!");

// Class DungeonCrawler.DCQuestListWidget
// 0x0010 (0x0368 - 0x0358)
class UDCQuestListWidget final : public UDCWidgetBase
{
public:
	class UDCQuestChapterDataAsset*               MyQuestChapterData;                                // 0x0358(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonListView*                        QuestListView;                                     // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestListWidget">();
	}
	static class UDCQuestListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestListWidget>();
	}
};
static_assert(alignof(UDCQuestListWidget) == 0x000008, "Wrong alignment on UDCQuestListWidget");
static_assert(sizeof(UDCQuestListWidget) == 0x000368, "Wrong size on UDCQuestListWidget");
static_assert(offsetof(UDCQuestListWidget, MyQuestChapterData) == 0x000358, "Member 'UDCQuestListWidget::MyQuestChapterData' has a wrong offset!");
static_assert(offsetof(UDCQuestListWidget, QuestListView) == 0x000360, "Member 'UDCQuestListWidget::QuestListView' has a wrong offset!");

// Class DungeonCrawler.DCQuestLogContentsListEntry
// 0x0030 (0x0388 - 0x0358)
class UDCQuestLogContentsListEntry final : public UDCWidgetBase
{
public:
	uint8                                         Pad_27A8[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCompeleted;                                     // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocked;                                         // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A9[0x6];                                     // 0x037A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCQuestProgressSlotWidget*             ProgressSlotWidget;                                // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogContentsListEntry">();
	}
	static class UDCQuestLogContentsListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogContentsListEntry>();
	}
};
static_assert(alignof(UDCQuestLogContentsListEntry) == 0x000008, "Wrong alignment on UDCQuestLogContentsListEntry");
static_assert(sizeof(UDCQuestLogContentsListEntry) == 0x000388, "Wrong size on UDCQuestLogContentsListEntry");
static_assert(offsetof(UDCQuestLogContentsListEntry, Title) == 0x000360, "Member 'UDCQuestLogContentsListEntry::Title' has a wrong offset!");
static_assert(offsetof(UDCQuestLogContentsListEntry, bIsCompeleted) == 0x000378, "Member 'UDCQuestLogContentsListEntry::bIsCompeleted' has a wrong offset!");
static_assert(offsetof(UDCQuestLogContentsListEntry, bIsLocked) == 0x000379, "Member 'UDCQuestLogContentsListEntry::bIsLocked' has a wrong offset!");
static_assert(offsetof(UDCQuestLogContentsListEntry, ProgressSlotWidget) == 0x000380, "Member 'UDCQuestLogContentsListEntry::ProgressSlotWidget' has a wrong offset!");

// Class DungeonCrawler.DCQuestLogContentsListWidget
// 0x0020 (0x0378 - 0x0358)
class UDCQuestLogContentsListWidget final : public UDCWidgetBase
{
public:
	class UDCQuestChapterDataAsset*               MyQuestChapterData;                                // 0x0358(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MerchantId;                                        // 0x0360(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonListView*                        QuestListView;                                     // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogContentsListWidget">();
	}
	static class UDCQuestLogContentsListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogContentsListWidget>();
	}
};
static_assert(alignof(UDCQuestLogContentsListWidget) == 0x000008, "Wrong alignment on UDCQuestLogContentsListWidget");
static_assert(sizeof(UDCQuestLogContentsListWidget) == 0x000378, "Wrong size on UDCQuestLogContentsListWidget");
static_assert(offsetof(UDCQuestLogContentsListWidget, MyQuestChapterData) == 0x000358, "Member 'UDCQuestLogContentsListWidget::MyQuestChapterData' has a wrong offset!");
static_assert(offsetof(UDCQuestLogContentsListWidget, MerchantId) == 0x000360, "Member 'UDCQuestLogContentsListWidget::MerchantId' has a wrong offset!");
static_assert(offsetof(UDCQuestLogContentsListWidget, QuestListView) == 0x000370, "Member 'UDCQuestLogContentsListWidget::QuestListView' has a wrong offset!");

// Class DungeonCrawler.DCQuestLogListWidget
// 0x0020 (0x0378 - 0x0358)
class UDCQuestLogListWidget final : public UDCWidgetBase
{
public:
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27AA[0x10];                                    // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonListView*                        QuestLogListView;                                  // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogListWidget">();
	}
	static class UDCQuestLogListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogListWidget>();
	}
};
static_assert(alignof(UDCQuestLogListWidget) == 0x000008, "Wrong alignment on UDCQuestLogListWidget");
static_assert(sizeof(UDCQuestLogListWidget) == 0x000378, "Wrong size on UDCQuestLogListWidget");
static_assert(offsetof(UDCQuestLogListWidget, MerchantComponent) == 0x000358, "Member 'UDCQuestLogListWidget::MerchantComponent' has a wrong offset!");
static_assert(offsetof(UDCQuestLogListWidget, QuestLogListView) == 0x000370, "Member 'UDCQuestLogListWidget::QuestLogListView' has a wrong offset!");

// Class DungeonCrawler.DCQuestLogWidgetBase
// 0x0018 (0x0370 - 0x0358)
class UDCQuestLogWidgetBase final : public UDCWidgetBase
{
public:
	class UDCMerchantComponent*                   MerchantComponent;                                 // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCQuestLogDealTableWidget*             DealTableQuestWidget;                              // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonAcceptAll;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAcceptAllButtonEnable(bool IsEnable);
	void OnQuestAcceptAll();
	void OnQuestAcceptAllSoundEvent();
	void OnQuestLogVisibilityChange(bool bIsEmpty);
	void SetIsActivated(bool bIsActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestLogWidgetBase">();
	}
	static class UDCQuestLogWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestLogWidgetBase>();
	}
};
static_assert(alignof(UDCQuestLogWidgetBase) == 0x000008, "Wrong alignment on UDCQuestLogWidgetBase");
static_assert(sizeof(UDCQuestLogWidgetBase) == 0x000370, "Wrong size on UDCQuestLogWidgetBase");
static_assert(offsetof(UDCQuestLogWidgetBase, MerchantComponent) == 0x000358, "Member 'UDCQuestLogWidgetBase::MerchantComponent' has a wrong offset!");
static_assert(offsetof(UDCQuestLogWidgetBase, DealTableQuestWidget) == 0x000360, "Member 'UDCQuestLogWidgetBase::DealTableQuestWidget' has a wrong offset!");
static_assert(offsetof(UDCQuestLogWidgetBase, ButtonAcceptAll) == 0x000368, "Member 'UDCQuestLogWidgetBase::ButtonAcceptAll' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequiredItemData
// 0x0008 (0x00A8 - 0x00A0)
class UDCQuestRequiredItemData final : public UDCMerchantRequiredItemData
{
public:
	int32                                         DeliverdItemCount;                                 // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AB[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequiredItemData">();
	}
	static class UDCQuestRequiredItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequiredItemData>();
	}
};
static_assert(alignof(UDCQuestRequiredItemData) == 0x000008, "Wrong alignment on UDCQuestRequiredItemData");
static_assert(sizeof(UDCQuestRequiredItemData) == 0x0000A8, "Wrong size on UDCQuestRequiredItemData");
static_assert(offsetof(UDCQuestRequiredItemData, DeliverdItemCount) == 0x0000A0, "Member 'UDCQuestRequiredItemData::DeliverdItemCount' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequiredEntryWidget
// 0x0000 (0x06C0 - 0x06C0)
class UDCQuestRequiredEntryWidget final : public UDCMerchantRequiredEntryWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequiredEntryWidget">();
	}
	static class UDCQuestRequiredEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequiredEntryWidget>();
	}
};
static_assert(alignof(UDCQuestRequiredEntryWidget) == 0x000008, "Wrong alignment on UDCQuestRequiredEntryWidget");
static_assert(sizeof(UDCQuestRequiredEntryWidget) == 0x0006C0, "Wrong size on UDCQuestRequiredEntryWidget");

// Class DungeonCrawler.DCQuestRequireDungeonTitleEntry
// 0x0038 (0x0390 - 0x0358)
class UDCQuestRequireDungeonTitleEntry final : public UDCWidgetBase
{
public:
	uint8                                         Pad_27AC[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         CurrentCountText;                                  // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MaxCountText;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCompleted;                                      // 0x0370(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27AD[0x7];                                     // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         ContentTitleRichText;                              // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27AE[0x10];                                    // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequireDungeonTitleEntry">();
	}
	static class UDCQuestRequireDungeonTitleEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequireDungeonTitleEntry>();
	}
};
static_assert(alignof(UDCQuestRequireDungeonTitleEntry) == 0x000008, "Wrong alignment on UDCQuestRequireDungeonTitleEntry");
static_assert(sizeof(UDCQuestRequireDungeonTitleEntry) == 0x000390, "Wrong size on UDCQuestRequireDungeonTitleEntry");
static_assert(offsetof(UDCQuestRequireDungeonTitleEntry, CurrentCountText) == 0x000360, "Member 'UDCQuestRequireDungeonTitleEntry::CurrentCountText' has a wrong offset!");
static_assert(offsetof(UDCQuestRequireDungeonTitleEntry, MaxCountText) == 0x000368, "Member 'UDCQuestRequireDungeonTitleEntry::MaxCountText' has a wrong offset!");
static_assert(offsetof(UDCQuestRequireDungeonTitleEntry, bIsCompleted) == 0x000370, "Member 'UDCQuestRequireDungeonTitleEntry::bIsCompleted' has a wrong offset!");
static_assert(offsetof(UDCQuestRequireDungeonTitleEntry, ContentTitleRichText) == 0x000378, "Member 'UDCQuestRequireDungeonTitleEntry::ContentTitleRichText' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementDetailEntryWidget
// 0x0020 (0x0378 - 0x0358)
class UDCQuestRequirementDetailEntryWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_27AF[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DetailText;                                        // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementDetailEntryWidget">();
	}
	static class UDCQuestRequirementDetailEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementDetailEntryWidget>();
	}
};
static_assert(alignof(UDCQuestRequirementDetailEntryWidget) == 0x000008, "Wrong alignment on UDCQuestRequirementDetailEntryWidget");
static_assert(sizeof(UDCQuestRequirementDetailEntryWidget) == 0x000378, "Wrong size on UDCQuestRequirementDetailEntryWidget");
static_assert(offsetof(UDCQuestRequirementDetailEntryWidget, DetailText) == 0x000360, "Member 'UDCQuestRequirementDetailEntryWidget::DetailText' has a wrong offset!");

// Class DungeonCrawler.DCQuestRequirementTitleEntryWidgetData
// 0x0018 (0x0040 - 0x0028)
class UDCQuestRequirementTitleEntryWidgetData final : public UObject
{
public:
	uint8                                         Pad_27B0[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCQuestRequirementTitleEntryWidgetData">();
	}
	static class UDCQuestRequirementTitleEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCQuestRequirementTitleEntryWidgetData>();
	}
};
static_assert(alignof(UDCQuestRequirementTitleEntryWidgetData) == 0x000008, "Wrong alignment on UDCQuestRequirementTitleEntryWidgetData");
static_assert(sizeof(UDCQuestRequirementTitleEntryWidgetData) == 0x000040, "Wrong size on UDCQuestRequirementTitleEntryWidgetData");

// Class DungeonCrawler.DCRecruitChannelListEntryWidget
// 0x0038 (0x02F8 - 0x02C0)
class UDCRecruitChannelListEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_27B1[0x18];                                    // 0x02C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ChannelTitle;                                      // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	int32                                         NumMembers;                                        // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27B2[0x4];                                     // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRecruitChannelListEntryWidget">();
	}
	static class UDCRecruitChannelListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRecruitChannelListEntryWidget>();
	}
};
static_assert(alignof(UDCRecruitChannelListEntryWidget) == 0x000008, "Wrong alignment on UDCRecruitChannelListEntryWidget");
static_assert(sizeof(UDCRecruitChannelListEntryWidget) == 0x0002F8, "Wrong size on UDCRecruitChannelListEntryWidget");
static_assert(offsetof(UDCRecruitChannelListEntryWidget, ChannelTitle) == 0x0002D8, "Member 'UDCRecruitChannelListEntryWidget::ChannelTitle' has a wrong offset!");
static_assert(offsetof(UDCRecruitChannelListEntryWidget, NumMembers) == 0x0002F0, "Member 'UDCRecruitChannelListEntryWidget::NumMembers' has a wrong offset!");

// Class DungeonCrawler.DCRecruitComponent
// 0x0230 (0x02D0 - 0x00A0)
class UDCRecruitComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_27B3[0x90];                                    // 0x00A0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27B4[0x198];                                   // 0x0138(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRecruitComponent">();
	}
	static class UDCRecruitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRecruitComponent>();
	}
};
static_assert(alignof(UDCRecruitComponent) == 0x000008, "Wrong alignment on UDCRecruitComponent");
static_assert(sizeof(UDCRecruitComponent) == 0x0002D0, "Wrong size on UDCRecruitComponent");
static_assert(offsetof(UDCRecruitComponent, InventoryComponent) == 0x000130, "Member 'UDCRecruitComponent::InventoryComponent' has a wrong offset!");

// Class DungeonCrawler.DCRedeemLearningTokenCheckPopupData
// 0x0098 (0x00C8 - 0x0030)
class UDCRedeemLearningTokenCheckPopupData final : public UPopupDataBase
{
public:
	struct FDCTrainingCharacterInfo               MasterCharacterInfo;                               // 0x0030(0x0098)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRedeemLearningTokenCheckPopupData">();
	}
	static class UDCRedeemLearningTokenCheckPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRedeemLearningTokenCheckPopupData>();
	}
};
static_assert(alignof(UDCRedeemLearningTokenCheckPopupData) == 0x000008, "Wrong alignment on UDCRedeemLearningTokenCheckPopupData");
static_assert(sizeof(UDCRedeemLearningTokenCheckPopupData) == 0x0000C8, "Wrong size on UDCRedeemLearningTokenCheckPopupData");
static_assert(offsetof(UDCRedeemLearningTokenCheckPopupData, MasterCharacterInfo) == 0x000030, "Member 'UDCRedeemLearningTokenCheckPopupData::MasterCharacterInfo' has a wrong offset!");

// Class DungeonCrawler.DCRedstoneShardShopSlotWidgetBase
// 0x0080 (0x0510 - 0x0490)
class UDCRedstoneShardShopSlotWidgetBase final : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_27B5[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SalesCount;                                        // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Price;                                             // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             RedstoneShardShopImage;                            // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x04E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27B6[0x2F];                                    // 0x04E1(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRedstoneShardShopSlotWidgetBase">();
	}
	static class UDCRedstoneShardShopSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRedstoneShardShopSlotWidgetBase>();
	}
};
static_assert(alignof(UDCRedstoneShardShopSlotWidgetBase) == 0x000008, "Wrong alignment on UDCRedstoneShardShopSlotWidgetBase");
static_assert(sizeof(UDCRedstoneShardShopSlotWidgetBase) == 0x000510, "Wrong size on UDCRedstoneShardShopSlotWidgetBase");
static_assert(offsetof(UDCRedstoneShardShopSlotWidgetBase, SalesCount) == 0x0004A8, "Member 'UDCRedstoneShardShopSlotWidgetBase::SalesCount' has a wrong offset!");
static_assert(offsetof(UDCRedstoneShardShopSlotWidgetBase, Price) == 0x0004C0, "Member 'UDCRedstoneShardShopSlotWidgetBase::Price' has a wrong offset!");
static_assert(offsetof(UDCRedstoneShardShopSlotWidgetBase, RedstoneShardShopImage) == 0x0004D8, "Member 'UDCRedstoneShardShopSlotWidgetBase::RedstoneShardShopImage' has a wrong offset!");
static_assert(offsetof(UDCRedstoneShardShopSlotWidgetBase, bIsSelected) == 0x0004E0, "Member 'UDCRedstoneShardShopSlotWidgetBase::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.DCReferenceCounterComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDCReferenceCounterComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_27B7[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReferenceCounterComponent">();
	}
	static class UDCReferenceCounterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReferenceCounterComponent>();
	}
};
static_assert(alignof(UDCReferenceCounterComponent) == 0x000008, "Wrong alignment on UDCReferenceCounterComponent");
static_assert(sizeof(UDCReferenceCounterComponent) == 0x0000C0, "Wrong size on UDCReferenceCounterComponent");

// Class DungeonCrawler.DCReligionBurfPopupData
// 0x0050 (0x0080 - 0x0030)
class UDCReligionBurfPopupData final : public UPopupDataBase
{
public:
	class FText                                   ReligionName;                                      // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	int32                                         BlessingLevel;                                     // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingCurrentCount;                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingMaxCount;                                  // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B8[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Decs;                                              // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 ReligionId;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionBurfPopupData">();
	}
	static class UDCReligionBurfPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionBurfPopupData>();
	}
};
static_assert(alignof(UDCReligionBurfPopupData) == 0x000008, "Wrong alignment on UDCReligionBurfPopupData");
static_assert(sizeof(UDCReligionBurfPopupData) == 0x000080, "Wrong size on UDCReligionBurfPopupData");
static_assert(offsetof(UDCReligionBurfPopupData, ReligionName) == 0x000030, "Member 'UDCReligionBurfPopupData::ReligionName' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopupData, BlessingLevel) == 0x000048, "Member 'UDCReligionBurfPopupData::BlessingLevel' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopupData, OfferingCurrentCount) == 0x00004C, "Member 'UDCReligionBurfPopupData::OfferingCurrentCount' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopupData, OfferingMaxCount) == 0x000050, "Member 'UDCReligionBurfPopupData::OfferingMaxCount' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopupData, Decs) == 0x000058, "Member 'UDCReligionBurfPopupData::Decs' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopupData, ReligionId) == 0x000070, "Member 'UDCReligionBurfPopupData::ReligionId' has a wrong offset!");

// Class DungeonCrawler.DCReligionBurfPopup
// 0x0070 (0x0500 - 0x0490)
class UDCReligionBurfPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_Bless;                                 // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentOfferingTicketNum;                          // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MaxOfferingTicketNum;                              // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ReligionDescText;                                  // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ReligionNameText;                                  // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingNameText;                                  // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingLevelText;                                 // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBoxBlessing;                               // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDCReligionBlessingLevelWidget*> ReligionBurfArray;                                 // 0x04D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27B9[0x10];                                    // 0x04E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCReligionBurfPopupData*               ReligionBurfPopupData;                             // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();
	void SetBlessingLevel(int32 Level);
	void SetReligionTimer(const struct FReligionRankTimerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionBurfPopup">();
	}
	static class UDCReligionBurfPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionBurfPopup>();
	}
};
static_assert(alignof(UDCReligionBurfPopup) == 0x000008, "Wrong alignment on UDCReligionBurfPopup");
static_assert(sizeof(UDCReligionBurfPopup) == 0x000500, "Wrong size on UDCReligionBurfPopup");
static_assert(offsetof(UDCReligionBurfPopup, Btn_One_Confirm) == 0x000490, "Member 'UDCReligionBurfPopup::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, ProgressBar_Bless) == 0x000498, "Member 'UDCReligionBurfPopup::ProgressBar_Bless' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, CurrentOfferingTicketNum) == 0x0004A0, "Member 'UDCReligionBurfPopup::CurrentOfferingTicketNum' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, MaxOfferingTicketNum) == 0x0004A8, "Member 'UDCReligionBurfPopup::MaxOfferingTicketNum' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, ReligionDescText) == 0x0004B0, "Member 'UDCReligionBurfPopup::ReligionDescText' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, ReligionNameText) == 0x0004B8, "Member 'UDCReligionBurfPopup::ReligionNameText' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, BlessingNameText) == 0x0004C0, "Member 'UDCReligionBurfPopup::BlessingNameText' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, BlessingLevelText) == 0x0004C8, "Member 'UDCReligionBurfPopup::BlessingLevelText' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, VerticalBoxBlessing) == 0x0004D0, "Member 'UDCReligionBurfPopup::VerticalBoxBlessing' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, ReligionBurfArray) == 0x0004D8, "Member 'UDCReligionBurfPopup::ReligionBurfArray' has a wrong offset!");
static_assert(offsetof(UDCReligionBurfPopup, ReligionBurfPopupData) == 0x0004F8, "Member 'UDCReligionBurfPopup::ReligionBurfPopupData' has a wrong offset!");

// Class DungeonCrawler.DCReligionConvetCompletePopupData
// 0x0110 (0x0140 - 0x0030)
class UDCReligionConvetCompletePopupData final : public UPopupDataBase
{
public:
	class FText                                   ReligionName;                                      // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   ReligionSubTitle;                                  // 0x0048(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 ReligionId;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ReligionImage;                                     // 0x0070(0x00D0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionConvetCompletePopupData">();
	}
	static class UDCReligionConvetCompletePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionConvetCompletePopupData>();
	}
};
static_assert(alignof(UDCReligionConvetCompletePopupData) == 0x000010, "Wrong alignment on UDCReligionConvetCompletePopupData");
static_assert(sizeof(UDCReligionConvetCompletePopupData) == 0x000140, "Wrong size on UDCReligionConvetCompletePopupData");
static_assert(offsetof(UDCReligionConvetCompletePopupData, ReligionName) == 0x000030, "Member 'UDCReligionConvetCompletePopupData::ReligionName' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopupData, ReligionSubTitle) == 0x000048, "Member 'UDCReligionConvetCompletePopupData::ReligionSubTitle' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopupData, ReligionId) == 0x000060, "Member 'UDCReligionConvetCompletePopupData::ReligionId' has a wrong offset!");
static_assert(offsetof(UDCReligionConvetCompletePopupData, ReligionImage) == 0x000070, "Member 'UDCReligionConvetCompletePopupData::ReligionImage' has a wrong offset!");

// Class DungeonCrawler.DCReligionSeasonDataAsset
// 0x0050 (0x0098 - 0x0048)
class UDCReligionSeasonDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   SeasonName;                                        // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCReligionDataAsset>> ReligionIds;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCReligionDataAsset>    DefaultReligionId;                                 // 0x0070(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionSeasonDataAsset">();
	}
	static class UDCReligionSeasonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionSeasonDataAsset>();
	}
};
static_assert(alignof(UDCReligionSeasonDataAsset) == 0x000008, "Wrong alignment on UDCReligionSeasonDataAsset");
static_assert(sizeof(UDCReligionSeasonDataAsset) == 0x000098, "Wrong size on UDCReligionSeasonDataAsset");
static_assert(offsetof(UDCReligionSeasonDataAsset, SeasonName) == 0x000048, "Member 'UDCReligionSeasonDataAsset::SeasonName' has a wrong offset!");
static_assert(offsetof(UDCReligionSeasonDataAsset, ReligionIds) == 0x000060, "Member 'UDCReligionSeasonDataAsset::ReligionIds' has a wrong offset!");
static_assert(offsetof(UDCReligionSeasonDataAsset, DefaultReligionId) == 0x000070, "Member 'UDCReligionSeasonDataAsset::DefaultReligionId' has a wrong offset!");

// Class DungeonCrawler.DCReligionDataAsset
// 0x0060 (0x00A8 - 0x0048)
class UDCReligionDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCReligionDataAsset;                          // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Desc;                                              // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0078(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         OfferingCost;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultReligion;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 OfferingLvCount;                                   // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionDataAsset">();
	}
	static class UDCReligionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionDataAsset>();
	}
};
static_assert(alignof(UDCReligionDataAsset) == 0x000008, "Wrong alignment on UDCReligionDataAsset");
static_assert(sizeof(UDCReligionDataAsset) == 0x0000A8, "Wrong size on UDCReligionDataAsset");
static_assert(offsetof(UDCReligionDataAsset, Name_DCReligionDataAsset) == 0x000048, "Member 'UDCReligionDataAsset::Name_DCReligionDataAsset' has a wrong offset!");
static_assert(offsetof(UDCReligionDataAsset, Desc) == 0x000060, "Member 'UDCReligionDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCReligionDataAsset, Subtitle) == 0x000078, "Member 'UDCReligionDataAsset::Subtitle' has a wrong offset!");
static_assert(offsetof(UDCReligionDataAsset, OfferingCost) == 0x000090, "Member 'UDCReligionDataAsset::OfferingCost' has a wrong offset!");
static_assert(offsetof(UDCReligionDataAsset, DefaultReligion) == 0x000094, "Member 'UDCReligionDataAsset::DefaultReligion' has a wrong offset!");
static_assert(offsetof(UDCReligionDataAsset, OfferingLvCount) == 0x000098, "Member 'UDCReligionDataAsset::OfferingLvCount' has a wrong offset!");

// Class DungeonCrawler.DCReligionOfferingCompletePopupData
// 0x0008 (0x0038 - 0x0030)
class UDCReligionOfferingCompletePopupData final : public UPopupDataBase
{
public:
	int32                                         OfferingCount;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BA[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionOfferingCompletePopupData">();
	}
	static class UDCReligionOfferingCompletePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionOfferingCompletePopupData>();
	}
};
static_assert(alignof(UDCReligionOfferingCompletePopupData) == 0x000008, "Wrong alignment on UDCReligionOfferingCompletePopupData");
static_assert(sizeof(UDCReligionOfferingCompletePopupData) == 0x000038, "Wrong size on UDCReligionOfferingCompletePopupData");
static_assert(offsetof(UDCReligionOfferingCompletePopupData, OfferingCount) == 0x000030, "Member 'UDCReligionOfferingCompletePopupData::OfferingCount' has a wrong offset!");

// Class DungeonCrawler.DCReligionRankEntryMine
// 0x0048 (0x03A0 - 0x0358)
class UDCReligionRankEntryMine final : public UDCWidgetBase
{
public:
	struct FReligionRankRecordMineWidgetHandleData WidgetHandleData;                                  // 0x0358(0x0048)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);
	void OnReligionRankRecordMineData(const struct FReligionRankRecordMineData& NewValue, const struct FReligionRankRecordMineData& OldValue);
	void SetOfferCountToWidget(const int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReligionRankEntryMine">();
	}
	static class UDCReligionRankEntryMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReligionRankEntryMine>();
	}
};
static_assert(alignof(UDCReligionRankEntryMine) == 0x000008, "Wrong alignment on UDCReligionRankEntryMine");
static_assert(sizeof(UDCReligionRankEntryMine) == 0x0003A0, "Wrong size on UDCReligionRankEntryMine");
static_assert(offsetof(UDCReligionRankEntryMine, WidgetHandleData) == 0x000358, "Member 'UDCReligionRankEntryMine::WidgetHandleData' has a wrong offset!");

// Class DungeonCrawler.ReligionDataItemWidgetData
// 0x0028 (0x0050 - 0x0028)
class UReligionDataItemWidgetData final : public UObject
{
public:
	class FString                                 SeasonId;                                          // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SeasonName;                                        // 0x0038(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReligionDataItemWidgetData">();
	}
	static class UReligionDataItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReligionDataItemWidgetData>();
	}
};
static_assert(alignof(UReligionDataItemWidgetData) == 0x000008, "Wrong alignment on UReligionDataItemWidgetData");
static_assert(sizeof(UReligionDataItemWidgetData) == 0x000050, "Wrong size on UReligionDataItemWidgetData");
static_assert(offsetof(UReligionDataItemWidgetData, SeasonId) == 0x000028, "Member 'UReligionDataItemWidgetData::SeasonId' has a wrong offset!");
static_assert(offsetof(UReligionDataItemWidgetData, SeasonName) == 0x000038, "Member 'UReligionDataItemWidgetData::SeasonName' has a wrong offset!");

// Class DungeonCrawler.DCReportPlayerGroupWidget
// 0x0008 (0x04B0 - 0x04A8)
class UDCReportPlayerGroupWidget final : public UGameGroupWidgetBase
{
public:
	class UDCReportPlayerWidget*                  ReportPlayer;                                      // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerGroupWidget">();
	}
	static class UDCReportPlayerGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerGroupWidget>();
	}
};
static_assert(alignof(UDCReportPlayerGroupWidget) == 0x000008, "Wrong alignment on UDCReportPlayerGroupWidget");
static_assert(sizeof(UDCReportPlayerGroupWidget) == 0x0004B0, "Wrong size on UDCReportPlayerGroupWidget");
static_assert(offsetof(UDCReportPlayerGroupWidget, ReportPlayer) == 0x0004A8, "Member 'UDCReportPlayerGroupWidget::ReportPlayer' has a wrong offset!");

// Class DungeonCrawler.DCReportPlayerResultPopup
// 0x0010 (0x04A0 - 0x0490)
class UDCReportPlayerResultPopup final : public UCommonPopupBase
{
public:
	class UDCReportPlayerResultPopupData*         ReportPlayerResultPopupData;                       // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Single;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleConfirmButtonClicked();

	const class FText GetPermanentBanListText() const;
	const class FText GetTemporaryBanListText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReportPlayerResultPopup">();
	}
	static class UDCReportPlayerResultPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReportPlayerResultPopup>();
	}
};
static_assert(alignof(UDCReportPlayerResultPopup) == 0x000008, "Wrong alignment on UDCReportPlayerResultPopup");
static_assert(sizeof(UDCReportPlayerResultPopup) == 0x0004A0, "Wrong size on UDCReportPlayerResultPopup");
static_assert(offsetof(UDCReportPlayerResultPopup, ReportPlayerResultPopupData) == 0x000490, "Member 'UDCReportPlayerResultPopup::ReportPlayerResultPopupData' has a wrong offset!");
static_assert(offsetof(UDCReportPlayerResultPopup, Btn_Single) == 0x000498, "Member 'UDCReportPlayerResultPopup::Btn_Single' has a wrong offset!");

// Class DungeonCrawler.DCRewardArtData
// 0x0008 (0x0050 - 0x0048)
class UDCRewardArtData final : public UArtDataBase
{
public:
	class UTexture2D*                             RewardIconTexture;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRewardArtData">();
	}
	static class UDCRewardArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRewardArtData>();
	}
};
static_assert(alignof(UDCRewardArtData) == 0x000008, "Wrong alignment on UDCRewardArtData");
static_assert(sizeof(UDCRewardArtData) == 0x000050, "Wrong size on UDCRewardArtData");
static_assert(offsetof(UDCRewardArtData, RewardIconTexture) == 0x000048, "Member 'UDCRewardArtData::RewardIconTexture' has a wrong offset!");

// Class DungeonCrawler.DCRewardPopupBase
// 0x0020 (0x04B0 - 0x0490)
class UDCRewardPopupBase final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_One_Confirm;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RewardItemHorizontalBox;                           // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRewardItemWidget>        RewardItemWidgetClass;                             // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCRewardPopupData*                     RewardPopupData;                                   // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnConfirmButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRewardPopupBase">();
	}
	static class UDCRewardPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRewardPopupBase>();
	}
};
static_assert(alignof(UDCRewardPopupBase) == 0x000008, "Wrong alignment on UDCRewardPopupBase");
static_assert(sizeof(UDCRewardPopupBase) == 0x0004B0, "Wrong size on UDCRewardPopupBase");
static_assert(offsetof(UDCRewardPopupBase, Btn_One_Confirm) == 0x000490, "Member 'UDCRewardPopupBase::Btn_One_Confirm' has a wrong offset!");
static_assert(offsetof(UDCRewardPopupBase, RewardItemHorizontalBox) == 0x000498, "Member 'UDCRewardPopupBase::RewardItemHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDCRewardPopupBase, RewardItemWidgetClass) == 0x0004A0, "Member 'UDCRewardPopupBase::RewardItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCRewardPopupBase, RewardPopupData) == 0x0004A8, "Member 'UDCRewardPopupBase::RewardPopupData' has a wrong offset!");

// Class DungeonCrawler.DCSceneCaptureComponent2D
// 0x0010 (0x0B60 - 0x0B50)
class UDCSceneCaptureComponent2D final : public USceneCaptureComponent2D
{
public:
	uint8                                         Pad_27BB[0x10];                                    // 0x0B50(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSceneCaptureComponent2D">();
	}
	static class UDCSceneCaptureComponent2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSceneCaptureComponent2D>();
	}
};
static_assert(alignof(UDCSceneCaptureComponent2D) == 0x000010, "Wrong alignment on UDCSceneCaptureComponent2D");
static_assert(sizeof(UDCSceneCaptureComponent2D) == 0x000B60, "Wrong size on UDCSceneCaptureComponent2D");

// Class DungeonCrawler.DCShapeShiftDataAsset
// 0x0128 (0x0170 - 0x0048)
class UDCShapeShiftDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCShapeShiftDataAsset;                        // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               Desc;                                              // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CastingTime;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadiusScale;                                // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHeightScale;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraceComplexOnMove;                                // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BC[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ShapeShiftTag;                                     // 0x00A8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShapeShiftStartTriggerTag;                         // 0x00B0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ShapeShiftedStateTags;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCCharacterShapeShiftArtData> ArtData;                                           // 0x00C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x00F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCGameplayAbilityDataAsset> ShapeShiftingAbility;                              // 0x0118(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCSkillDataAsset>> Skills;                                            // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShapeShiftDataAsset">();
	}
	static class UDCShapeShiftDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShapeShiftDataAsset>();
	}
};
static_assert(alignof(UDCShapeShiftDataAsset) == 0x000008, "Wrong alignment on UDCShapeShiftDataAsset");
static_assert(sizeof(UDCShapeShiftDataAsset) == 0x000170, "Wrong size on UDCShapeShiftDataAsset");
static_assert(offsetof(UDCShapeShiftDataAsset, Name_DCShapeShiftDataAsset) == 0x000048, "Member 'UDCShapeShiftDataAsset::Name_DCShapeShiftDataAsset' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, Desc) == 0x000060, "Member 'UDCShapeShiftDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, Classes) == 0x000088, "Member 'UDCShapeShiftDataAsset::Classes' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, CastingTime) == 0x000098, "Member 'UDCShapeShiftDataAsset::CastingTime' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, CapsuleRadiusScale) == 0x00009C, "Member 'UDCShapeShiftDataAsset::CapsuleRadiusScale' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, CapsuleHeightScale) == 0x0000A0, "Member 'UDCShapeShiftDataAsset::CapsuleHeightScale' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, TraceComplexOnMove) == 0x0000A4, "Member 'UDCShapeShiftDataAsset::TraceComplexOnMove' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, ShapeShiftTag) == 0x0000A8, "Member 'UDCShapeShiftDataAsset::ShapeShiftTag' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, ShapeShiftStartTriggerTag) == 0x0000B0, "Member 'UDCShapeShiftDataAsset::ShapeShiftStartTriggerTag' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, ShapeShiftedStateTags) == 0x0000B8, "Member 'UDCShapeShiftDataAsset::ShapeShiftedStateTags' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, ArtData) == 0x0000C8, "Member 'UDCShapeShiftDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, SoundData) == 0x0000F0, "Member 'UDCShapeShiftDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, ShapeShiftingAbility) == 0x000118, "Member 'UDCShapeShiftDataAsset::ShapeShiftingAbility' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, Abilities) == 0x000140, "Member 'UDCShapeShiftDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, Effects) == 0x000150, "Member 'UDCShapeShiftDataAsset::Effects' has a wrong offset!");
static_assert(offsetof(UDCShapeShiftDataAsset, Skills) == 0x000160, "Member 'UDCShapeShiftDataAsset::Skills' has a wrong offset!");

// Class DungeonCrawler.DCShopConfirmPurchasePopupData
// 0x0038 (0x0068 - 0x0030)
class UDCShopConfirmPurchasePopupData final : public UPopupDataBase
{
public:
	EDCShopCurrencyType                           CurrencyType;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BD[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCShopItemType                               ShopType;                                          // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BE[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        ShopItemAssetId;                                   // 0x003C(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BF[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ShopItemName;                                      // 0x0050(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopConfirmPurchasePopupData">();
	}
	static class UDCShopConfirmPurchasePopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopConfirmPurchasePopupData>();
	}
};
static_assert(alignof(UDCShopConfirmPurchasePopupData) == 0x000008, "Wrong alignment on UDCShopConfirmPurchasePopupData");
static_assert(sizeof(UDCShopConfirmPurchasePopupData) == 0x000068, "Wrong size on UDCShopConfirmPurchasePopupData");
static_assert(offsetof(UDCShopConfirmPurchasePopupData, CurrencyType) == 0x000030, "Member 'UDCShopConfirmPurchasePopupData::CurrencyType' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupData, Price) == 0x000034, "Member 'UDCShopConfirmPurchasePopupData::Price' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupData, ShopType) == 0x000038, "Member 'UDCShopConfirmPurchasePopupData::ShopType' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupData, ShopItemAssetId) == 0x00003C, "Member 'UDCShopConfirmPurchasePopupData::ShopItemAssetId' has a wrong offset!");
static_assert(offsetof(UDCShopConfirmPurchasePopupData, ShopItemName) == 0x000050, "Member 'UDCShopConfirmPurchasePopupData::ShopItemName' has a wrong offset!");

// Class DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase
// 0x0020 (0x0378 - 0x0358)
class UDCShopCurrencyTypeSlotWidgetBase : public UDCWidgetBase
{
public:
	uint8                                         Pad_27C0[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanSelect;                                        // 0x036C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCShopCurrencyType                           CurrencyType;                                      // 0x036D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C1[0x2];                                     // 0x036E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckBox*                              CheckBox;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool HasNotEnoughCurrency();
	bool IsBluestoneShardType();
	bool IsRedstoneShardType();
	void OnChangedCheckState(bool bNewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopCurrencyTypeSlotWidgetBase">();
	}
	static class UDCShopCurrencyTypeSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopCurrencyTypeSlotWidgetBase>();
	}
};
static_assert(alignof(UDCShopCurrencyTypeSlotWidgetBase) == 0x000008, "Wrong alignment on UDCShopCurrencyTypeSlotWidgetBase");
static_assert(sizeof(UDCShopCurrencyTypeSlotWidgetBase) == 0x000378, "Wrong size on UDCShopCurrencyTypeSlotWidgetBase");
static_assert(offsetof(UDCShopCurrencyTypeSlotWidgetBase, Value) == 0x000368, "Member 'UDCShopCurrencyTypeSlotWidgetBase::Value' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSlotWidgetBase, bCanSelect) == 0x00036C, "Member 'UDCShopCurrencyTypeSlotWidgetBase::bCanSelect' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSlotWidgetBase, CurrencyType) == 0x00036D, "Member 'UDCShopCurrencyTypeSlotWidgetBase::CurrencyType' has a wrong offset!");
static_assert(offsetof(UDCShopCurrencyTypeSlotWidgetBase, CheckBox) == 0x000370, "Member 'UDCShopCurrencyTypeSlotWidgetBase::CheckBox' has a wrong offset!");

// Class DungeonCrawler.DCEmoteShopDataAsset
// 0x0028 (0x00D0 - 0x00A8)
class UDCEmoteShopDataAsset final : public UDCShopDataAsset
{
public:
	TSoftObjectPtr<class UDCEmoteDataAsset>       StockData;                                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCEmoteShopDataAsset">();
	}
	static class UDCEmoteShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCEmoteShopDataAsset>();
	}
};
static_assert(alignof(UDCEmoteShopDataAsset) == 0x000008, "Wrong alignment on UDCEmoteShopDataAsset");
static_assert(sizeof(UDCEmoteShopDataAsset) == 0x0000D0, "Wrong size on UDCEmoteShopDataAsset");
static_assert(offsetof(UDCEmoteShopDataAsset, StockData) == 0x0000A8, "Member 'UDCEmoteShopDataAsset::StockData' has a wrong offset!");

// Class DungeonCrawler.DCActionSkinShopDataAsset
// 0x0028 (0x00D0 - 0x00A8)
class UDCActionSkinShopDataAsset final : public UDCShopDataAsset
{
public:
	TSoftObjectPtr<class UDCActionSkinDataAsset>  StockData;                                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCActionSkinShopDataAsset">();
	}
	static class UDCActionSkinShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCActionSkinShopDataAsset>();
	}
};
static_assert(alignof(UDCActionSkinShopDataAsset) == 0x000008, "Wrong alignment on UDCActionSkinShopDataAsset");
static_assert(sizeof(UDCActionSkinShopDataAsset) == 0x0000D0, "Wrong size on UDCActionSkinShopDataAsset");
static_assert(offsetof(UDCActionSkinShopDataAsset, StockData) == 0x0000A8, "Member 'UDCActionSkinShopDataAsset::StockData' has a wrong offset!");

// Class DungeonCrawler.DCClassPackageShopDataAsset
// 0x0028 (0x00D0 - 0x00A8)
class UDCClassPackageShopDataAsset final : public UDCShopDataAsset
{
public:
	TSoftObjectPtr<class UDCPlayerCharacterDataAsset> StockData;                                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCClassPackageShopDataAsset">();
	}
	static class UDCClassPackageShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCClassPackageShopDataAsset>();
	}
};
static_assert(alignof(UDCClassPackageShopDataAsset) == 0x000008, "Wrong alignment on UDCClassPackageShopDataAsset");
static_assert(sizeof(UDCClassPackageShopDataAsset) == 0x0000D0, "Wrong size on UDCClassPackageShopDataAsset");
static_assert(offsetof(UDCClassPackageShopDataAsset, StockData) == 0x0000A8, "Member 'UDCClassPackageShopDataAsset::StockData' has a wrong offset!");

// Class DungeonCrawler.DCRedstoneShardShopDataAsset
// 0x0028 (0x0070 - 0x0048)
class UDCRedstoneShardShopDataAsset final : public UDCTableDataAsset
{
public:
	TSoftObjectPtr<class UDCShopArtData>          ArtData;                                           // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCRedstoneShardShopDataAsset">();
	}
	static class UDCRedstoneShardShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCRedstoneShardShopDataAsset>();
	}
};
static_assert(alignof(UDCRedstoneShardShopDataAsset) == 0x000008, "Wrong alignment on UDCRedstoneShardShopDataAsset");
static_assert(sizeof(UDCRedstoneShardShopDataAsset) == 0x000070, "Wrong size on UDCRedstoneShardShopDataAsset");
static_assert(offsetof(UDCRedstoneShardShopDataAsset, ArtData) == 0x000048, "Member 'UDCRedstoneShardShopDataAsset::ArtData' has a wrong offset!");

// Class DungeonCrawler.DCShopItemSlotWidget
// 0x00F0 (0x0580 - 0x0490)
class UDCShopItemSlotWidget : public UDCControlWidgetBase
{
public:
	uint8                                         Pad_27C2[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ShopItemNameText;                                  // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           ShopItemDescTextArray;                             // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   ShopItemFlavorText;                                // 0x04D0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ShopItemTypeText;                                  // 0x04E8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   SalesChannelText;                                  // 0x0500(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ShopItemIconTexture;                               // 0x0518(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Price;                                             // 0x0520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CashPrice;                                         // 0x0524(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DiscountRate;                                      // 0x0528(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C3[0x4];                                     // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGameTooltipWithFlavorTextWidget> TooltipWidgetClass;                                // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            TooltipColor;                                      // 0x0538(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EDCShopItemState                              State;                                             // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExperimental;                                   // 0x054D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCShopSalesChannelType                       SalesChannelType;                                  // 0x054E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C4[0x21];                                    // 0x054F(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCGameTooltipWithFlavorTextWidget*     ShopItemTooltipWidget;                             // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C5[0x8];                                     // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EDCShopItemState GetShopItemState();
	class UUserWidget* GetTooltipWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopItemSlotWidget">();
	}
	static class UDCShopItemSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopItemSlotWidget>();
	}
};
static_assert(alignof(UDCShopItemSlotWidget) == 0x000008, "Wrong alignment on UDCShopItemSlotWidget");
static_assert(sizeof(UDCShopItemSlotWidget) == 0x000580, "Wrong size on UDCShopItemSlotWidget");
static_assert(offsetof(UDCShopItemSlotWidget, ShopItemNameText) == 0x0004A8, "Member 'UDCShopItemSlotWidget::ShopItemNameText' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, ShopItemDescTextArray) == 0x0004C0, "Member 'UDCShopItemSlotWidget::ShopItemDescTextArray' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, ShopItemFlavorText) == 0x0004D0, "Member 'UDCShopItemSlotWidget::ShopItemFlavorText' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, ShopItemTypeText) == 0x0004E8, "Member 'UDCShopItemSlotWidget::ShopItemTypeText' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, SalesChannelText) == 0x000500, "Member 'UDCShopItemSlotWidget::SalesChannelText' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, ShopItemIconTexture) == 0x000518, "Member 'UDCShopItemSlotWidget::ShopItemIconTexture' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, Price) == 0x000520, "Member 'UDCShopItemSlotWidget::Price' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, CashPrice) == 0x000524, "Member 'UDCShopItemSlotWidget::CashPrice' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, DiscountRate) == 0x000528, "Member 'UDCShopItemSlotWidget::DiscountRate' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, TooltipWidgetClass) == 0x000530, "Member 'UDCShopItemSlotWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, TooltipColor) == 0x000538, "Member 'UDCShopItemSlotWidget::TooltipColor' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, State) == 0x00054C, "Member 'UDCShopItemSlotWidget::State' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, bIsExperimental) == 0x00054D, "Member 'UDCShopItemSlotWidget::bIsExperimental' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, SalesChannelType) == 0x00054E, "Member 'UDCShopItemSlotWidget::SalesChannelType' has a wrong offset!");
static_assert(offsetof(UDCShopItemSlotWidget, ShopItemTooltipWidget) == 0x000570, "Member 'UDCShopItemSlotWidget::ShopItemTooltipWidget' has a wrong offset!");

// Class DungeonCrawler.DCShopItemListEntryWidget
// 0x0008 (0x0588 - 0x0580)
class UDCShopItemListEntryWidget final : public UDCShopItemSlotWidget
{
public:
	uint8                                         Pad_27C6[0x8];                                     // 0x0580(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopItemListEntryWidget">();
	}
	static class UDCShopItemListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopItemListEntryWidget>();
	}
};
static_assert(alignof(UDCShopItemListEntryWidget) == 0x000008, "Wrong alignment on UDCShopItemListEntryWidget");
static_assert(sizeof(UDCShopItemListEntryWidget) == 0x000588, "Wrong size on UDCShopItemListEntryWidget");

// Class DungeonCrawler.DCShopItemListWidget
// 0x0040 (0x0398 - 0x0358)
class UDCShopItemListWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_27C7[0x18];                                    // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTileView*                              TileView;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      GridPanel;                                         // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExclusiveNotShowing;                            // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C8[0x7];                                     // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCShopDataAsset*>               ShopDataAssetArray;                                // 0x0388(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopItemListWidget">();
	}
	static class UDCShopItemListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopItemListWidget>();
	}
};
static_assert(alignof(UDCShopItemListWidget) == 0x000008, "Wrong alignment on UDCShopItemListWidget");
static_assert(sizeof(UDCShopItemListWidget) == 0x000398, "Wrong size on UDCShopItemListWidget");
static_assert(offsetof(UDCShopItemListWidget, TileView) == 0x000370, "Member 'UDCShopItemListWidget::TileView' has a wrong offset!");
static_assert(offsetof(UDCShopItemListWidget, GridPanel) == 0x000378, "Member 'UDCShopItemListWidget::GridPanel' has a wrong offset!");
static_assert(offsetof(UDCShopItemListWidget, bIsExclusiveNotShowing) == 0x000380, "Member 'UDCShopItemListWidget::bIsExclusiveNotShowing' has a wrong offset!");
static_assert(offsetof(UDCShopItemListWidget, ShopDataAssetArray) == 0x000388, "Member 'UDCShopItemListWidget::ShopDataAssetArray' has a wrong offset!");

// Class DungeonCrawler.DCShopWidgetBase
// 0x0248 (0x05A0 - 0x0358)
class UDCShopWidgetBase final : public UDCWidgetBase
{
public:
	int32                                         RedstoneShardValue;                                // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BluestoneShardValue;                               // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TriumphLevelValue;                                 // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTriumphLevelValue;                              // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TriumphExpValue;                                   // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TriumphMaxExpValue;                                // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TriumphExpPercentage;                              // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentPageIndex;                                  // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPageIndex;                                      // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C9[0x4];                                     // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SelectedShopItemName;                              // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsFirstPage;                                      // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLastPage;                                       // 0x0399(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOwnedShopItem;                                  // 0x039A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowRedstoneShardRefreshBtn;                      // 0x039B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CA[0x4];                                     // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCGiftCodePopupBase>       GiftCodePopupClass;                                // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCGiftCodeRewardPopupBase> GiftCodeRewardPopupClass;                          // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCRewardPopupBase>         RewardPopupClass;                                  // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCAccountStatusUpgradeCompletePopup> AccountUpgradeCompletePopupClass;                  // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTabListWidgetBase*                   ShopCategoryTabList;                               // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  NewShopItemListWidget;                             // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  RaceShopItemListWidget;                            // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  ItemSkinShopItemListWidget;                        // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  EmoteShopItemListWidget;                           // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  LobbyEmoteShopItemListWidget;                      // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  ActionSkinShopItemListWidget;                      // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  ExclusiveShopItemListWidget;                       // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCShopItemListWidget*                  PromotionShopItemListWidget;                       // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTabListWidgetBase*                   ShopTabList;                                       // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAccountStatusUpgradeShopWidget*      UpgradeAccountStatusWidget;                        // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCAccountNameChangeShopWidget*         AccountNameChangeShopWidget;                       // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonArrowL;                                      // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonArrowR;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonBuy;                                         // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        PreviewSwitcher;                                   // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_EnterCode;                                     // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemSkinViewerWidgetBase*            ItemSkinViewerWidget;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_RefreshRedstoneShard;                          // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCRedstoneShardShopListWidgetBase*     RedstoneShardShopItemList;                         // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ButtonRedstoneShardBuy;                            // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        SelectedShopItemId;                                // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRedstoneShardShopItemSelected;                  // 0x0478(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CB[0x3];                                     // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedShopItemPrice;                             // 0x047C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedShopItemCashPrice;                         // 0x0480(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDiscounted;                                     // 0x0484(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CC[0x3];                                     // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              DiscountRemainTimespan;                            // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedShopItemDiscountPrice;                     // 0x0490(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedShopItemDiscountCashPrice;                 // 0x0494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExclusive;                                      // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CD[0x7];                                     // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ExclusiveSourceText;                               // 0x04A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EDCAccountStatus                              AccountStatus;                                     // 0x04B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CE[0xE7];                                    // 0x04B9(0x00E7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonBuyClicked();
	void OnButtonEnterCodeClicked();
	void OnButtonRedstoneShardBuyClicked();
	void OnNextPage();
	void OnPreviewSwitched(const EDCShopItemType ItemType);
	void OnPrevPage();
	void OnSelectedShopCategoryTabChanged(class FName SelectedTabId);
	void OnTriumphLevelAndExp();
	void OnWidgetClose();
	void OnWidgetOpen();

	bool CanPurchase() const;
	int32 GetDiscountRate() const;
	bool HasSelectedShopItemAnyPrice() const;
	bool HasSelectedShopItemBluestoneShardPrice() const;
	bool HasSelectedShopItemRedstoneShardPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCShopWidgetBase">();
	}
	static class UDCShopWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCShopWidgetBase>();
	}
};
static_assert(alignof(UDCShopWidgetBase) == 0x000008, "Wrong alignment on UDCShopWidgetBase");
static_assert(sizeof(UDCShopWidgetBase) == 0x0005A0, "Wrong size on UDCShopWidgetBase");
static_assert(offsetof(UDCShopWidgetBase, RedstoneShardValue) == 0x000358, "Member 'UDCShopWidgetBase::RedstoneShardValue' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, BluestoneShardValue) == 0x00035C, "Member 'UDCShopWidgetBase::BluestoneShardValue' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, TriumphLevelValue) == 0x000360, "Member 'UDCShopWidgetBase::TriumphLevelValue' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, MaxTriumphLevelValue) == 0x000364, "Member 'UDCShopWidgetBase::MaxTriumphLevelValue' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, TriumphExpValue) == 0x000368, "Member 'UDCShopWidgetBase::TriumphExpValue' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, TriumphMaxExpValue) == 0x00036C, "Member 'UDCShopWidgetBase::TriumphMaxExpValue' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, TriumphExpPercentage) == 0x000370, "Member 'UDCShopWidgetBase::TriumphExpPercentage' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, CurrentPageIndex) == 0x000374, "Member 'UDCShopWidgetBase::CurrentPageIndex' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, MaxPageIndex) == 0x000378, "Member 'UDCShopWidgetBase::MaxPageIndex' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, SelectedShopItemName) == 0x000380, "Member 'UDCShopWidgetBase::SelectedShopItemName' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bIsFirstPage) == 0x000398, "Member 'UDCShopWidgetBase::bIsFirstPage' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bIsLastPage) == 0x000399, "Member 'UDCShopWidgetBase::bIsLastPage' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bIsOwnedShopItem) == 0x00039A, "Member 'UDCShopWidgetBase::bIsOwnedShopItem' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bShowRedstoneShardRefreshBtn) == 0x00039B, "Member 'UDCShopWidgetBase::bShowRedstoneShardRefreshBtn' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, GiftCodePopupClass) == 0x0003A0, "Member 'UDCShopWidgetBase::GiftCodePopupClass' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, GiftCodeRewardPopupClass) == 0x0003A8, "Member 'UDCShopWidgetBase::GiftCodeRewardPopupClass' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, RewardPopupClass) == 0x0003B0, "Member 'UDCShopWidgetBase::RewardPopupClass' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, AccountUpgradeCompletePopupClass) == 0x0003B8, "Member 'UDCShopWidgetBase::AccountUpgradeCompletePopupClass' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ShopCategoryTabList) == 0x0003C0, "Member 'UDCShopWidgetBase::ShopCategoryTabList' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, NewShopItemListWidget) == 0x0003C8, "Member 'UDCShopWidgetBase::NewShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, RaceShopItemListWidget) == 0x0003D0, "Member 'UDCShopWidgetBase::RaceShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ItemSkinShopItemListWidget) == 0x0003D8, "Member 'UDCShopWidgetBase::ItemSkinShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, EmoteShopItemListWidget) == 0x0003E0, "Member 'UDCShopWidgetBase::EmoteShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, LobbyEmoteShopItemListWidget) == 0x0003E8, "Member 'UDCShopWidgetBase::LobbyEmoteShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ActionSkinShopItemListWidget) == 0x0003F0, "Member 'UDCShopWidgetBase::ActionSkinShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ExclusiveShopItemListWidget) == 0x0003F8, "Member 'UDCShopWidgetBase::ExclusiveShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, PromotionShopItemListWidget) == 0x000400, "Member 'UDCShopWidgetBase::PromotionShopItemListWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ShopTabList) == 0x000408, "Member 'UDCShopWidgetBase::ShopTabList' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, UpgradeAccountStatusWidget) == 0x000410, "Member 'UDCShopWidgetBase::UpgradeAccountStatusWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, AccountNameChangeShopWidget) == 0x000418, "Member 'UDCShopWidgetBase::AccountNameChangeShopWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ButtonArrowL) == 0x000420, "Member 'UDCShopWidgetBase::ButtonArrowL' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ButtonArrowR) == 0x000428, "Member 'UDCShopWidgetBase::ButtonArrowR' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ButtonBuy) == 0x000430, "Member 'UDCShopWidgetBase::ButtonBuy' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, PreviewSwitcher) == 0x000438, "Member 'UDCShopWidgetBase::PreviewSwitcher' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, Btn_EnterCode) == 0x000440, "Member 'UDCShopWidgetBase::Btn_EnterCode' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ItemSkinViewerWidget) == 0x000448, "Member 'UDCShopWidgetBase::ItemSkinViewerWidget' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, Btn_RefreshRedstoneShard) == 0x000450, "Member 'UDCShopWidgetBase::Btn_RefreshRedstoneShard' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, RedstoneShardShopItemList) == 0x000458, "Member 'UDCShopWidgetBase::RedstoneShardShopItemList' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ButtonRedstoneShardBuy) == 0x000460, "Member 'UDCShopWidgetBase::ButtonRedstoneShardBuy' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, SelectedShopItemId) == 0x000468, "Member 'UDCShopWidgetBase::SelectedShopItemId' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bIsRedstoneShardShopItemSelected) == 0x000478, "Member 'UDCShopWidgetBase::bIsRedstoneShardShopItemSelected' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, SelectedShopItemPrice) == 0x00047C, "Member 'UDCShopWidgetBase::SelectedShopItemPrice' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, SelectedShopItemCashPrice) == 0x000480, "Member 'UDCShopWidgetBase::SelectedShopItemCashPrice' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bIsDiscounted) == 0x000484, "Member 'UDCShopWidgetBase::bIsDiscounted' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, DiscountRemainTimespan) == 0x000488, "Member 'UDCShopWidgetBase::DiscountRemainTimespan' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, SelectedShopItemDiscountPrice) == 0x000490, "Member 'UDCShopWidgetBase::SelectedShopItemDiscountPrice' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, SelectedShopItemDiscountCashPrice) == 0x000494, "Member 'UDCShopWidgetBase::SelectedShopItemDiscountCashPrice' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, bIsExclusive) == 0x000498, "Member 'UDCShopWidgetBase::bIsExclusive' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, ExclusiveSourceText) == 0x0004A0, "Member 'UDCShopWidgetBase::ExclusiveSourceText' has a wrong offset!");
static_assert(offsetof(UDCShopWidgetBase, AccountStatus) == 0x0004B8, "Member 'UDCShopWidgetBase::AccountStatus' has a wrong offset!");

// Class DungeonCrawler.DCSimpleTooltipWidget
// 0x0030 (0x0388 - 0x0358)
class UDCSimpleTooltipWidget final : public UDCWidgetBase
{
public:
	class FText                                   TooltipNameText;                                   // 0x0358(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            TooltipColor;                                      // 0x0370(0x0014)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CF[0x4];                                     // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSlateColor GetTooltipColor();
	void SetTooltipData(const class FText& Text, const struct FSlateColor& TextColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSimpleTooltipWidget">();
	}
	static class UDCSimpleTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSimpleTooltipWidget>();
	}
};
static_assert(alignof(UDCSimpleTooltipWidget) == 0x000008, "Wrong alignment on UDCSimpleTooltipWidget");
static_assert(sizeof(UDCSimpleTooltipWidget) == 0x000388, "Wrong size on UDCSimpleTooltipWidget");
static_assert(offsetof(UDCSimpleTooltipWidget, TooltipNameText) == 0x000358, "Member 'UDCSimpleTooltipWidget::TooltipNameText' has a wrong offset!");
static_assert(offsetof(UDCSimpleTooltipWidget, TooltipColor) == 0x000370, "Member 'UDCSimpleTooltipWidget::TooltipColor' has a wrong offset!");

// Class DungeonCrawler.DCSkillDataAsset
// 0x0158 (0x01A0 - 0x0048)
class UDCSkillDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCSkillDataAsset;                             // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               DescData;                                          // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUse;                                            // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D1[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EDCSkillClassAbility                          SkillClassAbility;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D2[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SkillType;                                         // 0x00A4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillTier;                                         // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanRecharge;                                       // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStackable;                                       // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D3[0x2];                                     // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCount;                                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastingTime;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingDuration;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingInterval;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range;                                             // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMoving;                                         // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedAimTarget;                                     // 0x00C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D4[0x2];                                     // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SkillTag;                                          // 0x00CC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillCooldownTag;                                  // 0x00D4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D5[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCGameplayEffectDataAsset> SkillCooldownEffect;                               // 0x00E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCGameplayEffectDataAsset> SkillStackCooldownEffect;                          // 0x0108(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UArtDataSkill>           ArtData;                                           // 0x0130(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0158(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSkillDataAsset">();
	}
	static class UDCSkillDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSkillDataAsset>();
	}
};
static_assert(alignof(UDCSkillDataAsset) == 0x000008, "Wrong alignment on UDCSkillDataAsset");
static_assert(sizeof(UDCSkillDataAsset) == 0x0001A0, "Wrong size on UDCSkillDataAsset");
static_assert(offsetof(UDCSkillDataAsset, Name_DCSkillDataAsset) == 0x000048, "Member 'UDCSkillDataAsset::Name_DCSkillDataAsset' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, DescData) == 0x000060, "Member 'UDCSkillDataAsset::DescData' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, CanUse) == 0x000088, "Member 'UDCSkillDataAsset::CanUse' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, Classes) == 0x000090, "Member 'UDCSkillDataAsset::Classes' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillClassAbility) == 0x0000A0, "Member 'UDCSkillDataAsset::SkillClassAbility' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillType) == 0x0000A4, "Member 'UDCSkillDataAsset::SkillType' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillTier) == 0x0000AC, "Member 'UDCSkillDataAsset::SkillTier' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, CanRecharge) == 0x0000B0, "Member 'UDCSkillDataAsset::CanRecharge' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, IsStackable) == 0x0000B1, "Member 'UDCSkillDataAsset::IsStackable' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, MaxCount) == 0x0000B4, "Member 'UDCSkillDataAsset::MaxCount' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, CastingTime) == 0x0000B8, "Member 'UDCSkillDataAsset::CastingTime' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, ChannelingDuration) == 0x0000BC, "Member 'UDCSkillDataAsset::ChannelingDuration' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, ChannelingInterval) == 0x0000C0, "Member 'UDCSkillDataAsset::ChannelingInterval' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, Range) == 0x0000C4, "Member 'UDCSkillDataAsset::Range' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, UseMoving) == 0x0000C8, "Member 'UDCSkillDataAsset::UseMoving' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, NeedAimTarget) == 0x0000C9, "Member 'UDCSkillDataAsset::NeedAimTarget' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillTag) == 0x0000CC, "Member 'UDCSkillDataAsset::SkillTag' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillCooldownTag) == 0x0000D4, "Member 'UDCSkillDataAsset::SkillCooldownTag' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillCooldownEffect) == 0x0000E0, "Member 'UDCSkillDataAsset::SkillCooldownEffect' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SkillStackCooldownEffect) == 0x000108, "Member 'UDCSkillDataAsset::SkillStackCooldownEffect' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, ArtData) == 0x000130, "Member 'UDCSkillDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, SoundData) == 0x000158, "Member 'UDCSkillDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, Abilities) == 0x000180, "Member 'UDCSkillDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCSkillDataAsset, Effects) == 0x000190, "Member 'UDCSkillDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCSortButtonWidget
// 0x0090 (0x16F0 - 0x1660)
class UDCSortButtonWidget final : public UDCCommonButtonBase
{
public:
	class FName                                   SortTargetName;                                    // 0x1658(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSortable;                                       // 0x1660(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D6[0x7];                                     // 0x1661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDCSortButtonState, class UTexture2D*>   SortStateIconMap;                                  // 0x1668(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D7[0x8];                                     // 0x16B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 SortStateImage;                                    // 0x16C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27D8[0x28];                                    // 0x16C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UTexture2D* GetCurrentSortStateIcon() const;
	bool IsSortable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSortButtonWidget">();
	}
	static class UDCSortButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSortButtonWidget>();
	}
};
static_assert(alignof(UDCSortButtonWidget) == 0x000010, "Wrong alignment on UDCSortButtonWidget");
static_assert(sizeof(UDCSortButtonWidget) == 0x0016F0, "Wrong size on UDCSortButtonWidget");
static_assert(offsetof(UDCSortButtonWidget, SortTargetName) == 0x001658, "Member 'UDCSortButtonWidget::SortTargetName' has a wrong offset!");
static_assert(offsetof(UDCSortButtonWidget, bIsSortable) == 0x001660, "Member 'UDCSortButtonWidget::bIsSortable' has a wrong offset!");
static_assert(offsetof(UDCSortButtonWidget, SortStateIconMap) == 0x001668, "Member 'UDCSortButtonWidget::SortStateIconMap' has a wrong offset!");
static_assert(offsetof(UDCSortButtonWidget, SortStateImage) == 0x0016C0, "Member 'UDCSortButtonWidget::SortStateImage' has a wrong offset!");

// Class DungeonCrawler.DCSpawnerDataAsset
// 0x0010 (0x0058 - 0x0048)
class UDCSpawnerDataAsset final : public UDCTableDataAsset
{
public:
	TArray<struct FDCSpawnerItemData>             SpawnerItemArray;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSpawnerDataAsset">();
	}
	static class UDCSpawnerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSpawnerDataAsset>();
	}
};
static_assert(alignof(UDCSpawnerDataAsset) == 0x000008, "Wrong alignment on UDCSpawnerDataAsset");
static_assert(sizeof(UDCSpawnerDataAsset) == 0x000058, "Wrong size on UDCSpawnerDataAsset");
static_assert(offsetof(UDCSpawnerDataAsset, SpawnerItemArray) == 0x000048, "Member 'UDCSpawnerDataAsset::SpawnerItemArray' has a wrong offset!");

// Class DungeonCrawler.DCSpellBeamEndPointActorBase
// 0x0000 (0x02F8 - 0x02F8)
class ADCSpellBeamEndPointActorBase : public ADCActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSpellBeamEndPointActorBase">();
	}
	static class ADCSpellBeamEndPointActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCSpellBeamEndPointActorBase>();
	}
};
static_assert(alignof(ADCSpellBeamEndPointActorBase) == 0x000008, "Wrong alignment on ADCSpellBeamEndPointActorBase");
static_assert(sizeof(ADCSpellBeamEndPointActorBase) == 0x0002F8, "Wrong size on ADCSpellBeamEndPointActorBase");

// Class DungeonCrawler.DCSpellBeamSpringArmComponent
// 0x0010 (0x03B0 - 0x03A0)
class UDCSpellBeamSpringArmComponent final : public USpringArmComponent
{
public:
	float                                         SpellRange;                                        // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D9[0xC];                                     // 0x03A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpellRange(float OldSpellRange);
	void SetSpellRange(float InSpellRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSpellBeamSpringArmComponent">();
	}
	static class UDCSpellBeamSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSpellBeamSpringArmComponent>();
	}
};
static_assert(alignof(UDCSpellBeamSpringArmComponent) == 0x000010, "Wrong alignment on UDCSpellBeamSpringArmComponent");
static_assert(sizeof(UDCSpellBeamSpringArmComponent) == 0x0003B0, "Wrong size on UDCSpellBeamSpringArmComponent");
static_assert(offsetof(UDCSpellBeamSpringArmComponent, SpellRange) == 0x0003A0, "Member 'UDCSpellBeamSpringArmComponent::SpellRange' has a wrong offset!");

// Class DungeonCrawler.DCSpellDataAsset
// 0x0138 (0x0180 - 0x0048)
class UDCSpellDataAsset final : public UDCTableDataAsset
{
public:
	class FText                                   Name_DCSpellDataAsset;                             // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDescData>               Desc;                                              // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CastingType;                                       // 0x0098(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SourceType;                                        // 0x00A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CostType;                                          // 0x00A8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCGameplayEffectDataAsset> CostEffect;                                        // 0x00B0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpellTier;                                         // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastingTime;                                       // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingDuration;                                // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingInterval;                                // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range;                                             // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaRadius;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAreaInstall;                                     // 0x00F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DA[0x3];                                     // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameplayAbilityWorldReticle> ReticleActorClass;                                 // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMoving;                                         // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DB[0x3];                                     // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SpellTag;                                          // 0x0104(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DC[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UArtDataSpell>           ArtData;                                           // 0x0110(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0138(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayAbilityDataAsset>> Abilities;                                         // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCGameplayEffectDataAsset>> Effects;                                           // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCSpellDataAsset">();
	}
	static class UDCSpellDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCSpellDataAsset>();
	}
};
static_assert(alignof(UDCSpellDataAsset) == 0x000008, "Wrong alignment on UDCSpellDataAsset");
static_assert(sizeof(UDCSpellDataAsset) == 0x000180, "Wrong size on UDCSpellDataAsset");
static_assert(offsetof(UDCSpellDataAsset, Name_DCSpellDataAsset) == 0x000048, "Member 'UDCSpellDataAsset::Name_DCSpellDataAsset' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, Desc) == 0x000060, "Member 'UDCSpellDataAsset::Desc' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, Classes) == 0x000088, "Member 'UDCSpellDataAsset::Classes' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, CastingType) == 0x000098, "Member 'UDCSpellDataAsset::CastingType' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, SourceType) == 0x0000A0, "Member 'UDCSpellDataAsset::SourceType' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, CostType) == 0x0000A8, "Member 'UDCSpellDataAsset::CostType' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, CostEffect) == 0x0000B0, "Member 'UDCSpellDataAsset::CostEffect' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, SpellTier) == 0x0000D8, "Member 'UDCSpellDataAsset::SpellTier' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, MaxCount) == 0x0000DC, "Member 'UDCSpellDataAsset::MaxCount' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, CastingTime) == 0x0000E0, "Member 'UDCSpellDataAsset::CastingTime' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, ChannelingDuration) == 0x0000E4, "Member 'UDCSpellDataAsset::ChannelingDuration' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, ChannelingInterval) == 0x0000E8, "Member 'UDCSpellDataAsset::ChannelingInterval' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, Range) == 0x0000EC, "Member 'UDCSpellDataAsset::Range' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, AreaRadius) == 0x0000F0, "Member 'UDCSpellDataAsset::AreaRadius' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, IsAreaInstall) == 0x0000F4, "Member 'UDCSpellDataAsset::IsAreaInstall' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, ReticleActorClass) == 0x0000F8, "Member 'UDCSpellDataAsset::ReticleActorClass' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, UseMoving) == 0x000100, "Member 'UDCSpellDataAsset::UseMoving' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, SpellTag) == 0x000104, "Member 'UDCSpellDataAsset::SpellTag' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, ArtData) == 0x000110, "Member 'UDCSpellDataAsset::ArtData' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, SoundData) == 0x000138, "Member 'UDCSpellDataAsset::SoundData' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, Abilities) == 0x000160, "Member 'UDCSpellDataAsset::Abilities' has a wrong offset!");
static_assert(offsetof(UDCSpellDataAsset, Effects) == 0x000170, "Member 'UDCSpellDataAsset::Effects' has a wrong offset!");

// Class DungeonCrawler.DCStaticMeshComponent
// 0x0050 (0x0680 - 0x0630)
class UDCStaticMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_27DD[0x58];                                    // 0x0628(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStaticMeshComponent">();
	}
	static class UDCStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStaticMeshComponent>();
	}
};
static_assert(alignof(UDCStaticMeshComponent) == 0x000010, "Wrong alignment on UDCStaticMeshComponent");
static_assert(sizeof(UDCStaticMeshComponent) == 0x000680, "Wrong size on UDCStaticMeshComponent");

// Class DungeonCrawler.DCStatisticsManager
// 0x0050 (0x0080 - 0x0030)
class UDCStatisticsManager final : public UDCUserInfoManagerBase
{
public:
	uint8                                         Pad_27DE[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCStatisticsManager">();
	}
	static class UDCStatisticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCStatisticsManager>();
	}
};
static_assert(alignof(UDCStatisticsManager) == 0x000008, "Wrong alignment on UDCStatisticsManager");
static_assert(sizeof(UDCStatisticsManager) == 0x000080, "Wrong size on UDCStatisticsManager");

// Class DungeonCrawler.DCTabButtonWidgetBase
// 0x0010 (0x1670 - 0x1660)
class UDCTabButtonWidgetBase : public UDCCommonButtonBase
{
public:
	class UWidgetSwitcher*                        Switcher_OnOff;                                    // 0x1658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsYellowIndicatorOn;                              // 0x1660(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGreenIndicatorOn;                               // 0x1661(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27DF[0xE];                                     // 0x1662(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSelectedChanged(bool bInIsSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTabButtonWidgetBase">();
	}
	static class UDCTabButtonWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTabButtonWidgetBase>();
	}
};
static_assert(alignof(UDCTabButtonWidgetBase) == 0x000010, "Wrong alignment on UDCTabButtonWidgetBase");
static_assert(sizeof(UDCTabButtonWidgetBase) == 0x001670, "Wrong size on UDCTabButtonWidgetBase");
static_assert(offsetof(UDCTabButtonWidgetBase, Switcher_OnOff) == 0x001658, "Member 'UDCTabButtonWidgetBase::Switcher_OnOff' has a wrong offset!");
static_assert(offsetof(UDCTabButtonWidgetBase, bIsYellowIndicatorOn) == 0x001660, "Member 'UDCTabButtonWidgetBase::bIsYellowIndicatorOn' has a wrong offset!");
static_assert(offsetof(UDCTabButtonWidgetBase, bIsGreenIndicatorOn) == 0x001661, "Member 'UDCTabButtonWidgetBase::bIsGreenIndicatorOn' has a wrong offset!");

// Class DungeonCrawler.StorageWidget
// 0x0000 (0x0358 - 0x0358)
class UStorageWidget final : public UDCWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorageWidget">();
	}
	static class UStorageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorageWidget>();
	}
};
static_assert(alignof(UStorageWidget) == 0x000008, "Wrong alignment on UStorageWidget");
static_assert(sizeof(UStorageWidget) == 0x000358, "Wrong size on UStorageWidget");

// Class DungeonCrawler.DCTargetType_UseOwner
// 0x0000 (0x0028 - 0x0028)
class UDCTargetType_UseOwner final : public UDCTargetType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTargetType_UseOwner">();
	}
	static class UDCTargetType_UseOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTargetType_UseOwner>();
	}
};
static_assert(alignof(UDCTargetType_UseOwner) == 0x000008, "Wrong alignment on UDCTargetType_UseOwner");
static_assert(sizeof(UDCTargetType_UseOwner) == 0x000028, "Wrong size on UDCTargetType_UseOwner");

// Class DungeonCrawler.DCTradeBoxWidget
// 0x0028 (0x0408 - 0x03E0)
class UDCTradeBoxWidget final : public UDCInventoryWidgetBase
{
public:
	bool                                          bLocal;                                            // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27E0[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TraderName;                                        // 0x03E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReady;                                            // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27E1[0x3];                                     // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockRemainTime;                                    // 0x03FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCBagWidget*                           InnerBagWidget;                                    // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsEnableCheckBox();
	void SetReady(bool bState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradeBoxWidget">();
	}
	static class UDCTradeBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradeBoxWidget>();
	}
};
static_assert(alignof(UDCTradeBoxWidget) == 0x000008, "Wrong alignment on UDCTradeBoxWidget");
static_assert(sizeof(UDCTradeBoxWidget) == 0x000408, "Wrong size on UDCTradeBoxWidget");
static_assert(offsetof(UDCTradeBoxWidget, bLocal) == 0x0003E0, "Member 'UDCTradeBoxWidget::bLocal' has a wrong offset!");
static_assert(offsetof(UDCTradeBoxWidget, TraderName) == 0x0003E8, "Member 'UDCTradeBoxWidget::TraderName' has a wrong offset!");
static_assert(offsetof(UDCTradeBoxWidget, bReady) == 0x0003F8, "Member 'UDCTradeBoxWidget::bReady' has a wrong offset!");
static_assert(offsetof(UDCTradeBoxWidget, LockRemainTime) == 0x0003FC, "Member 'UDCTradeBoxWidget::LockRemainTime' has a wrong offset!");
static_assert(offsetof(UDCTradeBoxWidget, InnerBagWidget) == 0x000400, "Member 'UDCTradeBoxWidget::InnerBagWidget' has a wrong offset!");

// Class DungeonCrawler.DCTradeChannelCategoryWidget
// 0x0020 (0x02E0 - 0x02C0)
class UDCTradeChannelCategoryWidget final : public UUserWidget
{
public:
	class FText                                   CategoryNameText;                                  // 0x02C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_ChannelButton;                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradeChannelCategoryWidget">();
	}
	static class UDCTradeChannelCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradeChannelCategoryWidget>();
	}
};
static_assert(alignof(UDCTradeChannelCategoryWidget) == 0x000008, "Wrong alignment on UDCTradeChannelCategoryWidget");
static_assert(sizeof(UDCTradeChannelCategoryWidget) == 0x0002E0, "Wrong size on UDCTradeChannelCategoryWidget");
static_assert(offsetof(UDCTradeChannelCategoryWidget, CategoryNameText) == 0x0002C0, "Member 'UDCTradeChannelCategoryWidget::CategoryNameText' has a wrong offset!");
static_assert(offsetof(UDCTradeChannelCategoryWidget, VerticalBox_ChannelButton) == 0x0002D8, "Member 'UDCTradeChannelCategoryWidget::VerticalBox_ChannelButton' has a wrong offset!");

// Class DungeonCrawler.DCTradeSubscriptionPopupData
// 0x0008 (0x0038 - 0x0030)
class UDCTradeSubscriptionPopupData final : public UPopupDataBase
{
public:
	uint8                                         Pad_27E2[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradeSubscriptionPopupData">();
	}
	static class UDCTradeSubscriptionPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradeSubscriptionPopupData>();
	}
};
static_assert(alignof(UDCTradeSubscriptionPopupData) == 0x000008, "Wrong alignment on UDCTradeSubscriptionPopupData");
static_assert(sizeof(UDCTradeSubscriptionPopupData) == 0x000038, "Wrong size on UDCTradeSubscriptionPopupData");

// Class DungeonCrawler.DCTradeSubscriptionPopup
// 0x00A8 (0x0538 - 0x0490)
class UDCTradeSubscriptionPopup final : public UCommonPopupBase
{
public:
	class FText                                   RequirementLevelText;                              // 0x0490(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequirementFeeText;                                // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequirementMonthDueText;                           // 0x04C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RequirementTradeCostText;                          // 0x04D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   TraderName;                                        // 0x04F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         ContentBlockHoursAfterUpgradeAccountStatus;        // 0x0508(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAllowedSquireEnterTradingPost;                  // 0x050C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27E3[0x3];                                     // 0x050D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCommonButtonBase*                    CommonBtn_Cancel;                                  // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CommonBtn_Confirm;                                 // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CommonBtn_Done;                                    // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_Subscription;                       // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTradeSubscriptionPopupData*          TradeSubscriptionPopupData;                        // 0x0530(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseSelf();
	void OnClikedButtonDone();
	void SendMsgWidgetTradeSubscriptionButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTradeSubscriptionPopup">();
	}
	static class UDCTradeSubscriptionPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTradeSubscriptionPopup>();
	}
};
static_assert(alignof(UDCTradeSubscriptionPopup) == 0x000008, "Wrong alignment on UDCTradeSubscriptionPopup");
static_assert(sizeof(UDCTradeSubscriptionPopup) == 0x000538, "Wrong size on UDCTradeSubscriptionPopup");
static_assert(offsetof(UDCTradeSubscriptionPopup, RequirementLevelText) == 0x000490, "Member 'UDCTradeSubscriptionPopup::RequirementLevelText' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, RequirementFeeText) == 0x0004A8, "Member 'UDCTradeSubscriptionPopup::RequirementFeeText' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, RequirementMonthDueText) == 0x0004C0, "Member 'UDCTradeSubscriptionPopup::RequirementMonthDueText' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, RequirementTradeCostText) == 0x0004D8, "Member 'UDCTradeSubscriptionPopup::RequirementTradeCostText' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, TraderName) == 0x0004F0, "Member 'UDCTradeSubscriptionPopup::TraderName' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, ContentBlockHoursAfterUpgradeAccountStatus) == 0x000508, "Member 'UDCTradeSubscriptionPopup::ContentBlockHoursAfterUpgradeAccountStatus' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, bIsAllowedSquireEnterTradingPost) == 0x00050C, "Member 'UDCTradeSubscriptionPopup::bIsAllowedSquireEnterTradingPost' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, CommonBtn_Cancel) == 0x000510, "Member 'UDCTradeSubscriptionPopup::CommonBtn_Cancel' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, CommonBtn_Confirm) == 0x000518, "Member 'UDCTradeSubscriptionPopup::CommonBtn_Confirm' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, CommonBtn_Done) == 0x000520, "Member 'UDCTradeSubscriptionPopup::CommonBtn_Done' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, WidgetSwitcher_Subscription) == 0x000528, "Member 'UDCTradeSubscriptionPopup::WidgetSwitcher_Subscription' has a wrong offset!");
static_assert(offsetof(UDCTradeSubscriptionPopup, TradeSubscriptionPopupData) == 0x000530, "Member 'UDCTradeSubscriptionPopup::TradeSubscriptionPopupData' has a wrong offset!");

// Class DungeonCrawler.DCTrainingInterface
// 0x0000 (0x0028 - 0x0028)
class IDCTrainingInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingInterface">();
	}
	static class IDCTrainingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCTrainingInterface>();
	}
};
static_assert(alignof(IDCTrainingInterface) == 0x000008, "Wrong alignment on IDCTrainingInterface");
static_assert(sizeof(IDCTrainingInterface) == 0x000028, "Wrong size on IDCTrainingInterface");

// Class DungeonCrawler.DCTrainingReceiveCheckPopupData
// 0x0040 (0x0070 - 0x0030)
class UDCTrainingReceiveCheckPopupData final : public UPopupDataBase
{
public:
	struct FDCTrainingOptionInfo                  TrainingOptionInfo;                                // 0x0030(0x0040)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingReceiveCheckPopupData">();
	}
	static class UDCTrainingReceiveCheckPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingReceiveCheckPopupData>();
	}
};
static_assert(alignof(UDCTrainingReceiveCheckPopupData) == 0x000008, "Wrong alignment on UDCTrainingReceiveCheckPopupData");
static_assert(sizeof(UDCTrainingReceiveCheckPopupData) == 0x000070, "Wrong size on UDCTrainingReceiveCheckPopupData");
static_assert(offsetof(UDCTrainingReceiveCheckPopupData, TrainingOptionInfo) == 0x000030, "Member 'UDCTrainingReceiveCheckPopupData::TrainingOptionInfo' has a wrong offset!");

// Class DungeonCrawler.DCTrainingReceiveCheckPopup
// 0x0038 (0x04C8 - 0x0490)
class UDCTrainingReceiveCheckPopup final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    ReceiveButton;                                     // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    CancelButton;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTrainingOptionWidgetBase*            TrainingRewardWidget;                              // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RewardName;                                        // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UDCTrainingReceiveCheckPopupData*       ReceiveCheckPopupData;                             // 0x04C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelButtonClicked();
	void OnReceiveButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCTrainingReceiveCheckPopup">();
	}
	static class UDCTrainingReceiveCheckPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCTrainingReceiveCheckPopup>();
	}
};
static_assert(alignof(UDCTrainingReceiveCheckPopup) == 0x000008, "Wrong alignment on UDCTrainingReceiveCheckPopup");
static_assert(sizeof(UDCTrainingReceiveCheckPopup) == 0x0004C8, "Wrong size on UDCTrainingReceiveCheckPopup");
static_assert(offsetof(UDCTrainingReceiveCheckPopup, ReceiveButton) == 0x000490, "Member 'UDCTrainingReceiveCheckPopup::ReceiveButton' has a wrong offset!");
static_assert(offsetof(UDCTrainingReceiveCheckPopup, CancelButton) == 0x000498, "Member 'UDCTrainingReceiveCheckPopup::CancelButton' has a wrong offset!");
static_assert(offsetof(UDCTrainingReceiveCheckPopup, TrainingRewardWidget) == 0x0004A0, "Member 'UDCTrainingReceiveCheckPopup::TrainingRewardWidget' has a wrong offset!");
static_assert(offsetof(UDCTrainingReceiveCheckPopup, RewardName) == 0x0004A8, "Member 'UDCTrainingReceiveCheckPopup::RewardName' has a wrong offset!");
static_assert(offsetof(UDCTrainingReceiveCheckPopup, ReceiveCheckPopupData) == 0x0004C0, "Member 'UDCTrainingReceiveCheckPopup::ReceiveCheckPopupData' has a wrong offset!");

// Class DungeonCrawler.DCUpdateRateOptimizeManagerComponent
// 0x0080 (0x0120 - 0x00A0)
class UDCUpdateRateOptimizeManagerComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_27E4[0x80];                                    // 0x00A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFreezeIdle(bool bInFreezeIdle);
	void SetNeverOptimize(bool bInNeverOptimize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCUpdateRateOptimizeManagerComponent">();
	}
	static class UDCUpdateRateOptimizeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCUpdateRateOptimizeManagerComponent>();
	}
};
static_assert(alignof(UDCUpdateRateOptimizeManagerComponent) == 0x000008, "Wrong alignment on UDCUpdateRateOptimizeManagerComponent");
static_assert(sizeof(UDCUpdateRateOptimizeManagerComponent) == 0x000120, "Wrong size on UDCUpdateRateOptimizeManagerComponent");

// Class DungeonCrawler.DCVoipComponent
// 0x01A0 (0x0240 - 0x00A0)
class UDCVoipComponent : public UDCActorComponent
{
public:
	uint8                                         Pad_27E5[0x10];                                    // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DummyVoipReceiveActorClass;                        // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVoipAkComponent*                       SendVoipAkComponent;                               // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27E6[0x180];                                   // 0x00C0(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitVoip(class UVoipAkComponent* InSendVoipAkComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCVoipComponent">();
	}
	static class UDCVoipComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCVoipComponent>();
	}
};
static_assert(alignof(UDCVoipComponent) == 0x000008, "Wrong alignment on UDCVoipComponent");
static_assert(sizeof(UDCVoipComponent) == 0x000240, "Wrong size on UDCVoipComponent");
static_assert(offsetof(UDCVoipComponent, DummyVoipReceiveActorClass) == 0x0000B0, "Member 'UDCVoipComponent::DummyVoipReceiveActorClass' has a wrong offset!");
static_assert(offsetof(UDCVoipComponent, SendVoipAkComponent) == 0x0000B8, "Member 'UDCVoipComponent::SendVoipAkComponent' has a wrong offset!");

// Class DungeonCrawler.DCVoipInterface
// 0x0000 (0x0028 - 0x0028)
class IDCVoipInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCVoipInterface">();
	}
	static class IDCVoipInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCVoipInterface>();
	}
};
static_assert(alignof(IDCVoipInterface) == 0x000008, "Wrong alignment on IDCVoipInterface");
static_assert(sizeof(IDCVoipInterface) == 0x000028, "Wrong size on IDCVoipInterface");

// Class DungeonCrawler.DCWaitingGameState
// 0x0018 (0x07C8 - 0x07B0)
class ADCWaitingGameState final : public ADCGameStateBase
{
public:
	TArray<struct FGameAnnounceData>              AnnounceInfos;                                     // 0x07B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         StartTime;                                         // 0x07C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27E7[0x4];                                     // 0x07C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWaitingGameState">();
	}
	static class ADCWaitingGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADCWaitingGameState>();
	}
};
static_assert(alignof(ADCWaitingGameState) == 0x000008, "Wrong alignment on ADCWaitingGameState");
static_assert(sizeof(ADCWaitingGameState) == 0x0007C8, "Wrong size on ADCWaitingGameState");
static_assert(offsetof(ADCWaitingGameState, AnnounceInfos) == 0x0007B0, "Member 'ADCWaitingGameState::AnnounceInfos' has a wrong offset!");
static_assert(offsetof(ADCWaitingGameState, StartTime) == 0x0007C0, "Member 'ADCWaitingGameState::StartTime' has a wrong offset!");

// Class DungeonCrawler.DCWhisperChatInterface
// 0x0000 (0x0028 - 0x0028)
class IDCWhisperChatInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWhisperChatInterface">();
	}
	static class IDCWhisperChatInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDCWhisperChatInterface>();
	}
};
static_assert(alignof(IDCWhisperChatInterface) == 0x000008, "Wrong alignment on IDCWhisperChatInterface");
static_assert(sizeof(IDCWhisperChatInterface) == 0x000028, "Wrong size on IDCWhisperChatInterface");

// Class DungeonCrawler.DCWidgetBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDCWidgetBlueprintLibrary final : public UWidgetBlueprintLibrary
{
public:
	static void BroadcastCommonOneButtonSPopup(class APlayerController* InPlayer, const class FText& OutputMessage, bool bInIsBackHandler);
	static void BroadcastSystemMessageNotify(class APlayerController* InPlayer, const class FText& OutputMessage, float Duration);
	static struct FDateTime ConvertLocalTimeToUtc(const struct FDateTime& LocalTime);
	static class FText FormatQuestRichText(EDCQuestRichTextFormatType Type, const class FText& InText);
	static int32 GetArenaNumMaxRounds();
	static float GetForceExitRemainSeconds(const class UObject* WorldContextObject);
	static struct FTimespan GetMatchElapsedTime(const class UObject* WorldContextObject);
	static EVoipStatus GetVoipStatus(const struct FVoipUserData& InVoipUserData);
	static bool IsArenaEnabled(const class UObject* WorldContextObject);
	static bool IsArenaFirstRound(const class UObject* WorldContextObject);
	static bool IsCurrentPlayerWaitingNextFloor(const class UObject* WorldContextObject);
	static bool IsDeathCamAvailable(const class UObject* WorldContextObject);
	static bool IsDeathCamOn(const class UObject* WorldContextObject);
	static bool IsFreeSpectatingEnabled(const class UObject* WorldContextObject);
	static bool IsHighRoller(const class UObject* WorldContextObject);
	static bool IsUsingArena(const class UObject* WorldContextObject);
	static class UPopupDataSWidget* MakePopupDataSWidget(EPopupButtonType PopupButtonType, const class FText& DescMessage);
	static struct FMsgWidgetPopupMessageRequest MakePopupMessageReqeust(TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass, class UPopupDataBase* PopupData, bool bInIsBackHandler);
	static void PopupMessageSWidgetNotify(class APlayerController* InPlayer, TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass, const class FText& DescMessage, EPopupButtonType ButtonType, bool bInIsBackHandler);
	static void SetPlayerCursorCenter(const class UObject* WorldContextObject);
	static struct FDCAccountId StringToAccountId(const class FString& InAccountIdStr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCWidgetBlueprintLibrary">();
	}
	static class UDCWidgetBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCWidgetBlueprintLibrary>();
	}
};
static_assert(alignof(UDCWidgetBlueprintLibrary) == 0x000008, "Wrong alignment on UDCWidgetBlueprintLibrary");
static_assert(sizeof(UDCWidgetBlueprintLibrary) == 0x000028, "Wrong size on UDCWidgetBlueprintLibrary");

// Class DungeonCrawler.DeathSwarmBase
// 0x0300 (0x06E0 - 0x03E0)
class alignas(0x10) ADeathSwarmBase : public APropsActorBase
{
public:
	uint8                                         Pad_27F8[0x40];                                    // 0x03E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      AuraCapsule;                                       // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      AntiAuraCapsule;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          LevelBoundBox;                                     // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCFloorRuleDeathSwarmDataAsset*        FloorRuleDeathSwarmData;                           // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27F9[0x50];                                    // 0x0440(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameFloorRuleData                     GameFloorRuleData;                                 // 0x0490(0x0040)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameDeathSwarmData                    GameDeathSwarmData;                                // 0x04D0(0x0080)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27FA[0x190];                                   // 0x0550(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_GameDeathSwarmData(const struct FGameDeathSwarmData& InOldGameDeathSwarmData);
	void OnRep_GameFloorRuleData(const struct FGameFloorRuleData& InOldGameFloorRuleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathSwarmBase">();
	}
	static class ADeathSwarmBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathSwarmBase>();
	}
};
static_assert(alignof(ADeathSwarmBase) == 0x000010, "Wrong alignment on ADeathSwarmBase");
static_assert(sizeof(ADeathSwarmBase) == 0x0006E0, "Wrong size on ADeathSwarmBase");
static_assert(offsetof(ADeathSwarmBase, AuraCapsule) == 0x000420, "Member 'ADeathSwarmBase::AuraCapsule' has a wrong offset!");
static_assert(offsetof(ADeathSwarmBase, AntiAuraCapsule) == 0x000428, "Member 'ADeathSwarmBase::AntiAuraCapsule' has a wrong offset!");
static_assert(offsetof(ADeathSwarmBase, LevelBoundBox) == 0x000430, "Member 'ADeathSwarmBase::LevelBoundBox' has a wrong offset!");
static_assert(offsetof(ADeathSwarmBase, FloorRuleDeathSwarmData) == 0x000438, "Member 'ADeathSwarmBase::FloorRuleDeathSwarmData' has a wrong offset!");
static_assert(offsetof(ADeathSwarmBase, GameFloorRuleData) == 0x000490, "Member 'ADeathSwarmBase::GameFloorRuleData' has a wrong offset!");
static_assert(offsetof(ADeathSwarmBase, GameDeathSwarmData) == 0x0004D0, "Member 'ADeathSwarmBase::GameDeathSwarmData' has a wrong offset!");

// Class DungeonCrawler.DeathSwarmInterface
// 0x0000 (0x0028 - 0x0028)
class IDeathSwarmInterface final : public IInterface
{
public:
	void BindDeathSwarmDataDelegate(TDelegate<void(struct FGameDeathSwarmData& InDeathSwarmData)> InBindDelegate);
	void UnbindDeathSwarmDataDelegate(class UObject* InBoundObject);

	struct FGameDeathSwarmData GetDeathSwarmData() const;
	void LogHandleDeathSwarmData(const class UObject* InHandler, const struct FGameDeathSwarmData& InDeathSwarmData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathSwarmInterface">();
	}
	static class IDeathSwarmInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDeathSwarmInterface>();
	}
};
static_assert(alignof(IDeathSwarmInterface) == 0x000008, "Wrong alignment on IDeathSwarmInterface");
static_assert(sizeof(IDeathSwarmInterface) == 0x000028, "Wrong size on IDeathSwarmInterface");

// Class DungeonCrawler.DescDataParam
// 0x0000 (0x0028 - 0x0028)
class UDescDataParam : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DescDataParam">();
	}
	static class UDescDataParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDescDataParam>();
	}
};
static_assert(alignof(UDescDataParam) == 0x000008, "Wrong alignment on UDescDataParam");
static_assert(sizeof(UDescDataParam) == 0x000028, "Wrong size on UDescDataParam");

// Class DungeonCrawler.DescDataMultiEffectParams
// 0x0090 (0x00F0 - 0x0060)
class UDescDataMultiEffectParams final : public UDescData
{
public:
	TArray<class UDCGameplayEffectDataAsset*>     DCGameplayEffectDataAssetArray;                    // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCConstantDataAsset*>           ConstantDataAssetArray;                            // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCMovementModifierDataAsset*>   MovementModifierDataAssetArray;                    // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCGEModifierDataAsset*>         GEModifierDataAssetArray;                          // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCPerkDataAsset*>               PerkDataAssetArray;                                // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCSkillDataAsset*>              SkillDataAssetArray;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCSpellDataAsset*>              SpellDataAssetArray;                               // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCMusicDataAsset*>              MusicDataAssetArray;                               // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDCItemConsumeDataAsset*>        ItemConsumeDataAssetArray;                         // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DescDataMultiEffectParams">();
	}
	static class UDescDataMultiEffectParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDescDataMultiEffectParams>();
	}
};
static_assert(alignof(UDescDataMultiEffectParams) == 0x000008, "Wrong alignment on UDescDataMultiEffectParams");
static_assert(sizeof(UDescDataMultiEffectParams) == 0x0000F0, "Wrong size on UDescDataMultiEffectParams");
static_assert(offsetof(UDescDataMultiEffectParams, DCGameplayEffectDataAssetArray) == 0x000060, "Member 'UDescDataMultiEffectParams::DCGameplayEffectDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, ConstantDataAssetArray) == 0x000070, "Member 'UDescDataMultiEffectParams::ConstantDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, MovementModifierDataAssetArray) == 0x000080, "Member 'UDescDataMultiEffectParams::MovementModifierDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, GEModifierDataAssetArray) == 0x000090, "Member 'UDescDataMultiEffectParams::GEModifierDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, PerkDataAssetArray) == 0x0000A0, "Member 'UDescDataMultiEffectParams::PerkDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, SkillDataAssetArray) == 0x0000B0, "Member 'UDescDataMultiEffectParams::SkillDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, SpellDataAssetArray) == 0x0000C0, "Member 'UDescDataMultiEffectParams::SpellDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, MusicDataAssetArray) == 0x0000D0, "Member 'UDescDataMultiEffectParams::MusicDataAssetArray' has a wrong offset!");
static_assert(offsetof(UDescDataMultiEffectParams, ItemConsumeDataAssetArray) == 0x0000E0, "Member 'UDescDataMultiEffectParams::ItemConsumeDataAssetArray' has a wrong offset!");

// Class DungeonCrawler.DescDataParamAbilityWeapon
// 0x0030 (0x0058 - 0x0028)
class UDescDataParamAbilityWeapon final : public UDescDataParam
{
public:
	uint8                                         Pad_27FB[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCGameplayAbilityData                 GameplayAbilityData;                               // 0x0030(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DescDataParamAbilityWeapon">();
	}
	static class UDescDataParamAbilityWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDescDataParamAbilityWeapon>();
	}
};
static_assert(alignof(UDescDataParamAbilityWeapon) == 0x000008, "Wrong alignment on UDescDataParamAbilityWeapon");
static_assert(sizeof(UDescDataParamAbilityWeapon) == 0x000058, "Wrong size on UDescDataParamAbilityWeapon");
static_assert(offsetof(UDescDataParamAbilityWeapon, GameplayAbilityData) == 0x000030, "Member 'UDescDataParamAbilityWeapon::GameplayAbilityData' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetAnnounce
// 0x0018 (0x0060 - 0x0048)
class UDesignDataAssetAnnounce final : public UDCDataAssetBase
{
public:
	struct FDesignDataAnnounce                    Item;                                              // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetAnnounce">();
	}
	static class UDesignDataAssetAnnounce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetAnnounce>();
	}
};
static_assert(alignof(UDesignDataAssetAnnounce) == 0x000008, "Wrong alignment on UDesignDataAssetAnnounce");
static_assert(sizeof(UDesignDataAssetAnnounce) == 0x000060, "Wrong size on UDesignDataAssetAnnounce");
static_assert(offsetof(UDesignDataAssetAnnounce, Item) == 0x000048, "Member 'UDesignDataAssetAnnounce::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetGameplayAbility
// 0x0068 (0x00B0 - 0x0048)
class UDesignDataAssetGameplayAbility final : public UDCDataAssetBase
{
public:
	struct FDesignDataGameplayAbility             Item;                                              // 0x0048(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetGameplayAbility">();
	}
	static class UDesignDataAssetGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetGameplayAbility>();
	}
};
static_assert(alignof(UDesignDataAssetGameplayAbility) == 0x000008, "Wrong alignment on UDesignDataAssetGameplayAbility");
static_assert(sizeof(UDesignDataAssetGameplayAbility) == 0x0000B0, "Wrong size on UDesignDataAssetGameplayAbility");
static_assert(offsetof(UDesignDataAssetGameplayAbility, Item) == 0x000048, "Member 'UDesignDataAssetGameplayAbility::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetGameplayEffect
// 0x02A0 (0x02E8 - 0x0048)
class UDesignDataAssetGameplayEffect final : public UDCDataAssetBase
{
public:
	struct FDesignDataGameplayEffect              Item;                                              // 0x0048(0x02A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetGameplayEffect">();
	}
	static class UDesignDataAssetGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetGameplayEffect>();
	}
};
static_assert(alignof(UDesignDataAssetGameplayEffect) == 0x000008, "Wrong alignment on UDesignDataAssetGameplayEffect");
static_assert(sizeof(UDesignDataAssetGameplayEffect) == 0x0002E8, "Wrong size on UDesignDataAssetGameplayEffect");
static_assert(offsetof(UDesignDataAssetGameplayEffect, Item) == 0x000048, "Member 'UDesignDataAssetGameplayEffect::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetPlayerCharacter
// 0x0128 (0x0170 - 0x0048)
class UDesignDataAssetPlayerCharacter final : public UDCDataAssetBase
{
public:
	struct FDesignDataPlayerCharacter             Item;                                              // 0x0048(0x0128)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetPlayerCharacter">();
	}
	static class UDesignDataAssetPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetPlayerCharacter>();
	}
};
static_assert(alignof(UDesignDataAssetPlayerCharacter) == 0x000008, "Wrong alignment on UDesignDataAssetPlayerCharacter");
static_assert(sizeof(UDesignDataAssetPlayerCharacter) == 0x000170, "Wrong size on UDesignDataAssetPlayerCharacter");
static_assert(offsetof(UDesignDataAssetPlayerCharacter, Item) == 0x000048, "Member 'UDesignDataAssetPlayerCharacter::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetMonster
// 0x00C0 (0x0108 - 0x0048)
class UDesignDataAssetMonster final : public UDCDataAssetBase
{
public:
	struct FDesignDataMonster                     Item;                                              // 0x0048(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetMonster">();
	}
	static class UDesignDataAssetMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetMonster>();
	}
};
static_assert(alignof(UDesignDataAssetMonster) == 0x000008, "Wrong alignment on UDesignDataAssetMonster");
static_assert(sizeof(UDesignDataAssetMonster) == 0x000108, "Wrong size on UDesignDataAssetMonster");
static_assert(offsetof(UDesignDataAssetMonster, Item) == 0x000048, "Member 'UDesignDataAssetMonster::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetProps
// 0x00B0 (0x00F8 - 0x0048)
class UDesignDataAssetProps final : public UDCDataAssetBase
{
public:
	struct FDesignDataProps                       Item;                                              // 0x0048(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetProps">();
	}
	static class UDesignDataAssetProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetProps>();
	}
};
static_assert(alignof(UDesignDataAssetProps) == 0x000008, "Wrong alignment on UDesignDataAssetProps");
static_assert(sizeof(UDesignDataAssetProps) == 0x0000F8, "Wrong size on UDesignDataAssetProps");
static_assert(offsetof(UDesignDataAssetProps, Item) == 0x000048, "Member 'UDesignDataAssetProps::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetPropsSkillCheck
// 0x0030 (0x0078 - 0x0048)
class UDesignDataAssetPropsSkillCheck final : public UDCDataAssetBase
{
public:
	struct FDesignDataPropsSkillCheck             Item;                                              // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetPropsSkillCheck">();
	}
	static class UDesignDataAssetPropsSkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetPropsSkillCheck>();
	}
};
static_assert(alignof(UDesignDataAssetPropsSkillCheck) == 0x000008, "Wrong alignment on UDesignDataAssetPropsSkillCheck");
static_assert(sizeof(UDesignDataAssetPropsSkillCheck) == 0x000078, "Wrong size on UDesignDataAssetPropsSkillCheck");
static_assert(offsetof(UDesignDataAssetPropsSkillCheck, Item) == 0x000048, "Member 'UDesignDataAssetPropsSkillCheck::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetItem
// 0x0198 (0x01E0 - 0x0048)
class UDesignDataAssetItem final : public UDCDataAssetBase
{
public:
	struct FDesignDataItem                        Item;                                              // 0x0048(0x0198)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItem">();
	}
	static class UDesignDataAssetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItem>();
	}
};
static_assert(alignof(UDesignDataAssetItem) == 0x000008, "Wrong alignment on UDesignDataAssetItem");
static_assert(sizeof(UDesignDataAssetItem) == 0x0001E0, "Wrong size on UDesignDataAssetItem");
static_assert(offsetof(UDesignDataAssetItem, Item) == 0x000048, "Member 'UDesignDataAssetItem::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetItemRequirement
// 0x0058 (0x00A0 - 0x0048)
class UDesignDataAssetItemRequirement final : public UDCDataAssetBase
{
public:
	struct FDesignDataItemRequirement             Item;                                              // 0x0048(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItemRequirement">();
	}
	static class UDesignDataAssetItemRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItemRequirement>();
	}
};
static_assert(alignof(UDesignDataAssetItemRequirement) == 0x000008, "Wrong alignment on UDesignDataAssetItemRequirement");
static_assert(sizeof(UDesignDataAssetItemRequirement) == 0x0000A0, "Wrong size on UDesignDataAssetItemRequirement");
static_assert(offsetof(UDesignDataAssetItemRequirement, Item) == 0x000048, "Member 'UDesignDataAssetItemRequirement::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetItemBundleInfo
// 0x0010 (0x0058 - 0x0048)
class UDesignDataAssetItemBundleInfo final : public UDCDataAssetBase
{
public:
	struct FDesignDataItemBundleInfo              Item;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	struct FPrimaryAssetId GetBundleArtAssetByCount(int32 ItemCount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetItemBundleInfo">();
	}
	static class UDesignDataAssetItemBundleInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetItemBundleInfo>();
	}
};
static_assert(alignof(UDesignDataAssetItemBundleInfo) == 0x000008, "Wrong alignment on UDesignDataAssetItemBundleInfo");
static_assert(sizeof(UDesignDataAssetItemBundleInfo) == 0x000058, "Wrong size on UDesignDataAssetItemBundleInfo");
static_assert(offsetof(UDesignDataAssetItemBundleInfo, Item) == 0x000048, "Member 'UDesignDataAssetItemBundleInfo::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetMeleeAttack
// 0x0058 (0x00A0 - 0x0048)
class UDesignDataAssetMeleeAttack final : public UDCDataAssetBase
{
public:
	struct FDesignDataMeleeAttack                 Item;                                              // 0x0048(0x0054)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FC[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetMeleeAttack">();
	}
	static class UDesignDataAssetMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetMeleeAttack>();
	}
};
static_assert(alignof(UDesignDataAssetMeleeAttack) == 0x000008, "Wrong alignment on UDesignDataAssetMeleeAttack");
static_assert(sizeof(UDesignDataAssetMeleeAttack) == 0x0000A0, "Wrong size on UDesignDataAssetMeleeAttack");
static_assert(offsetof(UDesignDataAssetMeleeAttack, Item) == 0x000048, "Member 'UDesignDataAssetMeleeAttack::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetMusic
// 0x00C8 (0x0110 - 0x0048)
class UDesignDataAssetMusic final : public UDCDataAssetBase
{
public:
	struct FDesignDataMusic                       Item;                                              // 0x0048(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetMusic">();
	}
	static class UDesignDataAssetMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetMusic>();
	}
};
static_assert(alignof(UDesignDataAssetMusic) == 0x000008, "Wrong alignment on UDesignDataAssetMusic");
static_assert(sizeof(UDesignDataAssetMusic) == 0x000110, "Wrong size on UDesignDataAssetMusic");
static_assert(offsetof(UDesignDataAssetMusic, Item) == 0x000048, "Member 'UDesignDataAssetMusic::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetIdTagGroup
// 0x0010 (0x0058 - 0x0048)
class UDesignDataAssetIdTagGroup final : public UDCDataAssetBase
{
public:
	struct FDesignDataIdTagGroup                  Item;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetIdTagGroup">();
	}
	static class UDesignDataAssetIdTagGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetIdTagGroup>();
	}
};
static_assert(alignof(UDesignDataAssetIdTagGroup) == 0x000008, "Wrong alignment on UDesignDataAssetIdTagGroup");
static_assert(sizeof(UDesignDataAssetIdTagGroup) == 0x000058, "Wrong size on UDesignDataAssetIdTagGroup");
static_assert(offsetof(UDesignDataAssetIdTagGroup, Item) == 0x000048, "Member 'UDesignDataAssetIdTagGroup::Item' has a wrong offset!");

// Class DungeonCrawler.DesignDataAssetGEModifier
// 0x0028 (0x0070 - 0x0048)
class UDesignDataAssetGEModifier final : public UDCDataAssetBase
{
public:
	struct FDesignDataGEModifier                  Item;                                              // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignDataAssetGEModifier">();
	}
	static class UDesignDataAssetGEModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignDataAssetGEModifier>();
	}
};
static_assert(alignof(UDesignDataAssetGEModifier) == 0x000008, "Wrong alignment on UDesignDataAssetGEModifier");
static_assert(sizeof(UDesignDataAssetGEModifier) == 0x000070, "Wrong size on UDesignDataAssetGEModifier");
static_assert(offsetof(UDesignDataAssetGEModifier, Item) == 0x000048, "Member 'UDesignDataAssetGEModifier::Item' has a wrong offset!");

// Class DungeonCrawler.DungeonSelectSlotWidget
// 0x0050 (0x03A8 - 0x0358)
class UDungeonSelectSlotWidget final : public UDCWidgetBase
{
public:
	EGameType                                     ClassicNormalGameType;                             // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FD[0x3];                                     // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           NormalDungeonIdTag;                                // 0x035C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameType                                     ClassicHighRollerGameType;                         // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FE[0x3];                                     // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           HighRollerDungeonIdTag;                            // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDungeonSelectSlotButtonWidget*         NormalButton;                                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDungeonSelectSlotButtonWidget*         HighRollerButton;                                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DungeonSelectSlotDelegate;                         // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         PartyMemberCount;                                  // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchMode                                    SelectedMatchMode;                                 // 0x0394(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchMode                                    MatchMode;                                         // 0x0395(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameType                                     GameType;                                          // 0x0396(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameType                                     DungeonRotationNormalGameType;                     // 0x0397(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameType                                     DungeonRotationHighRollerGameType;                 // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FF[0x3];                                     // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SoloDuoTrioIdx;                                    // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEnter;                                         // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2800[0x7];                                     // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce);
	void OnHighRollerButtonClicked();
	void OnNormalButtonClicked();
	void SetSelectedMatchMode(EMatchMode InMatchMode);
	void UpdateDungeonSelectSlot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSelectSlotWidget">();
	}
	static class UDungeonSelectSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSelectSlotWidget>();
	}
};
static_assert(alignof(UDungeonSelectSlotWidget) == 0x000008, "Wrong alignment on UDungeonSelectSlotWidget");
static_assert(sizeof(UDungeonSelectSlotWidget) == 0x0003A8, "Wrong size on UDungeonSelectSlotWidget");
static_assert(offsetof(UDungeonSelectSlotWidget, ClassicNormalGameType) == 0x000358, "Member 'UDungeonSelectSlotWidget::ClassicNormalGameType' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, NormalDungeonIdTag) == 0x00035C, "Member 'UDungeonSelectSlotWidget::NormalDungeonIdTag' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, ClassicHighRollerGameType) == 0x000364, "Member 'UDungeonSelectSlotWidget::ClassicHighRollerGameType' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, HighRollerDungeonIdTag) == 0x000368, "Member 'UDungeonSelectSlotWidget::HighRollerDungeonIdTag' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, NormalButton) == 0x000370, "Member 'UDungeonSelectSlotWidget::NormalButton' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, HighRollerButton) == 0x000378, "Member 'UDungeonSelectSlotWidget::HighRollerButton' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, DungeonSelectSlotDelegate) == 0x000380, "Member 'UDungeonSelectSlotWidget::DungeonSelectSlotDelegate' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, PartyMemberCount) == 0x000390, "Member 'UDungeonSelectSlotWidget::PartyMemberCount' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, SelectedMatchMode) == 0x000394, "Member 'UDungeonSelectSlotWidget::SelectedMatchMode' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, MatchMode) == 0x000395, "Member 'UDungeonSelectSlotWidget::MatchMode' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, GameType) == 0x000396, "Member 'UDungeonSelectSlotWidget::GameType' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, DungeonRotationNormalGameType) == 0x000397, "Member 'UDungeonSelectSlotWidget::DungeonRotationNormalGameType' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, DungeonRotationHighRollerGameType) == 0x000398, "Member 'UDungeonSelectSlotWidget::DungeonRotationHighRollerGameType' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, SoloDuoTrioIdx) == 0x00039C, "Member 'UDungeonSelectSlotWidget::SoloDuoTrioIdx' has a wrong offset!");
static_assert(offsetof(UDungeonSelectSlotWidget, bCanEnter) == 0x0003A0, "Member 'UDungeonSelectSlotWidget::bCanEnter' has a wrong offset!");

// Class DungeonCrawler.EquipmentSlotWidget
// 0x01C0 (0x0518 - 0x0358)
class UEquipmentSlotWidget : public UDCWidgetBase
{
public:
	EEquipmentQuickSlotType                       EquipmentQuickSlotType;                            // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2802[0x3];                                     // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ItemSlotType;                                      // 0x035C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCEquipmentSlotIndex                         EquipmentSlot;                                     // 0x0364(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2803[0x3];                                     // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ValidSlotColor;                                    // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InvalidSlotColor;                                  // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              ItemWidgetScaleBox;                                // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameItemWearingBarWidget*              ItemWearingBarWidget;                              // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemCountTextBlock;                                // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotColorImage;                                    // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2804[0x8];                                     // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemWidget*                            ItemWidget;                                        // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UItemWidget>                ItemWidgetClass;                                   // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemData                              ItemData;                                          // 0x03C0(0x0100)(Protected, NativeAccessSpecifierProtected)
	bool                                          bSetPreview;                                       // 0x04C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivated;                                        // 0x04C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2805[0x6];                                     // 0x04C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCItemId, bool>                  CanEquipMap;                                       // 0x04C8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void CheckAndSetActiveHoverImage();
	void OnFinishedItemDataSet(const struct FItemData& InItemData, const struct FGameplayTag& HandType, const struct FGameplayTag& SlotType, const struct FItemInventorySize& InventorySize);
	void OnLeaveItemWidget();
	void OnOverlapItemWidget(const struct FPrimaryAssetId& ItemId, bool bValidSlot, bool bCanEquip);
	void OnRemoveItem(const struct FItemData& InItemData);
	void RemovePreviewItemWidget(bool bSetItem);
	void SetActiveHoverImage(bool bActivate);
	void SetPreviewItemWidget(const struct FPrimaryAssetId& ItemId, float Duration);

	EDCEquipmentSlotIndex GetEquipmentSlotIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSlotWidget">();
	}
	static class UEquipmentSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSlotWidget>();
	}
};
static_assert(alignof(UEquipmentSlotWidget) == 0x000008, "Wrong alignment on UEquipmentSlotWidget");
static_assert(sizeof(UEquipmentSlotWidget) == 0x000518, "Wrong size on UEquipmentSlotWidget");
static_assert(offsetof(UEquipmentSlotWidget, EquipmentQuickSlotType) == 0x000358, "Member 'UEquipmentSlotWidget::EquipmentQuickSlotType' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemSlotType) == 0x00035C, "Member 'UEquipmentSlotWidget::ItemSlotType' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, EquipmentSlot) == 0x000364, "Member 'UEquipmentSlotWidget::EquipmentSlot' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ValidSlotColor) == 0x000368, "Member 'UEquipmentSlotWidget::ValidSlotColor' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, InvalidSlotColor) == 0x000378, "Member 'UEquipmentSlotWidget::InvalidSlotColor' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemWidgetScaleBox) == 0x000388, "Member 'UEquipmentSlotWidget::ItemWidgetScaleBox' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemWearingBarWidget) == 0x000390, "Member 'UEquipmentSlotWidget::ItemWearingBarWidget' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemCountTextBlock) == 0x000398, "Member 'UEquipmentSlotWidget::ItemCountTextBlock' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, SlotColorImage) == 0x0003A0, "Member 'UEquipmentSlotWidget::SlotColorImage' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemWidget) == 0x0003B0, "Member 'UEquipmentSlotWidget::ItemWidget' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemWidgetClass) == 0x0003B8, "Member 'UEquipmentSlotWidget::ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, ItemData) == 0x0003C0, "Member 'UEquipmentSlotWidget::ItemData' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, bSetPreview) == 0x0004C0, "Member 'UEquipmentSlotWidget::bSetPreview' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, bActivated) == 0x0004C1, "Member 'UEquipmentSlotWidget::bActivated' has a wrong offset!");
static_assert(offsetof(UEquipmentSlotWidget, CanEquipMap) == 0x0004C8, "Member 'UEquipmentSlotWidget::CanEquipMap' has a wrong offset!");

// Class DungeonCrawler.EquipmentWeaponSlotSetWidget
// 0x0138 (0x0650 - 0x0518)
class UEquipmentWeaponSlotSetWidget final : public UEquipmentSlotWidget
{
public:
	class UScaleBox*                              SecondaryItemWidgetScaleBox;                       // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWidget*                            SecondaryItemWidget;                               // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PrimarySlot;                                       // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                SecondarySlot;                                     // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemData                              SecondaryItemData;                                 // 0x0538(0x0100)(Protected, NativeAccessSpecifierProtected)
	class UImage*                                 SecondarySlotColorImage;                           // 0x0638(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameItemWearingBarWidget*              SecondaryItemWearingBarWidget;                     // 0x0640(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCEquipmentSlotIndex                         SecondaryEquipmentSlotId;                          // 0x0648(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2807[0x7];                                     // 0x0649(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAndSetActiveHoverImageBySlot(class UWidget* SlotUnderPointerPosition);
	void SetActivePrimaryHoverImage(bool bActivate);
	void SetActiveSecondaryHoverImage(bool bActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentWeaponSlotSetWidget">();
	}
	static class UEquipmentWeaponSlotSetWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentWeaponSlotSetWidget>();
	}
};
static_assert(alignof(UEquipmentWeaponSlotSetWidget) == 0x000008, "Wrong alignment on UEquipmentWeaponSlotSetWidget");
static_assert(sizeof(UEquipmentWeaponSlotSetWidget) == 0x000650, "Wrong size on UEquipmentWeaponSlotSetWidget");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondaryItemWidgetScaleBox) == 0x000518, "Member 'UEquipmentWeaponSlotSetWidget::SecondaryItemWidgetScaleBox' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondaryItemWidget) == 0x000520, "Member 'UEquipmentWeaponSlotSetWidget::SecondaryItemWidget' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, PrimarySlot) == 0x000528, "Member 'UEquipmentWeaponSlotSetWidget::PrimarySlot' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondarySlot) == 0x000530, "Member 'UEquipmentWeaponSlotSetWidget::SecondarySlot' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondaryItemData) == 0x000538, "Member 'UEquipmentWeaponSlotSetWidget::SecondaryItemData' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondarySlotColorImage) == 0x000638, "Member 'UEquipmentWeaponSlotSetWidget::SecondarySlotColorImage' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondaryItemWearingBarWidget) == 0x000640, "Member 'UEquipmentWeaponSlotSetWidget::SecondaryItemWearingBarWidget' has a wrong offset!");
static_assert(offsetof(UEquipmentWeaponSlotSetWidget, SecondaryEquipmentSlotId) == 0x000648, "Member 'UEquipmentWeaponSlotSetWidget::SecondaryEquipmentSlotId' has a wrong offset!");

// Class DungeonCrawler.ExpandableInventoryComponent
// 0x0008 (0x0218 - 0x0210)
class UExpandableInventoryComponent final : public UInventoryComponent
{
public:
	bool                                          bExpandable;                                       // 0x0210(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2808[0x7];                                     // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetExpandable(bool bCanExpand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExpandableInventoryComponent">();
	}
	static class UExpandableInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExpandableInventoryComponent>();
	}
};
static_assert(alignof(UExpandableInventoryComponent) == 0x000008, "Wrong alignment on UExpandableInventoryComponent");
static_assert(sizeof(UExpandableInventoryComponent) == 0x000218, "Wrong size on UExpandableInventoryComponent");
static_assert(offsetof(UExpandableInventoryComponent, bExpandable) == 0x000210, "Member 'UExpandableInventoryComponent::bExpandable' has a wrong offset!");

// Class DungeonCrawler.FloorPortalBase
// 0x0038 (0x0418 - 0x03E0)
class AFloorPortalBase : public APropsActorBase
{
public:
	TSubclassOf<class AFloorPortalScrollBase>     DownFloorPortalScrollClass;                        // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFloorPortalScrollBase>     EscapeFloorPortalScrollClass;                      // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   FloorPortalScrollActivateAbilityTriggerTagArray;   // 0x03F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                FloorPortalScrollHolderArray;                      // 0x0400(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UDCSessionRuleComponent*                SessionRuleComponent;                              // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFloorRuleFired(const struct FGameFloorRuleData& InFloorRuleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPortalBase">();
	}
	static class AFloorPortalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFloorPortalBase>();
	}
};
static_assert(alignof(AFloorPortalBase) == 0x000008, "Wrong alignment on AFloorPortalBase");
static_assert(sizeof(AFloorPortalBase) == 0x000418, "Wrong size on AFloorPortalBase");
static_assert(offsetof(AFloorPortalBase, DownFloorPortalScrollClass) == 0x0003E0, "Member 'AFloorPortalBase::DownFloorPortalScrollClass' has a wrong offset!");
static_assert(offsetof(AFloorPortalBase, EscapeFloorPortalScrollClass) == 0x0003E8, "Member 'AFloorPortalBase::EscapeFloorPortalScrollClass' has a wrong offset!");
static_assert(offsetof(AFloorPortalBase, FloorPortalScrollActivateAbilityTriggerTagArray) == 0x0003F0, "Member 'AFloorPortalBase::FloorPortalScrollActivateAbilityTriggerTagArray' has a wrong offset!");
static_assert(offsetof(AFloorPortalBase, FloorPortalScrollHolderArray) == 0x000400, "Member 'AFloorPortalBase::FloorPortalScrollHolderArray' has a wrong offset!");
static_assert(offsetof(AFloorPortalBase, SessionRuleComponent) == 0x000410, "Member 'AFloorPortalBase::SessionRuleComponent' has a wrong offset!");

// Class DungeonCrawler.FriendSlotWidget
// 0x0048 (0x0438 - 0x03F0)
class UFriendSlotWidget : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_2809[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCFriendStatus                               Status;                                            // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCLocationStatus                             LocationStatus;                                    // 0x0421(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280A[0x2];                                     // 0x0422(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPartyMembers;                                   // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumPartyMembers;                                // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMine;                                             // 0x042C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x042D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280B[0xA];                                     // 0x042E(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSlotWidget">();
	}
	static class UFriendSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSlotWidget>();
	}
};
static_assert(alignof(UFriendSlotWidget) == 0x000008, "Wrong alignment on UFriendSlotWidget");
static_assert(sizeof(UFriendSlotWidget) == 0x000438, "Wrong size on UFriendSlotWidget");
static_assert(offsetof(UFriendSlotWidget, AccountId) == 0x000400, "Member 'UFriendSlotWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, CharacterId) == 0x000410, "Member 'UFriendSlotWidget::CharacterId' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, Status) == 0x000420, "Member 'UFriendSlotWidget::Status' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, LocationStatus) == 0x000421, "Member 'UFriendSlotWidget::LocationStatus' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, NumPartyMembers) == 0x000424, "Member 'UFriendSlotWidget::NumPartyMembers' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, MaxNumPartyMembers) == 0x000428, "Member 'UFriendSlotWidget::MaxNumPartyMembers' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, bMine) == 0x00042C, "Member 'UFriendSlotWidget::bMine' has a wrong offset!");
static_assert(offsetof(UFriendSlotWidget, bSelected) == 0x00042D, "Member 'UFriendSlotWidget::bSelected' has a wrong offset!");

// Class DungeonCrawler.GameActorStatusSlotItemData
// 0x0020 (0x0048 - 0x0028)
class UGameActorStatusSlotItemData final : public UObject
{
public:
	struct FActorStatusData                       ActorStatusData;                                   // 0x0028(0x0020)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameActorStatusSlotItemData">();
	}
	static class UGameActorStatusSlotItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameActorStatusSlotItemData>();
	}
};
static_assert(alignof(UGameActorStatusSlotItemData) == 0x000008, "Wrong alignment on UGameActorStatusSlotItemData");
static_assert(sizeof(UGameActorStatusSlotItemData) == 0x000048, "Wrong size on UGameActorStatusSlotItemData");
static_assert(offsetof(UGameActorStatusSlotItemData, ActorStatusData) == 0x000028, "Member 'UGameActorStatusSlotItemData::ActorStatusData' has a wrong offset!");

// Class DungeonCrawler.GameActorStatusWidget
// 0x0020 (0x0378 - 0x0358)
class UGameActorStatusWidget final : public UDCWidgetBase
{
public:
	class UTileView*                              ActorStatusTileView;                               // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAlive;                                          // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280C[0x17];                                    // 0x0361(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameActorStatusWidget">();
	}
	static class UGameActorStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameActorStatusWidget>();
	}
};
static_assert(alignof(UGameActorStatusWidget) == 0x000008, "Wrong alignment on UGameActorStatusWidget");
static_assert(sizeof(UGameActorStatusWidget) == 0x000378, "Wrong size on UGameActorStatusWidget");
static_assert(offsetof(UGameActorStatusWidget, ActorStatusTileView) == 0x000358, "Member 'UGameActorStatusWidget::ActorStatusTileView' has a wrong offset!");
static_assert(offsetof(UGameActorStatusWidget, bIsAlive) == 0x000360, "Member 'UGameActorStatusWidget::bIsAlive' has a wrong offset!");

// Class DungeonCrawler.GameAlivePlayerCountWidget
// 0x0010 (0x0368 - 0x0358)
class UGameAlivePlayerCountWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_280D[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLinkAll*                        AccountLinkAll;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAlivePlayerCount(int32 NewValue, int32 OldValue);
	void OnTotalPlayerCount(int32 NewValue, int32 OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAlivePlayerCountWidget">();
	}
	static class UGameAlivePlayerCountWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAlivePlayerCountWidget>();
	}
};
static_assert(alignof(UGameAlivePlayerCountWidget) == 0x000008, "Wrong alignment on UGameAlivePlayerCountWidget");
static_assert(sizeof(UGameAlivePlayerCountWidget) == 0x000368, "Wrong size on UGameAlivePlayerCountWidget");
static_assert(offsetof(UGameAlivePlayerCountWidget, AccountLinkAll) == 0x000360, "Member 'UGameAlivePlayerCountWidget::AccountLinkAll' has a wrong offset!");

// Class DungeonCrawler.GameCompassWidget
// 0x0010 (0x0368 - 0x0358)
class UGameCompassWidget final : public UDCWidgetBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  LinkedPawn;                                        // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameCompassWidget">();
	}
	static class UGameCompassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameCompassWidget>();
	}
};
static_assert(alignof(UGameCompassWidget) == 0x000008, "Wrong alignment on UGameCompassWidget");
static_assert(sizeof(UGameCompassWidget) == 0x000368, "Wrong size on UGameCompassWidget");
static_assert(offsetof(UGameCompassWidget, AccountLink) == 0x000358, "Member 'UGameCompassWidget::AccountLink' has a wrong offset!");
static_assert(offsetof(UGameCompassWidget, LinkedPawn) == 0x000360, "Member 'UGameCompassWidget::LinkedPawn' has a wrong offset!");

// Class DungeonCrawler.GameCrossHairWidget
// 0x0008 (0x0360 - 0x0358)
class UGameCrossHairWidget final : public UDCWidgetBase
{
public:
	bool                                          IsMeleeCrossHair;                                  // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280E[0x7];                                     // 0x0359(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateSpellCrossHair(bool IsActivate);
	void OnChangeCrossHairInfo(const struct FGameplayTag& WeaponTypeTag, float ChangeAngle, bool IsPinPoint, float RotateTime);
	void OnChangeToRangeCrossHairAndPullAction(const struct FGameplayTag& WeaponTypeTag, const struct FGameplayTag& ItemUtilityTag);
	void OnChangeWeaponCrossHair(const struct FGameplayTag& WeaponTypeTag, const struct FGameplayTag& ItemUtilityTag, const struct FGameplayTag& ItemSlotTypeTags, bool IsAttackEnable);
	void OnCrossHairChangeEvent(const TArray<class AItemActor*>& EquipItemActors);
	void OnCrossHairVisability(bool IsVisablile, bool SetDefault);
	void OnInitCrossHair();
	void OnPlayPullingCrossHair(float Rate);
	void OnPlayShootCrossHair(float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameCrossHairWidget">();
	}
	static class UGameCrossHairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameCrossHairWidget>();
	}
};
static_assert(alignof(UGameCrossHairWidget) == 0x000008, "Wrong alignment on UGameCrossHairWidget");
static_assert(sizeof(UGameCrossHairWidget) == 0x000360, "Wrong size on UGameCrossHairWidget");
static_assert(offsetof(UGameCrossHairWidget, IsMeleeCrossHair) == 0x000358, "Member 'UGameCrossHairWidget::IsMeleeCrossHair' has a wrong offset!");

// Class DungeonCrawler.GameEmoteSelectGroupWidget
// 0x0070 (0x0518 - 0x04A8)
class UGameEmoteSelectGroupWidget final : public UGameGroupWidgetBase
{
public:
	int32                                         SelectedEmoteIndex;                                // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2811[0x14];                                    // 0x04AC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameEmoteSlotWidget*                   EmoteSlot_1;                                       // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_2;                                       // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_3;                                       // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_4;                                       // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_5;                                       // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_6;                                       // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_7;                                       // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameEmoteSlotWidget*                   EmoteSlot_8;                                       // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGameEmoteSlotWidget*>           EmoteSlots;                                        // 0x0508(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnCurrentEmoteSlotChanged(const class FText& InName);
	void OnEmoteSelectClose();
	void OnEmoteSelectPopup();
	void OnSelectedEmoteIndexChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEmoteSelectGroupWidget">();
	}
	static class UGameEmoteSelectGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEmoteSelectGroupWidget>();
	}
};
static_assert(alignof(UGameEmoteSelectGroupWidget) == 0x000008, "Wrong alignment on UGameEmoteSelectGroupWidget");
static_assert(sizeof(UGameEmoteSelectGroupWidget) == 0x000518, "Wrong size on UGameEmoteSelectGroupWidget");
static_assert(offsetof(UGameEmoteSelectGroupWidget, SelectedEmoteIndex) == 0x0004A8, "Member 'UGameEmoteSelectGroupWidget::SelectedEmoteIndex' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, PlayerCharacter) == 0x0004C0, "Member 'UGameEmoteSelectGroupWidget::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_1) == 0x0004C8, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_1' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_2) == 0x0004D0, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_2' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_3) == 0x0004D8, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_3' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_4) == 0x0004E0, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_4' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_5) == 0x0004E8, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_5' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_6) == 0x0004F0, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_6' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_7) == 0x0004F8, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_7' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlot_8) == 0x000500, "Member 'UGameEmoteSelectGroupWidget::EmoteSlot_8' has a wrong offset!");
static_assert(offsetof(UGameEmoteSelectGroupWidget, EmoteSlots) == 0x000508, "Member 'UGameEmoteSelectGroupWidget::EmoteSlots' has a wrong offset!");

// Class DungeonCrawler.GameHeadupWidget
// 0x0008 (0x0360 - 0x0358)
class UGameHeadupWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2812[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHeadupWidget">();
	}
	static class UGameHeadupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHeadupWidget>();
	}
};
static_assert(alignof(UGameHeadupWidget) == 0x000008, "Wrong alignment on UGameHeadupWidget");
static_assert(sizeof(UGameHeadupWidget) == 0x000360, "Wrong size on UGameHeadupWidget");

// Class DungeonCrawler.GameHeadupAccountWidget
// 0x0078 (0x03D8 - 0x0360)
class UGameHeadupAccountWidget : public UGameHeadupWidget
{
public:
	uint8                                         Pad_2813[0x10];                                    // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              Nickname;                                          // 0x0370(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x03B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2814[0x27];                                    // 0x03B1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRefreshNickname();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHeadupAccountWidget">();
	}
	static class UGameHeadupAccountWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHeadupAccountWidget>();
	}
};
static_assert(alignof(UGameHeadupAccountWidget) == 0x000008, "Wrong alignment on UGameHeadupAccountWidget");
static_assert(sizeof(UGameHeadupAccountWidget) == 0x0003D8, "Wrong size on UGameHeadupAccountWidget");
static_assert(offsetof(UGameHeadupAccountWidget, Nickname) == 0x000370, "Member 'UGameHeadupAccountWidget::Nickname' has a wrong offset!");
static_assert(offsetof(UGameHeadupAccountWidget, bVisible) == 0x0003B0, "Member 'UGameHeadupAccountWidget::bVisible' has a wrong offset!");

// Class DungeonCrawler.GameHeadupWidgetComponent
// 0x0050 (0x0740 - 0x06F0)
class UGameHeadupWidgetComponent final : public UWidgetComponent
{
public:
	uint8                                         Pad_2815[0x50];                                    // 0x06F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHeadupWidgetComponent">();
	}
	static class UGameHeadupWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHeadupWidgetComponent>();
	}
};
static_assert(alignof(UGameHeadupWidgetComponent) == 0x000010, "Wrong alignment on UGameHeadupWidgetComponent");
static_assert(sizeof(UGameHeadupWidgetComponent) == 0x000740, "Wrong size on UGameHeadupWidgetComponent");

// Class DungeonCrawler.GameHitDirectionWidget
// 0x0018 (0x0370 - 0x0358)
class UGameHitDirectionWidget final : public UDCWidgetBase
{
public:
	struct FVector                                HitDiection;                                       // 0x0358(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAnimation();
	void SetHitDirection(const struct FVector& Direction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHitDirectionWidget">();
	}
	static class UGameHitDirectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHitDirectionWidget>();
	}
};
static_assert(alignof(UGameHitDirectionWidget) == 0x000008, "Wrong alignment on UGameHitDirectionWidget");
static_assert(sizeof(UGameHitDirectionWidget) == 0x000370, "Wrong size on UGameHitDirectionWidget");
static_assert(offsetof(UGameHitDirectionWidget, HitDiection) == 0x000358, "Member 'UGameHitDirectionWidget::HitDiection' has a wrong offset!");

// Class DungeonCrawler.GameInteractionDescriptionWidget
// 0x0078 (0x03D0 - 0x0358)
class UGameInteractionDescriptionWidget final : public UDCShowingKeyWidgetBase
{
public:
	struct FGameInteractionDescriptionWidgetData  WidgetData;                                        // 0x0358(0x0078)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnInputType(ECommonInputType NewValue, ECommonInputType OldValue);
	void OnInteractableDataByStateMap(const TMap<struct FGameplayTag, struct FInteractionData>& NewValue, const TMap<struct FGameplayTag, struct FInteractionData>& OldValue);
	void OnInteractTargetData(const struct FInteractTargetData& NewValue, const struct FInteractTargetData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInteractionDescriptionWidget">();
	}
	static class UGameInteractionDescriptionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInteractionDescriptionWidget>();
	}
};
static_assert(alignof(UGameInteractionDescriptionWidget) == 0x000008, "Wrong alignment on UGameInteractionDescriptionWidget");
static_assert(sizeof(UGameInteractionDescriptionWidget) == 0x0003D0, "Wrong size on UGameInteractionDescriptionWidget");
static_assert(offsetof(UGameInteractionDescriptionWidget, WidgetData) == 0x000358, "Member 'UGameInteractionDescriptionWidget::WidgetData' has a wrong offset!");

// Class DungeonCrawler.GameInteractionSkillCheckWidget
// 0x0010 (0x0368 - 0x0358)
class UGameInteractionSkillCheckWidget final : public UDCShowingKeyWidgetBase
{
public:
	struct FGameplayTag                           SkillCheckType;                                    // 0x0358(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2816[0x4];                                     // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractSkillCheckEnd(ESkillCheckResult SkillCheckResult);
	void OnInteractSkillCheckStart(const struct FSkillCheckData& SkillCheckData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInteractionSkillCheckWidget">();
	}
	static class UGameInteractionSkillCheckWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInteractionSkillCheckWidget>();
	}
};
static_assert(alignof(UGameInteractionSkillCheckWidget) == 0x000008, "Wrong alignment on UGameInteractionSkillCheckWidget");
static_assert(sizeof(UGameInteractionSkillCheckWidget) == 0x000368, "Wrong size on UGameInteractionSkillCheckWidget");
static_assert(offsetof(UGameInteractionSkillCheckWidget, SkillCheckType) == 0x000358, "Member 'UGameInteractionSkillCheckWidget::SkillCheckType' has a wrong offset!");
static_assert(offsetof(UGameInteractionSkillCheckWidget, Duration) == 0x000360, "Member 'UGameInteractionSkillCheckWidget::Duration' has a wrong offset!");

// Class DungeonCrawler.GameItemWearingBarWidget
// 0x0020 (0x0378 - 0x0358)
class UGameItemWearingBarWidget final : public UDCWidgetBase
{
public:
	class UProgressBar*                           ItemWearingGauge;                                  // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GaugeInterval;                                     // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2817[0x14];                                    // 0x0364(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameItemWearingBarWidget">();
	}
	static class UGameItemWearingBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameItemWearingBarWidget>();
	}
};
static_assert(alignof(UGameItemWearingBarWidget) == 0x000008, "Wrong alignment on UGameItemWearingBarWidget");
static_assert(sizeof(UGameItemWearingBarWidget) == 0x000378, "Wrong size on UGameItemWearingBarWidget");
static_assert(offsetof(UGameItemWearingBarWidget, ItemWearingGauge) == 0x000358, "Member 'UGameItemWearingBarWidget::ItemWearingGauge' has a wrong offset!");
static_assert(offsetof(UGameItemWearingBarWidget, GaugeInterval) == 0x000360, "Member 'UGameItemWearingBarWidget::GaugeInterval' has a wrong offset!");

// Class DungeonCrawler.GameMiniMapWidget
// 0x00C8 (0x0420 - 0x0358)
class UGameMiniMapWidget : public UDCShowingKeyWidgetBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2818[0x10];                                    // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  LinkedPawn;                                        // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2819[0xA8];                                    // 0x0378(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathSwarmData(const struct FGameDeathSwarmData& DeathSwarmData);
	void OnDungeonModuleName(const class FText& NewValue, const class FText& OldValue);
	void OnFloorRuleActorRegistered(class AActor* InFloorRuleActor);
	void OnMiniMapDeathSwarmData(const struct FMiniMapDeathSwarmData& NewValue, const struct FMiniMapDeathSwarmData& OldValue);
	void OnMiniMapName(const class FString& NewMiniMapName, const class FString& OldMiniMapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMiniMapWidget">();
	}
	static class UGameMiniMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMiniMapWidget>();
	}
};
static_assert(alignof(UGameMiniMapWidget) == 0x000008, "Wrong alignment on UGameMiniMapWidget");
static_assert(sizeof(UGameMiniMapWidget) == 0x000420, "Wrong size on UGameMiniMapWidget");
static_assert(offsetof(UGameMiniMapWidget, AccountLink) == 0x000358, "Member 'UGameMiniMapWidget::AccountLink' has a wrong offset!");
static_assert(offsetof(UGameMiniMapWidget, LinkedPawn) == 0x000370, "Member 'UGameMiniMapWidget::LinkedPawn' has a wrong offset!");

// Class DungeonCrawler.GameMapWidget
// 0x0000 (0x0420 - 0x0420)
class UGameMapWidget final : public UGameMiniMapWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMapWidget">();
	}
	static class UGameMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMapWidget>();
	}
};
static_assert(alignof(UGameMapWidget) == 0x000008, "Wrong alignment on UGameMapWidget");
static_assert(sizeof(UGameMapWidget) == 0x000420, "Wrong size on UGameMapWidget");

// Class DungeonCrawler.GameMenuOptionPopupWidget
// 0x0020 (0x04A8 - 0x0488)
class UGameMenuOptionPopupWidget : public UDCCommonActivatableWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UDCCommonButtonBase*                    Btn_Left;                                          // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Right;                                         // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleLeftButtonClicked();
	void HandleRightButtonClicked();
	void SetButtonText(const class FText& InLeftText, const class FText& InRightText);
	void SetDetailText(const class FText& InDetailText);
	void UpdateButtonText(const class FText& InLeftText, const class FText& InRightText);
	void UpdateDetailText(const class FText& InDetailText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionPopupWidget">();
	}
	static class UGameMenuOptionPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionPopupWidget>();
	}
};
static_assert(alignof(UGameMenuOptionPopupWidget) == 0x000008, "Wrong alignment on UGameMenuOptionPopupWidget");
static_assert(sizeof(UGameMenuOptionPopupWidget) == 0x0004A8, "Wrong size on UGameMenuOptionPopupWidget");
static_assert(offsetof(UGameMenuOptionPopupWidget, OnClicked) == 0x000488, "Member 'UGameMenuOptionPopupWidget::OnClicked' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionPopupWidget, Btn_Left) == 0x000498, "Member 'UGameMenuOptionPopupWidget::Btn_Left' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionPopupWidget, Btn_Right) == 0x0004A0, "Member 'UGameMenuOptionPopupWidget::Btn_Right' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsAudioWidget
// 0x0080 (0x0508 - 0x0488)
class UGameMenuOptionsAudioWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UGameMenuOptionSliderWidget*            WB_TotalVolume;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_EffectVolume;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_MusicVolume;                                    // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_BackgroundVolume;                               // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_VoipOnOff;                                      // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_VoipMode;                                       // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_VoipSendMode;                                   // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_VoipInputVolume;                                // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_VoipOutputVolume;                               // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ApplyInputActionData;                              // 0x04D0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_281A[0x8];                                     // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ResetInputActionData;                              // 0x04E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_281B[0x10];                                    // 0x04F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAppActivateStateChanged(bool IsAppActivateChange);
	void OnApplyButtonClicked();
	void OnBackgroundMusicChanged(bool IsToggle);
	void OnEffectVolumeValueChanged(float NewValue);
	void OnGameUserSettingAudiosChanged(const struct FGameUserSettingAudios& InGameUserSettingAudios, const struct FGameUserSettingAudios& InOldGameUserSettingAudios, bool bInForce);
	void OnMusicVolumeValueChanged(float NewValue);
	void OnResetButtonClicked();
	void OnTotalVolumeValueChanged(float NewValue);
	void OnVoipInputVolumeValueChanged(float NewValue);
	void OnVoipModeChanged(bool IsToggle);
	void OnVoipOnOffChanged(bool IsToggle);
	void OnVoipOutputVolumeValueChanged(float NewValue);
	void OnVoipSendModeChanged(bool IsToggle);
	void UpdateWindowFocusChanged(bool IsFocus, bool IsBackgroundOption, float TotalVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsAudioWidget">();
	}
	static class UGameMenuOptionsAudioWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsAudioWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsAudioWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsAudioWidget");
static_assert(sizeof(UGameMenuOptionsAudioWidget) == 0x000508, "Wrong size on UGameMenuOptionsAudioWidget");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_TotalVolume) == 0x000488, "Member 'UGameMenuOptionsAudioWidget::WB_TotalVolume' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_EffectVolume) == 0x000490, "Member 'UGameMenuOptionsAudioWidget::WB_EffectVolume' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_MusicVolume) == 0x000498, "Member 'UGameMenuOptionsAudioWidget::WB_MusicVolume' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_BackgroundVolume) == 0x0004A0, "Member 'UGameMenuOptionsAudioWidget::WB_BackgroundVolume' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_VoipOnOff) == 0x0004A8, "Member 'UGameMenuOptionsAudioWidget::WB_VoipOnOff' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_VoipMode) == 0x0004B0, "Member 'UGameMenuOptionsAudioWidget::WB_VoipMode' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_VoipSendMode) == 0x0004B8, "Member 'UGameMenuOptionsAudioWidget::WB_VoipSendMode' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_VoipInputVolume) == 0x0004C0, "Member 'UGameMenuOptionsAudioWidget::WB_VoipInputVolume' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, WB_VoipOutputVolume) == 0x0004C8, "Member 'UGameMenuOptionsAudioWidget::WB_VoipOutputVolume' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, ApplyInputActionData) == 0x0004D0, "Member 'UGameMenuOptionsAudioWidget::ApplyInputActionData' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsAudioWidget, ResetInputActionData) == 0x0004E8, "Member 'UGameMenuOptionsAudioWidget::ResetInputActionData' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsControlsWidget
// 0x0138 (0x05C0 - 0x0488)
class UGameMenuOptionsControlsWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UGameMenuOptionSliderWidget*            WB_MouseSensitivity;                               // 0x0488(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_InvertMouseVerticalAxis;                        // 0x0490(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_InvertMouseHorizontalAxis;                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionComboBoxWidget*          WB_LanguageComboBox;                               // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                WhisperAllButton;                                  // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                WhisperFriendButton;                               // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                WhisperBlockButton;                                // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_StreamingMode;                                  // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      AutoFillUtilitySlotWidget;                         // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      AutoNextUtilitySlotWidget;                         // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      LowViolenceModeWidget;                             // 0x04D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      DeathCamWidget;                                    // 0x04E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      KnightLink;                                        // 0x04E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ApplyInputActionData;                              // 0x04F0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_281E[0x8];                                     // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ResetInputActionData;                              // 0x0508(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_281F[0x8];                                     // 0x0518(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FText>              LanguageMap;                                       // 0x0520(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2820[0x50];                                    // 0x0570(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyButtonClicked();
	void OnGameUserSettingControls(const struct FGameUserSettingControls& NewValue, const struct FGameUserSettingControls& OldValue);
	void OnInvertMouseHorizontalAxisClicked(bool IsClick);
	void OnInvertMouseVerticalAxisClicked(bool IsClick);
	void OnKnightLinkClicked(bool bIsVisible);
	void OnLowViolenceModeWidgetClicked(bool bIsClick);
	void OnMouseSensitivitySliderValueChanged(float InValue);
	void OnResetButtonClicked();
	void OnSetLanguageComboBox();
	void OnStreamingModeClicked(bool IsClick);
	void OnWhisperAllButtonClicked();
	void OnWhisperBlockButtonClicked();
	void OnWhisperFriendButtonClicked();
	void SetAutoFillUtilitySlot(bool bState);
	void SetAutoNextUtilitySlot(bool bState);
	void SetDeathCam(bool bState);
	void SetLanguageSelected(const class FString& SelectedString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsControlsWidget">();
	}
	static class UGameMenuOptionsControlsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsControlsWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsControlsWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsControlsWidget");
static_assert(sizeof(UGameMenuOptionsControlsWidget) == 0x0005C0, "Wrong size on UGameMenuOptionsControlsWidget");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WB_MouseSensitivity) == 0x000488, "Member 'UGameMenuOptionsControlsWidget::WB_MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WB_InvertMouseVerticalAxis) == 0x000490, "Member 'UGameMenuOptionsControlsWidget::WB_InvertMouseVerticalAxis' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WB_InvertMouseHorizontalAxis) == 0x000498, "Member 'UGameMenuOptionsControlsWidget::WB_InvertMouseHorizontalAxis' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WB_LanguageComboBox) == 0x0004A0, "Member 'UGameMenuOptionsControlsWidget::WB_LanguageComboBox' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WhisperAllButton) == 0x0004A8, "Member 'UGameMenuOptionsControlsWidget::WhisperAllButton' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WhisperFriendButton) == 0x0004B0, "Member 'UGameMenuOptionsControlsWidget::WhisperFriendButton' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WhisperBlockButton) == 0x0004B8, "Member 'UGameMenuOptionsControlsWidget::WhisperBlockButton' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, WB_StreamingMode) == 0x0004C0, "Member 'UGameMenuOptionsControlsWidget::WB_StreamingMode' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, AutoFillUtilitySlotWidget) == 0x0004C8, "Member 'UGameMenuOptionsControlsWidget::AutoFillUtilitySlotWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, AutoNextUtilitySlotWidget) == 0x0004D0, "Member 'UGameMenuOptionsControlsWidget::AutoNextUtilitySlotWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, LowViolenceModeWidget) == 0x0004D8, "Member 'UGameMenuOptionsControlsWidget::LowViolenceModeWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, DeathCamWidget) == 0x0004E0, "Member 'UGameMenuOptionsControlsWidget::DeathCamWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, KnightLink) == 0x0004E8, "Member 'UGameMenuOptionsControlsWidget::KnightLink' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, ApplyInputActionData) == 0x0004F0, "Member 'UGameMenuOptionsControlsWidget::ApplyInputActionData' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, ResetInputActionData) == 0x000508, "Member 'UGameMenuOptionsControlsWidget::ResetInputActionData' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsControlsWidget, LanguageMap) == 0x000520, "Member 'UGameMenuOptionsControlsWidget::LanguageMap' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionInputBindSlotItemData
// 0x0130 (0x0158 - 0x0028)
class UGameMenuOptionInputBindSlotItemData final : public UObject
{
public:
	struct FEnhancedActionKeyMapping              ActionKeyMapping;                                  // 0x0028(0x0050)(BlueprintVisible, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKeyboardInputBinding                  FirstMappableBinding;                              // 0x0078(0x0070)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FKeyboardInputBinding                  SecondaryMappableBinding;                          // 0x00E8(0x0070)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionInputBindSlotItemData">();
	}
	static class UGameMenuOptionInputBindSlotItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionInputBindSlotItemData>();
	}
};
static_assert(alignof(UGameMenuOptionInputBindSlotItemData) == 0x000008, "Wrong alignment on UGameMenuOptionInputBindSlotItemData");
static_assert(sizeof(UGameMenuOptionInputBindSlotItemData) == 0x000158, "Wrong size on UGameMenuOptionInputBindSlotItemData");
static_assert(offsetof(UGameMenuOptionInputBindSlotItemData, ActionKeyMapping) == 0x000028, "Member 'UGameMenuOptionInputBindSlotItemData::ActionKeyMapping' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionInputBindSlotItemData, FirstMappableBinding) == 0x000078, "Member 'UGameMenuOptionInputBindSlotItemData::FirstMappableBinding' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionInputBindSlotItemData, SecondaryMappableBinding) == 0x0000E8, "Member 'UGameMenuOptionInputBindSlotItemData::SecondaryMappableBinding' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsInputBindSlotWidget
// 0x0038 (0x0390 - 0x0358)
class UGameMenuOptionsInputBindSlotWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2821[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             InputName;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    PrimaryKeyButton;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    SecondaryKeyButton;                                // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ClearButton;                                       // 0x0378(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameMenuOptionsInputBindPopupWidget> InputBindPressAnyKeyPopupClass;                    // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionsInputBindPopupWidget*   InputBindPressAnyKeyPopupWidget;                   // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeBinding(int32 InKeyBindSlot, const struct FKey& InKey);
	class UWidget* GetPrimaryGamepadFocusWidget();
	void HandlePrimaryKeyPressed(const struct FKey& InKey);
	void HandleSecondaryKeyPressed(const struct FKey& InKey);
	void OnClearButtonClicked();
	void OnPrimaryKeyBindButtonClicked();
	void OnSecondaryKeyBindButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsInputBindSlotWidget">();
	}
	static class UGameMenuOptionsInputBindSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsInputBindSlotWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsInputBindSlotWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsInputBindSlotWidget");
static_assert(sizeof(UGameMenuOptionsInputBindSlotWidget) == 0x000390, "Wrong size on UGameMenuOptionsInputBindSlotWidget");
static_assert(offsetof(UGameMenuOptionsInputBindSlotWidget, InputName) == 0x000360, "Member 'UGameMenuOptionsInputBindSlotWidget::InputName' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputBindSlotWidget, PrimaryKeyButton) == 0x000368, "Member 'UGameMenuOptionsInputBindSlotWidget::PrimaryKeyButton' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputBindSlotWidget, SecondaryKeyButton) == 0x000370, "Member 'UGameMenuOptionsInputBindSlotWidget::SecondaryKeyButton' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputBindSlotWidget, ClearButton) == 0x000378, "Member 'UGameMenuOptionsInputBindSlotWidget::ClearButton' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputBindSlotWidget, InputBindPressAnyKeyPopupClass) == 0x000380, "Member 'UGameMenuOptionsInputBindSlotWidget::InputBindPressAnyKeyPopupClass' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputBindSlotWidget, InputBindPressAnyKeyPopupWidget) == 0x000388, "Member 'UGameMenuOptionsInputBindSlotWidget::InputBindPressAnyKeyPopupWidget' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsInputListView
// 0x0000 (0x0C70 - 0x0C70)
class UGameMenuOptionsInputListView final : public UListView
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsInputListView">();
	}
	static class UGameMenuOptionsInputListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsInputListView>();
	}
};
static_assert(alignof(UGameMenuOptionsInputListView) == 0x000010, "Wrong alignment on UGameMenuOptionsInputListView");
static_assert(sizeof(UGameMenuOptionsInputListView) == 0x000C70, "Wrong size on UGameMenuOptionsInputListView");

// Class DungeonCrawler.GameMenuOptionsInputSlotWidget
// 0x0018 (0x0370 - 0x0358)
class UGameMenuOptionsInputSlotWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2823[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             InputConfigName;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              InputBindSlotListView;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UWidget* GetPrimaryGamepadFocusWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsInputSlotWidget">();
	}
	static class UGameMenuOptionsInputSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsInputSlotWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsInputSlotWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsInputSlotWidget");
static_assert(sizeof(UGameMenuOptionsInputSlotWidget) == 0x000370, "Wrong size on UGameMenuOptionsInputSlotWidget");
static_assert(offsetof(UGameMenuOptionsInputSlotWidget, InputConfigName) == 0x000360, "Member 'UGameMenuOptionsInputSlotWidget::InputConfigName' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputSlotWidget, InputBindSlotListView) == 0x000368, "Member 'UGameMenuOptionsInputSlotWidget::InputBindSlotListView' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsInputWidget
// 0x0038 (0x04C0 - 0x0488)
class UGameMenuOptionsInputWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UListView*                              InputSlotListView;                                 // 0x0488(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ApplyInputActionData;                              // 0x0490(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2824[0x8];                                     // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ResetInputActionData;                              // 0x04A8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2825[0x8];                                     // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyButtonClicked();
	void OnInputBindPendingChange();
	void OnResetButtonClicked();
	void RefreshWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsInputWidget">();
	}
	static class UGameMenuOptionsInputWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsInputWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsInputWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsInputWidget");
static_assert(sizeof(UGameMenuOptionsInputWidget) == 0x0004C0, "Wrong size on UGameMenuOptionsInputWidget");
static_assert(offsetof(UGameMenuOptionsInputWidget, InputSlotListView) == 0x000488, "Member 'UGameMenuOptionsInputWidget::InputSlotListView' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputWidget, ApplyInputActionData) == 0x000490, "Member 'UGameMenuOptionsInputWidget::ApplyInputActionData' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsInputWidget, ResetInputActionData) == 0x0004A8, "Member 'UGameMenuOptionsInputWidget::ResetInputActionData' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionSliderWidget
// 0x0030 (0x0388 - 0x0358)
class UGameMenuOptionSliderWidget : public UDCWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnSliderValueChanged;                              // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UTextBlock*                             Title;                                             // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurValue;                                          // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurPerValue;                                       // 0x0374(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepSize;                                          // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2826[0x4];                                     // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString ExtractOnlyNumberics(const class FString& Message, bool IsInteger);

	void GetCurrentOptionValue();
	void GetCurrentOptionValueByPercent();
	float GetOptionValue();
	float GetOptionValuePercent();
	class UWidget* GetPrimaryGamepadFocusWidget();
	void SetOptionValue(float InValue);
	void SetSliderMinMaxValue(float InMinValue, float InMaxValue, float InStepSize);
	void SetTitle(const class FText& InText);
	void UpdateSliderMinMaxValue();
	void UpdateSliderValue(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionSliderWidget">();
	}
	static class UGameMenuOptionSliderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionSliderWidget>();
	}
};
static_assert(alignof(UGameMenuOptionSliderWidget) == 0x000008, "Wrong alignment on UGameMenuOptionSliderWidget");
static_assert(sizeof(UGameMenuOptionSliderWidget) == 0x000388, "Wrong size on UGameMenuOptionSliderWidget");
static_assert(offsetof(UGameMenuOptionSliderWidget, OnSliderValueChanged) == 0x000358, "Member 'UGameMenuOptionSliderWidget::OnSliderValueChanged' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSliderWidget, Title) == 0x000368, "Member 'UGameMenuOptionSliderWidget::Title' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSliderWidget, CurValue) == 0x000370, "Member 'UGameMenuOptionSliderWidget::CurValue' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSliderWidget, CurPerValue) == 0x000374, "Member 'UGameMenuOptionSliderWidget::CurPerValue' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSliderWidget, MinValue) == 0x000378, "Member 'UGameMenuOptionSliderWidget::MinValue' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSliderWidget, MaxValue) == 0x00037C, "Member 'UGameMenuOptionSliderWidget::MaxValue' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionSliderWidget, StepSize) == 0x000380, "Member 'UGameMenuOptionSliderWidget::StepSize' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionSlotWidget
// 0x0018 (0x03B8 - 0x03A0)
class UGameMenuOptionSlotWidget : public UGameMenuOptionBaseWidget
{
public:
	FMulticastInlineDelegateProperty_             GameMenuOptionSlotSelectedDelegate;                // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2828[0x8];                                     // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSelectedSlotIdx(const int32& NewValue, const int32& OldValue);
	void SetSelectedSlotIdx(int32 InSlotIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionSlotWidget">();
	}
	static class UGameMenuOptionSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionSlotWidget>();
	}
};
static_assert(alignof(UGameMenuOptionSlotWidget) == 0x000008, "Wrong alignment on UGameMenuOptionSlotWidget");
static_assert(sizeof(UGameMenuOptionSlotWidget) == 0x0003B8, "Wrong size on UGameMenuOptionSlotWidget");
static_assert(offsetof(UGameMenuOptionSlotWidget, GameMenuOptionSlotSelectedDelegate) == 0x0003A0, "Member 'UGameMenuOptionSlotWidget::GameMenuOptionSlotSelectedDelegate' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsPlatformWidget
// 0x0080 (0x0508 - 0x0488)
class UGameMenuOptionsPlatformWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UVerticalBox*                           VerticalBoxPlatform;                               // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameMenuOptionBaseWidget>  PlatformSlotWidgetClass;                           // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotTextBoxTwoButtonWidget* GetLinkCodeWidget;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionTwitchDropsWidget*       TwitchConnectWidget;                               // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDCPlatform, class UGameMenuOptionBaseWidget*> PlatformSlotWidgetMap;                             // 0x04A8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2829[0x10];                                    // 0x04F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyLinkCode();
	void GetLinkCode();
	void OnLinkCodeWidgetCheckStateChanged(bool bIsChecked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsPlatformWidget">();
	}
	static class UGameMenuOptionsPlatformWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsPlatformWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsPlatformWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsPlatformWidget");
static_assert(sizeof(UGameMenuOptionsPlatformWidget) == 0x000508, "Wrong size on UGameMenuOptionsPlatformWidget");
static_assert(offsetof(UGameMenuOptionsPlatformWidget, VerticalBoxPlatform) == 0x000488, "Member 'UGameMenuOptionsPlatformWidget::VerticalBoxPlatform' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsPlatformWidget, PlatformSlotWidgetClass) == 0x000490, "Member 'UGameMenuOptionsPlatformWidget::PlatformSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsPlatformWidget, GetLinkCodeWidget) == 0x000498, "Member 'UGameMenuOptionsPlatformWidget::GetLinkCodeWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsPlatformWidget, TwitchConnectWidget) == 0x0004A0, "Member 'UGameMenuOptionsPlatformWidget::TwitchConnectWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsPlatformWidget, PlatformSlotWidgetMap) == 0x0004A8, "Member 'UGameMenuOptionsPlatformWidget::PlatformSlotWidgetMap' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsSlotWidget
// 0x0000 (0x03A0 - 0x03A0)
class UGameMenuOptionsSlotWidget final : public UGameMenuOptionBaseWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsSlotWidget">();
	}
	static class UGameMenuOptionsSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsSlotWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsSlotWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsSlotWidget");
static_assert(sizeof(UGameMenuOptionsSlotWidget) == 0x0003A0, "Wrong size on UGameMenuOptionsSlotWidget");

// Class DungeonCrawler.GameMenuOptionsVideoWidget
// 0x00C0 (0x0548 - 0x0488)
class UGameMenuOptionsVideoWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UGameMenuOptionSlotWidget*              WB_ShadowQuality;                                  // 0x0488(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_TextureQuality;                                 // 0x0490(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_PostProcessQuality;                             // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_EffectsQuality;                                 // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionComboBoxWidget*          WB_DisplayMode;                                    // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionComboBoxWidget*          WB_DisplayResolution;                              // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_MaxFrameRateLimit;                              // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_MaxFrameRateLimitMeta;                          // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_Brightness;                                     // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_AntiAliasingSuperResolution;                    // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        AntiAliasingSuperResolutionSwitcher;               // 0x04D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSliderWidget*            WB_RenderScale;                                    // 0x04E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_SuperResolutionModeTSR;                         // 0x04E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_SuperResolutionModeDLSS;                        // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_SuperResolutionModeFSR2;                        // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionSlotWidget*              WB_SuperResolutionModeXeSS;                        // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_ClothSimuation;                                 // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ApplyInputActionData;                              // 0x0510(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_282A[0x8];                                     // 0x0520(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ResetInputActionData;                              // 0x0528(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_282B[0x10];                                    // 0x0538(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyButtonClicked();
	void OnApplyDisplayOption();
	void OnBrightnessChanged();
	void OnDisplayOptionChangePopup();
	void OnResetButtonClicked();
	void OnRevertDisplayOption();
	void UpdateAntiAliasingSuperResolution(int32 InSlotIdx);
	void UpdateDisplayMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsVideoWidget">();
	}
	static class UGameMenuOptionsVideoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsVideoWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsVideoWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsVideoWidget");
static_assert(sizeof(UGameMenuOptionsVideoWidget) == 0x000548, "Wrong size on UGameMenuOptionsVideoWidget");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_ShadowQuality) == 0x000488, "Member 'UGameMenuOptionsVideoWidget::WB_ShadowQuality' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_TextureQuality) == 0x000490, "Member 'UGameMenuOptionsVideoWidget::WB_TextureQuality' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_PostProcessQuality) == 0x000498, "Member 'UGameMenuOptionsVideoWidget::WB_PostProcessQuality' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_EffectsQuality) == 0x0004A0, "Member 'UGameMenuOptionsVideoWidget::WB_EffectsQuality' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_DisplayMode) == 0x0004A8, "Member 'UGameMenuOptionsVideoWidget::WB_DisplayMode' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_DisplayResolution) == 0x0004B0, "Member 'UGameMenuOptionsVideoWidget::WB_DisplayResolution' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_MaxFrameRateLimit) == 0x0004B8, "Member 'UGameMenuOptionsVideoWidget::WB_MaxFrameRateLimit' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_MaxFrameRateLimitMeta) == 0x0004C0, "Member 'UGameMenuOptionsVideoWidget::WB_MaxFrameRateLimitMeta' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_Brightness) == 0x0004C8, "Member 'UGameMenuOptionsVideoWidget::WB_Brightness' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_AntiAliasingSuperResolution) == 0x0004D0, "Member 'UGameMenuOptionsVideoWidget::WB_AntiAliasingSuperResolution' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, AntiAliasingSuperResolutionSwitcher) == 0x0004D8, "Member 'UGameMenuOptionsVideoWidget::AntiAliasingSuperResolutionSwitcher' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_RenderScale) == 0x0004E0, "Member 'UGameMenuOptionsVideoWidget::WB_RenderScale' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_SuperResolutionModeTSR) == 0x0004E8, "Member 'UGameMenuOptionsVideoWidget::WB_SuperResolutionModeTSR' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_SuperResolutionModeDLSS) == 0x0004F0, "Member 'UGameMenuOptionsVideoWidget::WB_SuperResolutionModeDLSS' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_SuperResolutionModeFSR2) == 0x0004F8, "Member 'UGameMenuOptionsVideoWidget::WB_SuperResolutionModeFSR2' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_SuperResolutionModeXeSS) == 0x000500, "Member 'UGameMenuOptionsVideoWidget::WB_SuperResolutionModeXeSS' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, WB_ClothSimuation) == 0x000508, "Member 'UGameMenuOptionsVideoWidget::WB_ClothSimuation' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, ApplyInputActionData) == 0x000510, "Member 'UGameMenuOptionsVideoWidget::ApplyInputActionData' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionsVideoWidget, ResetInputActionData) == 0x000528, "Member 'UGameMenuOptionsVideoWidget::ResetInputActionData' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionsWidget
// 0x0008 (0x0490 - 0x0488)
class UGameMenuOptionsWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UWidgetSwitcher*                        GameMenuOptionsWidgetSwitcher;                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnToggled(ESlateVisibility Invisibility);
	void OnWidgetToggleNotify(ESlateVisibility Invisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsWidget">();
	}
	static class UGameMenuOptionsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsWidget>();
	}
};
static_assert(alignof(UGameMenuOptionsWidget) == 0x000008, "Wrong alignment on UGameMenuOptionsWidget");
static_assert(sizeof(UGameMenuOptionsWidget) == 0x000490, "Wrong size on UGameMenuOptionsWidget");
static_assert(offsetof(UGameMenuOptionsWidget, GameMenuOptionsWidgetSwitcher) == 0x000488, "Member 'UGameMenuOptionsWidget::GameMenuOptionsWidgetSwitcher' has a wrong offset!");

// Class DungeonCrawler.GameMenuOptionToggleSwitchWidget
// 0x0020 (0x0378 - 0x0358)
class UGameMenuOptionToggleSwitchWidget : public UDCWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UTextBlock*                             Title;                                             // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_282C[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* GetPrimaryGamepadFocusWidget();
	bool GetToggleSwitch();
	void OffToggleSwitchClicked();
	void OnToggleSwitch(bool InSwitch);
	void OnToggleSwitchClicked();
	void SetButtonText(const class FText& LeftText, const class FText& RightText);
	void SetTitle(const class FText& InTitle);
	void SetToggleSwitch(bool InSwitch);
	void UpdateButtonText(const class FText& LeftText, const class FText& RightText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionToggleSwitchWidget">();
	}
	static class UGameMenuOptionToggleSwitchWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionToggleSwitchWidget>();
	}
};
static_assert(alignof(UGameMenuOptionToggleSwitchWidget) == 0x000008, "Wrong alignment on UGameMenuOptionToggleSwitchWidget");
static_assert(sizeof(UGameMenuOptionToggleSwitchWidget) == 0x000378, "Wrong size on UGameMenuOptionToggleSwitchWidget");
static_assert(offsetof(UGameMenuOptionToggleSwitchWidget, OnClicked) == 0x000358, "Member 'UGameMenuOptionToggleSwitchWidget::OnClicked' has a wrong offset!");
static_assert(offsetof(UGameMenuOptionToggleSwitchWidget, Title) == 0x000368, "Member 'UGameMenuOptionToggleSwitchWidget::Title' has a wrong offset!");

// Class DungeonCrawler.GameMenuWidget
// 0x0078 (0x0500 - 0x0488)
class UGameMenuWidget : public UDCCommonActivatableWidgetBase
{
public:
	class UButton*                                ContinueButton;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                OptionsButton;                                     // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                LobbyButton;                                       // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                CharacterSelectButton;                             // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ExitButton;                                        // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                GRACButton;                                        // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switcher_SubMenus;                                 // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionsWidget*                 GameMenuOptionsWidget;                             // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switcher_OptionBtnOnOff;                           // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionPopupWidget*             WB_DisplayApplyPopup;                              // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    BackInputActionData;                               // 0x04D8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_282D[0x18];                                    // 0x04E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterSelectClicked();
	void OnContinueButtonClicked();
	void OnDeselectedSubMenuButtons();
	void OnDisplayOptionApplyPopup();
	void OnDisplayTotalPlaytime(const struct FTimespan& CurrentTotalPlayTime);
	void OnExitButtonClicked();
	void OnLobbyButtonClicked();
	void OnMenuPop();
	void OnOptionsButtonClicked();
	void OnVisibleReportButton(bool bIsVisible);

	const bool IsLobby() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuWidget">();
	}
	static class UGameMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuWidget>();
	}
};
static_assert(alignof(UGameMenuWidget) == 0x000008, "Wrong alignment on UGameMenuWidget");
static_assert(sizeof(UGameMenuWidget) == 0x000500, "Wrong size on UGameMenuWidget");
static_assert(offsetof(UGameMenuWidget, ContinueButton) == 0x000488, "Member 'UGameMenuWidget::ContinueButton' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, OptionsButton) == 0x000490, "Member 'UGameMenuWidget::OptionsButton' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, LobbyButton) == 0x000498, "Member 'UGameMenuWidget::LobbyButton' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, CharacterSelectButton) == 0x0004A0, "Member 'UGameMenuWidget::CharacterSelectButton' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, ExitButton) == 0x0004A8, "Member 'UGameMenuWidget::ExitButton' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, GRACButton) == 0x0004B0, "Member 'UGameMenuWidget::GRACButton' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, Switcher_SubMenus) == 0x0004B8, "Member 'UGameMenuWidget::Switcher_SubMenus' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, GameMenuOptionsWidget) == 0x0004C0, "Member 'UGameMenuWidget::GameMenuOptionsWidget' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, Switcher_OptionBtnOnOff) == 0x0004C8, "Member 'UGameMenuWidget::Switcher_OptionBtnOnOff' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, WB_DisplayApplyPopup) == 0x0004D0, "Member 'UGameMenuWidget::WB_DisplayApplyPopup' has a wrong offset!");
static_assert(offsetof(UGameMenuWidget, BackInputActionData) == 0x0004D8, "Member 'UGameMenuWidget::BackInputActionData' has a wrong offset!");

// Class DungeonCrawler.GameMusicCurrentSlotWidget
// 0x0108 (0x0460 - 0x0358)
class UGameMusicCurrentSlotWidget final : public UDCWidgetBase
{
public:
	struct FMusicData                             MusicData;                                         // 0x0358(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_282E[0x4];                                     // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       DesignDataMusic;                                   // 0x0380(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_282F[0x10];                                    // 0x0448(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0458(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMusicDataChanged(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic);
	void SetMusicData(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMusicCurrentSlotWidget">();
	}
	static class UGameMusicCurrentSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMusicCurrentSlotWidget>();
	}
};
static_assert(alignof(UGameMusicCurrentSlotWidget) == 0x000008, "Wrong alignment on UGameMusicCurrentSlotWidget");
static_assert(sizeof(UGameMusicCurrentSlotWidget) == 0x000460, "Wrong size on UGameMusicCurrentSlotWidget");
static_assert(offsetof(UGameMusicCurrentSlotWidget, MusicData) == 0x000358, "Member 'UGameMusicCurrentSlotWidget::MusicData' has a wrong offset!");
static_assert(offsetof(UGameMusicCurrentSlotWidget, DesignDataMusic) == 0x000380, "Member 'UGameMusicCurrentSlotWidget::DesignDataMusic' has a wrong offset!");
static_assert(offsetof(UGameMusicCurrentSlotWidget, PlayerCharacter) == 0x000458, "Member 'UGameMusicCurrentSlotWidget::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.GameMusicPlayBarWidget
// 0x0208 (0x0560 - 0x0358)
class UGameMusicPlayBarWidget final : public UDCShowingKeyWidgetBase
{
public:
	class UTextBlock*                             PlayText;                                          // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChannelingText;                                    // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChannelingTimer;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                PlaySlider;                                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PlayGauge;                                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        SectionWidgets;                                    // 0x0380(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox;                                     // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox_Perfect;                             // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox_Channeling;                                // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2832[0x8];                                     // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            GoodJudgeAreaBrush;                                // 0x03B0(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            PerfectJudgeAreaBrush;                             // 0x0480(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2833[0x10];                                    // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMusicChannelingEnd();
	void OnMusicChannelingStart(EMusicPlaySectionJudgement Judge);
	void OnMusicJudgeNotify(EMusicPlaySectionJudgement Judge, float PastSectionRatio, float NextSectionRatio, float JudgePositionRatio);
	void OnMusicPlayEnd();
	void OnMusicPlayStart();
	void OnMusicPlaySucceed(EMusicPlaySectionJudgement Judge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMusicPlayBarWidget">();
	}
	static class UGameMusicPlayBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMusicPlayBarWidget>();
	}
};
static_assert(alignof(UGameMusicPlayBarWidget) == 0x000010, "Wrong alignment on UGameMusicPlayBarWidget");
static_assert(sizeof(UGameMusicPlayBarWidget) == 0x000560, "Wrong size on UGameMusicPlayBarWidget");
static_assert(offsetof(UGameMusicPlayBarWidget, PlayText) == 0x000358, "Member 'UGameMusicPlayBarWidget::PlayText' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, ChannelingText) == 0x000360, "Member 'UGameMusicPlayBarWidget::ChannelingText' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, ChannelingTimer) == 0x000368, "Member 'UGameMusicPlayBarWidget::ChannelingTimer' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, PlaySlider) == 0x000370, "Member 'UGameMusicPlayBarWidget::PlaySlider' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, PlayGauge) == 0x000378, "Member 'UGameMusicPlayBarWidget::PlayGauge' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, SectionWidgets) == 0x000380, "Member 'UGameMusicPlayBarWidget::SectionWidgets' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, HorizontalBox) == 0x000390, "Member 'UGameMusicPlayBarWidget::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, HorizontalBox_Perfect) == 0x000398, "Member 'UGameMusicPlayBarWidget::HorizontalBox_Perfect' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, SizeBox_Channeling) == 0x0003A0, "Member 'UGameMusicPlayBarWidget::SizeBox_Channeling' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, GoodJudgeAreaBrush) == 0x0003B0, "Member 'UGameMusicPlayBarWidget::GoodJudgeAreaBrush' has a wrong offset!");
static_assert(offsetof(UGameMusicPlayBarWidget, PerfectJudgeAreaBrush) == 0x000480, "Member 'UGameMusicPlayBarWidget::PerfectJudgeAreaBrush' has a wrong offset!");

// Class DungeonCrawler.GameMusicSlotWidget
// 0x0000 (0x0468 - 0x0468)
class UGameMusicSlotWidget final : public UMusicSlotWidgetBase
{
public:
	void OnSelectionChanged(bool bIsSelected);
	void SelectionChange(bool bIsSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMusicSlotWidget">();
	}
	static class UGameMusicSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMusicSlotWidget>();
	}
};
static_assert(alignof(UGameMusicSlotWidget) == 0x000008, "Wrong alignment on UGameMusicSlotWidget");
static_assert(sizeof(UGameMusicSlotWidget) == 0x000468, "Wrong size on UGameMusicSlotWidget");

// Class DungeonCrawler.GamePartyManagePartyMemberWidgetData
// 0x0010 (0x0038 - 0x0028)
class UGamePartyManagePartyMemberWidgetData final : public UObject
{
public:
	struct FPartyMemberData                       PartyMemberData;                                   // 0x0028(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyManagePartyMemberWidgetData">();
	}
	static class UGamePartyManagePartyMemberWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyManagePartyMemberWidgetData>();
	}
};
static_assert(alignof(UGamePartyManagePartyMemberWidgetData) == 0x000008, "Wrong alignment on UGamePartyManagePartyMemberWidgetData");
static_assert(sizeof(UGamePartyManagePartyMemberWidgetData) == 0x000038, "Wrong size on UGamePartyManagePartyMemberWidgetData");
static_assert(offsetof(UGamePartyManagePartyMemberWidgetData, PartyMemberData) == 0x000028, "Member 'UGamePartyManagePartyMemberWidgetData::PartyMemberData' has a wrong offset!");

// Class DungeonCrawler.GamePartyManagePartyMemberWidget
// 0x00A0 (0x03F8 - 0x0358)
class UGamePartyManagePartyMemberWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2835[0x98];                                    // 0x0358(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLink*                           AccountLink;                                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAccountDataReplication(const struct FAccountDataReplication& NewValue, const struct FAccountDataReplication& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyManagePartyMemberWidget">();
	}
	static class UGamePartyManagePartyMemberWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyManagePartyMemberWidget>();
	}
};
static_assert(alignof(UGamePartyManagePartyMemberWidget) == 0x000008, "Wrong alignment on UGamePartyManagePartyMemberWidget");
static_assert(sizeof(UGamePartyManagePartyMemberWidget) == 0x0003F8, "Wrong size on UGamePartyManagePartyMemberWidget");
static_assert(offsetof(UGamePartyManagePartyMemberWidget, AccountLink) == 0x0003F0, "Member 'UGamePartyManagePartyMemberWidget::AccountLink' has a wrong offset!");

// Class DungeonCrawler.GamePartyManagePartyWidget
// 0x0038 (0x0390 - 0x0358)
class UGamePartyManagePartyWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2836[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                PartyJoinButton;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              PartyMemberListView;                               // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2837[0x20];                                    // 0x0370(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPartyData(const struct FPartyData& NewValue, const struct FPartyData& OldValue);
	void PartyJoin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyManagePartyWidget">();
	}
	static class UGamePartyManagePartyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyManagePartyWidget>();
	}
};
static_assert(alignof(UGamePartyManagePartyWidget) == 0x000008, "Wrong alignment on UGamePartyManagePartyWidget");
static_assert(sizeof(UGamePartyManagePartyWidget) == 0x000390, "Wrong size on UGamePartyManagePartyWidget");
static_assert(offsetof(UGamePartyManagePartyWidget, PartyJoinButton) == 0x000360, "Member 'UGamePartyManagePartyWidget::PartyJoinButton' has a wrong offset!");
static_assert(offsetof(UGamePartyManagePartyWidget, PartyMemberListView) == 0x000368, "Member 'UGamePartyManagePartyWidget::PartyMemberListView' has a wrong offset!");

// Class DungeonCrawler.GamePartyManageWidget
// 0x0068 (0x03C0 - 0x0358)
class UGamePartyManageWidget final : public UDCWidgetBase
{
public:
	class UGamePartyManagePartyWidget*            NonPartyWidget;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              PartyTileView;                                     // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAccountLinkAll*                        AccountLinkAll;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UGamePartyManagePartyWidgetData*> GamePartyManagePartyWidgetDataMap;                 // 0x0370(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyManageWidget">();
	}
	static class UGamePartyManageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyManageWidget>();
	}
};
static_assert(alignof(UGamePartyManageWidget) == 0x000008, "Wrong alignment on UGamePartyManageWidget");
static_assert(sizeof(UGamePartyManageWidget) == 0x0003C0, "Wrong size on UGamePartyManageWidget");
static_assert(offsetof(UGamePartyManageWidget, NonPartyWidget) == 0x000358, "Member 'UGamePartyManageWidget::NonPartyWidget' has a wrong offset!");
static_assert(offsetof(UGamePartyManageWidget, PartyTileView) == 0x000360, "Member 'UGamePartyManageWidget::PartyTileView' has a wrong offset!");
static_assert(offsetof(UGamePartyManageWidget, AccountLinkAll) == 0x000368, "Member 'UGamePartyManageWidget::AccountLinkAll' has a wrong offset!");
static_assert(offsetof(UGamePartyManageWidget, GamePartyManagePartyWidgetDataMap) == 0x000370, "Member 'UGamePartyManageWidget::GamePartyManagePartyWidgetDataMap' has a wrong offset!");

// Class DungeonCrawler.GamePartyMemberWidget
// 0x00C0 (0x0418 - 0x0358)
class UGamePartyMemberWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_2838[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPortraitCharacter*                   PortraitCharacter;                                 // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PartyMemberActorStatusColumn;                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVoipUserWidget*                        VoipUserWidget;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClassRankIconBase*                     ClassRankIcon;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumActorStatusRows;                                // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2839[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCPartyMemberActorStatusRow> PartyMemberActorStatusRowClass;                    // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_283A[0x10];                                    // 0x0398(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              Nickname;                                          // 0x03A8(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAlive;                                          // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_283B[0x3];                                     // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRate;                                        // 0x03EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverhealedHealthRate;                              // 0x03F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoverableHealthRate;                             // 0x03F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEscaped;                                        // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReserved;                                       // 0x03F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDisconnected;                                   // 0x03FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnline;                                         // 0x03FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOffline;                                        // 0x03FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTarget;                                         // 0x03FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_283C[0x2];                                     // 0x03FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Portrait;                                          // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 PortraitRenderTarget;                              // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCArenaTeam                                  ArenaTeam;                                         // 0x0410(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_283D[0x7];                                     // 0x0411(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPortraitRenderTargetUpdated();
	void OnRefreshNickname();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePartyMemberWidget">();
	}
	static class UGamePartyMemberWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePartyMemberWidget>();
	}
};
static_assert(alignof(UGamePartyMemberWidget) == 0x000008, "Wrong alignment on UGamePartyMemberWidget");
static_assert(sizeof(UGamePartyMemberWidget) == 0x000418, "Wrong size on UGamePartyMemberWidget");
static_assert(offsetof(UGamePartyMemberWidget, PortraitCharacter) == 0x000368, "Member 'UGamePartyMemberWidget::PortraitCharacter' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, PartyMemberActorStatusColumn) == 0x000370, "Member 'UGamePartyMemberWidget::PartyMemberActorStatusColumn' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, VoipUserWidget) == 0x000378, "Member 'UGamePartyMemberWidget::VoipUserWidget' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, ClassRankIcon) == 0x000380, "Member 'UGamePartyMemberWidget::ClassRankIcon' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, NumActorStatusRows) == 0x000388, "Member 'UGamePartyMemberWidget::NumActorStatusRows' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, PartyMemberActorStatusRowClass) == 0x000390, "Member 'UGamePartyMemberWidget::PartyMemberActorStatusRowClass' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, Nickname) == 0x0003A8, "Member 'UGamePartyMemberWidget::Nickname' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsAlive) == 0x0003E8, "Member 'UGamePartyMemberWidget::bIsAlive' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, HealthRate) == 0x0003EC, "Member 'UGamePartyMemberWidget::HealthRate' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, OverhealedHealthRate) == 0x0003F0, "Member 'UGamePartyMemberWidget::OverhealedHealthRate' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, RecoverableHealthRate) == 0x0003F4, "Member 'UGamePartyMemberWidget::RecoverableHealthRate' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsEscaped) == 0x0003F8, "Member 'UGamePartyMemberWidget::bIsEscaped' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsReserved) == 0x0003F9, "Member 'UGamePartyMemberWidget::bIsReserved' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsDisconnected) == 0x0003FA, "Member 'UGamePartyMemberWidget::bIsDisconnected' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsOnline) == 0x0003FB, "Member 'UGamePartyMemberWidget::bIsOnline' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsOffline) == 0x0003FC, "Member 'UGamePartyMemberWidget::bIsOffline' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, bIsTarget) == 0x0003FD, "Member 'UGamePartyMemberWidget::bIsTarget' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, Portrait) == 0x000400, "Member 'UGamePartyMemberWidget::Portrait' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, PortraitRenderTarget) == 0x000408, "Member 'UGamePartyMemberWidget::PortraitRenderTarget' has a wrong offset!");
static_assert(offsetof(UGamePartyMemberWidget, ArenaTeam) == 0x000410, "Member 'UGamePartyMemberWidget::ArenaTeam' has a wrong offset!");

// Class DungeonCrawler.GamePlayerCharacterWidget
// 0x0070 (0x03C8 - 0x0358)
class UGamePlayerCharacterWidget final : public UDCShowingKeyWidgetBase
{
public:
	struct FNickname                              Nickname;                                          // 0x0358(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         HealthRate;                                        // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverhealedHealthRate;                              // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoverableHealthRate;                             // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ColdnessRate;                                      // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCAccountId                           AccountId;                                         // 0x03A8(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x03B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_283E[0x8];                                     // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCampfireChanged(bool bInCampfire);
	void OnCharacterClass(EDCCharacterClass InCharacterClass);
	void OnCurrentActiveSlot(const class UEquipmentSlotWidget* CurrentActiveWidget);
	void OnRecoveryHealing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePlayerCharacterWidget">();
	}
	static class UGamePlayerCharacterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePlayerCharacterWidget>();
	}
};
static_assert(alignof(UGamePlayerCharacterWidget) == 0x000008, "Wrong alignment on UGamePlayerCharacterWidget");
static_assert(sizeof(UGamePlayerCharacterWidget) == 0x0003C8, "Wrong size on UGamePlayerCharacterWidget");
static_assert(offsetof(UGamePlayerCharacterWidget, Nickname) == 0x000358, "Member 'UGamePlayerCharacterWidget::Nickname' has a wrong offset!");
static_assert(offsetof(UGamePlayerCharacterWidget, HealthRate) == 0x000398, "Member 'UGamePlayerCharacterWidget::HealthRate' has a wrong offset!");
static_assert(offsetof(UGamePlayerCharacterWidget, OverhealedHealthRate) == 0x00039C, "Member 'UGamePlayerCharacterWidget::OverhealedHealthRate' has a wrong offset!");
static_assert(offsetof(UGamePlayerCharacterWidget, RecoverableHealthRate) == 0x0003A0, "Member 'UGamePlayerCharacterWidget::RecoverableHealthRate' has a wrong offset!");
static_assert(offsetof(UGamePlayerCharacterWidget, ColdnessRate) == 0x0003A4, "Member 'UGamePlayerCharacterWidget::ColdnessRate' has a wrong offset!");
static_assert(offsetof(UGamePlayerCharacterWidget, AccountId) == 0x0003A8, "Member 'UGamePlayerCharacterWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UGamePlayerCharacterWidget, PlayerCharacter) == 0x0003B8, "Member 'UGamePlayerCharacterWidget::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.GamePlayerEquipSlotWidget
// 0x0068 (0x03C0 - 0x0358)
class UGamePlayerEquipSlotWidget final : public UDCShowingKeyWidgetBase
{
public:
	class UEquipmentWeaponSlotSetWidget*          WeaponSetL;                                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentWeaponSlotSetWidget*          WeaponSetR;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlotWidget*                   UtilityL1;                                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlotWidget*                   UtilityL2;                                         // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlotWidget*                   UtilityL3;                                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlotWidget*                   UtilityR1;                                         // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlotWidget*                   UtilityR2;                                         // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentSlotWidget*                   UtilityR3;                                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCAccountId                           AccountId;                                         // 0x0398(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UEquipmentSlotWidget*>           EquipmentSlotWidgetArray;                          // 0x03B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnQuickSlotDataChanged(EEquipmentQuickSlotType Type, int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePlayerEquipSlotWidget">();
	}
	static class UGamePlayerEquipSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePlayerEquipSlotWidget>();
	}
};
static_assert(alignof(UGamePlayerEquipSlotWidget) == 0x000008, "Wrong alignment on UGamePlayerEquipSlotWidget");
static_assert(sizeof(UGamePlayerEquipSlotWidget) == 0x0003C0, "Wrong size on UGamePlayerEquipSlotWidget");
static_assert(offsetof(UGamePlayerEquipSlotWidget, WeaponSetL) == 0x000358, "Member 'UGamePlayerEquipSlotWidget::WeaponSetL' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, WeaponSetR) == 0x000360, "Member 'UGamePlayerEquipSlotWidget::WeaponSetR' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, UtilityL1) == 0x000368, "Member 'UGamePlayerEquipSlotWidget::UtilityL1' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, UtilityL2) == 0x000370, "Member 'UGamePlayerEquipSlotWidget::UtilityL2' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, UtilityL3) == 0x000378, "Member 'UGamePlayerEquipSlotWidget::UtilityL3' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, UtilityR1) == 0x000380, "Member 'UGamePlayerEquipSlotWidget::UtilityR1' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, UtilityR2) == 0x000388, "Member 'UGamePlayerEquipSlotWidget::UtilityR2' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, UtilityR3) == 0x000390, "Member 'UGamePlayerEquipSlotWidget::UtilityR3' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, AccountId) == 0x000398, "Member 'UGamePlayerEquipSlotWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, PlayerCharacter) == 0x0003A8, "Member 'UGamePlayerEquipSlotWidget::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UGamePlayerEquipSlotWidget, EquipmentSlotWidgetArray) == 0x0003B0, "Member 'UGamePlayerEquipSlotWidget::EquipmentSlotWidgetArray' has a wrong offset!");

// Class DungeonCrawler.GameplayTagMessageRelationshipData
// 0x0050 (0x0080 - 0x0030)
class UGameplayTagMessageRelationshipData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, class FText>        GameplayTagMessageRelationshipData;                // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTagMessageRelationshipData">();
	}
	static class UGameplayTagMessageRelationshipData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagMessageRelationshipData>();
	}
};
static_assert(alignof(UGameplayTagMessageRelationshipData) == 0x000008, "Wrong alignment on UGameplayTagMessageRelationshipData");
static_assert(sizeof(UGameplayTagMessageRelationshipData) == 0x000080, "Wrong size on UGameplayTagMessageRelationshipData");
static_assert(offsetof(UGameplayTagMessageRelationshipData, GameplayTagMessageRelationshipData) == 0x000030, "Member 'UGameplayTagMessageRelationshipData::GameplayTagMessageRelationshipData' has a wrong offset!");

// Class DungeonCrawler.KnockBackImmuneGameplayTagData
// 0x0020 (0x0050 - 0x0030)
class UKnockBackImmuneGameplayTagData final : public UDataAsset
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnockBackImmuneGameplayTagData">();
	}
	static class UKnockBackImmuneGameplayTagData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnockBackImmuneGameplayTagData>();
	}
};
static_assert(alignof(UKnockBackImmuneGameplayTagData) == 0x000008, "Wrong alignment on UKnockBackImmuneGameplayTagData");
static_assert(sizeof(UKnockBackImmuneGameplayTagData) == 0x000050, "Wrong size on UKnockBackImmuneGameplayTagData");
static_assert(offsetof(UKnockBackImmuneGameplayTagData, TagContainer) == 0x000030, "Member 'UKnockBackImmuneGameplayTagData::TagContainer' has a wrong offset!");

// Class DungeonCrawler.StatisticsPopupData
// 0x0000 (0x0030 - 0x0030)
class UStatisticsPopupData final : public UPopupDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsPopupData">();
	}
	static class UStatisticsPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsPopupData>();
	}
};
static_assert(alignof(UStatisticsPopupData) == 0x000008, "Wrong alignment on UStatisticsPopupData");
static_assert(sizeof(UStatisticsPopupData) == 0x000030, "Wrong size on UStatisticsPopupData");

// Class DungeonCrawler.GameplayTagSoundConditionData
// 0x0050 (0x0080 - 0x0030)
class UGameplayTagSoundConditionData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FGameplayTagQuery> GameplayTagSoundConditionData;                     // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTagSoundConditionData">();
	}
	static class UGameplayTagSoundConditionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagSoundConditionData>();
	}
};
static_assert(alignof(UGameplayTagSoundConditionData) == 0x000008, "Wrong alignment on UGameplayTagSoundConditionData");
static_assert(sizeof(UGameplayTagSoundConditionData) == 0x000080, "Wrong size on UGameplayTagSoundConditionData");
static_assert(offsetof(UGameplayTagSoundConditionData, GameplayTagSoundConditionData) == 0x000030, "Member 'UGameplayTagSoundConditionData::GameplayTagSoundConditionData' has a wrong offset!");

// Class DungeonCrawler.GameProgressBarWidget
// 0x0028 (0x0380 - 0x0358)
class UGameProgressBarWidget final : public UDCShowingKeyWidgetBase
{
public:
	class UTextBlock*                             ProgressText;                                      // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressGauge;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Percent;                                           // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2840[0x14];                                    // 0x036C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPercentUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameProgressBarWidget">();
	}
	static class UGameProgressBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameProgressBarWidget>();
	}
};
static_assert(alignof(UGameProgressBarWidget) == 0x000008, "Wrong alignment on UGameProgressBarWidget");
static_assert(sizeof(UGameProgressBarWidget) == 0x000380, "Wrong size on UGameProgressBarWidget");
static_assert(offsetof(UGameProgressBarWidget, ProgressText) == 0x000358, "Member 'UGameProgressBarWidget::ProgressText' has a wrong offset!");
static_assert(offsetof(UGameProgressBarWidget, ProgressGauge) == 0x000360, "Member 'UGameProgressBarWidget::ProgressGauge' has a wrong offset!");
static_assert(offsetof(UGameProgressBarWidget, Percent) == 0x000368, "Member 'UGameProgressBarWidget::Percent' has a wrong offset!");

// Class DungeonCrawler.GameQuestInterface
// 0x0000 (0x0028 - 0x0028)
class IGameQuestInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameQuestInterface">();
	}
	static class IGameQuestInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameQuestInterface>();
	}
};
static_assert(alignof(IGameQuestInterface) == 0x000008, "Wrong alignment on IGameQuestInterface");
static_assert(sizeof(IGameQuestInterface) == 0x000028, "Wrong size on IGameQuestInterface");

// Class DungeonCrawler.GameQuestLogInterface
// 0x0000 (0x0028 - 0x0028)
class IGameQuestLogInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameQuestLogInterface">();
	}
	static class IGameQuestLogInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameQuestLogInterface>();
	}
};
static_assert(alignof(IGameQuestLogInterface) == 0x000008, "Wrong alignment on IGameQuestLogInterface");
static_assert(sizeof(IGameQuestLogInterface) == 0x000028, "Wrong size on IGameQuestLogInterface");

// Class DungeonCrawler.GameShapeShiftSelectGroupWidget
// 0x0020 (0x0508 - 0x04E8)
class UGameShapeShiftSelectGroupWidget final : public UShapeShiftListWidgetBase
{
public:
	int32                                         SelectedShapeShiftIndex;                           // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2841[0x14];                                    // 0x04EC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0500(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCurrentShapeShiftSlotChanged(class UGameShapeShiftSlotWidget* InSelectedSlot);
	void OnSelectedShapeShiftIndexChanged();
	void OnShapeShiftSelectClose();
	void OnShapeShiftSelectPopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameShapeShiftSelectGroupWidget">();
	}
	static class UGameShapeShiftSelectGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameShapeShiftSelectGroupWidget>();
	}
};
static_assert(alignof(UGameShapeShiftSelectGroupWidget) == 0x000008, "Wrong alignment on UGameShapeShiftSelectGroupWidget");
static_assert(sizeof(UGameShapeShiftSelectGroupWidget) == 0x000508, "Wrong size on UGameShapeShiftSelectGroupWidget");
static_assert(offsetof(UGameShapeShiftSelectGroupWidget, SelectedShapeShiftIndex) == 0x0004E8, "Member 'UGameShapeShiftSelectGroupWidget::SelectedShapeShiftIndex' has a wrong offset!");
static_assert(offsetof(UGameShapeShiftSelectGroupWidget, PlayerCharacter) == 0x000500, "Member 'UGameShapeShiftSelectGroupWidget::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.GameShapeShiftSlotWidget
// 0x0000 (0x03B8 - 0x03B8)
class UGameShapeShiftSlotWidget final : public UShapeShiftSlotWidgetBase
{
public:
	void OnSelectionChanged(bool bIsSelected);
	void SelectionChange(bool bIsSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameShapeShiftSlotWidget">();
	}
	static class UGameShapeShiftSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameShapeShiftSlotWidget>();
	}
};
static_assert(alignof(UGameShapeShiftSlotWidget) == 0x000008, "Wrong alignment on UGameShapeShiftSlotWidget");
static_assert(sizeof(UGameShapeShiftSlotWidget) == 0x0003B8, "Wrong size on UGameShapeShiftSlotWidget");

// Class DungeonCrawler.GameSkillSlotWidget
// 0x0050 (0x03A8 - 0x0358)
class UGameSkillSlotWidget final : public UDCShowingKeyWidgetBase
{
public:
	ESkillIndex                                   SkillSlotIndex;                                    // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2842[0x3];                                     // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillCooldownData                     SkillCooldownData;                                 // 0x035C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSkillData                             SkillData;                                         // 0x0364(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2843[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLink*                           AccountLink;                                       // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   LinkedPawn;                                        // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetSkillSlotCooldownDuration();
	float GetSkillSlotCooldownPercent();
	void OnLinkedPawnDestroyed(class AActor* InActor);
	void OnResetSkillCooldownUI();
	void OnResetSkillDesc();
	void OnSkillCooldownEnd();
	void OnSkillFailedSystemMessage();
	void OnUpdateSkillArtData(class UArtDataSkill* SkillArtData);
	void OnUpdateSkillData(const struct FSkillData& InSkillData, const struct FDesignDataSkill& InDesignDataSkill);
	void OnUpdateSkillDesc(const class FText& SkillName, const class FText& SkillDesc);
	void OnUpdateSkillSlot(const struct FGameplayTag& SkillTag, float Duration);
	void OnUpdateSkillSlotVisible(bool IsVisibility);
	void UpdateSkillCooldownUI();

	float GetSkillChargedPercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSkillSlotWidget">();
	}
	static class UGameSkillSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSkillSlotWidget>();
	}
};
static_assert(alignof(UGameSkillSlotWidget) == 0x000008, "Wrong alignment on UGameSkillSlotWidget");
static_assert(sizeof(UGameSkillSlotWidget) == 0x0003A8, "Wrong size on UGameSkillSlotWidget");
static_assert(offsetof(UGameSkillSlotWidget, SkillSlotIndex) == 0x000358, "Member 'UGameSkillSlotWidget::SkillSlotIndex' has a wrong offset!");
static_assert(offsetof(UGameSkillSlotWidget, SkillCooldownData) == 0x00035C, "Member 'UGameSkillSlotWidget::SkillCooldownData' has a wrong offset!");
static_assert(offsetof(UGameSkillSlotWidget, SkillData) == 0x000364, "Member 'UGameSkillSlotWidget::SkillData' has a wrong offset!");
static_assert(offsetof(UGameSkillSlotWidget, AccountLink) == 0x000398, "Member 'UGameSkillSlotWidget::AccountLink' has a wrong offset!");
static_assert(offsetof(UGameSkillSlotWidget, LinkedPawn) == 0x0003A0, "Member 'UGameSkillSlotWidget::LinkedPawn' has a wrong offset!");

// Class DungeonCrawler.GameSpellCastingBarWidget
// 0x0020 (0x0378 - 0x0358)
class UGameSpellCastingBarWidget final : public UDCShowingKeyWidgetBase
{
public:
	class UTextBlock*                             CastingText;                                       // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CastingGauge;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2844[0x10];                                    // 0x0368(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpellCastEnd();
	void OnSpellCastStart();
	void OnSpellCastSucceed();
	void OnSpellChannelingEnd();
	void OnSpellChannelingStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSpellCastingBarWidget">();
	}
	static class UGameSpellCastingBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSpellCastingBarWidget>();
	}
};
static_assert(alignof(UGameSpellCastingBarWidget) == 0x000008, "Wrong alignment on UGameSpellCastingBarWidget");
static_assert(sizeof(UGameSpellCastingBarWidget) == 0x000378, "Wrong size on UGameSpellCastingBarWidget");
static_assert(offsetof(UGameSpellCastingBarWidget, CastingText) == 0x000358, "Member 'UGameSpellCastingBarWidget::CastingText' has a wrong offset!");
static_assert(offsetof(UGameSpellCastingBarWidget, CastingGauge) == 0x000360, "Member 'UGameSpellCastingBarWidget::CastingGauge' has a wrong offset!");

// Class DungeonCrawler.GameSpellSelectGroupWidget
// 0x0020 (0x0508 - 0x04E8)
class UGameSpellSelectGroupWidget final : public USpellListWidgetBase
{
public:
	int32                                         SelectedSpellIndex;                                // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2845[0x14];                                    // 0x04EC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0500(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCurrentSpellSlotChanged(class UGameSpellSlotWidget* InSelectedSlot);
	void OnSelectedSpellIndexChanged();
	void OnSpellSelectClose();
	void OnSpellSelectPopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSpellSelectGroupWidget">();
	}
	static class UGameSpellSelectGroupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSpellSelectGroupWidget>();
	}
};
static_assert(alignof(UGameSpellSelectGroupWidget) == 0x000008, "Wrong alignment on UGameSpellSelectGroupWidget");
static_assert(sizeof(UGameSpellSelectGroupWidget) == 0x000508, "Wrong size on UGameSpellSelectGroupWidget");
static_assert(offsetof(UGameSpellSelectGroupWidget, SelectedSpellIndex) == 0x0004E8, "Member 'UGameSpellSelectGroupWidget::SelectedSpellIndex' has a wrong offset!");
static_assert(offsetof(UGameSpellSelectGroupWidget, PlayerCharacter) == 0x000500, "Member 'UGameSpellSelectGroupWidget::PlayerCharacter' has a wrong offset!");

// Class DungeonCrawler.GameSpellSlotWidget
// 0x0000 (0x0490 - 0x0490)
class UGameSpellSlotWidget final : public USpellSlotWidgetBase
{
public:
	int32 GetSpellHealthCost();
	void OnSelectionChanged(bool bIsSelected);
	void SelectionChange(bool bIsSelected);

	float GetSpellChargedPercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSpellSlotWidget">();
	}
	static class UGameSpellSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSpellSlotWidget>();
	}
};
static_assert(alignof(UGameSpellSlotWidget) == 0x000008, "Wrong alignment on UGameSpellSlotWidget");
static_assert(sizeof(UGameSpellSlotWidget) == 0x000490, "Wrong size on UGameSpellSlotWidget");

// Class DungeonCrawler.GameTavernStartTimerWidget
// 0x0008 (0x0380 - 0x0378)
class UGameTavernStartTimerWidget final : public UTimerWidgetBase
{
public:
	int32                                         NumCurrentPlayers;                                 // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumMaxPlayers;                                     // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerCount(int32 NewValue, int32 OldValue);
	void OnPlayerLimit(int32 NewValue, int32 OldValue);
	void OnUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTavernStartTimerWidget">();
	}
	static class UGameTavernStartTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTavernStartTimerWidget>();
	}
};
static_assert(alignof(UGameTavernStartTimerWidget) == 0x000008, "Wrong alignment on UGameTavernStartTimerWidget");
static_assert(sizeof(UGameTavernStartTimerWidget) == 0x000380, "Wrong size on UGameTavernStartTimerWidget");
static_assert(offsetof(UGameTavernStartTimerWidget, NumCurrentPlayers) == 0x000378, "Member 'UGameTavernStartTimerWidget::NumCurrentPlayers' has a wrong offset!");
static_assert(offsetof(UGameTavernStartTimerWidget, NumMaxPlayers) == 0x00037C, "Member 'UGameTavernStartTimerWidget::NumMaxPlayers' has a wrong offset!");

// Class DungeonCrawler.GameVoipComponent
// 0x0078 (0x02B8 - 0x0240)
class UGameVoipComponent : public UDCVoipComponent
{
public:
	uint8                                         Pad_2846[0x28];                                    // 0x0240(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCAccountId, struct FBindAccountUserData> BindAccountUserDataMap;                            // 0x0268(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameVoipComponent">();
	}
	static class UGameVoipComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameVoipComponent>();
	}
};
static_assert(alignof(UGameVoipComponent) == 0x000008, "Wrong alignment on UGameVoipComponent");
static_assert(sizeof(UGameVoipComponent) == 0x0002B8, "Wrong size on UGameVoipComponent");
static_assert(offsetof(UGameVoipComponent, BindAccountUserDataMap) == 0x000268, "Member 'UGameVoipComponent::BindAccountUserDataMap' has a wrong offset!");

// Class DungeonCrawler.GameVoipInterface
// 0x0000 (0x0028 - 0x0028)
class IGameVoipInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameVoipInterface">();
	}
	static class IGameVoipInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameVoipInterface>();
	}
};
static_assert(alignof(IGameVoipInterface) == 0x000008, "Wrong alignment on IGameVoipInterface");
static_assert(sizeof(IGameVoipInterface) == 0x000028, "Wrong size on IGameVoipInterface");

// Class DungeonCrawler.GA_ActivateItemBase
// 0x0040 (0x05E0 - 0x05A0)
class UGA_ActivateItemBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnSourceObject;                       // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateTag;                                       // 0x05B0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DeactivateTag;                                     // 0x05B8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2847[0x8];                                     // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           OtherHandIACompletedHandle;                        // 0x05C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           OtherHandTriggerEventTag;                          // 0x05D0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           OtherHandEnablingEventTag;                         // 0x05D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OtherHandIACompleted();
	void OtherHandIAStarted();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ActivateItemBase">();
	}
	static class UGA_ActivateItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ActivateItemBase>();
	}
};
static_assert(alignof(UGA_ActivateItemBase) == 0x000008, "Wrong alignment on UGA_ActivateItemBase");
static_assert(sizeof(UGA_ActivateItemBase) == 0x0005E0, "Wrong size on UGA_ActivateItemBase");
static_assert(offsetof(UGA_ActivateItemBase, MontageToPlay) == 0x0005A0, "Member 'UGA_ActivateItemBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_ActivateItemBase, MontageToPlayOnSourceObject) == 0x0005A8, "Member 'UGA_ActivateItemBase::MontageToPlayOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_ActivateItemBase, ActivateTag) == 0x0005B0, "Member 'UGA_ActivateItemBase::ActivateTag' has a wrong offset!");
static_assert(offsetof(UGA_ActivateItemBase, DeactivateTag) == 0x0005B8, "Member 'UGA_ActivateItemBase::DeactivateTag' has a wrong offset!");
static_assert(offsetof(UGA_ActivateItemBase, OtherHandIACompletedHandle) == 0x0005C8, "Member 'UGA_ActivateItemBase::OtherHandIACompletedHandle' has a wrong offset!");
static_assert(offsetof(UGA_ActivateItemBase, OtherHandTriggerEventTag) == 0x0005D0, "Member 'UGA_ActivateItemBase::OtherHandTriggerEventTag' has a wrong offset!");
static_assert(offsetof(UGA_ActivateItemBase, OtherHandEnablingEventTag) == 0x0005D8, "Member 'UGA_ActivateItemBase::OtherHandEnablingEventTag' has a wrong offset!");

// Class DungeonCrawler.GA_AuraBase
// 0x0070 (0x0610 - 0x05A0)
class UGA_AuraBase : public UDCGameplayAbilityBase
{
public:
	TSubclassOf<class AActor>                     TargetActorClass;                                  // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePremadeSpec;                                   // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2848[0x3];                                     // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        GameplayCueTag;                                    // 0x05AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ImmuneStateTag;                                    // 0x05B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreAuraDuration;                                   // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           AuraTargetActorSet;                                // 0x05C0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void AbilityEnded();
	void OnAntiAuraOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnAntiAuraOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnAuraOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnAuraOverlapBeginEvent(class AActor* TargetActor);
	void OnAuraOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnAuraOverlapEndEvent(class AActor* TargetActor);
	void OnAuraTargetGameplayTag(class AActor* InTargetActor, const struct FGameplayTag& InGameplayTag, int32 InCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_AuraBase">();
	}
	static class UGA_AuraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_AuraBase>();
	}
};
static_assert(alignof(UGA_AuraBase) == 0x000008, "Wrong alignment on UGA_AuraBase");
static_assert(sizeof(UGA_AuraBase) == 0x000610, "Wrong size on UGA_AuraBase");
static_assert(offsetof(UGA_AuraBase, TargetActorClass) == 0x0005A0, "Member 'UGA_AuraBase::TargetActorClass' has a wrong offset!");
static_assert(offsetof(UGA_AuraBase, bUsePremadeSpec) == 0x0005A8, "Member 'UGA_AuraBase::bUsePremadeSpec' has a wrong offset!");
static_assert(offsetof(UGA_AuraBase, GameplayCueTag) == 0x0005AC, "Member 'UGA_AuraBase::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGA_AuraBase, ImmuneStateTag) == 0x0005B4, "Member 'UGA_AuraBase::ImmuneStateTag' has a wrong offset!");
static_assert(offsetof(UGA_AuraBase, PreAuraDuration) == 0x0005BC, "Member 'UGA_AuraBase::PreAuraDuration' has a wrong offset!");
static_assert(offsetof(UGA_AuraBase, AuraTargetActorSet) == 0x0005C0, "Member 'UGA_AuraBase::AuraTargetActorSet' has a wrong offset!");

// Class DungeonCrawler.AuraTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IAuraTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuraTargetInterface">();
	}
	static class IAuraTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAuraTargetInterface>();
	}
};
static_assert(alignof(IAuraTargetInterface) == 0x000008, "Wrong alignment on IAuraTargetInterface");
static_assert(sizeof(IAuraTargetInterface) == 0x000028, "Wrong size on IAuraTargetInterface");

// Class DungeonCrawler.GA_BowAttackBase
// 0x0010 (0x0670 - 0x0660)
class UGA_BowAttackBase : public UGA_ChargedRangedAttackBase
{
public:
	class UAnimMontage*                           NimbleHandMontageToPlay;                           // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NimbleHandMontageToPlayOnSourceObject;             // 0x0668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_BowAttackBase">();
	}
	static class UGA_BowAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_BowAttackBase>();
	}
};
static_assert(alignof(UGA_BowAttackBase) == 0x000008, "Wrong alignment on UGA_BowAttackBase");
static_assert(sizeof(UGA_BowAttackBase) == 0x000670, "Wrong size on UGA_BowAttackBase");
static_assert(offsetof(UGA_BowAttackBase, NimbleHandMontageToPlay) == 0x000660, "Member 'UGA_BowAttackBase::NimbleHandMontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_BowAttackBase, NimbleHandMontageToPlayOnSourceObject) == 0x000668, "Member 'UGA_BowAttackBase::NimbleHandMontageToPlayOnSourceObject' has a wrong offset!");

// Class DungeonCrawler.GA_BowQuickShotBase
// 0x0008 (0x0660 - 0x0658)
class UGA_BowQuickShotBase : public UGA_RangedAttackBase
{
public:
	int32                                         AmmoWholeUsage;                                    // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284E[0x4];                                     // 0x065C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputActionCompleted();
	void InputActionStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_BowQuickShotBase">();
	}
	static class UGA_BowQuickShotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_BowQuickShotBase>();
	}
};
static_assert(alignof(UGA_BowQuickShotBase) == 0x000008, "Wrong alignment on UGA_BowQuickShotBase");
static_assert(sizeof(UGA_BowQuickShotBase) == 0x000660, "Wrong size on UGA_BowQuickShotBase");
static_assert(offsetof(UGA_BowQuickShotBase, AmmoWholeUsage) == 0x000658, "Member 'UGA_BowQuickShotBase::AmmoWholeUsage' has a wrong offset!");

// Class DungeonCrawler.GA_CaveCollapseBase
// 0x0030 (0x05D0 - 0x05A0)
class UGA_CaveCollapseBase : public UDCGameplayAbilityBase
{
public:
	bool                                          bRepeat;                                           // 0x05A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284F[0x3];                                     // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollapseInterval;                                  // 0x05A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollapseEffectDelay;                               // 0x05A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CollapseEffectTag;                                 // 0x05AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CollapseHitTag;                                    // 0x05B4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2850[0x14];                                    // 0x05BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerOnCaveCollapseApplyEffect();
	void ServerOnCaveCollapseStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_CaveCollapseBase">();
	}
	static class UGA_CaveCollapseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_CaveCollapseBase>();
	}
};
static_assert(alignof(UGA_CaveCollapseBase) == 0x000008, "Wrong alignment on UGA_CaveCollapseBase");
static_assert(sizeof(UGA_CaveCollapseBase) == 0x0005D0, "Wrong size on UGA_CaveCollapseBase");
static_assert(offsetof(UGA_CaveCollapseBase, bRepeat) == 0x0005A0, "Member 'UGA_CaveCollapseBase::bRepeat' has a wrong offset!");
static_assert(offsetof(UGA_CaveCollapseBase, CollapseInterval) == 0x0005A4, "Member 'UGA_CaveCollapseBase::CollapseInterval' has a wrong offset!");
static_assert(offsetof(UGA_CaveCollapseBase, CollapseEffectDelay) == 0x0005A8, "Member 'UGA_CaveCollapseBase::CollapseEffectDelay' has a wrong offset!");
static_assert(offsetof(UGA_CaveCollapseBase, CollapseEffectTag) == 0x0005AC, "Member 'UGA_CaveCollapseBase::CollapseEffectTag' has a wrong offset!");
static_assert(offsetof(UGA_CaveCollapseBase, CollapseHitTag) == 0x0005B4, "Member 'UGA_CaveCollapseBase::CollapseHitTag' has a wrong offset!");

// Class DungeonCrawler.GA_CharacterJump
// 0x0000 (0x05A0 - 0x05A0)
class UGA_CharacterJump : public UDCGameplayAbilityBase
{
public:
	void EventReceived(const struct FGameplayEventData& EventData);
	void OnMovementModeChange(EMovementMode MovementMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_CharacterJump">();
	}
	static class UGA_CharacterJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_CharacterJump>();
	}
};
static_assert(alignof(UGA_CharacterJump) == 0x000008, "Wrong alignment on UGA_CharacterJump");
static_assert(sizeof(UGA_CharacterJump) == 0x0005A0, "Wrong size on UGA_CharacterJump");

// Class DungeonCrawler.GA_CharacterLadderJump
// 0x0000 (0x05A0 - 0x05A0)
class UGA_CharacterLadderJump : public UDCGameplayAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_CharacterLadderJump">();
	}
	static class UGA_CharacterLadderJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_CharacterLadderJump>();
	}
};
static_assert(alignof(UGA_CharacterLadderJump) == 0x000008, "Wrong alignment on UGA_CharacterLadderJump");
static_assert(sizeof(UGA_CharacterLadderJump) == 0x0005A0, "Wrong size on UGA_CharacterLadderJump");

// Class DungeonCrawler.GA_Drawbridge
// 0x0018 (0x05B8 - 0x05A0)
class UGA_Drawbridge : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2851[0x10];                                    // 0x05A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void FinishTickTask();
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void UpdatePlayCurrentTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_Drawbridge">();
	}
	static class UGA_Drawbridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_Drawbridge>();
	}
};
static_assert(alignof(UGA_Drawbridge) == 0x000008, "Wrong alignment on UGA_Drawbridge");
static_assert(sizeof(UGA_Drawbridge) == 0x0005B8, "Wrong size on UGA_Drawbridge");
static_assert(offsetof(UGA_Drawbridge, MontageToPlay) == 0x0005A0, "Member 'UGA_Drawbridge::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.GA_Drop
// 0x0028 (0x05C8 - 0x05A0)
class UGA_Drop : public UDCGameplayAbilityBase
{
public:
	bool                                          bFailedDropItem;                                   // 0x05A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2852[0x7];                                     // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHoldingItem;                                      // 0x05B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2853[0x3];                                     // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        SoundDataId;                                       // 0x05B4(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2854[0x4];                                     // 0x05C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndSync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_Drop">();
	}
	static class UGA_Drop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_Drop>();
	}
};
static_assert(alignof(UGA_Drop) == 0x000008, "Wrong alignment on UGA_Drop");
static_assert(sizeof(UGA_Drop) == 0x0005C8, "Wrong size on UGA_Drop");
static_assert(offsetof(UGA_Drop, bFailedDropItem) == 0x0005A0, "Member 'UGA_Drop::bFailedDropItem' has a wrong offset!");
static_assert(offsetof(UGA_Drop, OwnerActor) == 0x0005A8, "Member 'UGA_Drop::OwnerActor' has a wrong offset!");
static_assert(offsetof(UGA_Drop, bHoldingItem) == 0x0005B0, "Member 'UGA_Drop::bHoldingItem' has a wrong offset!");
static_assert(offsetof(UGA_Drop, SoundDataId) == 0x0005B4, "Member 'UGA_Drop::SoundDataId' has a wrong offset!");

// Class DungeonCrawler.GA_PlayMontageAndWaitForEvent
// 0x0008 (0x05A8 - 0x05A0)
class UGA_PlayMontageAndWaitForEvent : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayMontageAndWaitForEvent">();
	}
	static class UGA_PlayMontageAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayMontageAndWaitForEvent>();
	}
};
static_assert(alignof(UGA_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on UGA_PlayMontageAndWaitForEvent");
static_assert(sizeof(UGA_PlayMontageAndWaitForEvent) == 0x0005A8, "Wrong size on UGA_PlayMontageAndWaitForEvent");
static_assert(offsetof(UGA_PlayMontageAndWaitForEvent, MontageToPlay) == 0x0005A0, "Member 'UGA_PlayMontageAndWaitForEvent::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.GA_EmoteBase
// 0x0010 (0x05B8 - 0x05A8)
class UGA_EmoteBase : public UGA_PlayMontageAndWaitForEvent
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2855[0x8];                                     // 0x05B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitKnockBackAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_EmoteBase">();
	}
	static class UGA_EmoteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_EmoteBase>();
	}
};
static_assert(alignof(UGA_EmoteBase) == 0x000008, "Wrong alignment on UGA_EmoteBase");
static_assert(sizeof(UGA_EmoteBase) == 0x0005B8, "Wrong size on UGA_EmoteBase");
static_assert(offsetof(UGA_EmoteBase, GameplayCueTag) == 0x0005A8, "Member 'UGA_EmoteBase::GameplayCueTag' has a wrong offset!");

// Class DungeonCrawler.GA_EmoteRandom
// 0x0010 (0x05C0 - 0x05B0)
class UGA_EmoteRandom : public UGA_PlayRandomMontageWaitForEvent
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2856[0x8];                                     // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitKnockBackAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_EmoteRandom">();
	}
	static class UGA_EmoteRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_EmoteRandom>();
	}
};
static_assert(alignof(UGA_EmoteRandom) == 0x000008, "Wrong alignment on UGA_EmoteRandom");
static_assert(sizeof(UGA_EmoteRandom) == 0x0005C0, "Wrong size on UGA_EmoteRandom");
static_assert(offsetof(UGA_EmoteRandom, GameplayCueTag) == 0x0005B0, "Member 'UGA_EmoteRandom::GameplayCueTag' has a wrong offset!");

// Class DungeonCrawler.GA_Equip
// 0x0030 (0x05D0 - 0x05A0)
class UGA_Equip : public UDCGameplayAbilityBase
{
public:
	EEquipmentQuickSlotType                       NextQuickSlotType;                                 // 0x05A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoFillUtilitySlot;                              // 0x05A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTryingEquip;                                      // 0x05A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2857[0x5];                                     // 0x05A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItem*>                          TargetItems;                                       // 0x05A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 Character;                                         // 0x05B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentInventoryComponent*           EquipmentComponent;                                // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           GameplayTagToAdd;                                  // 0x05C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMontageEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnMontageFinished(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_Equip">();
	}
	static class UGA_Equip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_Equip>();
	}
};
static_assert(alignof(UGA_Equip) == 0x000008, "Wrong alignment on UGA_Equip");
static_assert(sizeof(UGA_Equip) == 0x0005D0, "Wrong size on UGA_Equip");
static_assert(offsetof(UGA_Equip, NextQuickSlotType) == 0x0005A0, "Member 'UGA_Equip::NextQuickSlotType' has a wrong offset!");
static_assert(offsetof(UGA_Equip, bAutoFillUtilitySlot) == 0x0005A1, "Member 'UGA_Equip::bAutoFillUtilitySlot' has a wrong offset!");
static_assert(offsetof(UGA_Equip, bTryingEquip) == 0x0005A2, "Member 'UGA_Equip::bTryingEquip' has a wrong offset!");
static_assert(offsetof(UGA_Equip, TargetItems) == 0x0005A8, "Member 'UGA_Equip::TargetItems' has a wrong offset!");
static_assert(offsetof(UGA_Equip, Character) == 0x0005B8, "Member 'UGA_Equip::Character' has a wrong offset!");
static_assert(offsetof(UGA_Equip, EquipmentComponent) == 0x0005C0, "Member 'UGA_Equip::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(UGA_Equip, GameplayTagToAdd) == 0x0005C8, "Member 'UGA_Equip::GameplayTagToAdd' has a wrong offset!");

// Class DungeonCrawler.GA_HuntingTrapDisarmPassiveBase
// 0x0060 (0x0628 - 0x05C8)
class UGA_HuntingTrapDisarmPassiveBase : public UGA_StoppablePassiveBase
{
public:
	uint8                                         Pad_2858[0x8];                                     // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FInteractionData> CurrentInteractableDatas;                          // 0x05D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2859[0x8];                                     // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearDisarmTarget();
	void OnTargetGameplayTagChange(const struct FGameplayTag& InGameplayTag, int32 InCount);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void SetDisarmTarget(class APropsActorBase* TargetHuntingTrap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_HuntingTrapDisarmPassiveBase">();
	}
	static class UGA_HuntingTrapDisarmPassiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_HuntingTrapDisarmPassiveBase>();
	}
};
static_assert(alignof(UGA_HuntingTrapDisarmPassiveBase) == 0x000008, "Wrong alignment on UGA_HuntingTrapDisarmPassiveBase");
static_assert(sizeof(UGA_HuntingTrapDisarmPassiveBase) == 0x000628, "Wrong size on UGA_HuntingTrapDisarmPassiveBase");
static_assert(offsetof(UGA_HuntingTrapDisarmPassiveBase, CurrentInteractableDatas) == 0x0005D0, "Member 'UGA_HuntingTrapDisarmPassiveBase::CurrentInteractableDatas' has a wrong offset!");

// Class DungeonCrawler.GA_ItemActivateBase
// 0x0000 (0x05A0 - 0x05A0)
class UGA_ItemActivateBase : public UDCGameplayAbilityBase
{
public:
	void Activated();
	void Deactivated();
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ItemActivateBase">();
	}
	static class UGA_ItemActivateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ItemActivateBase>();
	}
};
static_assert(alignof(UGA_ItemActivateBase) == 0x000008, "Wrong alignment on UGA_ItemActivateBase");
static_assert(sizeof(UGA_ItemActivateBase) == 0x0005A0, "Wrong size on UGA_ItemActivateBase");

// Class DungeonCrawler.GA_ItemConsumeBase
// 0x01A8 (0x0758 - 0x05B0)
class UGA_ItemConsumeBase : public UDCItemActorAbilityBase
{
public:
	class UAnimMontage*                           PreConsumeMontage;                                 // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ConsumeMontage;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PreConsumeMontageOnSourceObject;                   // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ConsumeMontageOnSourceObject;                      // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemConsumeRandomEffectData>   RandomEffectDataArray;                             // 0x05D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDCItemInfo                            ConsumeItemInfo;                                   // 0x05E0(0x0168)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCItemConsumeDataAsset*                ConsumeDataAsset;                                  // 0x0748(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285A[0x8];                                     // 0x0750(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ConsumeEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnConsumeEndEventReceived();
	void OnConsumeMontageCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnConsumeStartEventReceived(const float ConsumeDuration);
	void OnConsumeSucceed();
	void OnEndSync();
	void OnFinish();
	void OnStartSync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ItemConsumeBase">();
	}
	static class UGA_ItemConsumeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ItemConsumeBase>();
	}
};
static_assert(alignof(UGA_ItemConsumeBase) == 0x000008, "Wrong alignment on UGA_ItemConsumeBase");
static_assert(sizeof(UGA_ItemConsumeBase) == 0x000758, "Wrong size on UGA_ItemConsumeBase");
static_assert(offsetof(UGA_ItemConsumeBase, PreConsumeMontage) == 0x0005B0, "Member 'UGA_ItemConsumeBase::PreConsumeMontage' has a wrong offset!");
static_assert(offsetof(UGA_ItemConsumeBase, ConsumeMontage) == 0x0005B8, "Member 'UGA_ItemConsumeBase::ConsumeMontage' has a wrong offset!");
static_assert(offsetof(UGA_ItemConsumeBase, PreConsumeMontageOnSourceObject) == 0x0005C0, "Member 'UGA_ItemConsumeBase::PreConsumeMontageOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_ItemConsumeBase, ConsumeMontageOnSourceObject) == 0x0005C8, "Member 'UGA_ItemConsumeBase::ConsumeMontageOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_ItemConsumeBase, RandomEffectDataArray) == 0x0005D0, "Member 'UGA_ItemConsumeBase::RandomEffectDataArray' has a wrong offset!");
static_assert(offsetof(UGA_ItemConsumeBase, ConsumeItemInfo) == 0x0005E0, "Member 'UGA_ItemConsumeBase::ConsumeItemInfo' has a wrong offset!");
static_assert(offsetof(UGA_ItemConsumeBase, ConsumeDataAsset) == 0x000748, "Member 'UGA_ItemConsumeBase::ConsumeDataAsset' has a wrong offset!");

// Class DungeonCrawler.GA_MultiShotBase
// 0x0000 (0x0658 - 0x0658)
class UGA_MultiShotBase : public UGA_RangedAttackBase
{
public:
	void InputActionCompleted();
	void InputActionStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MultiShotBase">();
	}
	static class UGA_MultiShotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MultiShotBase>();
	}
};
static_assert(alignof(UGA_MultiShotBase) == 0x000008, "Wrong alignment on UGA_MultiShotBase");
static_assert(sizeof(UGA_MultiShotBase) == 0x000658, "Wrong size on UGA_MultiShotBase");

// Class DungeonCrawler.GA_MusicInstantBase
// 0x0000 (0x0800 - 0x0800)
class UGA_MusicInstantBase : public UGA_MusicBase
{
public:
	void OnTargetActorOverlap(const TArray<class AActor*>& InTargetActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_MusicInstantBase">();
	}
	static class UGA_MusicInstantBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_MusicInstantBase>();
	}
};
static_assert(alignof(UGA_MusicInstantBase) == 0x000008, "Wrong alignment on UGA_MusicInstantBase");
static_assert(sizeof(UGA_MusicInstantBase) == 0x000800, "Wrong size on UGA_MusicInstantBase");

// Class DungeonCrawler.GA_PaviseInstall
// 0x0020 (0x05C0 - 0x05A0)
class UGA_PaviseInstall : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           MontageToPlayOnSourceObject;                       // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APavisePropBase>            InstalledActorClass;                               // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285B[0x8];                                     // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnVelocityChange();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PaviseInstall">();
	}
	static class UGA_PaviseInstall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PaviseInstall>();
	}
};
static_assert(alignof(UGA_PaviseInstall) == 0x000008, "Wrong alignment on UGA_PaviseInstall");
static_assert(sizeof(UGA_PaviseInstall) == 0x0005C0, "Wrong size on UGA_PaviseInstall");
static_assert(offsetof(UGA_PaviseInstall, MontageToPlay) == 0x0005A0, "Member 'UGA_PaviseInstall::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_PaviseInstall, MontageToPlayOnSourceObject) == 0x0005A8, "Member 'UGA_PaviseInstall::MontageToPlayOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PaviseInstall, InstalledActorClass) == 0x0005B0, "Member 'UGA_PaviseInstall::InstalledActorClass' has a wrong offset!");

// Class DungeonCrawler.GA_Pickpocket
// 0x0010 (0x05B0 - 0x05A0)
class UGA_Pickpocket : public UDCGameplayAbilityBase
{
public:
	struct FPrimaryAssetId                        IdGroupAssetId;                                    // 0x05A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_Pickpocket">();
	}
	static class UGA_Pickpocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_Pickpocket>();
	}
};
static_assert(alignof(UGA_Pickpocket) == 0x000008, "Wrong alignment on UGA_Pickpocket");
static_assert(sizeof(UGA_Pickpocket) == 0x0005B0, "Wrong size on UGA_Pickpocket");
static_assert(offsetof(UGA_Pickpocket, IdGroupAssetId) == 0x0005A0, "Member 'UGA_Pickpocket::IdGroupAssetId' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerCharMeleeAttackBase
// 0x0070 (0x06D0 - 0x0660)
class UGA_PlayerCharMeleeAttackBase : public UGA_MeleeAttackBase
{
public:
	uint8                                         Pad_285C[0x4];                                     // 0x0660(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComboInputQueueTime;                               // 0x0664(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ComboIACompletedHandle;                            // 0x0668(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           OtherHandIACompletedHandle;                        // 0x0670(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           AddLooseTagNextTickTimerHandle;                    // 0x0678(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ComboTriggerTag;                                   // 0x0680(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ComboInputTag;                                     // 0x0688(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           OtherHandInputTag;                                 // 0x0690(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           OtherHandTriggerEventTag;                          // 0x0698(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           OtherHandEnablingEventTag;                         // 0x06A0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ComboIA;                                           // 0x06A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OtherHandIA;                                       // 0x06B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x06B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AItemActor*                             WeaponItemActor;                                   // 0x06C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCItemDataAsset*                       WeaponItemDataAsset;                               // 0x06C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ComboIACompleted();
	void ComboIAStarted();
	void OnReceiveTargetDataEnd();
	void OnReceiveTargetDataStart();
	void OtherHandIACompleted();
	void OtherHandIAStarted();
	void ReceivedServerTargetData(const struct FGameplayAbilityTargetDataHandle& InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerCharMeleeAttackBase">();
	}
	static class UGA_PlayerCharMeleeAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerCharMeleeAttackBase>();
	}
};
static_assert(alignof(UGA_PlayerCharMeleeAttackBase) == 0x000008, "Wrong alignment on UGA_PlayerCharMeleeAttackBase");
static_assert(sizeof(UGA_PlayerCharMeleeAttackBase) == 0x0006D0, "Wrong size on UGA_PlayerCharMeleeAttackBase");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, ComboInputQueueTime) == 0x000664, "Member 'UGA_PlayerCharMeleeAttackBase::ComboInputQueueTime' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, ComboIACompletedHandle) == 0x000668, "Member 'UGA_PlayerCharMeleeAttackBase::ComboIACompletedHandle' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, OtherHandIACompletedHandle) == 0x000670, "Member 'UGA_PlayerCharMeleeAttackBase::OtherHandIACompletedHandle' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, AddLooseTagNextTickTimerHandle) == 0x000678, "Member 'UGA_PlayerCharMeleeAttackBase::AddLooseTagNextTickTimerHandle' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, ComboTriggerTag) == 0x000680, "Member 'UGA_PlayerCharMeleeAttackBase::ComboTriggerTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, ComboInputTag) == 0x000688, "Member 'UGA_PlayerCharMeleeAttackBase::ComboInputTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, OtherHandInputTag) == 0x000690, "Member 'UGA_PlayerCharMeleeAttackBase::OtherHandInputTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, OtherHandTriggerEventTag) == 0x000698, "Member 'UGA_PlayerCharMeleeAttackBase::OtherHandTriggerEventTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, OtherHandEnablingEventTag) == 0x0006A0, "Member 'UGA_PlayerCharMeleeAttackBase::OtherHandEnablingEventTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, ComboIA) == 0x0006A8, "Member 'UGA_PlayerCharMeleeAttackBase::ComboIA' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, OtherHandIA) == 0x0006B0, "Member 'UGA_PlayerCharMeleeAttackBase::OtherHandIA' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, PlayerCharacter) == 0x0006B8, "Member 'UGA_PlayerCharMeleeAttackBase::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, WeaponItemActor) == 0x0006C0, "Member 'UGA_PlayerCharMeleeAttackBase::WeaponItemActor' has a wrong offset!");
static_assert(offsetof(UGA_PlayerCharMeleeAttackBase, WeaponItemDataAsset) == 0x0006C8, "Member 'UGA_PlayerCharMeleeAttackBase::WeaponItemDataAsset' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerMagicWandUseBase
// 0x0238 (0x07D8 - 0x05A0)
class UGA_PlayerMagicWandUseBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlayOnCasting;                            // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnChanneling;                         // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnInstant;                            // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnCastingSourceObject;                // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnChannelingSourceObject;             // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnInstantSourceObject;                // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckPlayRate;                                     // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckPlayRateDuration;                             // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckBlendOutTime;                                 // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FireSocketName;                                    // 0x05DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285D[0x4];                                     // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCGATA_LineCollision*                  TargetActor;                                       // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_Repeat*                    ChannelingTask;                                    // 0x05F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285E[0x1E0];                                   // 0x05F8(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnChannelingAction(int32 ActionCounter);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnFire();
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnInterruptFinish();
	void OnRelease();
	void OnStuck();
	void OnStuckFinish();
	void OnVelocityChange();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData);
	void ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerMagicWandUseBase">();
	}
	static class UGA_PlayerMagicWandUseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerMagicWandUseBase>();
	}
};
static_assert(alignof(UGA_PlayerMagicWandUseBase) == 0x000008, "Wrong alignment on UGA_PlayerMagicWandUseBase");
static_assert(sizeof(UGA_PlayerMagicWandUseBase) == 0x0007D8, "Wrong size on UGA_PlayerMagicWandUseBase");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, MontageToPlayOnCasting) == 0x0005A0, "Member 'UGA_PlayerMagicWandUseBase::MontageToPlayOnCasting' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, MontageToPlayOnChanneling) == 0x0005A8, "Member 'UGA_PlayerMagicWandUseBase::MontageToPlayOnChanneling' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, MontageToPlayOnInstant) == 0x0005B0, "Member 'UGA_PlayerMagicWandUseBase::MontageToPlayOnInstant' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, MontageToPlayOnCastingSourceObject) == 0x0005B8, "Member 'UGA_PlayerMagicWandUseBase::MontageToPlayOnCastingSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, MontageToPlayOnChannelingSourceObject) == 0x0005C0, "Member 'UGA_PlayerMagicWandUseBase::MontageToPlayOnChannelingSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, MontageToPlayOnInstantSourceObject) == 0x0005C8, "Member 'UGA_PlayerMagicWandUseBase::MontageToPlayOnInstantSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, StuckPlayRate) == 0x0005D0, "Member 'UGA_PlayerMagicWandUseBase::StuckPlayRate' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, StuckPlayRateDuration) == 0x0005D4, "Member 'UGA_PlayerMagicWandUseBase::StuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, StuckBlendOutTime) == 0x0005D8, "Member 'UGA_PlayerMagicWandUseBase::StuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, FireSocketName) == 0x0005DC, "Member 'UGA_PlayerMagicWandUseBase::FireSocketName' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, TargetActor) == 0x0005E8, "Member 'UGA_PlayerMagicWandUseBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMagicWandUseBase, ChannelingTask) == 0x0005F0, "Member 'UGA_PlayerMagicWandUseBase::ChannelingTask' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerMusicPlayBase
// 0x0220 (0x07C0 - 0x05A0)
class UGA_PlayerMusicPlayBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlayOnPlaying;                            // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnPlayingSourceObject;                // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnRandomPlay;                         // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnRandomPlaySourceObject;             // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentMusicTriggerTag;                            // 0x05C0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDesignDataMusic                       CurrentMusicData;                                  // 0x05C8(0x00C8)(NativeAccessSpecifierPrivate)
	class AMusicActor*                            CurrentMusicActor;                                 // 0x0690(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayMusicData*                         CurrentPlayMusicDatas;                             // 0x0698(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayCueParameters                 CurrentCueParams;                                  // 0x06A0(0x00D8)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FRandomStream                          Stream;                                            // 0x0778(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285F[0x40];                                    // 0x0780(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnBad();
	void OnChannelingAction(int32 ActionCounter);
	void OnChannelingFinish();
	void OnChannelingSectionFinish();
	void OnChannelingStartSync();
	void OnCompleted();
	void OnGood();
	void OnMiss();
	void OnPerfect();
	void OnPlayFinish();
	void OnPlayFinishFailed();
	void OnPlayFinishSucceed();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerMusicPlayBase">();
	}
	static class UGA_PlayerMusicPlayBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerMusicPlayBase>();
	}
};
static_assert(alignof(UGA_PlayerMusicPlayBase) == 0x000008, "Wrong alignment on UGA_PlayerMusicPlayBase");
static_assert(sizeof(UGA_PlayerMusicPlayBase) == 0x0007C0, "Wrong size on UGA_PlayerMusicPlayBase");
static_assert(offsetof(UGA_PlayerMusicPlayBase, MontageToPlayOnPlaying) == 0x0005A0, "Member 'UGA_PlayerMusicPlayBase::MontageToPlayOnPlaying' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, MontageToPlayOnPlayingSourceObject) == 0x0005A8, "Member 'UGA_PlayerMusicPlayBase::MontageToPlayOnPlayingSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, MontageToPlayOnRandomPlay) == 0x0005B0, "Member 'UGA_PlayerMusicPlayBase::MontageToPlayOnRandomPlay' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, MontageToPlayOnRandomPlaySourceObject) == 0x0005B8, "Member 'UGA_PlayerMusicPlayBase::MontageToPlayOnRandomPlaySourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, CurrentMusicTriggerTag) == 0x0005C0, "Member 'UGA_PlayerMusicPlayBase::CurrentMusicTriggerTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, CurrentMusicData) == 0x0005C8, "Member 'UGA_PlayerMusicPlayBase::CurrentMusicData' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, CurrentMusicActor) == 0x000690, "Member 'UGA_PlayerMusicPlayBase::CurrentMusicActor' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, CurrentPlayMusicDatas) == 0x000698, "Member 'UGA_PlayerMusicPlayBase::CurrentPlayMusicDatas' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, CurrentCueParams) == 0x0006A0, "Member 'UGA_PlayerMusicPlayBase::CurrentCueParams' has a wrong offset!");
static_assert(offsetof(UGA_PlayerMusicPlayBase, Stream) == 0x000778, "Member 'UGA_PlayerMusicPlayBase::Stream' has a wrong offset!");

// Class DungeonCrawler.StatisticsPopup
// 0x0078 (0x0508 - 0x0490)
class UStatisticsPopup final : public UCommonPopupBase
{
public:
	class UComboBoxWidget*                        SeasonComboBox;                                    // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UComboBoxWidget*                        SheetComboBox;                                     // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonListView*                        RankListView;                                      // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonListView*                        StatisticsListView;                                // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLeaderboardInfo                       SelectedLeaderboardInfo;                           // 0x04B0(0x0040)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2860[0x10];                                    // 0x04F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ClassIconTex;                                      // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSeasonComboBoxSelected(class UObject* InItem);
	void OnSheetComboBoxSelected(class UObject* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsPopup">();
	}
	static class UStatisticsPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsPopup>();
	}
};
static_assert(alignof(UStatisticsPopup) == 0x000008, "Wrong alignment on UStatisticsPopup");
static_assert(sizeof(UStatisticsPopup) == 0x000508, "Wrong size on UStatisticsPopup");
static_assert(offsetof(UStatisticsPopup, SeasonComboBox) == 0x000490, "Member 'UStatisticsPopup::SeasonComboBox' has a wrong offset!");
static_assert(offsetof(UStatisticsPopup, SheetComboBox) == 0x000498, "Member 'UStatisticsPopup::SheetComboBox' has a wrong offset!");
static_assert(offsetof(UStatisticsPopup, RankListView) == 0x0004A0, "Member 'UStatisticsPopup::RankListView' has a wrong offset!");
static_assert(offsetof(UStatisticsPopup, StatisticsListView) == 0x0004A8, "Member 'UStatisticsPopup::StatisticsListView' has a wrong offset!");
static_assert(offsetof(UStatisticsPopup, SelectedLeaderboardInfo) == 0x0004B0, "Member 'UStatisticsPopup::SelectedLeaderboardInfo' has a wrong offset!");
static_assert(offsetof(UStatisticsPopup, ClassIconTex) == 0x000500, "Member 'UStatisticsPopup::ClassIconTex' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerShapeShiftSpellCastBase
// 0x0138 (0x06D8 - 0x05A0)
class UGA_PlayerShapeShiftSpellCastBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlayOnCasting;                            // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckPlayRate;                                     // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckPlayRateDuration;                             // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckBlendOutTime;                                 // 0x05B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FireSocketName;                                    // 0x05B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2861[0x4];                                     // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCSpellDataAsset*                      SpellDataAsset;                                    // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADCGATA_LineCollision*                  TargetActor;                                       // 0x05C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2862[0x108];                                   // 0x05D0(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCastTriggerSync();
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnFinish();
	void OnFinishSync();
	void OnFire();
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnInterruptFinish();
	void OnRelease();
	void OnStartSync();
	void OnStuck();
	void OnStuckFinish();
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData);
	void ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerShapeShiftSpellCastBase">();
	}
	static class UGA_PlayerShapeShiftSpellCastBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerShapeShiftSpellCastBase>();
	}
};
static_assert(alignof(UGA_PlayerShapeShiftSpellCastBase) == 0x000008, "Wrong alignment on UGA_PlayerShapeShiftSpellCastBase");
static_assert(sizeof(UGA_PlayerShapeShiftSpellCastBase) == 0x0006D8, "Wrong size on UGA_PlayerShapeShiftSpellCastBase");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, MontageToPlayOnCasting) == 0x0005A0, "Member 'UGA_PlayerShapeShiftSpellCastBase::MontageToPlayOnCasting' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, StuckPlayRate) == 0x0005A8, "Member 'UGA_PlayerShapeShiftSpellCastBase::StuckPlayRate' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, StuckPlayRateDuration) == 0x0005AC, "Member 'UGA_PlayerShapeShiftSpellCastBase::StuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, StuckBlendOutTime) == 0x0005B0, "Member 'UGA_PlayerShapeShiftSpellCastBase::StuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, FireSocketName) == 0x0005B4, "Member 'UGA_PlayerShapeShiftSpellCastBase::FireSocketName' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, SpellDataAsset) == 0x0005C0, "Member 'UGA_PlayerShapeShiftSpellCastBase::SpellDataAsset' has a wrong offset!");
static_assert(offsetof(UGA_PlayerShapeShiftSpellCastBase, TargetActor) == 0x0005C8, "Member 'UGA_PlayerShapeShiftSpellCastBase::TargetActor' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillChannelingBase
// 0x0100 (0x07D0 - 0x06D0)
class UGA_PlayerSkillChannelingBase : public UGA_PlayerSkillBase
{
public:
	struct FGameplayTag                           SkillBuffTag;                                      // 0x06D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlay;                                     // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMoveWhileChanneling;                           // 0x06E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2863[0xEF];                                    // 0x06E1(0x00EF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChannelingFinish();
	void OnChannelingFinishSync();
	void OnChannelingStartSync();
	void OnVelocityChange();
	void ServerOnChannelingAction(int32 ActionCount);
	void ServerOnChannelingAction_BP(const struct FGameplayEventData& EventData, const struct FGameplayCueParameters& CueParams, int32 ActionCount);
	void ServerOnChannelingStart(const struct FGameplayEventData& EventData, const struct FGameplayCueParameters& CueParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillChannelingBase">();
	}
	static class UGA_PlayerSkillChannelingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillChannelingBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillChannelingBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillChannelingBase");
static_assert(sizeof(UGA_PlayerSkillChannelingBase) == 0x0007D0, "Wrong size on UGA_PlayerSkillChannelingBase");
static_assert(offsetof(UGA_PlayerSkillChannelingBase, SkillBuffTag) == 0x0006D0, "Member 'UGA_PlayerSkillChannelingBase::SkillBuffTag' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillChannelingBase, MontageToPlay) == 0x0006D8, "Member 'UGA_PlayerSkillChannelingBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSkillChannelingBase, bCanMoveWhileChanneling) == 0x0006E0, "Member 'UGA_PlayerSkillChannelingBase::bCanMoveWhileChanneling' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillInstantBase
// 0x0008 (0x06D8 - 0x06D0)
class UGA_PlayerSkillInstantBase : public UGA_PlayerSkillBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillInstantBase">();
	}
	static class UGA_PlayerSkillInstantBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillInstantBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillInstantBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillInstantBase");
static_assert(sizeof(UGA_PlayerSkillInstantBase) == 0x0006D8, "Wrong size on UGA_PlayerSkillInstantBase");
static_assert(offsetof(UGA_PlayerSkillInstantBase, MontageToPlay) == 0x0006D0, "Member 'UGA_PlayerSkillInstantBase::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillInstantAndWaitForEndBase
// 0x0008 (0x06E0 - 0x06D8)
class UGA_PlayerSkillInstantAndWaitForEndBase : public UGA_PlayerSkillInstantBase
{
public:
	struct FGameplayTag                           SkillBuffTag;                                      // 0x06D8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ConsumeBuff();
	void OnSkillBuffTagRemoved(int32 NewCount);
	void ServerBuffRemoved();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillInstantAndWaitForEndBase">();
	}
	static class UGA_PlayerSkillInstantAndWaitForEndBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillInstantAndWaitForEndBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillInstantAndWaitForEndBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillInstantAndWaitForEndBase");
static_assert(sizeof(UGA_PlayerSkillInstantAndWaitForEndBase) == 0x0006E0, "Wrong size on UGA_PlayerSkillInstantAndWaitForEndBase");
static_assert(offsetof(UGA_PlayerSkillInstantAndWaitForEndBase, SkillBuffTag) == 0x0006D8, "Member 'UGA_PlayerSkillInstantAndWaitForEndBase::SkillBuffTag' has a wrong offset!");

// Class DungeonCrawler.GA_PlayerSkillWithoutMontageBase
// 0x0000 (0x06D0 - 0x06D0)
class UGA_PlayerSkillWithoutMontageBase : public UGA_PlayerSkillBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSkillWithoutMontageBase">();
	}
	static class UGA_PlayerSkillWithoutMontageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSkillWithoutMontageBase>();
	}
};
static_assert(alignof(UGA_PlayerSkillWithoutMontageBase) == 0x000008, "Wrong alignment on UGA_PlayerSkillWithoutMontageBase");
static_assert(sizeof(UGA_PlayerSkillWithoutMontageBase) == 0x0006D0, "Wrong size on UGA_PlayerSkillWithoutMontageBase");

// Class DungeonCrawler.GA_PlayerSpellCastBase
// 0x0278 (0x0818 - 0x05A0)
class UGA_PlayerSpellCastBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlayOnCasting;                            // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnChanneling;                         // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnInstant;                            // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnCastingSourceObject;                // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnChannelingSourceObject;             // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnInstantSourceObject;                // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckPlayRate;                                     // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckPlayRateDuration;                             // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckBlendOutTime;                                 // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2865[0x4];                                     // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameplayAbilityWorldReticle> ReticleActorClass;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  AreaCollisionProfile;                              // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FireSocketName;                                    // 0x05F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2866[0x4];                                     // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCGATA_LineCollision*                  StuckTargetActor;                                  // 0x0600(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_Repeat*                    ChannelingTask;                                    // 0x0608(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityTask_WaitTargetData*            AreaTargetTask;                                    // 0x0610(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2867[0x200];                                   // 0x0618(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCastTriggerSync();
	void OnChannelingAction(int32 ActionCounter);
	void OnChannelingFinish();
	void OnChannelingFinishSync();
	void OnChannelingTriggerSync();
	void OnChannelingWithoutInterval(int32 ActionCounter);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnFinish();
	void OnFinishSync();
	void OnFire();
	void OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnInterruptFinish();
	void OnRelease();
	void OnStartSync();
	void OnStuck();
	void OnStuckFinish();
	void OnVelocityChange();
	void ReceivedAreaTargetData(const struct FGameplayAbilityTargetDataHandle& InData);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData);
	void SendActivateSpellCrossHairNotify(bool IsActivate);
	void ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_PlayerSpellCastBase">();
	}
	static class UGA_PlayerSpellCastBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_PlayerSpellCastBase>();
	}
};
static_assert(alignof(UGA_PlayerSpellCastBase) == 0x000008, "Wrong alignment on UGA_PlayerSpellCastBase");
static_assert(sizeof(UGA_PlayerSpellCastBase) == 0x000818, "Wrong size on UGA_PlayerSpellCastBase");
static_assert(offsetof(UGA_PlayerSpellCastBase, MontageToPlayOnCasting) == 0x0005A0, "Member 'UGA_PlayerSpellCastBase::MontageToPlayOnCasting' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, MontageToPlayOnChanneling) == 0x0005A8, "Member 'UGA_PlayerSpellCastBase::MontageToPlayOnChanneling' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, MontageToPlayOnInstant) == 0x0005B0, "Member 'UGA_PlayerSpellCastBase::MontageToPlayOnInstant' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, MontageToPlayOnCastingSourceObject) == 0x0005B8, "Member 'UGA_PlayerSpellCastBase::MontageToPlayOnCastingSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, MontageToPlayOnChannelingSourceObject) == 0x0005C0, "Member 'UGA_PlayerSpellCastBase::MontageToPlayOnChannelingSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, MontageToPlayOnInstantSourceObject) == 0x0005C8, "Member 'UGA_PlayerSpellCastBase::MontageToPlayOnInstantSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, StuckPlayRate) == 0x0005D0, "Member 'UGA_PlayerSpellCastBase::StuckPlayRate' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, StuckPlayRateDuration) == 0x0005D4, "Member 'UGA_PlayerSpellCastBase::StuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, StuckBlendOutTime) == 0x0005D8, "Member 'UGA_PlayerSpellCastBase::StuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, ReticleActorClass) == 0x0005E0, "Member 'UGA_PlayerSpellCastBase::ReticleActorClass' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, AreaCollisionProfile) == 0x0005E8, "Member 'UGA_PlayerSpellCastBase::AreaCollisionProfile' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, MaxHeight) == 0x0005F0, "Member 'UGA_PlayerSpellCastBase::MaxHeight' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, FireSocketName) == 0x0005F4, "Member 'UGA_PlayerSpellCastBase::FireSocketName' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, StuckTargetActor) == 0x000600, "Member 'UGA_PlayerSpellCastBase::StuckTargetActor' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, ChannelingTask) == 0x000608, "Member 'UGA_PlayerSpellCastBase::ChannelingTask' has a wrong offset!");
static_assert(offsetof(UGA_PlayerSpellCastBase, AreaTargetTask) == 0x000610, "Member 'UGA_PlayerSpellCastBase::AreaTargetTask' has a wrong offset!");

// Class DungeonCrawler.GA_ProjectileCollision
// 0x0020 (0x05C0 - 0x05A0)
class UGA_ProjectileCollision : public UDCGameplayAbilityBase
{
public:
	class ADCGATA_LineCollision*                  TargetActor;                                       // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameplayCueOnStuckStaticObject;                    // 0x05A8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameplayCueOnStuckCharacter;                       // 0x05B0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameplayCueOnStuckShield;                          // 0x05B8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& Data);
	void TargetDataReceived(const struct FHitResult& Hit);
	void UpdateIgnoreActors(class AActor* InCheckActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ProjectileCollision">();
	}
	static class UGA_ProjectileCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ProjectileCollision>();
	}
};
static_assert(alignof(UGA_ProjectileCollision) == 0x000008, "Wrong alignment on UGA_ProjectileCollision");
static_assert(sizeof(UGA_ProjectileCollision) == 0x0005C0, "Wrong size on UGA_ProjectileCollision");
static_assert(offsetof(UGA_ProjectileCollision, TargetActor) == 0x0005A0, "Member 'UGA_ProjectileCollision::TargetActor' has a wrong offset!");
static_assert(offsetof(UGA_ProjectileCollision, GameplayCueOnStuckStaticObject) == 0x0005A8, "Member 'UGA_ProjectileCollision::GameplayCueOnStuckStaticObject' has a wrong offset!");
static_assert(offsetof(UGA_ProjectileCollision, GameplayCueOnStuckCharacter) == 0x0005B0, "Member 'UGA_ProjectileCollision::GameplayCueOnStuckCharacter' has a wrong offset!");
static_assert(offsetof(UGA_ProjectileCollision, GameplayCueOnStuckShield) == 0x0005B8, "Member 'UGA_ProjectileCollision::GameplayCueOnStuckShield' has a wrong offset!");

// Class DungeonCrawler.GA_ReloadAmmoBase
// 0x0020 (0x05D0 - 0x05B0)
class UGA_ReloadAmmoBase : public UDCItemActorAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayOnSourceObject;                       // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AmmoItemId;                                        // 0x05C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void ActivateCrossHairPullAnimationByCrossbow(float ActionSpeed);
	void CancelReloadByCrossHairAim();
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ReloadAmmoBase">();
	}
	static class UGA_ReloadAmmoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ReloadAmmoBase>();
	}
};
static_assert(alignof(UGA_ReloadAmmoBase) == 0x000008, "Wrong alignment on UGA_ReloadAmmoBase");
static_assert(sizeof(UGA_ReloadAmmoBase) == 0x0005D0, "Wrong size on UGA_ReloadAmmoBase");
static_assert(offsetof(UGA_ReloadAmmoBase, MontageToPlay) == 0x0005B0, "Member 'UGA_ReloadAmmoBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_ReloadAmmoBase, MontageToPlayOnSourceObject) == 0x0005B8, "Member 'UGA_ReloadAmmoBase::MontageToPlayOnSourceObject' has a wrong offset!");
static_assert(offsetof(UGA_ReloadAmmoBase, AmmoItemId) == 0x0005C0, "Member 'UGA_ReloadAmmoBase::AmmoItemId' has a wrong offset!");

// Class DungeonCrawler.GA_ReversibleChangeIdle
// 0x0008 (0x05A8 - 0x05A0)
class UGA_ReversibleChangeIdle : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbilityActivated(const struct FGameplayEventData& TriggerEventData);
	void OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ReversibleChangeIdle">();
	}
	static class UGA_ReversibleChangeIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ReversibleChangeIdle>();
	}
};
static_assert(alignof(UGA_ReversibleChangeIdle) == 0x000008, "Wrong alignment on UGA_ReversibleChangeIdle");
static_assert(sizeof(UGA_ReversibleChangeIdle) == 0x0005A8, "Wrong size on UGA_ReversibleChangeIdle");
static_assert(offsetof(UGA_ReversibleChangeIdle, MontageToPlay) == 0x0005A0, "Member 'UGA_ReversibleChangeIdle::MontageToPlay' has a wrong offset!");

// Class DungeonCrawler.GA_SequenceDamageBase
// 0x0018 (0x05B8 - 0x05A0)
class UGA_SequenceDamageBase : public UDCGameplayAbilityBase
{
public:
	TSubclassOf<class AActor>                     TargetActorClass;                                  // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePremadeSpec;                                   // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2868[0x3];                                     // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        GameplayCueTag;                                    // 0x05AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2869[0x4];                                     // 0x05B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnDamageEvent(class AActor* TargetActor);
	void OnDamageOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnDamageOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SequenceDamageBase">();
	}
	static class UGA_SequenceDamageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SequenceDamageBase>();
	}
};
static_assert(alignof(UGA_SequenceDamageBase) == 0x000008, "Wrong alignment on UGA_SequenceDamageBase");
static_assert(sizeof(UGA_SequenceDamageBase) == 0x0005B8, "Wrong size on UGA_SequenceDamageBase");
static_assert(offsetof(UGA_SequenceDamageBase, TargetActorClass) == 0x0005A0, "Member 'UGA_SequenceDamageBase::TargetActorClass' has a wrong offset!");
static_assert(offsetof(UGA_SequenceDamageBase, bUsePremadeSpec) == 0x0005A8, "Member 'UGA_SequenceDamageBase::bUsePremadeSpec' has a wrong offset!");
static_assert(offsetof(UGA_SequenceDamageBase, GameplayCueTag) == 0x0005AC, "Member 'UGA_SequenceDamageBase::GameplayCueTag' has a wrong offset!");

// Class DungeonCrawler.GA_ShapeShiftEndBase
// 0x0010 (0x05B0 - 0x05A0)
class UGA_ShapeShiftEndBase : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           NextTickTimerHandle;                               // 0x05A8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ShapeShiftEndBase">();
	}
	static class UGA_ShapeShiftEndBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ShapeShiftEndBase>();
	}
};
static_assert(alignof(UGA_ShapeShiftEndBase) == 0x000008, "Wrong alignment on UGA_ShapeShiftEndBase");
static_assert(sizeof(UGA_ShapeShiftEndBase) == 0x0005B0, "Wrong size on UGA_ShapeShiftEndBase");
static_assert(offsetof(UGA_ShapeShiftEndBase, MontageToPlay) == 0x0005A0, "Member 'UGA_ShapeShiftEndBase::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGA_ShapeShiftEndBase, NextTickTimerHandle) == 0x0005A8, "Member 'UGA_ShapeShiftEndBase::NextTickTimerHandle' has a wrong offset!");

// Class DungeonCrawler.GA_SpellCastingAndInstallBase
// 0x0078 (0x06E0 - 0x0668)
class UGA_SpellCastingAndInstallBase : public UGA_SpellCastingAndWaitForEndBase
{
public:
	struct FGameplayTag                           InstallTag;                                        // 0x0668(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BlastTag;                                          // 0x0670(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionHeight;                                   // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TargetActors;                                      // 0x0680(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                InstallLocation;                                   // 0x0690(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectContainerSpec> PremadeEffectContainerSpecArray;                   // 0x06A8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_286C[0x28];                                    // 0x06B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateInstalledSpell(const struct FGameplayTag& OptionalEffectContainerTag);
	void ExecuteBlastGameplayCue();
	bool InstallOnGround();
	void OnSpellBlasted(const TArray<struct FActiveGameplayEffectHandle>& EffectHandles, const struct FGameplayEventData& EventData);
	void OnSpellBlastFinish();
	void SetTargetActorFromBoxOverlapActors(const class UObject* WorldContextObject, const TArray<TSubclassOf<class AActor>>& InTargetClasses, const TArray<class AActor*>& InIgnoreActors);
	void SetTargetActorFromCylinderOverlapActors(const class UObject* WorldContextObject, const TArray<TSubclassOf<class AActor>>& InTargetClasses, const TArray<class AActor*>& InIgnoreActors);
	void SetTargetActorFromSphereOverlapActors(const class UObject* WorldContextObject, const TArray<TSubclassOf<class AActor>>& InTargetClasses, const TArray<class AActor*>& InIgnoreActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SpellCastingAndInstallBase">();
	}
	static class UGA_SpellCastingAndInstallBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SpellCastingAndInstallBase>();
	}
};
static_assert(alignof(UGA_SpellCastingAndInstallBase) == 0x000008, "Wrong alignment on UGA_SpellCastingAndInstallBase");
static_assert(sizeof(UGA_SpellCastingAndInstallBase) == 0x0006E0, "Wrong size on UGA_SpellCastingAndInstallBase");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, InstallTag) == 0x000668, "Member 'UGA_SpellCastingAndInstallBase::InstallTag' has a wrong offset!");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, BlastTag) == 0x000670, "Member 'UGA_SpellCastingAndInstallBase::BlastTag' has a wrong offset!");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, IntervalTime) == 0x000678, "Member 'UGA_SpellCastingAndInstallBase::IntervalTime' has a wrong offset!");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, CollisionHeight) == 0x00067C, "Member 'UGA_SpellCastingAndInstallBase::CollisionHeight' has a wrong offset!");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, TargetActors) == 0x000680, "Member 'UGA_SpellCastingAndInstallBase::TargetActors' has a wrong offset!");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, InstallLocation) == 0x000690, "Member 'UGA_SpellCastingAndInstallBase::InstallLocation' has a wrong offset!");
static_assert(offsetof(UGA_SpellCastingAndInstallBase, PremadeEffectContainerSpecArray) == 0x0006A8, "Member 'UGA_SpellCastingAndInstallBase::PremadeEffectContainerSpecArray' has a wrong offset!");

// Class DungeonCrawler.GA_SpellChannelingBase
// 0x0028 (0x0688 - 0x0660)
class UGA_SpellChannelingBase : public UGA_SpellBase
{
public:
	uint8                                         Pad_286D[0x20];                                    // 0x0660(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionCounter;                                     // 0x0680(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPlayFireCuePerChannelingAction;             // 0x0684(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_286E[0x3];                                     // 0x0685(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnChannelingAction(int32 ChannelingActionCount);
	void OnChannelingCancelled();
	void OnServerChannelingFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SpellChannelingBase">();
	}
	static class UGA_SpellChannelingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SpellChannelingBase>();
	}
};
static_assert(alignof(UGA_SpellChannelingBase) == 0x000008, "Wrong alignment on UGA_SpellChannelingBase");
static_assert(sizeof(UGA_SpellChannelingBase) == 0x000688, "Wrong size on UGA_SpellChannelingBase");
static_assert(offsetof(UGA_SpellChannelingBase, ActionCounter) == 0x000680, "Member 'UGA_SpellChannelingBase::ActionCounter' has a wrong offset!");
static_assert(offsetof(UGA_SpellChannelingBase, bShouldPlayFireCuePerChannelingAction) == 0x000684, "Member 'UGA_SpellChannelingBase::bShouldPlayFireCuePerChannelingAction' has a wrong offset!");

// Class DungeonCrawler.GA_SpellGrantingAbilityBase
// 0x0040 (0x06A0 - 0x0660)
class UGA_SpellGrantingAbilityBase : public UGA_SpellBase
{
public:
	struct FPrimaryAssetId                        GrantingAbilityId;                                 // 0x0660(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GrantedAbilityTag;                                 // 0x0670(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCGameplayAbilityData                 GrantingAbilityData;                               // 0x0678(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SetGrantingAbilityDatas(const struct FPrimaryAssetId& InGrantingAbilityId, const struct FGameplayTag& InGrantedAbilityTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_SpellGrantingAbilityBase">();
	}
	static class UGA_SpellGrantingAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_SpellGrantingAbilityBase>();
	}
};
static_assert(alignof(UGA_SpellGrantingAbilityBase) == 0x000008, "Wrong alignment on UGA_SpellGrantingAbilityBase");
static_assert(sizeof(UGA_SpellGrantingAbilityBase) == 0x0006A0, "Wrong size on UGA_SpellGrantingAbilityBase");
static_assert(offsetof(UGA_SpellGrantingAbilityBase, GrantingAbilityId) == 0x000660, "Member 'UGA_SpellGrantingAbilityBase::GrantingAbilityId' has a wrong offset!");
static_assert(offsetof(UGA_SpellGrantingAbilityBase, GrantedAbilityTag) == 0x000670, "Member 'UGA_SpellGrantingAbilityBase::GrantedAbilityTag' has a wrong offset!");
static_assert(offsetof(UGA_SpellGrantingAbilityBase, GrantingAbilityData) == 0x000678, "Member 'UGA_SpellGrantingAbilityBase::GrantingAbilityData' has a wrong offset!");

// Class DungeonCrawler.GA_WearBase
// 0x0118 (0x06B8 - 0x05A0)
class UGA_WearBase final : public UDCGameplayAbilityBase
{
public:
	class UAnimMontage*                           ChangingMontage;                                   // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemData                              TargetItemData;                                    // 0x05A8(0x0100)(Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x06A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bQuickSlotReserved;                                // 0x06B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEquipmentQuickSlotType                       ReserveQuickSlotType;                              // 0x06B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_286F[0x6];                                     // 0x06B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnChangingMontageCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData);
	void OnEndSync();
	void OnFinish();
	void OnLootTargetRemoved();
	void OnStartSync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_WearBase">();
	}
	static class UGA_WearBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_WearBase>();
	}
};
static_assert(alignof(UGA_WearBase) == 0x000008, "Wrong alignment on UGA_WearBase");
static_assert(sizeof(UGA_WearBase) == 0x0006B8, "Wrong size on UGA_WearBase");
static_assert(offsetof(UGA_WearBase, ChangingMontage) == 0x0005A0, "Member 'UGA_WearBase::ChangingMontage' has a wrong offset!");
static_assert(offsetof(UGA_WearBase, TargetItemData) == 0x0005A8, "Member 'UGA_WearBase::TargetItemData' has a wrong offset!");
static_assert(offsetof(UGA_WearBase, TargetActor) == 0x0006A8, "Member 'UGA_WearBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UGA_WearBase, bQuickSlotReserved) == 0x0006B0, "Member 'UGA_WearBase::bQuickSlotReserved' has a wrong offset!");
static_assert(offsetof(UGA_WearBase, ReserveQuickSlotType) == 0x0006B1, "Member 'UGA_WearBase::ReserveQuickSlotType' has a wrong offset!");

// Class DungeonCrawler.GRACPopupData
// 0x0008 (0x0038 - 0x0030)
class UGRACPopupData final : public UPopupDataBase
{
public:
	int32                                         PopupShowDelaySec;                                 // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2870[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRACPopupData">();
	}
	static class UGRACPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRACPopupData>();
	}
};
static_assert(alignof(UGRACPopupData) == 0x000008, "Wrong alignment on UGRACPopupData");
static_assert(sizeof(UGRACPopupData) == 0x000038, "Wrong size on UGRACPopupData");
static_assert(offsetof(UGRACPopupData, PopupShowDelaySec) == 0x000030, "Member 'UGRACPopupData::PopupShowDelaySec' has a wrong offset!");

// Class DungeonCrawler.MonsterSpawnableInterface
// 0x0000 (0x0028 - 0x0028)
class IMonsterSpawnableInterface final : public IInterface
{
public:
	class ADCMonsterBase* Spawn(TSubclassOf<class ADCMonsterBase> Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterSpawnableInterface">();
	}
	static class IMonsterSpawnableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMonsterSpawnableInterface>();
	}
};
static_assert(alignof(IMonsterSpawnableInterface) == 0x000008, "Wrong alignment on IMonsterSpawnableInterface");
static_assert(sizeof(IMonsterSpawnableInterface) == 0x000028, "Wrong size on IMonsterSpawnableInterface");

// Class DungeonCrawler.ImpactableComponent
// 0x0078 (0x0118 - 0x00A0)
class UImpactableComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2871[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ImpactEnduranceExhausted;                          // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UTagQueryData*>                  ImpactableTagQueryArray;                           // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void SetImpactableQuery(const TArray<struct FPrimaryAssetId>& TagQueryDatas);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	TArray<class UTagQueryData*> GetImpactableTagQueryArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactableComponent">();
	}
	static class UImpactableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpactableComponent>();
	}
};
static_assert(alignof(UImpactableComponent) == 0x000008, "Wrong alignment on UImpactableComponent");
static_assert(sizeof(UImpactableComponent) == 0x000118, "Wrong size on UImpactableComponent");
static_assert(offsetof(UImpactableComponent, ImpactEnduranceExhausted) == 0x0000F8, "Member 'UImpactableComponent::ImpactEnduranceExhausted' has a wrong offset!");
static_assert(offsetof(UImpactableComponent, ImpactableTagQueryArray) == 0x000108, "Member 'UImpactableComponent::ImpactableTagQueryArray' has a wrong offset!");

// Class DungeonCrawler.IMUtilBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UIMUtilBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetProjectVersion(class FString* OutVersion);
	static float GetServerWorldTimeSeconds(const class UObject* WorldContextObject);
	static bool IsServer(const class UObject* WorldContextObject);
	static class FText MakeTextwithParam1(const class FText& Text, const class FText& Param1);
	static class FText MakeTextwithParam2(const class FText& Text, const class FText& Param1, const class FText& Param2);
	static class FText MakeTextwithParam3(const class FText& Text, const class FText& Param1, const class FText& Param2, const class FText& Param3);
	static class FText MakeTextwithParam4(const class FText& Text, const class FText& Param1, const class FText& Param2, const class FText& Param3, const class FText& Param4);
	static class FText MakeTextwithParam5(const class FText& Text, const class FText& Param1, const class FText& Param2, const class FText& Param3, const class FText& Param4, const class FText& Param5);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IMUtilBlueprintLibrary">();
	}
	static class UIMUtilBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIMUtilBlueprintLibrary>();
	}
};
static_assert(alignof(UIMUtilBlueprintLibrary) == 0x000008, "Wrong alignment on UIMUtilBlueprintLibrary");
static_assert(sizeof(UIMUtilBlueprintLibrary) == 0x000028, "Wrong size on UIMUtilBlueprintLibrary");

// Class DungeonCrawler.InjectionItemListEntryWidgetBase
// 0x0028 (0x0310 - 0x02E8)
class UInjectionItemListEntryWidgetBase final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2874[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemIdText;                                        // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2875[0x7];                                     // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemListEntryWidgetBase">();
	}
	static class UInjectionItemListEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemListEntryWidgetBase>();
	}
};
static_assert(alignof(UInjectionItemListEntryWidgetBase) == 0x000008, "Wrong alignment on UInjectionItemListEntryWidgetBase");
static_assert(sizeof(UInjectionItemListEntryWidgetBase) == 0x000310, "Wrong size on UInjectionItemListEntryWidgetBase");
static_assert(offsetof(UInjectionItemListEntryWidgetBase, ItemIdText) == 0x0002F0, "Member 'UInjectionItemListEntryWidgetBase::ItemIdText' has a wrong offset!");
static_assert(offsetof(UInjectionItemListEntryWidgetBase, bIsSelected) == 0x000308, "Member 'UInjectionItemListEntryWidgetBase::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.InjectionItemPropertyListEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UInjectionItemPropertyListEntryWidgetData final : public UObject
{
public:
	class UDCItemPropertyTypeDataAsset*           ItemPropertyTypeData;                              // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2876[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemPropertyListEntryWidgetData">();
	}
	static class UInjectionItemPropertyListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemPropertyListEntryWidgetData>();
	}
};
static_assert(alignof(UInjectionItemPropertyListEntryWidgetData) == 0x000008, "Wrong alignment on UInjectionItemPropertyListEntryWidgetData");
static_assert(sizeof(UInjectionItemPropertyListEntryWidgetData) == 0x000038, "Wrong size on UInjectionItemPropertyListEntryWidgetData");
static_assert(offsetof(UInjectionItemPropertyListEntryWidgetData, ItemPropertyTypeData) == 0x000028, "Member 'UInjectionItemPropertyListEntryWidgetData::ItemPropertyTypeData' has a wrong offset!");
static_assert(offsetof(UInjectionItemPropertyListEntryWidgetData, bIsSelected) == 0x000030, "Member 'UInjectionItemPropertyListEntryWidgetData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.InjectionItemPropertyListEntryWidgetBase
// 0x0028 (0x0310 - 0x02E8)
class UInjectionItemPropertyListEntryWidgetBase final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2877[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemPropertTypeText;                               // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2878[0x7];                                     // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemPropertyListEntryWidgetBase">();
	}
	static class UInjectionItemPropertyListEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemPropertyListEntryWidgetBase>();
	}
};
static_assert(alignof(UInjectionItemPropertyListEntryWidgetBase) == 0x000008, "Wrong alignment on UInjectionItemPropertyListEntryWidgetBase");
static_assert(sizeof(UInjectionItemPropertyListEntryWidgetBase) == 0x000310, "Wrong size on UInjectionItemPropertyListEntryWidgetBase");
static_assert(offsetof(UInjectionItemPropertyListEntryWidgetBase, ItemPropertTypeText) == 0x0002F0, "Member 'UInjectionItemPropertyListEntryWidgetBase::ItemPropertTypeText' has a wrong offset!");
static_assert(offsetof(UInjectionItemPropertyListEntryWidgetBase, bIsSelected) == 0x000308, "Member 'UInjectionItemPropertyListEntryWidgetBase::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.InjectionItemTypeListEntryWidgetData
// 0x0010 (0x0038 - 0x0028)
class UInjectionItemTypeListEntryWidgetData final : public UObject
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2879[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemTypeListEntryWidgetData">();
	}
	static class UInjectionItemTypeListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemTypeListEntryWidgetData>();
	}
};
static_assert(alignof(UInjectionItemTypeListEntryWidgetData) == 0x000008, "Wrong alignment on UInjectionItemTypeListEntryWidgetData");
static_assert(sizeof(UInjectionItemTypeListEntryWidgetData) == 0x000038, "Wrong size on UInjectionItemTypeListEntryWidgetData");
static_assert(offsetof(UInjectionItemTypeListEntryWidgetData, TypeTag) == 0x000028, "Member 'UInjectionItemTypeListEntryWidgetData::TypeTag' has a wrong offset!");
static_assert(offsetof(UInjectionItemTypeListEntryWidgetData, bIsSelected) == 0x000030, "Member 'UInjectionItemTypeListEntryWidgetData::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.InjectionItemTypeListEntryWidgetBase
// 0x0028 (0x0310 - 0x02E8)
class UInjectionItemTypeListEntryWidgetBase final : public UCommonUserWidget
{
public:
	uint8                                         Pad_287A[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TypeText;                                          // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_287B[0x7];                                     // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectionItemTypeListEntryWidgetBase">();
	}
	static class UInjectionItemTypeListEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectionItemTypeListEntryWidgetBase>();
	}
};
static_assert(alignof(UInjectionItemTypeListEntryWidgetBase) == 0x000008, "Wrong alignment on UInjectionItemTypeListEntryWidgetBase");
static_assert(sizeof(UInjectionItemTypeListEntryWidgetBase) == 0x000310, "Wrong size on UInjectionItemTypeListEntryWidgetBase");
static_assert(offsetof(UInjectionItemTypeListEntryWidgetBase, TypeText) == 0x0002F0, "Member 'UInjectionItemTypeListEntryWidgetBase::TypeText' has a wrong offset!");
static_assert(offsetof(UInjectionItemTypeListEntryWidgetBase, bIsSelected) == 0x000308, "Member 'UInjectionItemTypeListEntryWidgetBase::bIsSelected' has a wrong offset!");

// Class DungeonCrawler.InputTriggerComboAction
// 0x0018 (0x0068 - 0x0050)
class UInputTriggerComboAction final : public UInputTrigger
{
public:
	struct FComboTriggerStep                      ComboStep;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ActivationCooldown;                                // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287C[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputTriggerComboAction">();
	}
	static class UInputTriggerComboAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputTriggerComboAction>();
	}
};
static_assert(alignof(UInputTriggerComboAction) == 0x000008, "Wrong alignment on UInputTriggerComboAction");
static_assert(sizeof(UInputTriggerComboAction) == 0x000068, "Wrong size on UInputTriggerComboAction");
static_assert(offsetof(UInputTriggerComboAction, ComboStep) == 0x000050, "Member 'UInputTriggerComboAction::ComboStep' has a wrong offset!");
static_assert(offsetof(UInputTriggerComboAction, ActivationCooldown) == 0x000060, "Member 'UInputTriggerComboAction::ActivationCooldown' has a wrong offset!");

// Class DungeonCrawler.InteractData
// 0x0038 (0x0080 - 0x0048)
class UInteractData final : public UDCDataAssetBase
{
public:
	class UAnimMontage*                           MontageToPlayBothHandEquipped;                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayPrimaryEquipped;                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlaySecondaryEquipped;                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlayPrimaryEquippedInstant;               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlaySecondaryEquippedInstant;             // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   IgnoreTypeArray;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractData">();
	}
	static class UInteractData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractData>();
	}
};
static_assert(alignof(UInteractData) == 0x000008, "Wrong alignment on UInteractData");
static_assert(sizeof(UInteractData) == 0x000080, "Wrong size on UInteractData");
static_assert(offsetof(UInteractData, MontageToPlayBothHandEquipped) == 0x000048, "Member 'UInteractData::MontageToPlayBothHandEquipped' has a wrong offset!");
static_assert(offsetof(UInteractData, MontageToPlayPrimaryEquipped) == 0x000050, "Member 'UInteractData::MontageToPlayPrimaryEquipped' has a wrong offset!");
static_assert(offsetof(UInteractData, MontageToPlaySecondaryEquipped) == 0x000058, "Member 'UInteractData::MontageToPlaySecondaryEquipped' has a wrong offset!");
static_assert(offsetof(UInteractData, MontageToPlayPrimaryEquippedInstant) == 0x000060, "Member 'UInteractData::MontageToPlayPrimaryEquippedInstant' has a wrong offset!");
static_assert(offsetof(UInteractData, MontageToPlaySecondaryEquippedInstant) == 0x000068, "Member 'UInteractData::MontageToPlaySecondaryEquippedInstant' has a wrong offset!");
static_assert(offsetof(UInteractData, IgnoreTypeArray) == 0x000070, "Member 'UInteractData::IgnoreTypeArray' has a wrong offset!");

// Class DungeonCrawler.InventoryLootingWidget
// 0x0050 (0x03A8 - 0x0358)
class UInventoryLootingWidget final : public UDCWidgetBase
{
public:
	class UContainerInventoryGroupWidget*         LootingTargetContainerGroup;                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULootingPlayerInventoryWidget*          LootingTargetPlayerInventoryGroup;                 // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TargetText;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LootingChestText;                                  // 0x0370(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   LootingPlayerText;                                 // 0x0388(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bSetLootPlayer;                                    // 0x03A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_287D[0x3];                                     // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LootingChestCount;                                 // 0x03A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLootingPlayerSet(bool bSetTargetPlayer, class FName TargetPlayerName);
	void OnLootingTargetCountChanged(int32 Count);
	void RequestInventoryWidgetVisible(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryLootingWidget">();
	}
	static class UInventoryLootingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryLootingWidget>();
	}
};
static_assert(alignof(UInventoryLootingWidget) == 0x000008, "Wrong alignment on UInventoryLootingWidget");
static_assert(sizeof(UInventoryLootingWidget) == 0x0003A8, "Wrong size on UInventoryLootingWidget");
static_assert(offsetof(UInventoryLootingWidget, LootingTargetContainerGroup) == 0x000358, "Member 'UInventoryLootingWidget::LootingTargetContainerGroup' has a wrong offset!");
static_assert(offsetof(UInventoryLootingWidget, LootingTargetPlayerInventoryGroup) == 0x000360, "Member 'UInventoryLootingWidget::LootingTargetPlayerInventoryGroup' has a wrong offset!");
static_assert(offsetof(UInventoryLootingWidget, TargetText) == 0x000368, "Member 'UInventoryLootingWidget::TargetText' has a wrong offset!");
static_assert(offsetof(UInventoryLootingWidget, LootingChestText) == 0x000370, "Member 'UInventoryLootingWidget::LootingChestText' has a wrong offset!");
static_assert(offsetof(UInventoryLootingWidget, LootingPlayerText) == 0x000388, "Member 'UInventoryLootingWidget::LootingPlayerText' has a wrong offset!");
static_assert(offsetof(UInventoryLootingWidget, bSetLootPlayer) == 0x0003A0, "Member 'UInventoryLootingWidget::bSetLootPlayer' has a wrong offset!");
static_assert(offsetof(UInventoryLootingWidget, LootingChestCount) == 0x0003A4, "Member 'UInventoryLootingWidget::LootingChestCount' has a wrong offset!");

// Class DungeonCrawler.InventoryPerkListWidgetBase
// 0x0068 (0x03E8 - 0x0380)
class UInventoryPerkListWidgetBase final : public UPerkListWidgetBase
{
public:
	TSubclassOf<class UPerkWidget>                PerkWidgetClass;                                   // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPanelWidget*>                   PerkWidgetParentArray;                             // 0x0388(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UPanelWidget*, class UPerkWidget*> PerkWidgetMap;                                     // 0x0398(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryPerkListWidgetBase">();
	}
	static class UInventoryPerkListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryPerkListWidgetBase>();
	}
};
static_assert(alignof(UInventoryPerkListWidgetBase) == 0x000008, "Wrong alignment on UInventoryPerkListWidgetBase");
static_assert(sizeof(UInventoryPerkListWidgetBase) == 0x0003E8, "Wrong size on UInventoryPerkListWidgetBase");
static_assert(offsetof(UInventoryPerkListWidgetBase, PerkWidgetClass) == 0x000380, "Member 'UInventoryPerkListWidgetBase::PerkWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventoryPerkListWidgetBase, PerkWidgetParentArray) == 0x000388, "Member 'UInventoryPerkListWidgetBase::PerkWidgetParentArray' has a wrong offset!");
static_assert(offsetof(UInventoryPerkListWidgetBase, PerkWidgetMap) == 0x000398, "Member 'UInventoryPerkListWidgetBase::PerkWidgetMap' has a wrong offset!");

// Class DungeonCrawler.InventoryStatusWidget
// 0x0018 (0x0370 - 0x0358)
class UInventoryStatusWidget final : public UDCWidgetBase
{
public:
	class UCharacterStatusWidget*                 SimpleStatusWidget;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterStatusDetailWidget*           DetailStatusWidget;                                // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCCharacterClass                             CharacterClass;                                    // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_287F[0x7];                                     // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryStatusWidget">();
	}
	static class UInventoryStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryStatusWidget>();
	}
};
static_assert(alignof(UInventoryStatusWidget) == 0x000008, "Wrong alignment on UInventoryStatusWidget");
static_assert(sizeof(UInventoryStatusWidget) == 0x000370, "Wrong size on UInventoryStatusWidget");
static_assert(offsetof(UInventoryStatusWidget, SimpleStatusWidget) == 0x000358, "Member 'UInventoryStatusWidget::SimpleStatusWidget' has a wrong offset!");
static_assert(offsetof(UInventoryStatusWidget, DetailStatusWidget) == 0x000360, "Member 'UInventoryStatusWidget::DetailStatusWidget' has a wrong offset!");
static_assert(offsetof(UInventoryStatusWidget, CharacterClass) == 0x000368, "Member 'UInventoryStatusWidget::CharacterClass' has a wrong offset!");

// Class DungeonCrawler.InventoryTabWidgetBase
// 0x0000 (0x1660 - 0x1660)
class UInventoryTabWidgetBase final : public UDCCommonButtonBase
{
public:
	EWidgetPlayerInventoryTabType                 PlayerInventoryTabType;                            // 0x1658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2880[0x7];                                     // 0x1659(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeActiveState(bool bActive);
	void OnClickedInventoryTab();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryTabWidgetBase">();
	}
	static class UInventoryTabWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryTabWidgetBase>();
	}
};
static_assert(alignof(UInventoryTabWidgetBase) == 0x000010, "Wrong alignment on UInventoryTabWidgetBase");
static_assert(sizeof(UInventoryTabWidgetBase) == 0x001660, "Wrong size on UInventoryTabWidgetBase");
static_assert(offsetof(UInventoryTabWidgetBase, PlayerInventoryTabType) == 0x001658, "Member 'UInventoryTabWidgetBase::PlayerInventoryTabType' has a wrong offset!");

// Class DungeonCrawler.InvitePartyMemberSlotWidget
// 0x0008 (0x0440 - 0x0438)
class UInvitePartyMemberSlotWidget final : public UFriendSlotWidget
{
public:
	class UVoipUserWidget*                        VoipUserWidget;                                    // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvitePartyMemberSlotWidget">();
	}
	static class UInvitePartyMemberSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvitePartyMemberSlotWidget>();
	}
};
static_assert(alignof(UInvitePartyMemberSlotWidget) == 0x000008, "Wrong alignment on UInvitePartyMemberSlotWidget");
static_assert(sizeof(UInvitePartyMemberSlotWidget) == 0x000440, "Wrong size on UInvitePartyMemberSlotWidget");
static_assert(offsetof(UInvitePartyMemberSlotWidget, VoipUserWidget) == 0x000438, "Member 'UInvitePartyMemberSlotWidget::VoipUserWidget' has a wrong offset!");

// Class DungeonCrawler.Item
// 0x04B0 (0x04D8 - 0x0028)
class UItem final : public UObject
{
public:
	uint8                                         Pad_2881[0x60];                                    // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemInventorySize                     InventorySize;                                     // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FItemData                              ItemData;                                          // 0x0098(0x0100)(NativeAccessSpecifierPrivate)
	struct FDesignDataItem                        ItemDesignData;                                    // 0x0198(0x0198)(NativeAccessSpecifierPrivate)
	class UArtDataItem*                           ItemArtData;                                       // 0x0330(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDesignDataAssetItemRequirement*        DesignDataItemRequirement;                         // 0x0338(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDesignDataAssetItemBundleInfo*         DesignDataItemBundleInfo;                          // 0x0340(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDesignDataItemContainer               DesignDataItemContainer;                           // 0x0348(0x0014)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2882[0x4];                                     // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundData*                             SoundData;                                         // 0x0360(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFunctionTrigger                       ItemEquipTrigger;                                  // 0x0368(0x0070)(NativeAccessSpecifierPrivate)
	struct FFunctionTrigger                       ItemSheathTrigger;                                 // 0x03D8(0x0070)(NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayAbilityData>         GameplayAbilityDataArray;                          // 0x0448(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayEffectData>          GameplayEffectDataArray;                           // 0x0458(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayAbilityData>         OwnerGameplayAbilityDataArray;                     // 0x0468(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayEffectData>          OwnerGameplayEffectDataArray;                      // 0x0478(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDCPropertyEffectData>          PropertyEffectDataArray;                           // 0x0488(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayAbilitySpecHandle>     OwnerGameplayAbilitySpecHandles;                   // 0x0498(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    OwnerGameplayEffectHandles;                        // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AItemActor>              ItemActor;                                         // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2883[0x10];                                    // 0x04C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void Initialize(const struct FItemData& Data);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

	const struct FDesignDataItem GetDesignDataItem() const;
	class AItemActor* GetItemActor() const;
	struct FItemData GetItemData() const;
	struct FGameplayTag GetItemDataUtilityTag() const;
	TArray<struct FGameplayTag> GetItemDataWeaponTypeTags() const;
	struct FGameplayTag GetItemHandType() const;
	class UTexture2D* GetItemIconTexture() const;
	struct FGameplayTag GetItemSlotType() const;
	TArray<struct FGameplayTag> GetItemWeaponTypes() const;
	bool IsItemWeaponType(const struct FGameplayTag& WeaponType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item">();
	}
	static class UItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItem>();
	}
};
static_assert(alignof(UItem) == 0x000008, "Wrong alignment on UItem");
static_assert(sizeof(UItem) == 0x0004D8, "Wrong size on UItem");
static_assert(offsetof(UItem, BaseObject) == 0x000088, "Member 'UItem::BaseObject' has a wrong offset!");
static_assert(offsetof(UItem, InventorySize) == 0x000090, "Member 'UItem::InventorySize' has a wrong offset!");
static_assert(offsetof(UItem, ItemData) == 0x000098, "Member 'UItem::ItemData' has a wrong offset!");
static_assert(offsetof(UItem, ItemDesignData) == 0x000198, "Member 'UItem::ItemDesignData' has a wrong offset!");
static_assert(offsetof(UItem, ItemArtData) == 0x000330, "Member 'UItem::ItemArtData' has a wrong offset!");
static_assert(offsetof(UItem, DesignDataItemRequirement) == 0x000338, "Member 'UItem::DesignDataItemRequirement' has a wrong offset!");
static_assert(offsetof(UItem, DesignDataItemBundleInfo) == 0x000340, "Member 'UItem::DesignDataItemBundleInfo' has a wrong offset!");
static_assert(offsetof(UItem, DesignDataItemContainer) == 0x000348, "Member 'UItem::DesignDataItemContainer' has a wrong offset!");
static_assert(offsetof(UItem, SoundData) == 0x000360, "Member 'UItem::SoundData' has a wrong offset!");
static_assert(offsetof(UItem, ItemEquipTrigger) == 0x000368, "Member 'UItem::ItemEquipTrigger' has a wrong offset!");
static_assert(offsetof(UItem, ItemSheathTrigger) == 0x0003D8, "Member 'UItem::ItemSheathTrigger' has a wrong offset!");
static_assert(offsetof(UItem, GameplayAbilityDataArray) == 0x000448, "Member 'UItem::GameplayAbilityDataArray' has a wrong offset!");
static_assert(offsetof(UItem, GameplayEffectDataArray) == 0x000458, "Member 'UItem::GameplayEffectDataArray' has a wrong offset!");
static_assert(offsetof(UItem, OwnerGameplayAbilityDataArray) == 0x000468, "Member 'UItem::OwnerGameplayAbilityDataArray' has a wrong offset!");
static_assert(offsetof(UItem, OwnerGameplayEffectDataArray) == 0x000478, "Member 'UItem::OwnerGameplayEffectDataArray' has a wrong offset!");
static_assert(offsetof(UItem, PropertyEffectDataArray) == 0x000488, "Member 'UItem::PropertyEffectDataArray' has a wrong offset!");
static_assert(offsetof(UItem, OwnerGameplayAbilitySpecHandles) == 0x000498, "Member 'UItem::OwnerGameplayAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(UItem, OwnerGameplayEffectHandles) == 0x0004A8, "Member 'UItem::OwnerGameplayEffectHandles' has a wrong offset!");
static_assert(offsetof(UItem, OwnerActor) == 0x0004B8, "Member 'UItem::OwnerActor' has a wrong offset!");
static_assert(offsetof(UItem, ItemActor) == 0x0004C0, "Member 'UItem::ItemActor' has a wrong offset!");

// Class DungeonCrawler.ItemActor
// 0x0078 (0x0558 - 0x04E0)
class AItemActor : public ADCItemActorBase
{
public:
	uint8                                         Pad_2885[0x8];                                     // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AttachedInvisibleStateTagContainer;                // 0x04F0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bForceHide;                                        // 0x0510(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2886[0x7];                                     // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCItemAttachType                             AttachType;                                        // 0x0520(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2887[0x7];                                     // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     AbilityHandles;                                    // 0x0528(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    EffectHandles;                                     // 0x0538(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHideOnBack;                                       // 0x0548(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2888[0x3];                                     // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActivateTagCount;                                  // 0x054C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2889[0x8];                                     // 0x0550(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount);
	void ItemDataUpdated(const struct FItemData& InItemData);
	void OnAttachedEquipSocket();
	void OnAttachedSheathSocket();
	void OnAttachmentReplication();
	void OnHiddenInGameStateChanged(const bool bIsHidden);
	void OnRep_AttachType(const EDCItemAttachType& OldAttachType);
	void OnRep_ForceHide(const bool bOldForceHide);
	void OnStateActivated();
	void OnStateDeactivated();
	void PreReduceAmmoCount(int32 ReduceCount);
	bool SetAttachType(EDCItemAttachType InAttachType);

	struct FItemData GetItemData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemActor">();
	}
	static class AItemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemActor>();
	}
};
static_assert(alignof(AItemActor) == 0x000008, "Wrong alignment on AItemActor");
static_assert(sizeof(AItemActor) == 0x000558, "Wrong size on AItemActor");
static_assert(offsetof(AItemActor, Mesh) == 0x0004E8, "Member 'AItemActor::Mesh' has a wrong offset!");
static_assert(offsetof(AItemActor, AttachedInvisibleStateTagContainer) == 0x0004F0, "Member 'AItemActor::AttachedInvisibleStateTagContainer' has a wrong offset!");
static_assert(offsetof(AItemActor, bForceHide) == 0x000510, "Member 'AItemActor::bForceHide' has a wrong offset!");
static_assert(offsetof(AItemActor, AbilitySystemComponent) == 0x000518, "Member 'AItemActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AItemActor, AttachType) == 0x000520, "Member 'AItemActor::AttachType' has a wrong offset!");
static_assert(offsetof(AItemActor, AbilityHandles) == 0x000528, "Member 'AItemActor::AbilityHandles' has a wrong offset!");
static_assert(offsetof(AItemActor, EffectHandles) == 0x000538, "Member 'AItemActor::EffectHandles' has a wrong offset!");
static_assert(offsetof(AItemActor, bHideOnBack) == 0x000548, "Member 'AItemActor::bHideOnBack' has a wrong offset!");
static_assert(offsetof(AItemActor, ActivateTagCount) == 0x00054C, "Member 'AItemActor::ActivateTagCount' has a wrong offset!");

// Class DungeonCrawler.ItemComponentBase
// 0x0060 (0x0100 - 0x00A0)
class UItemComponentBase : public UDCActorComponent
{
public:
	uint8                                         Pad_288A[0x60];                                    // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ClientWearItem(class AActor* NewOwner, const struct FItemData& WearingItemData, bool bReserveQuickSlotType, EEquipmentQuickSlotType QuickSlotType);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemComponentBase">();
	}
	static class UItemComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemComponentBase>();
	}
};
static_assert(alignof(UItemComponentBase) == 0x000008, "Wrong alignment on UItemComponentBase");
static_assert(sizeof(UItemComponentBase) == 0x000100, "Wrong size on UItemComponentBase");

// Class DungeonCrawler.ItemCountSelectWidget
// 0x0038 (0x04C8 - 0x0490)
class UItemCountSelectWidget final : public UCommonPopupBase
{
public:
	class UDCCommonButtonBase*                    Btn_Single;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Left;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Two_Right;                                     // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                Slider_ItemCount;                                  // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          EditableTextBox_ItemCount;                         // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Desc;                                          // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemCountSelectWidgetData*             ItemCountSelectWidgetData;                         // 0x04C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleLeftButtonClicked();
	void HandleRightButtonClicked();
	void OnCreatePopup();
	void OnRemovePopup();
	void OnSliderValueChanged(float Value);
	void OnTextBlockCommitted(const class FText& Text, ETextCommit CommitMethod);
	void OnTextBlockValueChanged(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCountSelectWidget">();
	}
	static class UItemCountSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCountSelectWidget>();
	}
};
static_assert(alignof(UItemCountSelectWidget) == 0x000008, "Wrong alignment on UItemCountSelectWidget");
static_assert(sizeof(UItemCountSelectWidget) == 0x0004C8, "Wrong size on UItemCountSelectWidget");
static_assert(offsetof(UItemCountSelectWidget, Btn_Single) == 0x000490, "Member 'UItemCountSelectWidget::Btn_Single' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidget, Btn_Two_Left) == 0x000498, "Member 'UItemCountSelectWidget::Btn_Two_Left' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidget, Btn_Two_Right) == 0x0004A0, "Member 'UItemCountSelectWidget::Btn_Two_Right' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidget, Slider_ItemCount) == 0x0004A8, "Member 'UItemCountSelectWidget::Slider_ItemCount' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidget, EditableTextBox_ItemCount) == 0x0004B0, "Member 'UItemCountSelectWidget::EditableTextBox_ItemCount' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidget, Txt_Desc) == 0x0004B8, "Member 'UItemCountSelectWidget::Txt_Desc' has a wrong offset!");
static_assert(offsetof(UItemCountSelectWidget, ItemCountSelectWidgetData) == 0x0004C0, "Member 'UItemCountSelectWidget::ItemCountSelectWidgetData' has a wrong offset!");

// Class DungeonCrawler.DCItemDataComponent
// 0x0148 (0x0218 - 0x00D0)
class UDCItemDataComponent final : public UDCDataComponent
{
public:
	struct FItemData                              ItemData;                                          // 0x00D0(0x0100)(NativeAccessSpecifierPrivate)
	int32                                         ItemCount;                                         // 0x01D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288D[0x4];                                     // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x01D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x01E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288E[0x30];                                    // 0x01E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadData_Art(class UObject* InLoadedObject);
	void OnLoadData_Bundle(class UObject* InLoadedObject);
	void OnLoadData_Sound(class UObject* InLoadedObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCItemDataComponent">();
	}
	static class UDCItemDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCItemDataComponent>();
	}
};
static_assert(alignof(UDCItemDataComponent) == 0x000008, "Wrong alignment on UDCItemDataComponent");
static_assert(sizeof(UDCItemDataComponent) == 0x000218, "Wrong size on UDCItemDataComponent");
static_assert(offsetof(UDCItemDataComponent, ItemData) == 0x0000D0, "Member 'UDCItemDataComponent::ItemData' has a wrong offset!");
static_assert(offsetof(UDCItemDataComponent, ItemCount) == 0x0001D0, "Member 'UDCItemDataComponent::ItemCount' has a wrong offset!");
static_assert(offsetof(UDCItemDataComponent, StaticMeshComponent) == 0x0001D8, "Member 'UDCItemDataComponent::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UDCItemDataComponent, SkeletalMeshComponent) == 0x0001E0, "Member 'UDCItemDataComponent::SkeletalMeshComponent' has a wrong offset!");

// Class DungeonCrawler.ItemGenerateInterface
// 0x0000 (0x0028 - 0x0028)
class IItemGenerateInterface final : public IInterface
{
public:
	void GenerateItems(float InLuck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemGenerateInterface">();
	}
	static class IItemGenerateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemGenerateInterface>();
	}
};
static_assert(alignof(IItemGenerateInterface) == 0x000008, "Wrong alignment on IItemGenerateInterface");
static_assert(sizeof(IItemGenerateInterface) == 0x000028, "Wrong size on IItemGenerateInterface");

// Class DungeonCrawler.ItemMoveValidatorComponent
// 0x0168 (0x0268 - 0x0100)
class UItemMoveValidatorComponent final : public UItemComponentBase
{
public:
	class AActor*                                 MoveItemOldOwner;                                  // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 MoveItemNewOwner;                                  // 0x0108(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FItemData                              MoveItemOldData;                                   // 0x0110(0x0100)(NativeAccessSpecifierPrivate)
	TArray<struct FItemData>                      MoveItemNewDataArray;                              // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FItemData>                      SwapItemOldDataArray;                              // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FItemData>                      SwapItemNewDataArray;                              // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlockedTags;                                       // 0x0240(0x0020)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288F[0x8];                                     // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientMoveItemEnd(bool bMoveSucceed, const TArray<struct FItemData>& MovedItemDataArray);
	void ClientShowMessage(const class FText& OutputMessage);
	bool IsEnableMoveItem(const struct FItemData& OldItemData, const TArray<struct FItemData>& NewItemDataArray, class AActor* OldOwner, class AActor* NewOwner);
	void ServerMoveItem(const struct FItemData& OldItemData, const TArray<struct FItemData>& NewItemDataArray, class AActor* OldOwner, class AActor* NewOwner, bool bHasDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemMoveValidatorComponent">();
	}
	static class UItemMoveValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemMoveValidatorComponent>();
	}
};
static_assert(alignof(UItemMoveValidatorComponent) == 0x000008, "Wrong alignment on UItemMoveValidatorComponent");
static_assert(sizeof(UItemMoveValidatorComponent) == 0x000268, "Wrong size on UItemMoveValidatorComponent");
static_assert(offsetof(UItemMoveValidatorComponent, MoveItemOldOwner) == 0x000100, "Member 'UItemMoveValidatorComponent::MoveItemOldOwner' has a wrong offset!");
static_assert(offsetof(UItemMoveValidatorComponent, MoveItemNewOwner) == 0x000108, "Member 'UItemMoveValidatorComponent::MoveItemNewOwner' has a wrong offset!");
static_assert(offsetof(UItemMoveValidatorComponent, MoveItemOldData) == 0x000110, "Member 'UItemMoveValidatorComponent::MoveItemOldData' has a wrong offset!");
static_assert(offsetof(UItemMoveValidatorComponent, MoveItemNewDataArray) == 0x000210, "Member 'UItemMoveValidatorComponent::MoveItemNewDataArray' has a wrong offset!");
static_assert(offsetof(UItemMoveValidatorComponent, SwapItemOldDataArray) == 0x000220, "Member 'UItemMoveValidatorComponent::SwapItemOldDataArray' has a wrong offset!");
static_assert(offsetof(UItemMoveValidatorComponent, SwapItemNewDataArray) == 0x000230, "Member 'UItemMoveValidatorComponent::SwapItemNewDataArray' has a wrong offset!");
static_assert(offsetof(UItemMoveValidatorComponent, BlockedTags) == 0x000240, "Member 'UItemMoveValidatorComponent::BlockedTags' has a wrong offset!");

// Class DungeonCrawler.ItemRandomGenerateComponent
// 0x00A0 (0x0140 - 0x00A0)
class UItemRandomGenerateComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_2893[0x60];                                    // 0x00A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemRandomGenerateData>        ItemRandomGenerateDataArray;                       // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bGenerateRepeatedly;                               // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2894[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      GenerateItemDatas;                                 // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnItemGenerationFinished;                          // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2895[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void ClearAllItems();
	void DropAllItems(float InLuck);
	void DropItem(int64 ItemUniqueId, class AActor* Owner);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRandomGenerateComponent">();
	}
	static class UItemRandomGenerateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRandomGenerateComponent>();
	}
};
static_assert(alignof(UItemRandomGenerateComponent) == 0x000008, "Wrong alignment on UItemRandomGenerateComponent");
static_assert(sizeof(UItemRandomGenerateComponent) == 0x000140, "Wrong size on UItemRandomGenerateComponent");
static_assert(offsetof(UItemRandomGenerateComponent, ItemRandomGenerateDataArray) == 0x000100, "Member 'UItemRandomGenerateComponent::ItemRandomGenerateDataArray' has a wrong offset!");
static_assert(offsetof(UItemRandomGenerateComponent, bGenerateRepeatedly) == 0x000110, "Member 'UItemRandomGenerateComponent::bGenerateRepeatedly' has a wrong offset!");
static_assert(offsetof(UItemRandomGenerateComponent, GenerateItemDatas) == 0x000118, "Member 'UItemRandomGenerateComponent::GenerateItemDatas' has a wrong offset!");
static_assert(offsetof(UItemRandomGenerateComponent, OnItemGenerationFinished) == 0x000128, "Member 'UItemRandomGenerateComponent::OnItemGenerationFinished' has a wrong offset!");

// Class DungeonCrawler.ItemRichTextBlockDecorator
// 0x0010 (0x0038 - 0x0028)
class UItemRichTextBlockDecorator : public URichTextBlockDecorator
{
public:
	TSubclassOf<class UItemTooltipWidget>         ItemTooltipWidgetClass;                            // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2896[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTextBlockStyle GetItemTextBlockStyle(const struct FGameplayTag& InRarityType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRichTextBlockDecorator">();
	}
	static class UItemRichTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRichTextBlockDecorator>();
	}
};
static_assert(alignof(UItemRichTextBlockDecorator) == 0x000008, "Wrong alignment on UItemRichTextBlockDecorator");
static_assert(sizeof(UItemRichTextBlockDecorator) == 0x000038, "Wrong size on UItemRichTextBlockDecorator");
static_assert(offsetof(UItemRichTextBlockDecorator, ItemTooltipWidgetClass) == 0x000028, "Member 'UItemRichTextBlockDecorator::ItemTooltipWidgetClass' has a wrong offset!");

// Class DungeonCrawler.ItemTooltipRequirementWidget
// 0x0048 (0x03A0 - 0x0358)
class UItemTooltipRequirementWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_2898[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            CommonNameColor;                                   // 0x0360(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            CommonValueColor;                                  // 0x0374(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            UnmetRequirementColor;                             // 0x0388(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2899[0x4];                                     // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangedRequirementStatus(bool bFulfilled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipRequirementWidget">();
	}
	static class UItemTooltipRequirementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipRequirementWidget>();
	}
};
static_assert(alignof(UItemTooltipRequirementWidget) == 0x000008, "Wrong alignment on UItemTooltipRequirementWidget");
static_assert(sizeof(UItemTooltipRequirementWidget) == 0x0003A0, "Wrong size on UItemTooltipRequirementWidget");
static_assert(offsetof(UItemTooltipRequirementWidget, CommonNameColor) == 0x000360, "Member 'UItemTooltipRequirementWidget::CommonNameColor' has a wrong offset!");
static_assert(offsetof(UItemTooltipRequirementWidget, CommonValueColor) == 0x000374, "Member 'UItemTooltipRequirementWidget::CommonValueColor' has a wrong offset!");
static_assert(offsetof(UItemTooltipRequirementWidget, UnmetRequirementColor) == 0x000388, "Member 'UItemTooltipRequirementWidget::UnmetRequirementColor' has a wrong offset!");

// Class DungeonCrawler.ItemTooltipStatWidgetData
// 0x0010 (0x0038 - 0x0028)
class UItemTooltipStatWidgetData final : public UObject
{
public:
	TArray<class FText>                           DescTextArray;                                     // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipStatWidgetData">();
	}
	static class UItemTooltipStatWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipStatWidgetData>();
	}
};
static_assert(alignof(UItemTooltipStatWidgetData) == 0x000008, "Wrong alignment on UItemTooltipStatWidgetData");
static_assert(sizeof(UItemTooltipStatWidgetData) == 0x000038, "Wrong size on UItemTooltipStatWidgetData");
static_assert(offsetof(UItemTooltipStatWidgetData, DescTextArray) == 0x000028, "Member 'UItemTooltipStatWidgetData::DescTextArray' has a wrong offset!");

// Class DungeonCrawler.ItemWeaponAnimInstanceBase
// 0x0000 (0x0660 - 0x0660)
class UItemWeaponAnimInstanceBase : public UDCPlayerCharacterAnimInstanceBase
{
public:
	void GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount);
	void OnItemDataUpdated(const struct FItemData& ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWeaponAnimInstanceBase">();
	}
	static class UItemWeaponAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWeaponAnimInstanceBase>();
	}
};
static_assert(alignof(UItemWeaponAnimInstanceBase) == 0x000010, "Wrong alignment on UItemWeaponAnimInstanceBase");
static_assert(sizeof(UItemWeaponAnimInstanceBase) == 0x000660, "Wrong size on UItemWeaponAnimInstanceBase");

// Class DungeonCrawler.KarmaMemberSlotWidgetBase
// 0x0000 (0x0358 - 0x0358)
class UKarmaMemberSlotWidgetBase final : public UDCWidgetBase
{
public:
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KarmaMemberSlotWidgetBase">();
	}
	static class UKarmaMemberSlotWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKarmaMemberSlotWidgetBase>();
	}
};
static_assert(alignof(UKarmaMemberSlotWidgetBase) == 0x000008, "Wrong alignment on UKarmaMemberSlotWidgetBase");
static_assert(sizeof(UKarmaMemberSlotWidgetBase) == 0x000358, "Wrong size on UKarmaMemberSlotWidgetBase");

// Class DungeonCrawler.LeaderboardClassComboBoxWidget
// 0x0000 (0x0368 - 0x0368)
class ULeaderboardClassComboBoxWidget final : public UComboBoxWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardClassComboBoxWidget">();
	}
	static class ULeaderboardClassComboBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardClassComboBoxWidget>();
	}
};
static_assert(alignof(ULeaderboardClassComboBoxWidget) == 0x000008, "Wrong alignment on ULeaderboardClassComboBoxWidget");
static_assert(sizeof(ULeaderboardClassComboBoxWidget) == 0x000368, "Wrong size on ULeaderboardClassComboBoxWidget");

// Class DungeonCrawler.LeaderboardClassIconWidgetData
// 0x0018 (0x0040 - 0x0028)
class ULeaderboardClassIconWidgetData final : public UObject
{
public:
	int32                                         ItemIndex;                                         // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterClassId;                                  // 0x002C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289A[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardClassIconWidgetData">();
	}
	static class ULeaderboardClassIconWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardClassIconWidgetData>();
	}
};
static_assert(alignof(ULeaderboardClassIconWidgetData) == 0x000008, "Wrong alignment on ULeaderboardClassIconWidgetData");
static_assert(sizeof(ULeaderboardClassIconWidgetData) == 0x000040, "Wrong size on ULeaderboardClassIconWidgetData");
static_assert(offsetof(ULeaderboardClassIconWidgetData, ItemIndex) == 0x000028, "Member 'ULeaderboardClassIconWidgetData::ItemIndex' has a wrong offset!");
static_assert(offsetof(ULeaderboardClassIconWidgetData, CharacterClassId) == 0x00002C, "Member 'ULeaderboardClassIconWidgetData::CharacterClassId' has a wrong offset!");

// Class DungeonCrawler.LeaderboardDetailRankAPItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class ULeaderboardDetailRankAPItemWidgetData final : public UObject
{
public:
	struct FLeaderboardRankAPInfo                 LeaderboardRankAPInfo;                             // 0x0028(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UDCLeaderboardRankDataAsset*            LeaderboardRankData;                               // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDetailRankAPItemWidgetData">();
	}
	static class ULeaderboardDetailRankAPItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDetailRankAPItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardDetailRankAPItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardDetailRankAPItemWidgetData");
static_assert(sizeof(ULeaderboardDetailRankAPItemWidgetData) == 0x000040, "Wrong size on ULeaderboardDetailRankAPItemWidgetData");
static_assert(offsetof(ULeaderboardDetailRankAPItemWidgetData, LeaderboardRankAPInfo) == 0x000028, "Member 'ULeaderboardDetailRankAPItemWidgetData::LeaderboardRankAPInfo' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailRankAPItemWidgetData, LeaderboardRankData) == 0x000038, "Member 'ULeaderboardDetailRankAPItemWidgetData::LeaderboardRankData' has a wrong offset!");

// Class DungeonCrawler.LeaderboardDetailRankEFItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class ULeaderboardDetailRankEFItemWidgetData final : public UObject
{
public:
	struct FLeaderboardRankEFInfo                 LeaderboardRankEFInfo;                             // 0x0028(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UDCLeaderboardRankDataAsset*            LeaderboardRankData;                               // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDetailRankEFItemWidgetData">();
	}
	static class ULeaderboardDetailRankEFItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDetailRankEFItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardDetailRankEFItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardDetailRankEFItemWidgetData");
static_assert(sizeof(ULeaderboardDetailRankEFItemWidgetData) == 0x000040, "Wrong size on ULeaderboardDetailRankEFItemWidgetData");
static_assert(offsetof(ULeaderboardDetailRankEFItemWidgetData, LeaderboardRankEFInfo) == 0x000028, "Member 'ULeaderboardDetailRankEFItemWidgetData::LeaderboardRankEFInfo' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailRankEFItemWidgetData, LeaderboardRankData) == 0x000038, "Member 'ULeaderboardDetailRankEFItemWidgetData::LeaderboardRankData' has a wrong offset!");

// Class DungeonCrawler.LeaderboardDetailPopup
// 0x0030 (0x04C0 - 0x0490)
class ULeaderboardDetailPopup final : public UCommonPopupBase
{
public:
	class UComboBoxWidget*                        DungeonComboBox;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonListView*                        RankAPListView;                                    // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonListView*                        RankEFListView;                                    // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCLeaderboardDataAsset*                LeaderboardData;                                   // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameType                                     SelectedGameType;                                  // 0x04B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289B[0x3];                                     // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SelectedDungeonIdTag;                              // 0x04B4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289C[0x4];                                     // 0x04BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDungeonComboBoxSelected(class UObject* InItem);
	void OnLeaderboardDetailPopupData(const class ULeaderboardDetailPopupData* LeaderboardDetailPopupData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDetailPopup">();
	}
	static class ULeaderboardDetailPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDetailPopup>();
	}
};
static_assert(alignof(ULeaderboardDetailPopup) == 0x000008, "Wrong alignment on ULeaderboardDetailPopup");
static_assert(sizeof(ULeaderboardDetailPopup) == 0x0004C0, "Wrong size on ULeaderboardDetailPopup");
static_assert(offsetof(ULeaderboardDetailPopup, DungeonComboBox) == 0x000490, "Member 'ULeaderboardDetailPopup::DungeonComboBox' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailPopup, RankAPListView) == 0x000498, "Member 'ULeaderboardDetailPopup::RankAPListView' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailPopup, RankEFListView) == 0x0004A0, "Member 'ULeaderboardDetailPopup::RankEFListView' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailPopup, LeaderboardData) == 0x0004A8, "Member 'ULeaderboardDetailPopup::LeaderboardData' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailPopup, SelectedGameType) == 0x0004B0, "Member 'ULeaderboardDetailPopup::SelectedGameType' has a wrong offset!");
static_assert(offsetof(ULeaderboardDetailPopup, SelectedDungeonIdTag) == 0x0004B4, "Member 'ULeaderboardDetailPopup::SelectedDungeonIdTag' has a wrong offset!");

// Class DungeonCrawler.LeaderboardRankGuideItemWidgetData
// 0x0040 (0x0068 - 0x0028)
class ULeaderboardRankGuideItemWidgetData final : public UObject
{
public:
	class UDCLeaderboardDataAsset*                LeaderboardData;                                   // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCLeaderboardRankGroupDataAsset*       LeaderboardRankGroupData;                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentRankGroup;                                 // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAchievedRankGroup;                                // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289D[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ClassIconTex;                                      // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCRewardInfo                          RewardInfo;                                        // 0x0048(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardRankGuideItemWidgetData">();
	}
	static class ULeaderboardRankGuideItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardRankGuideItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardRankGuideItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardRankGuideItemWidgetData");
static_assert(sizeof(ULeaderboardRankGuideItemWidgetData) == 0x000068, "Wrong size on ULeaderboardRankGuideItemWidgetData");
static_assert(offsetof(ULeaderboardRankGuideItemWidgetData, LeaderboardData) == 0x000028, "Member 'ULeaderboardRankGuideItemWidgetData::LeaderboardData' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankGuideItemWidgetData, LeaderboardRankGroupData) == 0x000030, "Member 'ULeaderboardRankGuideItemWidgetData::LeaderboardRankGroupData' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankGuideItemWidgetData, bCurrentRankGroup) == 0x000038, "Member 'ULeaderboardRankGuideItemWidgetData::bCurrentRankGroup' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankGuideItemWidgetData, bAchievedRankGroup) == 0x000039, "Member 'ULeaderboardRankGuideItemWidgetData::bAchievedRankGroup' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankGuideItemWidgetData, ClassIconTex) == 0x000040, "Member 'ULeaderboardRankGuideItemWidgetData::ClassIconTex' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankGuideItemWidgetData, RewardInfo) == 0x000048, "Member 'ULeaderboardRankGuideItemWidgetData::RewardInfo' has a wrong offset!");

// Class DungeonCrawler.LeaderboardRankGuideItemWidget
// 0x0068 (0x03C0 - 0x0358)
class ULeaderboardRankGuideItemWidget final : public UDCWidgetBase
{
public:
	struct FLeaderboardRankGuideItemWidgetHandleData WidgetHandleData;                                  // 0x0358(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_289E[0x50];                                    // 0x0368(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ULeaderboardRankGuideItemWidgetData*    RankGuideItemWidgetData;                           // 0x03B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UObject* GetRequireData();
	void OnLeaderboardRankGuideItemWidgetData(const class ULeaderboardRankGuideItemWidgetData* NewValue, const class ULeaderboardRankGuideItemWidgetData* OldValue);
	void OnLeaderboardRankRewardState(ELeaderboardRankRewardState NewValue, ELeaderboardRankRewardState OldValue);
	void OnLeaderboardState(ELeaderboardState NewValue, ELeaderboardState OldValue);
	void RequestReward();
	void SetRequiredItemData(class UObject* ListItemObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardRankGuideItemWidget">();
	}
	static class ULeaderboardRankGuideItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardRankGuideItemWidget>();
	}
};
static_assert(alignof(ULeaderboardRankGuideItemWidget) == 0x000008, "Wrong alignment on ULeaderboardRankGuideItemWidget");
static_assert(sizeof(ULeaderboardRankGuideItemWidget) == 0x0003C0, "Wrong size on ULeaderboardRankGuideItemWidget");
static_assert(offsetof(ULeaderboardRankGuideItemWidget, WidgetHandleData) == 0x000358, "Member 'ULeaderboardRankGuideItemWidget::WidgetHandleData' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankGuideItemWidget, RankGuideItemWidgetData) == 0x0003B8, "Member 'ULeaderboardRankGuideItemWidget::RankGuideItemWidgetData' has a wrong offset!");

// Class DungeonCrawler.LeaderboardRankRecordWidgetData
// 0x00B0 (0x00D8 - 0x0028)
class ULeaderboardRankRecordWidgetData final : public UObject
{
public:
	struct FRankRecord                            RankRecordData;                                    // 0x0028(0x0070)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FNickname                              NickNameMine;                                      // 0x0098(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardRankRecordWidgetData">();
	}
	static class ULeaderboardRankRecordWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardRankRecordWidgetData>();
	}
};
static_assert(alignof(ULeaderboardRankRecordWidgetData) == 0x000008, "Wrong alignment on ULeaderboardRankRecordWidgetData");
static_assert(sizeof(ULeaderboardRankRecordWidgetData) == 0x0000D8, "Wrong size on ULeaderboardRankRecordWidgetData");
static_assert(offsetof(ULeaderboardRankRecordWidgetData, RankRecordData) == 0x000028, "Member 'ULeaderboardRankRecordWidgetData::RankRecordData' has a wrong offset!");
static_assert(offsetof(ULeaderboardRankRecordWidgetData, NickNameMine) == 0x000098, "Member 'ULeaderboardRankRecordWidgetData::NickNameMine' has a wrong offset!");

// Class DungeonCrawler.LeaderboardRankRecordWidget
// 0x0080 (0x03D8 - 0x0358)
class ULeaderboardRankRecordWidget final : public UDCWidgetBase
{
public:
	uint8                                         Pad_289F[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLeaderboardRankRecordWidgetHandleData WidgetHandleData;                                  // 0x0360(0x0078)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);
	void OnLeaderboardRankRecordData(const struct FLeaderboardRankRecordData& NewValue, const struct FLeaderboardRankRecordData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardRankRecordWidget">();
	}
	static class ULeaderboardRankRecordWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardRankRecordWidget>();
	}
};
static_assert(alignof(ULeaderboardRankRecordWidget) == 0x000008, "Wrong alignment on ULeaderboardRankRecordWidget");
static_assert(sizeof(ULeaderboardRankRecordWidget) == 0x0003D8, "Wrong size on ULeaderboardRankRecordWidget");
static_assert(offsetof(ULeaderboardRankRecordWidget, WidgetHandleData) == 0x000360, "Member 'ULeaderboardRankRecordWidget::WidgetHandleData' has a wrong offset!");

// Class DungeonCrawler.LeaderboardSheetWidget
// 0x0118 (0x05A0 - 0x0488)
class ULeaderboardSheetWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UComboBoxWidget*                        ClassComboBox;                                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULeaderboardContentWidget*              LeaderboardContentWidget;                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RankGuideHorizontalBox;                            // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULeaderboardRankGuideItemWidget> RankGuideItemWidgetClass;                          // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLeaderboardSheetWidgetHandleData      WidgetHandleData;                                  // 0x04A8(0x0088)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLeaderboardInfo                       LeaderboardInfo;                                   // 0x0530(0x0040)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLeaderboardSheetInfo                  LeaderboardSheetInfo;                              // 0x0570(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLeaderboardContentInfo>        LeaderboardContentInfoArray;                       // 0x0588(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UTexture2D*                             ClassIconTex;                                      // 0x0598(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClassComboBoxSelected(class UObject* InItem);
	void OnLeaderboardData(const class UDCLeaderboardDataAsset* NewValue, const class UDCLeaderboardDataAsset* OldValue);
	void OnLeaderboardSeasonInfo(const struct FLeaderboardSeasonInfo& NewValue, const struct FLeaderboardSeasonInfo& OldValue);
	void OnLeaderboardSheetData(const class UDCLeaderboardSheetDataAsset* NewValue, const class UDCLeaderboardSheetDataAsset* OldValue);
	void OnPlayerCharacterData(const class UDCPlayerCharacterDataAsset* NewValue, const class UDCPlayerCharacterDataAsset* OldValue);
	void OnRankInfo(const struct FRankInfo& NewValue, const struct FRankInfo& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardSheetWidget">();
	}
	static class ULeaderboardSheetWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardSheetWidget>();
	}
};
static_assert(alignof(ULeaderboardSheetWidget) == 0x000008, "Wrong alignment on ULeaderboardSheetWidget");
static_assert(sizeof(ULeaderboardSheetWidget) == 0x0005A0, "Wrong size on ULeaderboardSheetWidget");
static_assert(offsetof(ULeaderboardSheetWidget, ClassComboBox) == 0x000488, "Member 'ULeaderboardSheetWidget::ClassComboBox' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, LeaderboardContentWidget) == 0x000490, "Member 'ULeaderboardSheetWidget::LeaderboardContentWidget' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, RankGuideHorizontalBox) == 0x000498, "Member 'ULeaderboardSheetWidget::RankGuideHorizontalBox' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, RankGuideItemWidgetClass) == 0x0004A0, "Member 'ULeaderboardSheetWidget::RankGuideItemWidgetClass' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, WidgetHandleData) == 0x0004A8, "Member 'ULeaderboardSheetWidget::WidgetHandleData' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, LeaderboardInfo) == 0x000530, "Member 'ULeaderboardSheetWidget::LeaderboardInfo' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, LeaderboardSheetInfo) == 0x000570, "Member 'ULeaderboardSheetWidget::LeaderboardSheetInfo' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, LeaderboardContentInfoArray) == 0x000588, "Member 'ULeaderboardSheetWidget::LeaderboardContentInfoArray' has a wrong offset!");
static_assert(offsetof(ULeaderboardSheetWidget, ClassIconTex) == 0x000598, "Member 'ULeaderboardSheetWidget::ClassIconTex' has a wrong offset!");

// Class DungeonCrawler.LeaderboardSheetDataItemWidgetData
// 0x0018 (0x0040 - 0x0028)
class ULeaderboardSheetDataItemWidgetData final : public UObject
{
public:
	struct FLeaderboardSheetInfo                  LeaderboardSheetInfo;                              // 0x0028(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardSheetDataItemWidgetData">();
	}
	static class ULeaderboardSheetDataItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardSheetDataItemWidgetData>();
	}
};
static_assert(alignof(ULeaderboardSheetDataItemWidgetData) == 0x000008, "Wrong alignment on ULeaderboardSheetDataItemWidgetData");
static_assert(sizeof(ULeaderboardSheetDataItemWidgetData) == 0x000040, "Wrong size on ULeaderboardSheetDataItemWidgetData");
static_assert(offsetof(ULeaderboardSheetDataItemWidgetData, LeaderboardSheetInfo) == 0x000028, "Member 'ULeaderboardSheetDataItemWidgetData::LeaderboardSheetInfo' has a wrong offset!");

// Class DungeonCrawler.LeaderboardWidget
// 0x0070 (0x04F8 - 0x0488)
class ULeaderboardWidget final : public UDCCommonActivatableWidgetBase
{
public:
	class UComboBoxWidget*                        SeasonComboBox;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UComboBoxWidget*                        SheetComboBox;                                     // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULeaderboardSheetWidget*                LeaderboardSheetWidget;                            // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLeaderboardInfo                       SelectedLeaderboardInfo;                           // 0x04A0(0x0040)(NativeAccessSpecifierPrivate)
	struct FLeaderboardSheetInfo                  SelectedLeaderboardSheetInfo;                      // 0x04E0(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnSeasonComboBoxSelected(class UObject* InItem);
	void OnSheetComboBoxSelected(class UObject* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWidget">();
	}
	static class ULeaderboardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWidget>();
	}
};
static_assert(alignof(ULeaderboardWidget) == 0x000008, "Wrong alignment on ULeaderboardWidget");
static_assert(sizeof(ULeaderboardWidget) == 0x0004F8, "Wrong size on ULeaderboardWidget");
static_assert(offsetof(ULeaderboardWidget, SeasonComboBox) == 0x000488, "Member 'ULeaderboardWidget::SeasonComboBox' has a wrong offset!");
static_assert(offsetof(ULeaderboardWidget, SheetComboBox) == 0x000490, "Member 'ULeaderboardWidget::SheetComboBox' has a wrong offset!");
static_assert(offsetof(ULeaderboardWidget, LeaderboardSheetWidget) == 0x000498, "Member 'ULeaderboardWidget::LeaderboardSheetWidget' has a wrong offset!");
static_assert(offsetof(ULeaderboardWidget, SelectedLeaderboardInfo) == 0x0004A0, "Member 'ULeaderboardWidget::SelectedLeaderboardInfo' has a wrong offset!");
static_assert(offsetof(ULeaderboardWidget, SelectedLeaderboardSheetInfo) == 0x0004E0, "Member 'ULeaderboardWidget::SelectedLeaderboardSheetInfo' has a wrong offset!");

// Class DungeonCrawler.LobbyGroupTradeChannelWidget
// 0x0018 (0x04D0 - 0x04B8)
class ULobbyGroupTradeChannelWidget final : public ULobbyGroupWidgetBase
{
public:
	class UTopTitleWidgetBase*                    TopTitle;                                          // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCTradeInventoryWidget*                TradeUserInventory;                                // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTradeSubscriptionPopup>  TradersGuildRulesPopupClass;                       // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLeaveChannelButtonClicked();
	void OnReadRulesButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGroupTradeChannelWidget">();
	}
	static class ULobbyGroupTradeChannelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyGroupTradeChannelWidget>();
	}
};
static_assert(alignof(ULobbyGroupTradeChannelWidget) == 0x000008, "Wrong alignment on ULobbyGroupTradeChannelWidget");
static_assert(sizeof(ULobbyGroupTradeChannelWidget) == 0x0004D0, "Wrong size on ULobbyGroupTradeChannelWidget");
static_assert(offsetof(ULobbyGroupTradeChannelWidget, TopTitle) == 0x0004B8, "Member 'ULobbyGroupTradeChannelWidget::TopTitle' has a wrong offset!");
static_assert(offsetof(ULobbyGroupTradeChannelWidget, TradeUserInventory) == 0x0004C0, "Member 'ULobbyGroupTradeChannelWidget::TradeUserInventory' has a wrong offset!");
static_assert(offsetof(ULobbyGroupTradeChannelWidget, TradersGuildRulesPopupClass) == 0x0004C8, "Member 'ULobbyGroupTradeChannelWidget::TradersGuildRulesPopupClass' has a wrong offset!");

// Class DungeonCrawler.LobbyWidget
// 0x0038 (0x04C0 - 0x0488)
class ULobbyWidget final : public UDCCommonActivatableWidgetBase
{
public:
	struct FDataTableRowHandle                    BackInputActionData;                               // 0x0488(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A0[0x8];                                     // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonTabListWidgetBase*               WB_TabList_Lobby;                                  // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCLegendaryStatusPopup>    LegendaryStatusPopupClass;                         // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCFriendItemRecoveryPopup> FriendItemRecoveryPopupClass;                      // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCFriendItemRecoveryReceivePopup> FriendItemRecoveryReceiveMessagePopupClass;        // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBackButtonClicked();
	void OnMatchingStateChanged(bool bMatching);
	void OnPlayPartyReadyStateChanged(bool bMine, bool bLeader, bool bReady);
	void ShowLegendaryStatusPopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyWidget">();
	}
	static class ULobbyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyWidget>();
	}
};
static_assert(alignof(ULobbyWidget) == 0x000008, "Wrong alignment on ULobbyWidget");
static_assert(sizeof(ULobbyWidget) == 0x0004C0, "Wrong size on ULobbyWidget");
static_assert(offsetof(ULobbyWidget, BackInputActionData) == 0x000488, "Member 'ULobbyWidget::BackInputActionData' has a wrong offset!");
static_assert(offsetof(ULobbyWidget, WB_TabList_Lobby) == 0x0004A0, "Member 'ULobbyWidget::WB_TabList_Lobby' has a wrong offset!");
static_assert(offsetof(ULobbyWidget, LegendaryStatusPopupClass) == 0x0004A8, "Member 'ULobbyWidget::LegendaryStatusPopupClass' has a wrong offset!");
static_assert(offsetof(ULobbyWidget, FriendItemRecoveryPopupClass) == 0x0004B0, "Member 'ULobbyWidget::FriendItemRecoveryPopupClass' has a wrong offset!");
static_assert(offsetof(ULobbyWidget, FriendItemRecoveryReceiveMessagePopupClass) == 0x0004B8, "Member 'ULobbyWidget::FriendItemRecoveryReceiveMessagePopupClass' has a wrong offset!");

// Class DungeonCrawler.LoginSecretTokenPopupData
// 0x0010 (0x0040 - 0x0030)
class ULoginSecretTokenPopupData final : public UPopupDataBase
{
public:
	class FString                                 SecretToken;                                       // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginSecretTokenPopupData">();
	}
	static class ULoginSecretTokenPopupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginSecretTokenPopupData>();
	}
};
static_assert(alignof(ULoginSecretTokenPopupData) == 0x000008, "Wrong alignment on ULoginSecretTokenPopupData");
static_assert(sizeof(ULoginSecretTokenPopupData) == 0x000040, "Wrong size on ULoginSecretTokenPopupData");
static_assert(offsetof(ULoginSecretTokenPopupData, SecretToken) == 0x000030, "Member 'ULoginSecretTokenPopupData::SecretToken' has a wrong offset!");

// Class DungeonCrawler.LoginSecretTokenPopup
// 0x0018 (0x04A8 - 0x0490)
class ULoginSecretTokenPopup final : public UCommonPopupBase
{
public:
	class ULoginSecretTokenPopupData*             LoginSecretTokenPopupData;                         // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Single;                                        // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_CopyToClipboard;                               // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleConfirmButtonClicked();
	void HandleCopyToClipboardButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginSecretTokenPopup">();
	}
	static class ULoginSecretTokenPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginSecretTokenPopup>();
	}
};
static_assert(alignof(ULoginSecretTokenPopup) == 0x000008, "Wrong alignment on ULoginSecretTokenPopup");
static_assert(sizeof(ULoginSecretTokenPopup) == 0x0004A8, "Wrong size on ULoginSecretTokenPopup");
static_assert(offsetof(ULoginSecretTokenPopup, LoginSecretTokenPopupData) == 0x000490, "Member 'ULoginSecretTokenPopup::LoginSecretTokenPopupData' has a wrong offset!");
static_assert(offsetof(ULoginSecretTokenPopup, Btn_Single) == 0x000498, "Member 'ULoginSecretTokenPopup::Btn_Single' has a wrong offset!");
static_assert(offsetof(ULoginSecretTokenPopup, Btn_CopyToClipboard) == 0x0004A0, "Member 'ULoginSecretTokenPopup::Btn_CopyToClipboard' has a wrong offset!");

// Class DungeonCrawler.LoginVoipInitializePopup
// 0x0058 (0x04E8 - 0x0490)
class ULoginVoipInitializePopup final : public UCommonPopupBase
{
public:
	class ULoginVoipInitializePopupData*          LoginVoipInitializePopupData;                      // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_VoipOnOff;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           VoipOnOffAction;                                   // 0x04A0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              WB_VoipOnOffBindListView;                          // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_VoipMode;                                       // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           VoipModeAction;                                    // 0x04B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              WB_VoipModeBindListView;                           // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuOptionToggleSwitchWidget*      WB_VoipSendMode;                                   // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           VoipSendModeAction;                                // 0x04D0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              WB_VoipSendModeBindListView;                       // 0x04D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    Btn_Accept;                                        // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleAcceptButtonClicked();
	void SetInputBind();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginVoipInitializePopup">();
	}
	static class ULoginVoipInitializePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginVoipInitializePopup>();
	}
};
static_assert(alignof(ULoginVoipInitializePopup) == 0x000008, "Wrong alignment on ULoginVoipInitializePopup");
static_assert(sizeof(ULoginVoipInitializePopup) == 0x0004E8, "Wrong size on ULoginVoipInitializePopup");
static_assert(offsetof(ULoginVoipInitializePopup, LoginVoipInitializePopupData) == 0x000490, "Member 'ULoginVoipInitializePopup::LoginVoipInitializePopupData' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, WB_VoipOnOff) == 0x000498, "Member 'ULoginVoipInitializePopup::WB_VoipOnOff' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, VoipOnOffAction) == 0x0004A0, "Member 'ULoginVoipInitializePopup::VoipOnOffAction' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, WB_VoipOnOffBindListView) == 0x0004A8, "Member 'ULoginVoipInitializePopup::WB_VoipOnOffBindListView' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, WB_VoipMode) == 0x0004B0, "Member 'ULoginVoipInitializePopup::WB_VoipMode' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, VoipModeAction) == 0x0004B8, "Member 'ULoginVoipInitializePopup::VoipModeAction' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, WB_VoipModeBindListView) == 0x0004C0, "Member 'ULoginVoipInitializePopup::WB_VoipModeBindListView' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, WB_VoipSendMode) == 0x0004C8, "Member 'ULoginVoipInitializePopup::WB_VoipSendMode' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, VoipSendModeAction) == 0x0004D0, "Member 'ULoginVoipInitializePopup::VoipSendModeAction' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, WB_VoipSendModeBindListView) == 0x0004D8, "Member 'ULoginVoipInitializePopup::WB_VoipSendModeBindListView' has a wrong offset!");
static_assert(offsetof(ULoginVoipInitializePopup, Btn_Accept) == 0x0004E0, "Member 'ULoginVoipInitializePopup::Btn_Accept' has a wrong offset!");

// Class DungeonCrawler.LoginWidget
// 0x0140 (0x05C8 - 0x0488)
class ULoginWidget final : public UDCCommonActivatableWidgetBase
{
public:
	EDCLoginState                                 LoginState;                                        // 0x0488(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A1[0x7];                                     // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonPopupManageWidget*               WB_Common_Popup_Manage;                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCommonPopupSWidget>        PopupWidgetClass;                                  // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonPopupSWidget*                    WB_CommonPopup_S;                                  // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   AbnormalDisconnectionText;                         // 0x04A8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   WelcomeText;                                       // 0x04C0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ConfirmReconnectText;                              // 0x04D8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ConfirmShouldReconnectText;                        // 0x04F0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ConnectText;                                       // 0x0508(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PrevGameClosedText;                                // 0x0520(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UComboBoxString*                        ServerListComboBox;                                // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_IP;                                        // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_ServerList;                                // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       IPTextBox;                                         // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCEditableText*                        IDTextBox;                                         // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       PasswordTextBox;                                   // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LoginMessage;                                      // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCCommonActivatableWidgetBase> LinkCrossPlatformPopupClass;                       // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCCommonActivatableWidgetBase> CreateAccountNicknamePopupClass;                   // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Password;                                          // 0x0580(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A2[0x14];                                    // 0x0590(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoginWidgetHandleData                 WidgetHandleData;                                  // 0x05A4(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A3[0x3];                                     // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCCommonActivatableWidgetBase> LoginVoipInitializePopupClass;                     // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCCommonActivatableWidgetBase> LoginGRACPopupClass;                               // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPreloadInfo                           PreloadInfo;                                       // 0x05B8(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A4[0x4];                                     // 0x05C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAgeRatingType(EAgeRatingType NewValue, EAgeRatingType OldValue);
	void OnLoginButtonClicked();
	void OnSelectionChanged(const class FString& SelectedItem, ESelectInfo SelectionType);
	void OnTextChangedLoginId(const class FText& InLoginId);
	void OnTextChangedPassWord(const class FText& InPassWord);
	void PlayLoginSound();
	void StopLoginSound();

	bool IsUsingDevPlatform() const;
	bool IsUsingPlatform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginWidget">();
	}
	static class ULoginWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginWidget>();
	}
};
static_assert(alignof(ULoginWidget) == 0x000008, "Wrong alignment on ULoginWidget");
static_assert(sizeof(ULoginWidget) == 0x0005C8, "Wrong size on ULoginWidget");
static_assert(offsetof(ULoginWidget, LoginState) == 0x000488, "Member 'ULoginWidget::LoginState' has a wrong offset!");
static_assert(offsetof(ULoginWidget, WB_Common_Popup_Manage) == 0x000490, "Member 'ULoginWidget::WB_Common_Popup_Manage' has a wrong offset!");
static_assert(offsetof(ULoginWidget, PopupWidgetClass) == 0x000498, "Member 'ULoginWidget::PopupWidgetClass' has a wrong offset!");
static_assert(offsetof(ULoginWidget, WB_CommonPopup_S) == 0x0004A0, "Member 'ULoginWidget::WB_CommonPopup_S' has a wrong offset!");
static_assert(offsetof(ULoginWidget, AbnormalDisconnectionText) == 0x0004A8, "Member 'ULoginWidget::AbnormalDisconnectionText' has a wrong offset!");
static_assert(offsetof(ULoginWidget, WelcomeText) == 0x0004C0, "Member 'ULoginWidget::WelcomeText' has a wrong offset!");
static_assert(offsetof(ULoginWidget, ConfirmReconnectText) == 0x0004D8, "Member 'ULoginWidget::ConfirmReconnectText' has a wrong offset!");
static_assert(offsetof(ULoginWidget, ConfirmShouldReconnectText) == 0x0004F0, "Member 'ULoginWidget::ConfirmShouldReconnectText' has a wrong offset!");
static_assert(offsetof(ULoginWidget, ConnectText) == 0x000508, "Member 'ULoginWidget::ConnectText' has a wrong offset!");
static_assert(offsetof(ULoginWidget, PrevGameClosedText) == 0x000520, "Member 'ULoginWidget::PrevGameClosedText' has a wrong offset!");
static_assert(offsetof(ULoginWidget, ServerListComboBox) == 0x000538, "Member 'ULoginWidget::ServerListComboBox' has a wrong offset!");
static_assert(offsetof(ULoginWidget, Overlay_IP) == 0x000540, "Member 'ULoginWidget::Overlay_IP' has a wrong offset!");
static_assert(offsetof(ULoginWidget, Overlay_ServerList) == 0x000548, "Member 'ULoginWidget::Overlay_ServerList' has a wrong offset!");
static_assert(offsetof(ULoginWidget, IPTextBox) == 0x000550, "Member 'ULoginWidget::IPTextBox' has a wrong offset!");
static_assert(offsetof(ULoginWidget, IDTextBox) == 0x000558, "Member 'ULoginWidget::IDTextBox' has a wrong offset!");
static_assert(offsetof(ULoginWidget, PasswordTextBox) == 0x000560, "Member 'ULoginWidget::PasswordTextBox' has a wrong offset!");
static_assert(offsetof(ULoginWidget, LoginMessage) == 0x000568, "Member 'ULoginWidget::LoginMessage' has a wrong offset!");
static_assert(offsetof(ULoginWidget, LinkCrossPlatformPopupClass) == 0x000570, "Member 'ULoginWidget::LinkCrossPlatformPopupClass' has a wrong offset!");
static_assert(offsetof(ULoginWidget, CreateAccountNicknamePopupClass) == 0x000578, "Member 'ULoginWidget::CreateAccountNicknamePopupClass' has a wrong offset!");
static_assert(offsetof(ULoginWidget, Password) == 0x000580, "Member 'ULoginWidget::Password' has a wrong offset!");
static_assert(offsetof(ULoginWidget, WidgetHandleData) == 0x0005A4, "Member 'ULoginWidget::WidgetHandleData' has a wrong offset!");
static_assert(offsetof(ULoginWidget, LoginVoipInitializePopupClass) == 0x0005A8, "Member 'ULoginWidget::LoginVoipInitializePopupClass' has a wrong offset!");
static_assert(offsetof(ULoginWidget, LoginGRACPopupClass) == 0x0005B0, "Member 'ULoginWidget::LoginGRACPopupClass' has a wrong offset!");
static_assert(offsetof(ULoginWidget, PreloadInfo) == 0x0005B8, "Member 'ULoginWidget::PreloadInfo' has a wrong offset!");

// Class DungeonCrawler.LootComponent
// 0x0108 (0x0318 - 0x0210)
class ULootComponent final : public UInventoryComponent
{
public:
	class AActor*                                 LootTargetActor;                                   // 0x0210(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             HitResultTargetData;                               // 0x0218(0x00E8)(Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bLootTargetIsPlayer;                               // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A6[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRemoveLootTarget;                                // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DCRemoveLootTargetEvent__DelegateSignature();
	class AActor* GetLootTargetActor();
	bool IsLootTargetPlayer();
	void OnRep_LootTargetActor(const class AActor* OldLootTargetActor);
	void ServerClearLootingTargetContainingItems();
	void ServerRemoveLootTarget(class UInventoryComponent* InventoryComponent, const TArray<struct FItemData>& InContainingItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootComponent">();
	}
	static class ULootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootComponent>();
	}
};
static_assert(alignof(ULootComponent) == 0x000008, "Wrong alignment on ULootComponent");
static_assert(sizeof(ULootComponent) == 0x000318, "Wrong size on ULootComponent");
static_assert(offsetof(ULootComponent, LootTargetActor) == 0x000210, "Member 'ULootComponent::LootTargetActor' has a wrong offset!");
static_assert(offsetof(ULootComponent, HitResultTargetData) == 0x000218, "Member 'ULootComponent::HitResultTargetData' has a wrong offset!");
static_assert(offsetof(ULootComponent, bLootTargetIsPlayer) == 0x000300, "Member 'ULootComponent::bLootTargetIsPlayer' has a wrong offset!");
static_assert(offsetof(ULootComponent, OnRemoveLootTarget) == 0x000308, "Member 'ULootComponent::OnRemoveLootTarget' has a wrong offset!");

// Class DungeonCrawler.LootingPlayerInventoryWidget
// 0x0010 (0x0368 - 0x0358)
class ULootingPlayerInventoryWidget final : public UDCWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnSetLootTargetPlayer;                             // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootingPlayerInventoryWidget">();
	}
	static class ULootingPlayerInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootingPlayerInventoryWidget>();
	}
};
static_assert(alignof(ULootingPlayerInventoryWidget) == 0x000008, "Wrong alignment on ULootingPlayerInventoryWidget");
static_assert(sizeof(ULootingPlayerInventoryWidget) == 0x000368, "Wrong size on ULootingPlayerInventoryWidget");
static_assert(offsetof(ULootingPlayerInventoryWidget, OnSetLootTargetPlayer) == 0x000358, "Member 'ULootingPlayerInventoryWidget::OnSetLootTargetPlayer' has a wrong offset!");

// Class DungeonCrawler.MailBoxItemWidgetDataBase
// 0x0060 (0x0088 - 0x0028)
class UMailBoxItemWidgetDataBase final : public UObject
{
public:
	struct FNickname                              Nickname;                                          // 0x0028(0x0040)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FString                                 AccountId;                                         // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailBoxItemWidgetDataBase">();
	}
	static class UMailBoxItemWidgetDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailBoxItemWidgetDataBase>();
	}
};
static_assert(alignof(UMailBoxItemWidgetDataBase) == 0x000008, "Wrong alignment on UMailBoxItemWidgetDataBase");
static_assert(sizeof(UMailBoxItemWidgetDataBase) == 0x000088, "Wrong size on UMailBoxItemWidgetDataBase");
static_assert(offsetof(UMailBoxItemWidgetDataBase, Nickname) == 0x000028, "Member 'UMailBoxItemWidgetDataBase::Nickname' has a wrong offset!");
static_assert(offsetof(UMailBoxItemWidgetDataBase, AccountId) == 0x000068, "Member 'UMailBoxItemWidgetDataBase::AccountId' has a wrong offset!");
static_assert(offsetof(UMailBoxItemWidgetDataBase, CharacterId) == 0x000078, "Member 'UMailBoxItemWidgetDataBase::CharacterId' has a wrong offset!");

// Class DungeonCrawler.MailBoxListWidgetBase
// 0x0008 (0x0360 - 0x0358)
class UMailBoxListWidgetBase final : public UDCWidgetBase
{
public:
	uint8                                         Pad_28A7[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPopupSWidgetInvitePartyAnswerResponse(EPopupResult PopupResult, const class FString& ReturnAccountID, const struct FNickname& SenderNickname);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailBoxListWidgetBase">();
	}
	static class UMailBoxListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailBoxListWidgetBase>();
	}
};
static_assert(alignof(UMailBoxListWidgetBase) == 0x000008, "Wrong alignment on UMailBoxListWidgetBase");
static_assert(sizeof(UMailBoxListWidgetBase) == 0x000360, "Wrong size on UMailBoxListWidgetBase");

// Class DungeonCrawler.MetaClassComponent
// 0x01F0 (0x02F0 - 0x0100)
class UMetaClassComponent final : public UMetaComponentBase
{
public:
	uint8                                         Pad_28A9[0x98];                                    // 0x0100(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccountLink*                           AccountLink;                                       // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EDCSkillClassAbility>                  SkillClassAbilities;                               // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                SpellIdArray;                                      // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataSpell>              AccountDataSpellArray;                             // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                MusicIdArray;                                      // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataMusic>              AccountDataMusicArray;                             // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                ShapeShiftIdArray;                                 // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAccountDataShapeShift>         AccountDataShapeShiftArray;                        // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FDCClassTrainingInfo                   TrainingInfo;                                      // 0x0210(0x0088)(Transient, NativeAccessSpecifierPrivate)
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28AA[0x48];                                    // 0x02A0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TokenRedeemSound;                                  // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaClassComponent">();
	}
	static class UMetaClassComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaClassComponent>();
	}
};
static_assert(alignof(UMetaClassComponent) == 0x000008, "Wrong alignment on UMetaClassComponent");
static_assert(sizeof(UMetaClassComponent) == 0x0002F0, "Wrong size on UMetaClassComponent");
static_assert(offsetof(UMetaClassComponent, AccountLink) == 0x000198, "Member 'UMetaClassComponent::AccountLink' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, SkillClassAbilities) == 0x0001A0, "Member 'UMetaClassComponent::SkillClassAbilities' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, SpellIdArray) == 0x0001B0, "Member 'UMetaClassComponent::SpellIdArray' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, AccountDataSpellArray) == 0x0001C0, "Member 'UMetaClassComponent::AccountDataSpellArray' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, MusicIdArray) == 0x0001D0, "Member 'UMetaClassComponent::MusicIdArray' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, AccountDataMusicArray) == 0x0001E0, "Member 'UMetaClassComponent::AccountDataMusicArray' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, ShapeShiftIdArray) == 0x0001F0, "Member 'UMetaClassComponent::ShapeShiftIdArray' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, AccountDataShapeShiftArray) == 0x000200, "Member 'UMetaClassComponent::AccountDataShapeShiftArray' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, TrainingInfo) == 0x000210, "Member 'UMetaClassComponent::TrainingInfo' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, InventoryComponent) == 0x000298, "Member 'UMetaClassComponent::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UMetaClassComponent, TokenRedeemSound) == 0x0002E8, "Member 'UMetaClassComponent::TokenRedeemSound' has a wrong offset!");

// Class DungeonCrawler.MetaDungeonRotationInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaDungeonRotationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaDungeonRotationInterface">();
	}
	static class IMetaDungeonRotationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaDungeonRotationInterface>();
	}
};
static_assert(alignof(IMetaDungeonRotationInterface) == 0x000008, "Wrong alignment on IMetaDungeonRotationInterface");
static_assert(sizeof(IMetaDungeonRotationInterface) == 0x000028, "Wrong size on IMetaDungeonRotationInterface");

// Class DungeonCrawler.MetaFriendComponent
// 0x0040 (0x0140 - 0x0100)
class UMetaFriendComponent final : public UMetaComponentBase
{
public:
	uint8                                         Pad_28AB[0x40];                                    // 0x0100(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaFriendComponent">();
	}
	static class UMetaFriendComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaFriendComponent>();
	}
};
static_assert(alignof(UMetaFriendComponent) == 0x000008, "Wrong alignment on UMetaFriendComponent");
static_assert(sizeof(UMetaFriendComponent) == 0x000140, "Wrong size on UMetaFriendComponent");

// Class DungeonCrawler.MetaGRACInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaGRACInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaGRACInterface">();
	}
	static class IMetaGRACInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaGRACInterface>();
	}
};
static_assert(alignof(IMetaGRACInterface) == 0x000008, "Wrong alignment on IMetaGRACInterface");
static_assert(sizeof(IMetaGRACInterface) == 0x000028, "Wrong size on IMetaGRACInterface");

// Class DungeonCrawler.MetaKarmaComponent
// 0x0000 (0x0100 - 0x0100)
class UMetaKarmaComponent final : public UMetaComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaKarmaComponent">();
	}
	static class UMetaKarmaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaKarmaComponent>();
	}
};
static_assert(alignof(UMetaKarmaComponent) == 0x000008, "Wrong alignment on UMetaKarmaComponent");
static_assert(sizeof(UMetaKarmaComponent) == 0x000100, "Wrong size on UMetaKarmaComponent");

// Class DungeonCrawler.MetaLeaderboardComponent
// 0x0160 (0x0260 - 0x0100)
class UMetaLeaderboardComponent final : public UMetaComponentBase
{
public:
	uint8                                         Pad_28AC[0x80];                                    // 0x0100(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLeaderboardSeasonInfo>         LeaderboardSeasonInfoArray;                        // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28AD[0xD0];                                    // 0x0190(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaLeaderboardComponent">();
	}
	static class UMetaLeaderboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaLeaderboardComponent>();
	}
};
static_assert(alignof(UMetaLeaderboardComponent) == 0x000008, "Wrong alignment on UMetaLeaderboardComponent");
static_assert(sizeof(UMetaLeaderboardComponent) == 0x000260, "Wrong size on UMetaLeaderboardComponent");
static_assert(offsetof(UMetaLeaderboardComponent, LeaderboardSeasonInfoArray) == 0x000180, "Member 'UMetaLeaderboardComponent::LeaderboardSeasonInfoArray' has a wrong offset!");

// Class DungeonCrawler.MetaPartyInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaPartyInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaPartyInterface">();
	}
	static class IMetaPartyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaPartyInterface>();
	}
};
static_assert(alignof(IMetaPartyInterface) == 0x000008, "Wrong alignment on IMetaPartyInterface");
static_assert(sizeof(IMetaPartyInterface) == 0x000028, "Wrong size on IMetaPartyInterface");

// Class DungeonCrawler.MetaPlayComponent
// 0x0080 (0x0180 - 0x0100)
class UMetaPlayComponent final : public UMetaComponentBase
{
public:
	uint8                                         Pad_28AE[0x20];                                    // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCInventoryComponent*                  InventoryComponent;                                // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28AF[0x8];                                     // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EWidgetPartyUserLocate, class ADCCharacterLobbyCapture*> CharacterLobbyCaptureMap;                          // 0x0130(0x0050)(NativeAccessSpecifierPrivate)

public:
	void OnRecruitBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaPlayComponent">();
	}
	static class UMetaPlayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaPlayComponent>();
	}
};
static_assert(alignof(UMetaPlayComponent) == 0x000008, "Wrong alignment on UMetaPlayComponent");
static_assert(sizeof(UMetaPlayComponent) == 0x000180, "Wrong size on UMetaPlayComponent");
static_assert(offsetof(UMetaPlayComponent, InventoryComponent) == 0x000120, "Member 'UMetaPlayComponent::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UMetaPlayComponent, CharacterLobbyCaptureMap) == 0x000130, "Member 'UMetaPlayComponent::CharacterLobbyCaptureMap' has a wrong offset!");

// Class DungeonCrawler.MetaStatisticsComponent
// 0x0068 (0x0168 - 0x0100)
class UMetaStatisticsComponent final : public UMetaComponentBase
{
public:
	uint8                                         Pad_28B0[0x68];                                    // 0x0100(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaStatisticsComponent">();
	}
	static class UMetaStatisticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaStatisticsComponent>();
	}
};
static_assert(alignof(UMetaStatisticsComponent) == 0x000008, "Wrong alignment on UMetaStatisticsComponent");
static_assert(sizeof(UMetaStatisticsComponent) == 0x000168, "Wrong size on UMetaStatisticsComponent");

// Class DungeonCrawler.MetaVoipComponent
// 0x0070 (0x02B0 - 0x0240)
class UMetaVoipComponent : public UDCVoipComponent
{
public:
	uint8                                         Pad_28B1[0x20];                                    // 0x0240(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDCAccountId, struct FMetaBindAccountUserData> MetaBindAccountUserDataMap;                        // 0x0260(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaVoipComponent">();
	}
	static class UMetaVoipComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaVoipComponent>();
	}
};
static_assert(alignof(UMetaVoipComponent) == 0x000008, "Wrong alignment on UMetaVoipComponent");
static_assert(sizeof(UMetaVoipComponent) == 0x0002B0, "Wrong size on UMetaVoipComponent");
static_assert(offsetof(UMetaVoipComponent, MetaBindAccountUserDataMap) == 0x000260, "Member 'UMetaVoipComponent::MetaBindAccountUserDataMap' has a wrong offset!");

// Class DungeonCrawler.VoipAkComponent
// 0x0090 (0x0500 - 0x0470)
class UVoipAkComponent : public UAkComponent
{
public:
	class UAkAudioEvent*                          SendPlayEvent;                                     // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          SendStopEvent;                                     // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          Receive2dPlayEvent;                                // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          Receive3dPlayEvent;                                // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ReceiveStopEvent;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                ReceiveSensitivityRtpc;                            // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReceiveSensitivityMargin;                          // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B2[0x4];                                     // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                SendSensitivityRtpc;                               // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SendSensitivityMargin;                             // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B3[0x4];                                     // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                GlobalInputVolumeRtpc;                             // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                GlobalOutputVolumeRtpc;                            // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkRtpc*                                ReceiveVolumeRtpc;                                 // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B4[0x30];                                    // 0x04D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipAkComponent">();
	}
	static class UVoipAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipAkComponent>();
	}
};
static_assert(alignof(UVoipAkComponent) == 0x000010, "Wrong alignment on UVoipAkComponent");
static_assert(sizeof(UVoipAkComponent) == 0x000500, "Wrong size on UVoipAkComponent");
static_assert(offsetof(UVoipAkComponent, SendPlayEvent) == 0x000470, "Member 'UVoipAkComponent::SendPlayEvent' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, SendStopEvent) == 0x000478, "Member 'UVoipAkComponent::SendStopEvent' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, Receive2dPlayEvent) == 0x000480, "Member 'UVoipAkComponent::Receive2dPlayEvent' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, Receive3dPlayEvent) == 0x000488, "Member 'UVoipAkComponent::Receive3dPlayEvent' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, ReceiveStopEvent) == 0x000490, "Member 'UVoipAkComponent::ReceiveStopEvent' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, ReceiveSensitivityRtpc) == 0x000498, "Member 'UVoipAkComponent::ReceiveSensitivityRtpc' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, ReceiveSensitivityMargin) == 0x0004A0, "Member 'UVoipAkComponent::ReceiveSensitivityMargin' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, SendSensitivityRtpc) == 0x0004A8, "Member 'UVoipAkComponent::SendSensitivityRtpc' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, SendSensitivityMargin) == 0x0004B0, "Member 'UVoipAkComponent::SendSensitivityMargin' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, GlobalInputVolumeRtpc) == 0x0004B8, "Member 'UVoipAkComponent::GlobalInputVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, GlobalOutputVolumeRtpc) == 0x0004C0, "Member 'UVoipAkComponent::GlobalOutputVolumeRtpc' has a wrong offset!");
static_assert(offsetof(UVoipAkComponent, ReceiveVolumeRtpc) == 0x0004C8, "Member 'UVoipAkComponent::ReceiveVolumeRtpc' has a wrong offset!");

// Class DungeonCrawler.MetaVoipInterface
// 0x0000 (0x0028 - 0x0028)
class IMetaVoipInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaVoipInterface">();
	}
	static class IMetaVoipInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMetaVoipInterface>();
	}
};
static_assert(alignof(IMetaVoipInterface) == 0x000008, "Wrong alignment on IMetaVoipInterface");
static_assert(sizeof(IMetaVoipInterface) == 0x000028, "Wrong size on IMetaVoipInterface");

// Class DungeonCrawler.MiniMapConfigData
// 0x0020 (0x0068 - 0x0048)
class UMiniMapConfigData final : public UDCDataAssetBase
{
public:
	float                                         OrthoWidth;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Zoom;                                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ModuleSize;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullMapActorTranslationOffset;                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B5[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapConfigData">();
	}
	static class UMiniMapConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapConfigData>();
	}
};
static_assert(alignof(UMiniMapConfigData) == 0x000008, "Wrong alignment on UMiniMapConfigData");
static_assert(sizeof(UMiniMapConfigData) == 0x000068, "Wrong size on UMiniMapConfigData");
static_assert(offsetof(UMiniMapConfigData, OrthoWidth) == 0x000048, "Member 'UMiniMapConfigData::OrthoWidth' has a wrong offset!");
static_assert(offsetof(UMiniMapConfigData, Zoom) == 0x00004C, "Member 'UMiniMapConfigData::Zoom' has a wrong offset!");
static_assert(offsetof(UMiniMapConfigData, ModuleSize) == 0x000050, "Member 'UMiniMapConfigData::ModuleSize' has a wrong offset!");
static_assert(offsetof(UMiniMapConfigData, FullMapActorTranslationOffset) == 0x000060, "Member 'UMiniMapConfigData::FullMapActorTranslationOffset' has a wrong offset!");

// Class DungeonCrawler.MusicActor
// 0x0128 (0x0420 - 0x02F8)
class AMusicActor final : public ADCActorBase
{
public:
	uint8                                         Pad_28B6[0x20];                                    // 0x02F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       DesignDataMusic;                                   // 0x0318(0x00C8)(NativeAccessSpecifierPrivate)
	struct FMusicData                             MusicData;                                         // 0x03E0(0x0024)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28B7[0x4];                                     // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArtDataMusic*                          ArtDataMusic;                                      // 0x0408(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundData*                             SoundData;                                         // 0x0410(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayMusicData*                         PlayMusicData;                                     // 0x0418(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_MusicData(const struct FMusicData& OldMusicData);
	void SetMusicData(const struct FMusicData& NewMusicData);

	class UArtDataMusic* GetArtDataMusic() const;
	struct FDesignDataMusic GetDesignDataMusic() const;
	struct FMusicData GetMusicData() const;
	class UPlayMusicData* GetPlayMusicData() const;
	class USoundData* GetSoundDataMusic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicActor">();
	}
	static class AMusicActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicActor>();
	}
};
static_assert(alignof(AMusicActor) == 0x000008, "Wrong alignment on AMusicActor");
static_assert(sizeof(AMusicActor) == 0x000420, "Wrong size on AMusicActor");
static_assert(offsetof(AMusicActor, DesignDataMusic) == 0x000318, "Member 'AMusicActor::DesignDataMusic' has a wrong offset!");
static_assert(offsetof(AMusicActor, MusicData) == 0x0003E0, "Member 'AMusicActor::MusicData' has a wrong offset!");
static_assert(offsetof(AMusicActor, ArtDataMusic) == 0x000408, "Member 'AMusicActor::ArtDataMusic' has a wrong offset!");
static_assert(offsetof(AMusicActor, SoundData) == 0x000410, "Member 'AMusicActor::SoundData' has a wrong offset!");
static_assert(offsetof(AMusicActor, PlayMusicData) == 0x000418, "Member 'AMusicActor::PlayMusicData' has a wrong offset!");

// Class DungeonCrawler.MusicComponent
// 0x00A0 (0x0148 - 0x00A8)
class UMusicComponent final : public UDCPlayerCharacterClassComponent
{
public:
	uint8                                         Pad_28B8[0x88];                                    // 0x00A8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMusicActor*>                    MusicActors;                                       // 0x0130(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentMusicTag;                                   // 0x0140(0x0008)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnRep_CurrentMusicTag();
	void OnRep_MusicActors(const TArray<class AMusicActor*>& OldAMusicActors);
	void ServerSetCurrentMusic(const struct FGameplayTag& MusicTag);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicComponent">();
	}
	static class UMusicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicComponent>();
	}
};
static_assert(alignof(UMusicComponent) == 0x000008, "Wrong alignment on UMusicComponent");
static_assert(sizeof(UMusicComponent) == 0x000148, "Wrong size on UMusicComponent");
static_assert(offsetof(UMusicComponent, MusicActors) == 0x000130, "Member 'UMusicComponent::MusicActors' has a wrong offset!");
static_assert(offsetof(UMusicComponent, CurrentMusicTag) == 0x000140, "Member 'UMusicComponent::CurrentMusicTag' has a wrong offset!");

// Class DungeonCrawler.MyStatusWidget
// 0x0028 (0x0380 - 0x0358)
class UMyStatusWidget final : public UDCWidgetBase
{
public:
	class UStatusSlotWidget*                      Online;                                            // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatusSlotWidget*                      Absence;                                           // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatusSlotWidget*                      Offline;                                           // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B9[0x10];                                    // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectStatus(int32 InRadioButtonIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyStatusWidget">();
	}
	static class UMyStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyStatusWidget>();
	}
};
static_assert(alignof(UMyStatusWidget) == 0x000008, "Wrong alignment on UMyStatusWidget");
static_assert(sizeof(UMyStatusWidget) == 0x000380, "Wrong size on UMyStatusWidget");
static_assert(offsetof(UMyStatusWidget, Online) == 0x000358, "Member 'UMyStatusWidget::Online' has a wrong offset!");
static_assert(offsetof(UMyStatusWidget, Absence) == 0x000360, "Member 'UMyStatusWidget::Absence' has a wrong offset!");
static_assert(offsetof(UMyStatusWidget, Offline) == 0x000368, "Member 'UMyStatusWidget::Offline' has a wrong offset!");

// Class DungeonCrawler.OnlineSystemEpic
// 0x00B0 (0x00E0 - 0x0030)
class UOnlineSystemEpic final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_28BA[0xB0];                                    // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSystemEpic">();
	}
	static class UOnlineSystemEpic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSystemEpic>();
	}
};
static_assert(alignof(UOnlineSystemEpic) == 0x000008, "Wrong alignment on UOnlineSystemEpic");
static_assert(sizeof(UOnlineSystemEpic) == 0x0000E0, "Wrong size on UOnlineSystemEpic");

// Class DungeonCrawler.OnlineSystemIronmace
// 0x0058 (0x0088 - 0x0030)
class UOnlineSystemIronmace final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_28BB[0x58];                                    // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSystemIronmace">();
	}
	static class UOnlineSystemIronmace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSystemIronmace>();
	}
};
static_assert(alignof(UOnlineSystemIronmace) == 0x000008, "Wrong alignment on UOnlineSystemIronmace");
static_assert(sizeof(UOnlineSystemIronmace) == 0x000088, "Wrong size on UOnlineSystemIronmace");

// Class DungeonCrawler.OnlineSystemSteam
// 0x00D0 (0x0100 - 0x0030)
class UOnlineSystemSteam final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_28BC[0xD0];                                    // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSystemSteam">();
	}
	static class UOnlineSystemSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSystemSteam>();
	}
};
static_assert(alignof(UOnlineSystemSteam) == 0x000008, "Wrong alignment on UOnlineSystemSteam");
static_assert(sizeof(UOnlineSystemSteam) == 0x000100, "Wrong size on UOnlineSystemSteam");

// Class DungeonCrawler.PartySession
// 0x0080 (0x00A8 - 0x0028)
class UPartySession final : public UObject
{
public:
	uint8                                         Pad_28BD[0x58];                                    // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28BE[0x20];                                    // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartySession">();
	}
	static class UPartySession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartySession>();
	}
};
static_assert(alignof(UPartySession) == 0x000008, "Wrong alignment on UPartySession");
static_assert(sizeof(UPartySession) == 0x0000A8, "Wrong size on UPartySession");
static_assert(offsetof(UPartySession, BaseObject) == 0x000080, "Member 'UPartySession::BaseObject' has a wrong offset!");

// Class DungeonCrawler.PavisePropBase
// 0x0010 (0x03F0 - 0x03E0)
class APavisePropBase : public APropsActorBase
{
public:
	TSubclassOf<class AItemHolderActorBase>       ItemHolderClassToSpawn;                            // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushingForce;                                      // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28BF[0x4];                                     // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PavisePropBase">();
	}
	static class APavisePropBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APavisePropBase>();
	}
};
static_assert(alignof(APavisePropBase) == 0x000008, "Wrong alignment on APavisePropBase");
static_assert(sizeof(APavisePropBase) == 0x0003F0, "Wrong size on APavisePropBase");
static_assert(offsetof(APavisePropBase, ItemHolderClassToSpawn) == 0x0003E0, "Member 'APavisePropBase::ItemHolderClassToSpawn' has a wrong offset!");
static_assert(offsetof(APavisePropBase, PushingForce) == 0x0003E8, "Member 'APavisePropBase::PushingForce' has a wrong offset!");

// Class DungeonCrawler.PerkWidget
// 0x0050 (0x03A8 - 0x0358)
class UPerkWidget final : public UDCWidgetBase
{
public:
	class UImage*                                 PerkIconImage;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPerkWidgetData                        PerkWidgetData;                                    // 0x0360(0x0030)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                PerkToolTipWidgetClass;                            // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        PerkId;                                            // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializePerkWidget(const struct FPrimaryAssetId& InPerkId);
	void OnSetPerkData();
	void SetPerkData(const class FText& PerkName, const class FText& PerkDesc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkWidget">();
	}
	static class UPerkWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkWidget>();
	}
};
static_assert(alignof(UPerkWidget) == 0x000008, "Wrong alignment on UPerkWidget");
static_assert(sizeof(UPerkWidget) == 0x0003A8, "Wrong size on UPerkWidget");
static_assert(offsetof(UPerkWidget, PerkIconImage) == 0x000358, "Member 'UPerkWidget::PerkIconImage' has a wrong offset!");
static_assert(offsetof(UPerkWidget, PerkWidgetData) == 0x000360, "Member 'UPerkWidget::PerkWidgetData' has a wrong offset!");
static_assert(offsetof(UPerkWidget, PerkToolTipWidgetClass) == 0x000390, "Member 'UPerkWidget::PerkToolTipWidgetClass' has a wrong offset!");
static_assert(offsetof(UPerkWidget, PerkId) == 0x000398, "Member 'UPerkWidget::PerkId' has a wrong offset!");

// Class DungeonCrawler.PlayerSlotWidgetData
// 0x01D8 (0x0200 - 0x0028)
class UPlayerSlotWidgetData final : public UObject
{
public:
	struct FInvitePartyUserSlot                   Info;                                              // 0x0028(0x0098)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterClassId;                                  // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPlayerCharacter             DesignDataPlayerCharacter;                         // 0x00D0(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UInvitePartyWidget*                     InvitePartyWidget;                                 // 0x01F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSlotWidgetData">();
	}
	static class UPlayerSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSlotWidgetData>();
	}
};
static_assert(alignof(UPlayerSlotWidgetData) == 0x000008, "Wrong alignment on UPlayerSlotWidgetData");
static_assert(sizeof(UPlayerSlotWidgetData) == 0x000200, "Wrong size on UPlayerSlotWidgetData");
static_assert(offsetof(UPlayerSlotWidgetData, Info) == 0x000028, "Member 'UPlayerSlotWidgetData::Info' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidgetData, CharacterClassId) == 0x0000C0, "Member 'UPlayerSlotWidgetData::CharacterClassId' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidgetData, DesignDataPlayerCharacter) == 0x0000D0, "Member 'UPlayerSlotWidgetData::DesignDataPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidgetData, InvitePartyWidget) == 0x0001F8, "Member 'UPlayerSlotWidgetData::InvitePartyWidget' has a wrong offset!");

// Class DungeonCrawler.PlayerSlotWidget
// 0x0048 (0x0438 - 0x03F0)
class UPlayerSlotWidget final : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_28C0[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCLocationStatus                             LocationStatus;                                    // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C1[0x3];                                     // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPartyMembers;                                   // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumPartyMembers;                                // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMine;                                             // 0x042C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x042D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EServerLocation                               ServerLocation;                                    // 0x042E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C2[0x9];                                     // 0x042F(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSlotWidget">();
	}
	static class UPlayerSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSlotWidget>();
	}
};
static_assert(alignof(UPlayerSlotWidget) == 0x000008, "Wrong alignment on UPlayerSlotWidget");
static_assert(sizeof(UPlayerSlotWidget) == 0x000438, "Wrong size on UPlayerSlotWidget");
static_assert(offsetof(UPlayerSlotWidget, AccountId) == 0x000400, "Member 'UPlayerSlotWidget::AccountId' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, CharacterId) == 0x000410, "Member 'UPlayerSlotWidget::CharacterId' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, LocationStatus) == 0x000420, "Member 'UPlayerSlotWidget::LocationStatus' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, NumPartyMembers) == 0x000424, "Member 'UPlayerSlotWidget::NumPartyMembers' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, MaxNumPartyMembers) == 0x000428, "Member 'UPlayerSlotWidget::MaxNumPartyMembers' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, bMine) == 0x00042C, "Member 'UPlayerSlotWidget::bMine' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, bSelected) == 0x00042D, "Member 'UPlayerSlotWidget::bSelected' has a wrong offset!");
static_assert(offsetof(UPlayerSlotWidget, ServerLocation) == 0x00042E, "Member 'UPlayerSlotWidget::ServerLocation' has a wrong offset!");

// Class DungeonCrawler.PlayMusicData
// 0x0030 (0x0078 - 0x0048)
class UPlayMusicData final : public UDCDataAssetBase
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkStopEvent;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCPlayMusicDataContainer>      PlayMusicDatas;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDCPlayMusicDataContainer>      ChannelingPlayMusicDatas;                          // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayMusicData">();
	}
	static class UPlayMusicData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayMusicData>();
	}
};
static_assert(alignof(UPlayMusicData) == 0x000008, "Wrong alignment on UPlayMusicData");
static_assert(sizeof(UPlayMusicData) == 0x000078, "Wrong size on UPlayMusicData");
static_assert(offsetof(UPlayMusicData, AkEvent) == 0x000048, "Member 'UPlayMusicData::AkEvent' has a wrong offset!");
static_assert(offsetof(UPlayMusicData, AkStopEvent) == 0x000050, "Member 'UPlayMusicData::AkStopEvent' has a wrong offset!");
static_assert(offsetof(UPlayMusicData, PlayMusicDatas) == 0x000058, "Member 'UPlayMusicData::PlayMusicDatas' has a wrong offset!");
static_assert(offsetof(UPlayMusicData, ChannelingPlayMusicDatas) == 0x000068, "Member 'UPlayMusicData::ChannelingPlayMusicDatas' has a wrong offset!");

// Class DungeonCrawler.ProjectileActor
// 0x0458 (0x0760 - 0x0308)
class AProjectileActor : public ADCAbilityActorBase
{
public:
	uint8                                         Pad_28C3[0x8];                                     // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHomingProjectile;                               // 0x0320(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C4[0x3];                                     // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingMagnitude;                                   // 0x0324(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GravityScale;                                      // 0x0328(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C5[0x4];                                     // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HomingTargetComponent;                             // 0x0330(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        OldHomingTargetComponent;                          // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C6[0x8];                                     // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectileMovementComponentLocalVelocity;          // 0x0348(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ProjectileMovementComponentVelocity;               // 0x0360(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCProjectileDataAsset*                 ProjectileDataAsset;                               // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PierceCount;                                       // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsObstaclePierce;                                  // 0x0384(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTreatShieldAsObstacle;                            // 0x0385(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C7[0x2];                                     // 0x0386(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ObstaclePierceDecrease;                            // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Lifetime;                                          // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   AbilityTriggerTagsWhenLifeTimeExpired;             // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C8[0x8];                                     // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                AddEffectToTargetHit;                              // 0x03A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPrimaryAssetId>                AddEffectToGroundHit;                              // 0x03B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C9[0x8];                                     // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x03D0(0x0060)(Edit, BlueprintVisible, Config, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemData                              ProjectileItemData;                                // 0x0430(0x0100)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UArtDataItem*                           ProjectileItemArtData;                             // 0x0530(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemData                              AmmoItemData;                                      // 0x0538(0x0100)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AccelerationCurve;                                 // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTime_AccelTimeline;                           // 0x0640(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate_AccelTimeline;                            // 0x0644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLoop_AccelTimeline;                              // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28CA[0x7];                                     // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              AccelrationTimeline;                               // 0x0650(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USoundData*                             SoundData;                                         // 0x06E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayAbilitySpecHandle>     GameplayAbilitySpecHandles;                        // 0x06F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    GameplayEffectHandles;                             // 0x0700(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28CB[0x20];                                    // 0x0710(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldAttachWhenHitCharacter;                     // 0x0730(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldAttachWhenHitShield;                        // 0x0731(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldAttachWhenHitStaticObject;                  // 0x0732(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldAliveAfterHit;                              // 0x0733(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28CC[0x2C];                                    // 0x0734(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount);
	TArray<struct FPrimaryAssetId> GetAddEffectToGroundHit();
	TArray<struct FPrimaryAssetId> GetAddEffectToTargetHit();
	void HandleTimelineFinished();
	void HandleTimelineUpdate(float Value);
	void InitArrivalVelocity(const struct FVector& Velocity);
	float InitialSpeed();
	void InitVelocity(float FirePower);
	void LifeTimeExpired();
	bool MatchesProjectileSourceTypeTagExact(const struct FGameplayTag& CheckGameplayTag);
	void OnHomingTargetDeath(const struct FGameplayTag& InGameplayTag, int32 InCount);
	void OnLifeTimeExpired();
	void OnRep_HomingMagnitude();
	void OnRep_HomingTargetComponent();
	void OnRep_IsHomingProjectile();
	void OnRep_ProjectileGravityScale();
	void OnRep_ProjectileMovementComponentLocalVelocity();
	void OnRep_ProjectileMovementComponentVelocity();
	void PlayPierce(float SetPierceCount, bool SetObstaclePierce, float SetObstaclePierceDecrease);
	void ProjectileHit(const struct FHitResult& Hit, bool bIsAttached, const struct FTransform& ActorPrevTickTransform);
	void SetAddEffectToGroundtHit(const TArray<struct FPrimaryAssetId>& AddEffectList);
	void SetAddEffectToTargetHit(const TArray<struct FPrimaryAssetId>& AddEffectList);
	void SetHomingMagnitude(float InHomingMagnitude);
	void SetHomingTargetComponent(class USceneComponent* InHomingTargetComponent);
	void StopPierce();
	void TimelineFinishedEvent();
	void TimelineUpdateEvent(float Value, float TimelinePosition);

	class UArtDataProjectile* GetArtDataProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileActor">();
	}
	static class AProjectileActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileActor>();
	}
};
static_assert(alignof(AProjectileActor) == 0x000010, "Wrong alignment on AProjectileActor");
static_assert(sizeof(AProjectileActor) == 0x000760, "Wrong size on AProjectileActor");
static_assert(offsetof(AProjectileActor, Mesh) == 0x000310, "Member 'AProjectileActor::Mesh' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ProjectileMovement) == 0x000318, "Member 'AProjectileActor::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(AProjectileActor, bIsHomingProjectile) == 0x000320, "Member 'AProjectileActor::bIsHomingProjectile' has a wrong offset!");
static_assert(offsetof(AProjectileActor, HomingMagnitude) == 0x000324, "Member 'AProjectileActor::HomingMagnitude' has a wrong offset!");
static_assert(offsetof(AProjectileActor, GravityScale) == 0x000328, "Member 'AProjectileActor::GravityScale' has a wrong offset!");
static_assert(offsetof(AProjectileActor, HomingTargetComponent) == 0x000330, "Member 'AProjectileActor::HomingTargetComponent' has a wrong offset!");
static_assert(offsetof(AProjectileActor, OldHomingTargetComponent) == 0x000338, "Member 'AProjectileActor::OldHomingTargetComponent' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ProjectileMovementComponentLocalVelocity) == 0x000348, "Member 'AProjectileActor::ProjectileMovementComponentLocalVelocity' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ProjectileMovementComponentVelocity) == 0x000360, "Member 'AProjectileActor::ProjectileMovementComponentVelocity' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ProjectileDataAsset) == 0x000378, "Member 'AProjectileActor::ProjectileDataAsset' has a wrong offset!");
static_assert(offsetof(AProjectileActor, PierceCount) == 0x000380, "Member 'AProjectileActor::PierceCount' has a wrong offset!");
static_assert(offsetof(AProjectileActor, IsObstaclePierce) == 0x000384, "Member 'AProjectileActor::IsObstaclePierce' has a wrong offset!");
static_assert(offsetof(AProjectileActor, bTreatShieldAsObstacle) == 0x000385, "Member 'AProjectileActor::bTreatShieldAsObstacle' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ObstaclePierceDecrease) == 0x000388, "Member 'AProjectileActor::ObstaclePierceDecrease' has a wrong offset!");
static_assert(offsetof(AProjectileActor, Lifetime) == 0x00038C, "Member 'AProjectileActor::Lifetime' has a wrong offset!");
static_assert(offsetof(AProjectileActor, AbilityTriggerTagsWhenLifeTimeExpired) == 0x000390, "Member 'AProjectileActor::AbilityTriggerTagsWhenLifeTimeExpired' has a wrong offset!");
static_assert(offsetof(AProjectileActor, AddEffectToTargetHit) == 0x0003A8, "Member 'AProjectileActor::AddEffectToTargetHit' has a wrong offset!");
static_assert(offsetof(AProjectileActor, AddEffectToGroundHit) == 0x0003B8, "Member 'AProjectileActor::AddEffectToGroundHit' has a wrong offset!");
static_assert(offsetof(AProjectileActor, SpawnTransform) == 0x0003D0, "Member 'AProjectileActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ProjectileItemData) == 0x000430, "Member 'AProjectileActor::ProjectileItemData' has a wrong offset!");
static_assert(offsetof(AProjectileActor, ProjectileItemArtData) == 0x000530, "Member 'AProjectileActor::ProjectileItemArtData' has a wrong offset!");
static_assert(offsetof(AProjectileActor, AmmoItemData) == 0x000538, "Member 'AProjectileActor::AmmoItemData' has a wrong offset!");
static_assert(offsetof(AProjectileActor, AccelerationCurve) == 0x000638, "Member 'AProjectileActor::AccelerationCurve' has a wrong offset!");
static_assert(offsetof(AProjectileActor, StartTime_AccelTimeline) == 0x000640, "Member 'AProjectileActor::StartTime_AccelTimeline' has a wrong offset!");
static_assert(offsetof(AProjectileActor, PlayRate_AccelTimeline) == 0x000644, "Member 'AProjectileActor::PlayRate_AccelTimeline' has a wrong offset!");
static_assert(offsetof(AProjectileActor, IsLoop_AccelTimeline) == 0x000648, "Member 'AProjectileActor::IsLoop_AccelTimeline' has a wrong offset!");
static_assert(offsetof(AProjectileActor, AccelrationTimeline) == 0x000650, "Member 'AProjectileActor::AccelrationTimeline' has a wrong offset!");
static_assert(offsetof(AProjectileActor, SoundData) == 0x0006E8, "Member 'AProjectileActor::SoundData' has a wrong offset!");
static_assert(offsetof(AProjectileActor, GameplayAbilitySpecHandles) == 0x0006F0, "Member 'AProjectileActor::GameplayAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(AProjectileActor, GameplayEffectHandles) == 0x000700, "Member 'AProjectileActor::GameplayEffectHandles' has a wrong offset!");
static_assert(offsetof(AProjectileActor, bShouldAttachWhenHitCharacter) == 0x000730, "Member 'AProjectileActor::bShouldAttachWhenHitCharacter' has a wrong offset!");
static_assert(offsetof(AProjectileActor, bShouldAttachWhenHitShield) == 0x000731, "Member 'AProjectileActor::bShouldAttachWhenHitShield' has a wrong offset!");
static_assert(offsetof(AProjectileActor, bShouldAttachWhenHitStaticObject) == 0x000732, "Member 'AProjectileActor::bShouldAttachWhenHitStaticObject' has a wrong offset!");
static_assert(offsetof(AProjectileActor, bShouldAliveAfterHit) == 0x000733, "Member 'AProjectileActor::bShouldAliveAfterHit' has a wrong offset!");

// Class DungeonCrawler.DCPropDataComponent
// 0x0018 (0x00E8 - 0x00D0)
class UDCPropDataComponent final : public UDCDataComponent
{
public:
	uint8                                         Pad_28D0[0x8];                                     // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCPropsSkinInfo                       PropsSkin;                                         // 0x00D8(0x0010)(Net, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCPropDataComponent">();
	}
	static class UDCPropDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCPropDataComponent>();
	}
};
static_assert(alignof(UDCPropDataComponent) == 0x000008, "Wrong alignment on UDCPropDataComponent");
static_assert(sizeof(UDCPropDataComponent) == 0x0000E8, "Wrong size on UDCPropDataComponent");
static_assert(offsetof(UDCPropDataComponent, PropsSkin) == 0x0000D8, "Member 'UDCPropDataComponent::PropsSkin' has a wrong offset!");

// Class DungeonCrawler.ReceivedInvitationSlotWidgetData
// 0x01D0 (0x01F8 - 0x0028)
class UReceivedInvitationSlotWidgetData final : public UObject
{
public:
	struct FDCFriendReceivedInvitationInfo        Info;                                              // 0x0028(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterClassId;                                  // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPlayerCharacter             DesignDataPlayerCharacter;                         // 0x00C8(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UInvitePartyWidget*                     InvitePartyWidget;                                 // 0x01F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReceivedInvitationSlotWidgetData">();
	}
	static class UReceivedInvitationSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReceivedInvitationSlotWidgetData>();
	}
};
static_assert(alignof(UReceivedInvitationSlotWidgetData) == 0x000008, "Wrong alignment on UReceivedInvitationSlotWidgetData");
static_assert(sizeof(UReceivedInvitationSlotWidgetData) == 0x0001F8, "Wrong size on UReceivedInvitationSlotWidgetData");
static_assert(offsetof(UReceivedInvitationSlotWidgetData, Info) == 0x000028, "Member 'UReceivedInvitationSlotWidgetData::Info' has a wrong offset!");
static_assert(offsetof(UReceivedInvitationSlotWidgetData, CharacterClassId) == 0x0000B8, "Member 'UReceivedInvitationSlotWidgetData::CharacterClassId' has a wrong offset!");
static_assert(offsetof(UReceivedInvitationSlotWidgetData, DesignDataPlayerCharacter) == 0x0000C8, "Member 'UReceivedInvitationSlotWidgetData::DesignDataPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UReceivedInvitationSlotWidgetData, InvitePartyWidget) == 0x0001F0, "Member 'UReceivedInvitationSlotWidgetData::InvitePartyWidget' has a wrong offset!");

// Class DungeonCrawler.ReligionContentsWidget
// 0x0228 (0x0580 - 0x0358)
class UReligionContentsWidget final : public UDCWidgetBase
{
public:
	class FString                                 WidgetReligionName;                                // 0x0358(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D1[0xB0];                                    // 0x0368(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCReligionBurfPopup>       ReligionBurfPopupClass;                            // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCReligionConvertPopUp>    ReligionConvertPopupClass;                         // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCReligionConvetCompletePopup> ReligionConvetCompletePopupClass;                  // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SeasonalOfferingTicketNum;                         // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeeklyOfferingTicketNum;                           // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentTicketNum;                                  // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NextTicketNom;                                     // 0x0448(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ReligionNameText;                                  // 0x0450(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_Bless;                                 // 0x0458(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              RankRecordListView;                                // 0x0460(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    OfferingBtn;                                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ConversionBtn;                                     // 0x0470(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    ReligionKillBtn;                                   // 0x0478(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    BlessInfoBtn;                                      // 0x0480(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionRankEntryMine*               MyRankWidget;                                      // 0x0488(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCReligionOfferingWidget*              OfferingWidget;                                    // 0x0490(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingNameText;                                  // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingLevelText;                                 // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D2[0x8];                                     // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ReligionImageBrushMap;                             // 0x04B0(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void DeActivateReligionSeasonWidget(bool bIsCurrentSeason, bool bHasReligion);
	void OnReligionInfoSetting(const struct FDCReligionInfo& Info);
	void OnReligionPersonalRankInfoSetting(const struct FDCReligionRankEntryInfo& Info);
	void OnReligionRankInfoSetting(const struct FDCReligionRankInfo& Info);
	void SetBlessingLevel(int32 Level);
	void SetButtonType(bool HasReligion);
	void SetOfferingWidgetVisible(bool Param_IsVisible);
	void SetRankDurationSwitcherIndex(int32 Param_Index);
	void SetReligionTimer(const struct FReligionRankTimerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReligionContentsWidget">();
	}
	static class UReligionContentsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReligionContentsWidget>();
	}
};
static_assert(alignof(UReligionContentsWidget) == 0x000010, "Wrong alignment on UReligionContentsWidget");
static_assert(sizeof(UReligionContentsWidget) == 0x000580, "Wrong size on UReligionContentsWidget");
static_assert(offsetof(UReligionContentsWidget, WidgetReligionName) == 0x000358, "Member 'UReligionContentsWidget::WidgetReligionName' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ReligionBurfPopupClass) == 0x000418, "Member 'UReligionContentsWidget::ReligionBurfPopupClass' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ReligionConvertPopupClass) == 0x000420, "Member 'UReligionContentsWidget::ReligionConvertPopupClass' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ReligionConvetCompletePopupClass) == 0x000428, "Member 'UReligionContentsWidget::ReligionConvetCompletePopupClass' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, SeasonalOfferingTicketNum) == 0x000430, "Member 'UReligionContentsWidget::SeasonalOfferingTicketNum' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, WeeklyOfferingTicketNum) == 0x000438, "Member 'UReligionContentsWidget::WeeklyOfferingTicketNum' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, CurrentTicketNum) == 0x000440, "Member 'UReligionContentsWidget::CurrentTicketNum' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, NextTicketNom) == 0x000448, "Member 'UReligionContentsWidget::NextTicketNom' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ReligionNameText) == 0x000450, "Member 'UReligionContentsWidget::ReligionNameText' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ProgressBar_Bless) == 0x000458, "Member 'UReligionContentsWidget::ProgressBar_Bless' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, RankRecordListView) == 0x000460, "Member 'UReligionContentsWidget::RankRecordListView' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, OfferingBtn) == 0x000468, "Member 'UReligionContentsWidget::OfferingBtn' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ConversionBtn) == 0x000470, "Member 'UReligionContentsWidget::ConversionBtn' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ReligionKillBtn) == 0x000478, "Member 'UReligionContentsWidget::ReligionKillBtn' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, BlessInfoBtn) == 0x000480, "Member 'UReligionContentsWidget::BlessInfoBtn' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, MyRankWidget) == 0x000488, "Member 'UReligionContentsWidget::MyRankWidget' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, OfferingWidget) == 0x000490, "Member 'UReligionContentsWidget::OfferingWidget' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, BlessingNameText) == 0x000498, "Member 'UReligionContentsWidget::BlessingNameText' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, BlessingLevelText) == 0x0004A0, "Member 'UReligionContentsWidget::BlessingLevelText' has a wrong offset!");
static_assert(offsetof(UReligionContentsWidget, ReligionImageBrushMap) == 0x0004B0, "Member 'UReligionContentsWidget::ReligionImageBrushMap' has a wrong offset!");

// Class DungeonCrawler.ReligionRankListEntryData
// 0x0048 (0x0070 - 0x0028)
class UReligionRankListEntryData final : public UObject
{
public:
	struct FDCReligionRankEntryInfo               RankRecordData;                                    // 0x0028(0x0048)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReligionRankListEntryData">();
	}
	static class UReligionRankListEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReligionRankListEntryData>();
	}
};
static_assert(alignof(UReligionRankListEntryData) == 0x000008, "Wrong alignment on UReligionRankListEntryData");
static_assert(sizeof(UReligionRankListEntryData) == 0x000070, "Wrong size on UReligionRankListEntryData");
static_assert(offsetof(UReligionRankListEntryData, RankRecordData) == 0x000028, "Member 'UReligionRankListEntryData::RankRecordData' has a wrong offset!");

// Class DungeonCrawler.ReligionRankListEntry
// 0x0098 (0x03F0 - 0x0358)
class UReligionRankListEntry final : public UDCWidgetBase
{
public:
	uint8                                         Pad_28D3[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReligionRankRecordWidgetHandleData    WidgetHandleData;                                  // 0x0360(0x0090)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg);
	void OnReligionRankRecordData(const struct FReligionRankRecordData& NewValue, const struct FReligionRankRecordData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReligionRankListEntry">();
	}
	static class UReligionRankListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReligionRankListEntry>();
	}
};
static_assert(alignof(UReligionRankListEntry) == 0x000008, "Wrong alignment on UReligionRankListEntry");
static_assert(sizeof(UReligionRankListEntry) == 0x0003F0, "Wrong size on UReligionRankListEntry");
static_assert(offsetof(UReligionRankListEntry, WidgetHandleData) == 0x000360, "Member 'UReligionRankListEntry::WidgetHandleData' has a wrong offset!");

// Class DungeonCrawler.SampleSubObject
// 0x0058 (0x0080 - 0x0028)
class USampleSubObject final : public UObject
{
public:
	uint8                                         Pad_28D4[0x58];                                    // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginSampleSubObject();
	void BroadcastMsgBlueprint(const int32& InMsg);
	void InitializeSampleSubObject();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SampleSubObject">();
	}
	static class USampleSubObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USampleSubObject>();
	}
};
static_assert(alignof(USampleSubObject) == 0x000008, "Wrong alignment on USampleSubObject");
static_assert(sizeof(USampleSubObject) == 0x000080, "Wrong size on USampleSubObject");

// Class DungeonCrawler.SampleObject
// 0x0070 (0x0098 - 0x0028)
class USampleObject final : public UObject
{
public:
	uint8                                         Pad_28D5[0x58];                                    // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseObject*                            BaseObject;                                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class USampleSubObject>           SampleSubObjectClass;                              // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USampleSubObject*                       SampleSubObject;                                   // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginSampleObject();
	void BroadcastMsgBlueprint(const int32& InMsg);
	void InitializeSampleObject();
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SampleObject">();
	}
	static class USampleObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USampleObject>();
	}
};
static_assert(alignof(USampleObject) == 0x000008, "Wrong alignment on USampleObject");
static_assert(sizeof(USampleObject) == 0x000098, "Wrong size on USampleObject");
static_assert(offsetof(USampleObject, BaseObject) == 0x000080, "Member 'USampleObject::BaseObject' has a wrong offset!");
static_assert(offsetof(USampleObject, SampleSubObjectClass) == 0x000088, "Member 'USampleObject::SampleSubObjectClass' has a wrong offset!");
static_assert(offsetof(USampleObject, SampleSubObject) == 0x000090, "Member 'USampleObject::SampleSubObject' has a wrong offset!");

// Class DungeonCrawler.SentInvitationSlotWidgetData
// 0x01D0 (0x01F8 - 0x0028)
class USentInvitationSlotWidgetData final : public UObject
{
public:
	struct FDCFriendSentInvitationInfo            Info;                                              // 0x0028(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterClassId;                                  // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPlayerCharacter             DesignDataPlayerCharacter;                         // 0x00C8(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UInvitePartyWidget*                     InvitePartyWidget;                                 // 0x01F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SentInvitationSlotWidgetData">();
	}
	static class USentInvitationSlotWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USentInvitationSlotWidgetData>();
	}
};
static_assert(alignof(USentInvitationSlotWidgetData) == 0x000008, "Wrong alignment on USentInvitationSlotWidgetData");
static_assert(sizeof(USentInvitationSlotWidgetData) == 0x0001F8, "Wrong size on USentInvitationSlotWidgetData");
static_assert(offsetof(USentInvitationSlotWidgetData, Info) == 0x000028, "Member 'USentInvitationSlotWidgetData::Info' has a wrong offset!");
static_assert(offsetof(USentInvitationSlotWidgetData, CharacterClassId) == 0x0000B8, "Member 'USentInvitationSlotWidgetData::CharacterClassId' has a wrong offset!");
static_assert(offsetof(USentInvitationSlotWidgetData, DesignDataPlayerCharacter) == 0x0000C8, "Member 'USentInvitationSlotWidgetData::DesignDataPlayerCharacter' has a wrong offset!");
static_assert(offsetof(USentInvitationSlotWidgetData, InvitePartyWidget) == 0x0001F0, "Member 'USentInvitationSlotWidgetData::InvitePartyWidget' has a wrong offset!");

// Class DungeonCrawler.ServerAccountSubsystem
// 0x0310 (0x0340 - 0x0030)
class UServerAccountSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_28D6[0x150];                                   // 0x0030(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCGameInfo                            GameInfo;                                          // 0x0180(0x0040)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D7[0x180];                                   // 0x01C0(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerAccountSubsystem">();
	}
	static class UServerAccountSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerAccountSubsystem>();
	}
};
static_assert(alignof(UServerAccountSubsystem) == 0x000008, "Wrong alignment on UServerAccountSubsystem");
static_assert(sizeof(UServerAccountSubsystem) == 0x000340, "Wrong size on UServerAccountSubsystem");
static_assert(offsetof(UServerAccountSubsystem, GameInfo) == 0x000180, "Member 'UServerAccountSubsystem::GameInfo' has a wrong offset!");

// Class DungeonCrawler.ShapeShiftComponent
// 0x0040 (0x00E0 - 0x00A0)
class UShapeShiftComponent final : public UDCActorComponent
{
public:
	class UDCShapeShiftDataAsset*                 Data;                                              // 0x00A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D8[0x18];                                    // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     AbilitySpecHandles;                                // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    GameplayEffectHandles;                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_Data(const class UDCShapeShiftDataAsset* OldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShapeShiftComponent">();
	}
	static class UShapeShiftComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShapeShiftComponent>();
	}
};
static_assert(alignof(UShapeShiftComponent) == 0x000008, "Wrong alignment on UShapeShiftComponent");
static_assert(sizeof(UShapeShiftComponent) == 0x0000E0, "Wrong size on UShapeShiftComponent");
static_assert(offsetof(UShapeShiftComponent, Data) == 0x0000A0, "Member 'UShapeShiftComponent::Data' has a wrong offset!");
static_assert(offsetof(UShapeShiftComponent, AbilitySpecHandles) == 0x0000C0, "Member 'UShapeShiftComponent::AbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(UShapeShiftComponent, GameplayEffectHandles) == 0x0000D0, "Member 'UShapeShiftComponent::GameplayEffectHandles' has a wrong offset!");

// Class DungeonCrawler.SkeletalMeshItemHolderActor
// 0x0000 (0x0570 - 0x0570)
class ASkeletalMeshItemHolderActor : public AItemHolderActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshItemHolderActor">();
	}
	static class ASkeletalMeshItemHolderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletalMeshItemHolderActor>();
	}
};
static_assert(alignof(ASkeletalMeshItemHolderActor) == 0x000008, "Wrong alignment on ASkeletalMeshItemHolderActor");
static_assert(sizeof(ASkeletalMeshItemHolderActor) == 0x000570, "Wrong size on ASkeletalMeshItemHolderActor");

// Class DungeonCrawler.SkillComponent
// 0x00D0 (0x0170 - 0x00A0)
class USkillComponent final : public UDCActorComponent
{
public:
	uint8                                         Pad_28D9[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASkillActor*>                    SkillActors;                                       // 0x00F8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSkillDataInfo>                 CurSkillDataList;                                  // 0x0108(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FSkillDataInfo>                 AccountSkillDatas;                                 // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSkillDataInfo>                 ShapeShiftSkillDatas;                              // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28DA[0x8];                                     // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskEffectStackChanged*           EffectStackAsyncTask;                              // 0x0140(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayAbilitySpecHandle>     ShapeShiftAbilitySpecHandles;                      // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    ShapeShiftGameplayEffectHandles;                   // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28DB[0x8];                                     // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void GameplayEffectStackChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount);
	void OnRep_SkillActorList(TArray<class ASkillActor*>* OldSkillActors);
	void OnRep_SkillDataList(const TArray<struct FSkillDataInfo>& OldSkillDataList);
	void SetCooldownForDebug_Server(bool bNoCooldownTime);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillComponent">();
	}
	static class USkillComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillComponent>();
	}
};
static_assert(alignof(USkillComponent) == 0x000008, "Wrong alignment on USkillComponent");
static_assert(sizeof(USkillComponent) == 0x000170, "Wrong size on USkillComponent");
static_assert(offsetof(USkillComponent, SkillActors) == 0x0000F8, "Member 'USkillComponent::SkillActors' has a wrong offset!");
static_assert(offsetof(USkillComponent, CurSkillDataList) == 0x000108, "Member 'USkillComponent::CurSkillDataList' has a wrong offset!");
static_assert(offsetof(USkillComponent, AccountSkillDatas) == 0x000118, "Member 'USkillComponent::AccountSkillDatas' has a wrong offset!");
static_assert(offsetof(USkillComponent, ShapeShiftSkillDatas) == 0x000128, "Member 'USkillComponent::ShapeShiftSkillDatas' has a wrong offset!");
static_assert(offsetof(USkillComponent, EffectStackAsyncTask) == 0x000140, "Member 'USkillComponent::EffectStackAsyncTask' has a wrong offset!");
static_assert(offsetof(USkillComponent, ShapeShiftAbilitySpecHandles) == 0x000148, "Member 'USkillComponent::ShapeShiftAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(USkillComponent, ShapeShiftGameplayEffectHandles) == 0x000158, "Member 'USkillComponent::ShapeShiftGameplayEffectHandles' has a wrong offset!");

// Class DungeonCrawler.SkillWidget
// 0x0050 (0x03A8 - 0x0358)
class USkillWidget final : public UDCWidgetBase
{
public:
	class UImage*                                 SkillIconImage;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSkillWidgetData                       SkillWidgetData;                                   // 0x0360(0x0030)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                SkillToolTipWidgetClass;                           // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        SkillId;                                           // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeSkillWidget(const struct FPrimaryAssetId& InSkillId);
	void OnSetSkillData();
	void SetSkillData(const class FText& SkillName, const class FText& SkillDesc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillWidget">();
	}
	static class USkillWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillWidget>();
	}
};
static_assert(alignof(USkillWidget) == 0x000008, "Wrong alignment on USkillWidget");
static_assert(sizeof(USkillWidget) == 0x0003A8, "Wrong size on USkillWidget");
static_assert(offsetof(USkillWidget, SkillIconImage) == 0x000358, "Member 'USkillWidget::SkillIconImage' has a wrong offset!");
static_assert(offsetof(USkillWidget, SkillWidgetData) == 0x000360, "Member 'USkillWidget::SkillWidgetData' has a wrong offset!");
static_assert(offsetof(USkillWidget, SkillToolTipWidgetClass) == 0x000390, "Member 'USkillWidget::SkillToolTipWidgetClass' has a wrong offset!");
static_assert(offsetof(USkillWidget, SkillId) == 0x000398, "Member 'USkillWidget::SkillId' has a wrong offset!");

// Class DungeonCrawler.SoundBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USoundBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsMute();
	static bool IsSoundPlayable(class UObject* InSoundPlayer, const class UObject* InSoundProvider, const struct FGameplayTag& InSoundEventTag);
	static bool PlaySound(class UObject* InSoundPlayer, class UAkAudioEvent* AkEvent);
	static bool PlaySoundOnPlayerController(const class UObject* WorldContextObject, class UAkAudioEvent* AkEvent);
	static bool PlaySoundWithSwitch(class UObject* InSoundPlayer, class UAkAudioEvent* AkEvent, const class UObject* InSoundProvider, const struct FGameplayTag& Tag, const EPhysicalSurface Surface, const class FString& SwitchGroup, const class FString& SwitchState);
	static bool PlaySoundWithTag(class UObject* InSoundPlayer, const class UObject* InSoundProvider, const struct FGameplayTag& Tag);
	static bool SetRTPCValue(class UObject* InSoundPlayer, const class UAkRtpc* RtpcValue, float Value, int32 InterpolationTimeMs);
	static bool SetSwitch(class UObject* InSoundPlayer, class UAkSwitchValue* AkSwitchValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundBlueprintLibrary">();
	}
	static class USoundBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundBlueprintLibrary>();
	}
};
static_assert(alignof(USoundBlueprintLibrary) == 0x000008, "Wrong alignment on USoundBlueprintLibrary");
static_assert(sizeof(USoundBlueprintLibrary) == 0x000028, "Wrong size on USoundBlueprintLibrary");

// Class DungeonCrawler.SoundProvider
// 0x0000 (0x0028 - 0x0028)
class ISoundProvider final : public IInterface
{
public:
	class UAkAudioEvent* GetEvent(const struct FGameplayTag& Tag) const;
	TMap<struct FGameplayTag, class UAkAudioEvent*> GetEvents() const;
	struct FPrimaryAssetId GetLastPrimaryAssetId() const;
	class UAkSwitchValue* GetSwitch(const struct FGameplayTag& Tag, const EPhysicalSurface Surface) const;
	TMap<struct FGameplayTag, struct FDCSoundDataContainer> GetSwitches() const;
	TMap<struct FGameplayTag, struct FGameplayTagQuery> GetTagQueries() const;
	struct FGameplayTagQuery GetTagQuery(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundProvider">();
	}
	static class ISoundProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISoundProvider>();
	}
};
static_assert(alignof(ISoundProvider) == 0x000008, "Wrong alignment on ISoundProvider");
static_assert(sizeof(ISoundProvider) == 0x000028, "Wrong size on ISoundProvider");

// Class DungeonCrawler.SpellActor
// 0x0148 (0x0440 - 0x02F8)
class ASpellActor final : public ADCActorBase
{
public:
	uint8                                         Pad_28E5[0xF8];                                    // 0x02F8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpellData                             SpellData;                                         // 0x03F0(0x0040)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	class UArtDataSpell*                          ArtDataSpell;                                      // 0x0430(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundData*                             SoundData;                                         // 0x0438(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SpellData(const struct FSpellData& OldSpellData);

	class UArtDataSpell* GetArtDataSpell() const;
	struct FDesignDataSpell GetDesignDataSpell() const;
	class USoundData* GetSoundDataSpell() const;
	struct FSpellData GetSpellData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellActor">();
	}
	static class ASpellActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpellActor>();
	}
};
static_assert(alignof(ASpellActor) == 0x000008, "Wrong alignment on ASpellActor");
static_assert(sizeof(ASpellActor) == 0x000440, "Wrong size on ASpellActor");
static_assert(offsetof(ASpellActor, SpellData) == 0x0003F0, "Member 'ASpellActor::SpellData' has a wrong offset!");
static_assert(offsetof(ASpellActor, ArtDataSpell) == 0x000430, "Member 'ASpellActor::ArtDataSpell' has a wrong offset!");
static_assert(offsetof(ASpellActor, SoundData) == 0x000438, "Member 'ASpellActor::SoundData' has a wrong offset!");

// Class DungeonCrawler.SpellCastComponent
// 0x0010 (0x00B0 - 0x00A0)
class USpellCastComponent final : public UDCActorComponent
{
public:
	TArray<class AActor*>                         SpellCastingActorArray;                            // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void RequestCancelSpellCast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellCastComponent">();
	}
	static class USpellCastComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpellCastComponent>();
	}
};
static_assert(alignof(USpellCastComponent) == 0x000008, "Wrong alignment on USpellCastComponent");
static_assert(sizeof(USpellCastComponent) == 0x0000B0, "Wrong size on USpellCastComponent");
static_assert(offsetof(USpellCastComponent, SpellCastingActorArray) == 0x0000A0, "Member 'USpellCastComponent::SpellCastingActorArray' has a wrong offset!");

// Class DungeonCrawler.SpellComponent
// 0x00A0 (0x0148 - 0x00A8)
class USpellComponent final : public UDCPlayerCharacterClassComponent
{
public:
	uint8                                         Pad_28E6[0x88];                                    // 0x00A8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASpellActor*>                    SpellActors;                                       // 0x0130(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentSpellTag;                                   // 0x0140(0x0008)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastMsgBlueprint(const int32& InMsg);
	void OnRep_CurrentSpellTag();
	void OnRep_SpellActors(const TArray<class ASpellActor*>& OldASpellActors);
	void ServerSetCurrentSpell(const struct FGameplayTag& SpellTag);
	void TerminateBase();
	void UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject);
	void UnbindMsgAll(class UObject* InObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpellComponent">();
	}
	static class USpellComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpellComponent>();
	}
};
static_assert(alignof(USpellComponent) == 0x000008, "Wrong alignment on USpellComponent");
static_assert(sizeof(USpellComponent) == 0x000148, "Wrong size on USpellComponent");
static_assert(offsetof(USpellComponent, SpellActors) == 0x000130, "Member 'USpellComponent::SpellActors' has a wrong offset!");
static_assert(offsetof(USpellComponent, CurrentSpellTag) == 0x000140, "Member 'USpellComponent::CurrentSpellTag' has a wrong offset!");

// Class DungeonCrawler.StaticMeshItemHolderActor
// 0x0000 (0x0570 - 0x0570)
class AStaticMeshItemHolderActor : public AItemHolderActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshItemHolderActor">();
	}
	static class AStaticMeshItemHolderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshItemHolderActor>();
	}
};
static_assert(alignof(AStaticMeshItemHolderActor) == 0x000008, "Wrong alignment on AStaticMeshItemHolderActor");
static_assert(sizeof(AStaticMeshItemHolderActor) == 0x000570, "Wrong size on AStaticMeshItemHolderActor");

// Class DungeonCrawler.StatisticsSheetTabItemWidgetData
// 0x0010 (0x0038 - 0x0028)
class UStatisticsSheetTabItemWidgetData final : public UObject
{
public:
	EGameType                                     GameType;                                          // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E7[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DungeonIdTag;                                      // 0x002C(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E8[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsSheetTabItemWidgetData">();
	}
	static class UStatisticsSheetTabItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsSheetTabItemWidgetData>();
	}
};
static_assert(alignof(UStatisticsSheetTabItemWidgetData) == 0x000008, "Wrong alignment on UStatisticsSheetTabItemWidgetData");
static_assert(sizeof(UStatisticsSheetTabItemWidgetData) == 0x000038, "Wrong size on UStatisticsSheetTabItemWidgetData");
static_assert(offsetof(UStatisticsSheetTabItemWidgetData, GameType) == 0x000028, "Member 'UStatisticsSheetTabItemWidgetData::GameType' has a wrong offset!");
static_assert(offsetof(UStatisticsSheetTabItemWidgetData, DungeonIdTag) == 0x00002C, "Member 'UStatisticsSheetTabItemWidgetData::DungeonIdTag' has a wrong offset!");

// Class DungeonCrawler.StatisticsRankItemWidgetData
// 0x0020 (0x0048 - 0x0028)
class UStatisticsRankItemWidgetData final : public UObject
{
public:
	struct FLeaderboardSheetInfo                  LeaderboardSheetInfo;                              // 0x0028(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             ClassIconTex;                                      // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsRankItemWidgetData">();
	}
	static class UStatisticsRankItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsRankItemWidgetData>();
	}
};
static_assert(alignof(UStatisticsRankItemWidgetData) == 0x000008, "Wrong alignment on UStatisticsRankItemWidgetData");
static_assert(sizeof(UStatisticsRankItemWidgetData) == 0x000048, "Wrong size on UStatisticsRankItemWidgetData");
static_assert(offsetof(UStatisticsRankItemWidgetData, LeaderboardSheetInfo) == 0x000028, "Member 'UStatisticsRankItemWidgetData::LeaderboardSheetInfo' has a wrong offset!");
static_assert(offsetof(UStatisticsRankItemWidgetData, ClassIconTex) == 0x000040, "Member 'UStatisticsRankItemWidgetData::ClassIconTex' has a wrong offset!");

// Class DungeonCrawler.StatisticsItemWidgetData
// 0x0008 (0x0030 - 0x0028)
class UStatisticsItemWidgetData final : public UObject
{
public:
	struct FStatisticsItemInfo                    StatisticsItemInfo;                                // 0x0028(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsItemWidgetData">();
	}
	static class UStatisticsItemWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsItemWidgetData>();
	}
};
static_assert(alignof(UStatisticsItemWidgetData) == 0x000008, "Wrong alignment on UStatisticsItemWidgetData");
static_assert(sizeof(UStatisticsItemWidgetData) == 0x000030, "Wrong size on UStatisticsItemWidgetData");
static_assert(offsetof(UStatisticsItemWidgetData, StatisticsItemInfo) == 0x000028, "Member 'UStatisticsItemWidgetData::StatisticsItemInfo' has a wrong offset!");

// Class DungeonCrawler.TagQueryData
// 0x00A8 (0x00F0 - 0x0048)
class UTagQueryData final : public UDCDataAssetBase
{
public:
	class FText                                   DescText;                                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      SourceTagQuery;                                    // 0x0060(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TargetTagQuery;                                    // 0x00A8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TagQueryData">();
	}
	static class UTagQueryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTagQueryData>();
	}
};
static_assert(alignof(UTagQueryData) == 0x000008, "Wrong alignment on UTagQueryData");
static_assert(sizeof(UTagQueryData) == 0x0000F0, "Wrong size on UTagQueryData");
static_assert(offsetof(UTagQueryData, DescText) == 0x000048, "Member 'UTagQueryData::DescText' has a wrong offset!");
static_assert(offsetof(UTagQueryData, SourceTagQuery) == 0x000060, "Member 'UTagQueryData::SourceTagQuery' has a wrong offset!");
static_assert(offsetof(UTagQueryData, TargetTagQuery) == 0x0000A8, "Member 'UTagQueryData::TargetTagQuery' has a wrong offset!");

// Class DungeonCrawler.TestItemInjectionWidgetBase
// 0x0168 (0x0450 - 0x02E8)
class UTestItemInjectionWidgetBase final : public UCommonUserWidget
{
public:
	class UDCCommonButtonBase*                    RemoveSelectionButton;                             // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCCommonButtonBase*                    InjectButton;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ItemListView;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ItemPropertyListView;                              // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ItemRarityListView;                                // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ItemTypeListView;                                  // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ItemChildTypeListView;                             // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          ItemEditableSearchText;                            // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          PropertyEditableSearchText;                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SelectedPropertyVerticalBox;                       // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInjectionItemSelectedPropertyWidgetBase> SelectedPropertyWidget;                            // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          GenerateCountText;                                 // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              CheckBoxCanEquip;                                  // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   FailedLogText;                                     // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class UInjectionItemListEntryWidgetData*> ItemEntryDataList;                                 // 0x0368(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UInjectionItemPropertyListEntryWidgetData*> PropertyEntryDataList;                             // 0x0378(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E9[0xC8];                                    // 0x0388(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateItemsAndRequestInjection();
	void OnCanEquipCheckBoxStateChanged(bool bIsChecked);
	void OnGenerateCountTextChanged(const class FText& InText);
	void OnItemChildTypeSelected(class UObject* WidgetData);
	void OnItemPropertySelected(class UObject* WidgetData);
	void OnItemRaritySelected(class UObject* WidgetData);
	void OnItemSelected(class UObject* WidgetData);
	void OnItemTypeSelected(class UObject* WidgetData);
	void OnPropertySearchTextChanged(const class FText& InText);
	void OnSearchTextChanged(const class FText& InText);
	void OnSelectedPropertyValueChanged(const struct FPrimaryAssetId& PropertyTypeAssetId, int32 InPropertyValue);
	void RemoveAllSelections();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestItemInjectionWidgetBase">();
	}
	static class UTestItemInjectionWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestItemInjectionWidgetBase>();
	}
};
static_assert(alignof(UTestItemInjectionWidgetBase) == 0x000008, "Wrong alignment on UTestItemInjectionWidgetBase");
static_assert(sizeof(UTestItemInjectionWidgetBase) == 0x000450, "Wrong size on UTestItemInjectionWidgetBase");
static_assert(offsetof(UTestItemInjectionWidgetBase, RemoveSelectionButton) == 0x0002E8, "Member 'UTestItemInjectionWidgetBase::RemoveSelectionButton' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, InjectButton) == 0x0002F0, "Member 'UTestItemInjectionWidgetBase::InjectButton' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemListView) == 0x0002F8, "Member 'UTestItemInjectionWidgetBase::ItemListView' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemPropertyListView) == 0x000300, "Member 'UTestItemInjectionWidgetBase::ItemPropertyListView' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemRarityListView) == 0x000308, "Member 'UTestItemInjectionWidgetBase::ItemRarityListView' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemTypeListView) == 0x000310, "Member 'UTestItemInjectionWidgetBase::ItemTypeListView' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemChildTypeListView) == 0x000318, "Member 'UTestItemInjectionWidgetBase::ItemChildTypeListView' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemEditableSearchText) == 0x000320, "Member 'UTestItemInjectionWidgetBase::ItemEditableSearchText' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, PropertyEditableSearchText) == 0x000328, "Member 'UTestItemInjectionWidgetBase::PropertyEditableSearchText' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, SelectedPropertyVerticalBox) == 0x000330, "Member 'UTestItemInjectionWidgetBase::SelectedPropertyVerticalBox' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, SelectedPropertyWidget) == 0x000338, "Member 'UTestItemInjectionWidgetBase::SelectedPropertyWidget' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, GenerateCountText) == 0x000340, "Member 'UTestItemInjectionWidgetBase::GenerateCountText' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, CheckBoxCanEquip) == 0x000348, "Member 'UTestItemInjectionWidgetBase::CheckBoxCanEquip' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, FailedLogText) == 0x000350, "Member 'UTestItemInjectionWidgetBase::FailedLogText' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, ItemEntryDataList) == 0x000368, "Member 'UTestItemInjectionWidgetBase::ItemEntryDataList' has a wrong offset!");
static_assert(offsetof(UTestItemInjectionWidgetBase, PropertyEntryDataList) == 0x000378, "Member 'UTestItemInjectionWidgetBase::PropertyEntryDataList' has a wrong offset!");

// Class DungeonCrawler.TooltipRichTextImageDecorator
// 0x0000 (0x0030 - 0x0030)
class UTooltipRichTextImageDecorator : public URichTextBlockImageDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipRichTextImageDecorator">();
	}
	static class UTooltipRichTextImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipRichTextImageDecorator>();
	}
};
static_assert(alignof(UTooltipRichTextImageDecorator) == 0x000008, "Wrong alignment on UTooltipRichTextImageDecorator");
static_assert(sizeof(UTooltipRichTextImageDecorator) == 0x000030, "Wrong size on UTooltipRichTextImageDecorator");

// Class DungeonCrawler.TotalGoldCountWidgetBase
// 0x0038 (0x0390 - 0x0358)
class UTotalGoldCountWidgetBase final : public UDCWidgetBase
{
public:
	class UTextBlock*                             GoldCountText;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAccountLink*                           AccountLink;                                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   LinkedPlayerPawn;                                  // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LinkedAccountId;                                   // 0x0370(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CheckTargetAccountId;                              // 0x0380(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 CountTotalGold();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotalGoldCountWidgetBase">();
	}
	static class UTotalGoldCountWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotalGoldCountWidgetBase>();
	}
};
static_assert(alignof(UTotalGoldCountWidgetBase) == 0x000008, "Wrong alignment on UTotalGoldCountWidgetBase");
static_assert(sizeof(UTotalGoldCountWidgetBase) == 0x000390, "Wrong size on UTotalGoldCountWidgetBase");
static_assert(offsetof(UTotalGoldCountWidgetBase, GoldCountText) == 0x000358, "Member 'UTotalGoldCountWidgetBase::GoldCountText' has a wrong offset!");
static_assert(offsetof(UTotalGoldCountWidgetBase, AccountLink) == 0x000360, "Member 'UTotalGoldCountWidgetBase::AccountLink' has a wrong offset!");
static_assert(offsetof(UTotalGoldCountWidgetBase, LinkedPlayerPawn) == 0x000368, "Member 'UTotalGoldCountWidgetBase::LinkedPlayerPawn' has a wrong offset!");
static_assert(offsetof(UTotalGoldCountWidgetBase, LinkedAccountId) == 0x000370, "Member 'UTotalGoldCountWidgetBase::LinkedAccountId' has a wrong offset!");
static_assert(offsetof(UTotalGoldCountWidgetBase, CheckTargetAccountId) == 0x000380, "Member 'UTotalGoldCountWidgetBase::CheckTargetAccountId' has a wrong offset!");

// Class DungeonCrawler.TradeChannelButtonBase
// 0x0020 (0x1680 - 0x1660)
class UTradeChannelButtonBase final : public UDCCommonButtonBase
{
public:
	uint8                                         Pad_28EA[0x28];                                    // 0x1658(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChannelButtonClicked();
	void SetChannelName(const class FText& InChannelName, int32 InIndex);
	void SetMemberText(int32 InMemberCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeChannelButtonBase">();
	}
	static class UTradeChannelButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeChannelButtonBase>();
	}
};
static_assert(alignof(UTradeChannelButtonBase) == 0x000010, "Wrong alignment on UTradeChannelButtonBase");
static_assert(sizeof(UTradeChannelButtonBase) == 0x001680, "Wrong size on UTradeChannelButtonBase");

// Class DungeonCrawler.TradeChannelListWidget
// 0x0098 (0x03F0 - 0x0358)
class UTradeChannelListWidget final : public UDCWidgetBase
{
public:
	TSubclassOf<class UTradeChannelButtonBase>    ChannelButtonWidgetClass;                          // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTradeChannelCategoryWidget> ChannelCategoryWidgetClass;                        // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCMarketplaceButtonBase>   MarketplaceButtonWidgetClass;                      // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_ChannelList;                             // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Overlay_DisableSelection;                          // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBox_MarketplaceButton;                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCFeatureUnlockRemainTimeWidget*       FeatureLockTimerWidget;                            // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDCMarketplaceButtonBase*               MarketplaceButton;                                 // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTrader;                                         // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTradeLocked;                                    // 0x0399(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDCAccountStatus                              AccountStatus;                                     // 0x039A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28EC[0x55];                                    // 0x039B(0x0055)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFeatureLockTimerRunsOut();

	bool CannotEnterTradingPost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeChannelListWidget">();
	}
	static class UTradeChannelListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeChannelListWidget>();
	}
};
static_assert(alignof(UTradeChannelListWidget) == 0x000008, "Wrong alignment on UTradeChannelListWidget");
static_assert(sizeof(UTradeChannelListWidget) == 0x0003F0, "Wrong size on UTradeChannelListWidget");
static_assert(offsetof(UTradeChannelListWidget, ChannelButtonWidgetClass) == 0x000358, "Member 'UTradeChannelListWidget::ChannelButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, ChannelCategoryWidgetClass) == 0x000360, "Member 'UTradeChannelListWidget::ChannelCategoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, MarketplaceButtonWidgetClass) == 0x000368, "Member 'UTradeChannelListWidget::MarketplaceButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, ScrollBox_ChannelList) == 0x000370, "Member 'UTradeChannelListWidget::ScrollBox_ChannelList' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, Overlay_DisableSelection) == 0x000378, "Member 'UTradeChannelListWidget::Overlay_DisableSelection' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, VerticalBox_MarketplaceButton) == 0x000380, "Member 'UTradeChannelListWidget::VerticalBox_MarketplaceButton' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, FeatureLockTimerWidget) == 0x000388, "Member 'UTradeChannelListWidget::FeatureLockTimerWidget' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, MarketplaceButton) == 0x000390, "Member 'UTradeChannelListWidget::MarketplaceButton' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, bIsTrader) == 0x000398, "Member 'UTradeChannelListWidget::bIsTrader' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, bIsTradeLocked) == 0x000399, "Member 'UTradeChannelListWidget::bIsTradeLocked' has a wrong offset!");
static_assert(offsetof(UTradeChannelListWidget, AccountStatus) == 0x00039A, "Member 'UTradeChannelListWidget::AccountStatus' has a wrong offset!");

// Class DungeonCrawler.TradeMasterWidget
// 0x0020 (0x0378 - 0x0358)
class UTradeMasterWidget final : public UDCWidgetBase
{
public:
	class UDCCommonButtonBase*                    WB_CommonBtn_BecomeTrader;                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TradingMasterConversation;                    // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDCTradeSubscriptionPopup>  GuildSubscriptionPopupClass;                       // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28ED[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenTradersGuildSubscriptionPopup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeMasterWidget">();
	}
	static class UTradeMasterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeMasterWidget>();
	}
};
static_assert(alignof(UTradeMasterWidget) == 0x000008, "Wrong alignment on UTradeMasterWidget");
static_assert(sizeof(UTradeMasterWidget) == 0x000378, "Wrong size on UTradeMasterWidget");
static_assert(offsetof(UTradeMasterWidget, WB_CommonBtn_BecomeTrader) == 0x000358, "Member 'UTradeMasterWidget::WB_CommonBtn_BecomeTrader' has a wrong offset!");
static_assert(offsetof(UTradeMasterWidget, Text_TradingMasterConversation) == 0x000360, "Member 'UTradeMasterWidget::Text_TradingMasterConversation' has a wrong offset!");
static_assert(offsetof(UTradeMasterWidget, GuildSubscriptionPopupClass) == 0x000368, "Member 'UTradeMasterWidget::GuildSubscriptionPopupClass' has a wrong offset!");

// Class DungeonCrawler.TradeUserListEntryWidgetData
// 0x0090 (0x00B8 - 0x0028)
class UTradeUserListEntryWidgetData final : public UObject
{
public:
	uint8                                         Pad_28EE[0x90];                                    // 0x0028(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeUserListEntryWidgetData">();
	}
	static class UTradeUserListEntryWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeUserListEntryWidgetData>();
	}
};
static_assert(alignof(UTradeUserListEntryWidgetData) == 0x000008, "Wrong alignment on UTradeUserListEntryWidgetData");
static_assert(sizeof(UTradeUserListEntryWidgetData) == 0x0000B8, "Wrong size on UTradeUserListEntryWidgetData");

// Class DungeonCrawler.TradeUserListEntryWidget
// 0x0010 (0x0400 - 0x03F0)
class UTradeUserListEntryWidget final : public ULobbyUserSlotBase
{
public:
	uint8                                         Pad_28EF[0x10];                                    // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRightClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeUserListEntryWidget">();
	}
	static class UTradeUserListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeUserListEntryWidget>();
	}
};
static_assert(alignof(UTradeUserListEntryWidget) == 0x000008, "Wrong alignment on UTradeUserListEntryWidget");
static_assert(sizeof(UTradeUserListEntryWidget) == 0x000400, "Wrong size on UTradeUserListEntryWidget");

// Class DungeonCrawler.TradeUserListWidget
// 0x0060 (0x03B8 - 0x0358)
class UTradeUserListWidget final : public UDCWidgetBase
{
public:
	class FText                                   TraderNumText;                                     // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class ULobbyUserSlotBase*                     TradeUser_Local;                                   // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              TileView_UserList;                                 // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       FindUserEditableTextBox;                           // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F0[0x20];                                    // 0x0388(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTradeUserListEntryWidgetData*>  TradeUserList;                                     // 0x03A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnBlockUpdated();
	void OnTextChanged(const class FText& FindId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeUserListWidget">();
	}
	static class UTradeUserListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeUserListWidget>();
	}
};
static_assert(alignof(UTradeUserListWidget) == 0x000008, "Wrong alignment on UTradeUserListWidget");
static_assert(sizeof(UTradeUserListWidget) == 0x0003B8, "Wrong size on UTradeUserListWidget");
static_assert(offsetof(UTradeUserListWidget, TraderNumText) == 0x000358, "Member 'UTradeUserListWidget::TraderNumText' has a wrong offset!");
static_assert(offsetof(UTradeUserListWidget, TradeUser_Local) == 0x000370, "Member 'UTradeUserListWidget::TradeUser_Local' has a wrong offset!");
static_assert(offsetof(UTradeUserListWidget, TileView_UserList) == 0x000378, "Member 'UTradeUserListWidget::TileView_UserList' has a wrong offset!");
static_assert(offsetof(UTradeUserListWidget, FindUserEditableTextBox) == 0x000380, "Member 'UTradeUserListWidget::FindUserEditableTextBox' has a wrong offset!");
static_assert(offsetof(UTradeUserListWidget, TradeUserList) == 0x0003A8, "Member 'UTradeUserListWidget::TradeUserList' has a wrong offset!");

// Class DungeonCrawler.VoipPartyMemberSettingWidget
// 0x0008 (0x0360 - 0x0358)
class UVoipPartyMemberSettingWidget : public UDCWidgetBase
{
public:
	uint8                                         Pad_28F1[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipPartyMemberSettingWidget">();
	}
	static class UVoipPartyMemberSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipPartyMemberSettingWidget>();
	}
};
static_assert(alignof(UVoipPartyMemberSettingWidget) == 0x000008, "Wrong alignment on UVoipPartyMemberSettingWidget");
static_assert(sizeof(UVoipPartyMemberSettingWidget) == 0x000360, "Wrong size on UVoipPartyMemberSettingWidget");

// Class DungeonCrawler.DCAT_WaitforOverlap
// 0x0020 (0x00A0 - 0x0080)
class UDCAT_WaitforOverlap final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnOverlap;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F2[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDCAT_WaitforOverlap* WaitForOverlap(class UGameplayAbility* OwningAbility, bool bOnlyTriggerOnce);
	static class UDCAT_WaitforOverlap* WaitForOverlapByClass(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> TargetActor, bool bOnlyTriggerOnce);

	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCAT_WaitforOverlap">();
	}
	static class UDCAT_WaitforOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCAT_WaitforOverlap>();
	}
};
static_assert(alignof(UDCAT_WaitforOverlap) == 0x000008, "Wrong alignment on UDCAT_WaitforOverlap");
static_assert(sizeof(UDCAT_WaitforOverlap) == 0x0000A0, "Wrong size on UDCAT_WaitforOverlap");
static_assert(offsetof(UDCAT_WaitforOverlap, OnOverlap) == 0x000080, "Member 'UDCAT_WaitforOverlap::OnOverlap' has a wrong offset!");

// Class DungeonCrawler.DCReplicationGraph
// 0x0030 (0x05A0 - 0x0570)
class UDCReplicationGraph final : public UReplicationGraph
{
public:
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x0570(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x0578(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCConnectionAlwaysRelevantNodePair> AlwaysRelevantForConnectionList;                   // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsWithoutNetConnection;                        // 0x0590(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DCReplicationGraph">();
	}
	static class UDCReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDCReplicationGraph>();
	}
};
static_assert(alignof(UDCReplicationGraph) == 0x000010, "Wrong alignment on UDCReplicationGraph");
static_assert(sizeof(UDCReplicationGraph) == 0x0005A0, "Wrong size on UDCReplicationGraph");
static_assert(offsetof(UDCReplicationGraph, GridNode) == 0x000570, "Member 'UDCReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UDCReplicationGraph, AlwaysRelevantNode) == 0x000578, "Member 'UDCReplicationGraph::AlwaysRelevantNode' has a wrong offset!");
static_assert(offsetof(UDCReplicationGraph, AlwaysRelevantForConnectionList) == 0x000580, "Member 'UDCReplicationGraph::AlwaysRelevantForConnectionList' has a wrong offset!");
static_assert(offsetof(UDCReplicationGraph, ActorsWithoutNetConnection) == 0x000590, "Member 'UDCReplicationGraph::ActorsWithoutNetConnection' has a wrong offset!");

}

